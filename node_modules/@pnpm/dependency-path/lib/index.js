"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAbsolute = isAbsolute;
exports.indexOfPeersSuffix = indexOfPeersSuffix;
exports.parseDepPath = parseDepPath;
exports.removeSuffix = removeSuffix;
exports.getPkgIdWithPatchHash = getPkgIdWithPatchHash;
exports.tryGetPackageId = tryGetPackageId;
exports.getRegistryByPackageName = getRegistryByPackageName;
exports.refToRelative = refToRelative;
exports.parse = parse;
exports.depPathToFilename = depPathToFilename;
exports.createPeersDirSuffix = createPeersDirSuffix;
const crypto_base32_hash_1 = require("@pnpm/crypto.base32-hash");
const semver_1 = __importDefault(require("semver"));
function isAbsolute(dependencyPath) {
    return dependencyPath[0] !== '/';
}
function indexOfPeersSuffix(depPath) {
    if (!depPath.endsWith(')'))
        return { peersIndex: -1, patchHashIndex: -1 };
    let open = 1;
    for (let i = depPath.length - 2; i >= 0; i--) {
        if (depPath[i] === '(') {
            open--;
        }
        else if (depPath[i] === ')') {
            open++;
        }
        else if (!open) {
            if (depPath.substring(i + 1).startsWith('(patch_hash=')) {
                return {
                    patchHashIndex: i + 1,
                    peersIndex: depPath.indexOf('(', i + 2),
                };
            }
            return {
                patchHashIndex: -1,
                peersIndex: i + 1,
            };
        }
    }
    return { peersIndex: -1, patchHashIndex: -1 };
}
function parseDepPath(relDepPath) {
    const { peersIndex } = indexOfPeersSuffix(relDepPath);
    if (peersIndex !== -1) {
        return {
            id: relDepPath.substring(0, peersIndex),
            peersSuffix: relDepPath.substring(peersIndex),
        };
    }
    return {
        id: relDepPath,
        peersSuffix: '',
    };
}
function removeSuffix(relDepPath) {
    const { peersIndex, patchHashIndex } = indexOfPeersSuffix(relDepPath);
    if (patchHashIndex !== -1) {
        return relDepPath.substring(0, patchHashIndex);
    }
    if (peersIndex !== -1) {
        return relDepPath.substring(0, peersIndex);
    }
    return relDepPath;
}
function getPkgIdWithPatchHash(depPath) {
    let pkgId = depPath;
    const { peersIndex: sepIndex } = indexOfPeersSuffix(pkgId);
    if (sepIndex !== -1) {
        pkgId = pkgId.substring(0, sepIndex);
    }
    if (pkgId.includes(':')) {
        pkgId = pkgId.substring(pkgId.indexOf('@', 1) + 1);
    }
    return pkgId;
}
function tryGetPackageId(relDepPath) {
    let pkgId = relDepPath;
    const { peersIndex, patchHashIndex } = indexOfPeersSuffix(pkgId);
    const sepIndex = patchHashIndex === -1 ? peersIndex : patchHashIndex;
    if (sepIndex !== -1) {
        pkgId = pkgId.substring(0, sepIndex);
    }
    if (pkgId.includes(':')) {
        pkgId = pkgId.substring(pkgId.indexOf('@', 1) + 1);
    }
    return pkgId;
}
function getRegistryByPackageName(registries, packageName) {
    if (packageName[0] !== '@')
        return registries.default;
    const scope = packageName.substring(0, packageName.indexOf('/'));
    return registries[scope] || registries.default;
}
function refToRelative(reference, pkgName) {
    if (reference.startsWith('link:')) {
        return null;
    }
    if (reference.startsWith('@'))
        return reference;
    const atIndex = reference.indexOf('@');
    if (atIndex === -1)
        return `${pkgName}@${reference}`;
    const colonIndex = reference.indexOf(':');
    const bracketIndex = reference.indexOf('(');
    if ((colonIndex === -1 || atIndex < colonIndex) && (bracketIndex === -1 || atIndex < bracketIndex))
        return reference;
    return `${pkgName}@${reference}`;
}
function parse(dependencyPath) {
    // eslint-disable-next-line: strict-type-predicates
    if (typeof dependencyPath !== 'string') {
        throw new TypeError(`Expected \`dependencyPath\` to be of type \`string\`, got \`${
        // eslint-disable-next-line: strict-type-predicates
        dependencyPath === null ? 'null' : typeof dependencyPath}\``);
    }
    const sepIndex = dependencyPath.indexOf('@', 1);
    if (sepIndex === -1) {
        return {};
    }
    const name = dependencyPath.substring(0, sepIndex);
    let version = dependencyPath.substring(sepIndex + 1);
    if (version) {
        let peersSuffix;
        let patchHash;
        const { peersIndex, patchHashIndex } = indexOfPeersSuffix(version);
        if (peersIndex !== -1 || patchHashIndex !== -1) {
            if (peersIndex === -1) {
                patchHash = version.substring(patchHashIndex);
                version = version.substring(0, patchHashIndex);
            }
            else if (patchHashIndex === -1) {
                peersSuffix = version.substring(peersIndex);
                version = version.substring(0, peersIndex);
            }
            else {
                patchHash = version.substring(patchHashIndex, peersIndex);
                peersSuffix = version.substring(peersIndex);
                version = version.substring(0, patchHashIndex);
            }
        }
        if (semver_1.default.valid(version)) {
            return {
                name,
                peersSuffix,
                version,
                patchHash,
            };
        }
        return {
            name,
            nonSemverVersion: version,
            peersSuffix,
            patchHash,
        };
    }
    return {};
}
function depPathToFilename(depPath, maxLengthWithoutHash) {
    let filename = depPathToFilenameUnescaped(depPath).replace(/[\\/:*?"<>|]/g, '+');
    if (filename.includes('(')) {
        filename = filename
            .replace(/\)$/, '')
            .replace(/(\)\()|\(|\)/g, '_');
    }
    if (filename.length > maxLengthWithoutHash || filename !== filename.toLowerCase() && !filename.startsWith('file+')) {
        return `${filename.substring(0, maxLengthWithoutHash - 27)}_${(0, crypto_base32_hash_1.createBase32Hash)(filename)}`;
    }
    return filename;
}
function depPathToFilenameUnescaped(depPath) {
    if (depPath.indexOf('file:') !== 0) {
        if (depPath[0] === '/') {
            depPath = depPath.substring(1);
        }
        const index = depPath.indexOf('@', 1);
        if (index === -1)
            return depPath;
        return `${depPath.substring(0, index)}@${depPath.slice(index + 1)}`;
    }
    return depPath.replace(':', '+');
}
function createPeersDirSuffix(peerIds, maxLength = 1000) {
    let dirName = peerIds.map((peerId) => {
        if (typeof peerId !== 'string') {
            return `${peerId.name}@${peerId.version}`;
        }
        if (peerId.startsWith('/')) {
            return peerId.substring(1);
        }
        return peerId;
    }).sort().join(')(');
    if (dirName.length > maxLength) {
        dirName = (0, crypto_base32_hash_1.createBase32Hash)(dirName);
    }
    return `(${dirName})`;
}
//# sourceMappingURL=index.js.map