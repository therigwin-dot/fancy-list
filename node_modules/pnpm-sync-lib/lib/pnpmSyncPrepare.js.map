{"version":3,"file":"pnpmSyncPrepare.js","sourceRoot":"","sources":["../src/pnpmSyncPrepare.ts"],"names":[],"mappings":"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","sourcesContent":["import path from 'path';\nimport fs from 'fs';\nimport YAML from 'yaml';\nimport process from 'node:process';\nimport { depPathToFilename } from '@pnpm/dependency-path';\n\nimport {\n  ILockfile,\n  ILogMessageCallbackOptions,\n  LogMessageKind,\n  LogMessageIdentifier,\n  IPnpmSyncJson,\n  IVersionSpecifier,\n  ILockfilePackage,\n  ITargetFolder\n} from './interfaces';\nimport { pnpmSyncGetJsonVersion } from './utilities';\n\n/**\n * @beta\n */\nexport interface IPnpmSyncPrepareOptions {\n  /**\n   * The path to the `pnpm-lock.yaml` file\n   */\n  lockfilePath: string;\n\n  /**\n   * The path to the PNPM virtual store (\"node_modules/.pnpm\" folder)\n   */\n  dotPnpmFolder: string;\n\n  /**\n   * A lockfileId that can be used to recognize the `pnpm-lock.yaml`\n   */\n  lockfileId?: string;\n\n  /**\n   * Environment-provided API to avoid an NPM dependency.\n   * The \"pnpm-sync\" NPM package provides a reference implementation.\n   */\n  ensureFolderAsync: (folderPath: string) => Promise<void>;\n\n  /**\n   * Environment-provided API to avoid an NPM dependency.\n   * The \"pnpm-sync\" NPM package provides a reference implementation.\n   */\n  readPnpmLockfile: (\n    lockfilePath: string,\n    options: { ignoreIncompatible: boolean }\n  ) => Promise<ILockfile | undefined>;\n\n  /**\n   * A callback for reporting events during the operation.\n   *\n   * @remarks\n   * `LogMessageKind.ERROR` events do NOT cause the promise to reject,\n   * so they must be handled appropriately.\n   */\n  logMessageCallback: (options: ILogMessageCallbackOptions) => void;\n}\n\n/**\n * For each workspace project has injected dependencies in a PNPM workspace, this API\n * should be invoked to prepare its `.pnpm-sync.json` file.  While building projects,\n * that file will be used by {@link pnpmSyncCopyAsync} to recopy the build outputs into\n * injected dependency installation folders under the `node_modules` folder.\n *\n * @beta\n */\nexport async function pnpmSyncPrepareAsync(options: IPnpmSyncPrepareOptions): Promise<void> {\n  const { lockfileId, ensureFolderAsync, readPnpmLockfile, logMessageCallback } = options;\n  let { lockfilePath, dotPnpmFolder } = options;\n\n  // get the pnpm-lock.yaml path\n  lockfilePath = path.resolve(process.cwd(), lockfilePath);\n  dotPnpmFolder = path.resolve(process.cwd(), dotPnpmFolder);\n\n  logMessageCallback({\n    message:\n      `Starting operation...\\n` +\n      `pnpm-lock.yaml file path: ${lockfilePath}\\n` +\n      `.pnpm folder path: ${dotPnpmFolder}`,\n    messageKind: LogMessageKind.VERBOSE,\n    details: {\n      messageIdentifier: LogMessageIdentifier.PREPARE_STARTING,\n      lockfilePath,\n      dotPnpmFolder\n    }\n  });\n\n  if (!fs.existsSync(lockfilePath) || !fs.existsSync(dotPnpmFolder)) {\n    throw Error('The input pnpm-lock.yaml path or the input .pnpm folder path is not correct!');\n  }\n\n  const startTime = process.hrtime.bigint();\n\n  const pnpmModulesYamlPath: string = path.resolve(dotPnpmFolder, '..');\n  const pnpmModulesYaml = YAML.parse(fs.readFileSync(`${pnpmModulesYamlPath}/.modules.yaml`, 'utf8'));\n  const pnpmVersion: string | undefined = pnpmModulesYaml?.packageManager?.split('@')[1];\n\n  // currently, only support pnpm v8\n  if (!pnpmVersion || !pnpmVersion.startsWith('8')) {\n    logMessageCallback({\n      message: `The pnpm version is not supported; pnpm-sync requires pnpm version 8.x`,\n      messageKind: LogMessageKind.ERROR,\n      details: {\n        messageIdentifier: LogMessageIdentifier.PREPARE_ERROR_UNSUPPORTED_PNPM_VERSION,\n        lockfilePath,\n        pnpmVersion: pnpmVersion\n      }\n    });\n    return;\n  }\n\n  // read the pnpm-lock.yaml\n  const pnpmLockfile: ILockfile | undefined = await readPnpmLockfile(lockfilePath, {\n    ignoreIncompatible: true\n  });\n\n  // currently, only support lockfileVersion 6.x, which is pnpm v8\n  const lockfileVersion: string | undefined = pnpmLockfile?.lockfileVersion.toString();\n  if (!lockfileVersion || !lockfileVersion.startsWith('6')) {\n    logMessageCallback({\n      message: `The pnpm-lock.yaml format is not supported; pnpm-sync requires lockfile version 6`,\n      messageKind: LogMessageKind.ERROR,\n      details: {\n        messageIdentifier: LogMessageIdentifier.PREPARE_ERROR_UNSUPPORTED_FORMAT,\n        lockfilePath,\n        lockfileVersion\n      }\n    });\n    return;\n  }\n\n  // find injected dependency and all its available versions\n  const injectedDependencyToVersion: Map<string, Set<string>> = new Map();\n  for (const importerItem of Object.values(pnpmLockfile?.importers || {})) {\n    // based on https://pnpm.io/package_json#dependenciesmeta\n    // the injected dependencies could available inside dependencies, optionalDependencies, and devDependencies.\n    getInjectedDependencyToVersion(importerItem?.dependencies, injectedDependencyToVersion);\n    getInjectedDependencyToVersion(importerItem?.devDependencies, injectedDependencyToVersion);\n    getInjectedDependencyToVersion(importerItem?.optionalDependencies, injectedDependencyToVersion);\n  }\n\n  // check and process transitive injected dependency\n  processTransitiveInjectedDependency(pnpmLockfile, injectedDependencyToVersion);\n\n  // get pnpm-lock.yaml folder path\n  const pnpmLockFolder = path.dirname(lockfilePath);\n\n  // generate a map, where key is the absolute path of the injectedDependency, value is all available paths in .pnpm folder\n  const injectedDependencyToFilePathSet: Map<string, Set<string>> = new Map();\n  for (const [injectedDependency, injectedDependencyVersionSet] of injectedDependencyToVersion) {\n    for (const injectedDependencyVersion of injectedDependencyVersionSet) {\n      // this logic is heavily depends on pnpm-lock formate\n      // the current logic is for pnpm v8\n      // for example: file:../../libraries/lib1(react@16.0.0) -> ../../libraries/lib1\n      let injectedDependencyPath = injectedDependencyVersion.split('(')[0].slice('file:'.length);\n      injectedDependencyPath = path.resolve(pnpmLockFolder, injectedDependencyPath);\n      if (!injectedDependencyToFilePathSet.has(injectedDependencyPath)) {\n        injectedDependencyToFilePathSet.set(injectedDependencyPath, new Set());\n      }\n\n      const fullPackagePath = path.join(\n        dotPnpmFolder,\n        depPathToFilename(injectedDependencyVersion),\n        'node_modules',\n        injectedDependency\n      );\n\n      injectedDependencyToFilePathSet.get(injectedDependencyPath)?.add(fullPackagePath);\n    }\n  }\n\n  // now, we have everything we need to generate the the .pnpm-sync.json\n  // console.log('injectedDependencyToFilePathSet =>', injectedDependencyToFilePathSet);\n  for (const [projectFolder, targetFolderSet] of injectedDependencyToFilePathSet) {\n    if (targetFolderSet.size === 0) {\n      continue;\n    }\n\n    const pnpmSyncJsonFolder = `${projectFolder}/node_modules`;\n    const pnpmSyncJsonPath = `${pnpmSyncJsonFolder}/.pnpm-sync.json`;\n\n    logMessageCallback({\n      message: `Writing ${pnpmSyncJsonPath}`,\n      messageKind: LogMessageKind.VERBOSE,\n      details: {\n        messageIdentifier: LogMessageIdentifier.PREPARE_WRITING_FILE,\n        pnpmSyncJsonPath,\n        projectFolder\n      }\n    });\n\n    // make sure the node_modules folder exists, if not, create it\n    // why?\n    // in the transitive injected dependencies case\n    // it is possible that node_modules folder for a package is not exist yet\n    // but we need to generate .pnpm-sync.json for that package\n    if (!fs.existsSync(pnpmSyncJsonFolder)) {\n      await ensureFolderAsync(pnpmSyncJsonFolder);\n    }\n\n    const expectedPnpmSyncJsonVersion: string = pnpmSyncGetJsonVersion();\n\n    let pnpmSyncJsonFile: IPnpmSyncJson = {\n      version: expectedPnpmSyncJsonVersion,\n      postbuildInjectedCopy: {\n        sourceFolder: '..', // path from pnpmSyncJsonFolder to projectFolder\n        targetFolders: []\n      }\n    };\n\n    // if .pnpm-sync.json already exists, read it first\n    if (fs.existsSync(pnpmSyncJsonPath)) {\n      let existingPnpmSyncJsonFile: IPnpmSyncJson | undefined;\n      try {\n        existingPnpmSyncJsonFile = JSON.parse(fs.readFileSync(pnpmSyncJsonPath).toString());\n      } catch (e) {\n        // no-catch\n        // Regenerate .pnpm-sync.json when failed to load the current one\n      }\n\n      if (existingPnpmSyncJsonFile) {\n        const actualPnpmSyncJsonVersion: string = existingPnpmSyncJsonFile.version;\n        if (actualPnpmSyncJsonVersion === expectedPnpmSyncJsonVersion) {\n          // If a lockfileId is provided\n          // then all entries with this lockfileId should be deleted\n          // they will be regenerated later\n          if (lockfileId) {\n            const filteredTargetFolders = existingPnpmSyncJsonFile.postbuildInjectedCopy.targetFolders.filter(\n              (targetFolder) => targetFolder?.lockfileId !== lockfileId\n            );\n            existingPnpmSyncJsonFile.postbuildInjectedCopy.targetFolders = filteredTargetFolders;\n          }\n          pnpmSyncJsonFile = existingPnpmSyncJsonFile;\n        } else {\n          logMessageCallback({\n            message: `The .pnpm-sync.json file in ${pnpmSyncJsonFolder} has an incompatible version; pnpm-sync will regenerate it.`,\n            messageKind: LogMessageKind.VERBOSE,\n            details: {\n              messageIdentifier: LogMessageIdentifier.PREPARE_REPLACING_FILE,\n              pnpmSyncJsonPath,\n              projectFolder,\n              actualVersion: actualPnpmSyncJsonVersion,\n              expectedVersion: expectedPnpmSyncJsonVersion\n            }\n          });\n        }\n      }\n    }\n\n    const existingTargetFolderSet: Set<string> = new Set();\n\n    for (const targetFolder of pnpmSyncJsonFile.postbuildInjectedCopy.targetFolders) {\n      existingTargetFolderSet.add(targetFolder.folderPath);\n    }\n\n    for (const targetFolder of targetFolderSet) {\n      let relativePath: string = path.relative(pnpmSyncJsonFolder, targetFolder);\n\n      // the final path in .pnpm-sync.json will always in posix style\n      relativePath = relativePath.split(path.sep).join(path.posix.sep);\n\n      if (!existingTargetFolderSet.has(relativePath)) {\n        const targetFolderItem: ITargetFolder = {\n          folderPath: relativePath\n        };\n\n        if (lockfileId) {\n          targetFolderItem.lockfileId = lockfileId;\n        }\n\n        pnpmSyncJsonFile.postbuildInjectedCopy.targetFolders.push(targetFolderItem);\n      }\n    }\n\n    await fs.promises.writeFile(pnpmSyncJsonPath, JSON.stringify(pnpmSyncJsonFile, null, 2));\n  }\n\n  const endTime = process.hrtime.bigint();\n  const executionTimeInMs: number = Number(endTime - startTime) / 1e6;\n\n  logMessageCallback({\n    message: `Regenerated .pnpm-sync.json in ${executionTimeInMs.toFixed(3)} ms for ${lockfilePath}`,\n    messageKind: LogMessageKind.INFO,\n    details: {\n      messageIdentifier: LogMessageIdentifier.PREPARE_FINISHING,\n      lockfilePath,\n      dotPnpmFolder,\n      executionTimeInMs\n    }\n  });\n}\n\nfunction getInjectedDependencyToVersion(\n  dependencies: Record<string, IVersionSpecifier> | undefined,\n  injectedDependencyToVersion: Map<string, Set<string>>\n): void {\n  if (dependencies) {\n    for (const [dependency, specifier] of Object.entries(dependencies)) {\n      const specifierToUse: string = typeof specifier === 'string' ? specifier : specifier.version;\n      // the injected dependency should always start with file protocol\n      // and exclude tarball installation\n      // what is the tarball installation, learn more: https://pnpm.io/cli/add#install-from-local-file-system\n\n      const tarballSuffix = ['.tar', '.tar.gz', '.tgz'];\n      if (\n        specifierToUse.startsWith('file:') &&\n        !tarballSuffix.some((suffix) => specifierToUse.endsWith(suffix))\n      ) {\n        if (!injectedDependencyToVersion.has(dependency)) {\n          injectedDependencyToVersion.set(dependency, new Set());\n        }\n        injectedDependencyToVersion.get(dependency)?.add(specifierToUse);\n      }\n    }\n  }\n}\n\n// process all dependencies and devDependencies to find potential transitive injected dependencies\n// and add to injectedDependencyToFilePath map\nfunction processTransitiveInjectedDependency(\n  pnpmLockfile: ILockfile | undefined,\n  injectedDependencyToVersion: Map<string, Set<string>>\n): void {\n  const potentialTransitiveInjectedDependencyVersionQueue: Array<string> = [];\n  for (const injectedDependencyVersion of [...injectedDependencyToVersion.values()]) {\n    potentialTransitiveInjectedDependencyVersionQueue.push(...injectedDependencyVersion);\n  }\n\n  const lockfilePackages: Record<string, ILockfilePackage> | undefined = pnpmLockfile?.packages;\n\n  if (lockfilePackages) {\n    while (potentialTransitiveInjectedDependencyVersionQueue.length > 0) {\n      const transitiveInjectedDependencyVersion: string | undefined =\n        potentialTransitiveInjectedDependencyVersionQueue.shift();\n      if (transitiveInjectedDependencyVersion) {\n        const { dependencies, optionalDependencies } = lockfilePackages[transitiveInjectedDependencyVersion];\n        processInjectedDependencies(\n          dependencies,\n          injectedDependencyToVersion,\n          potentialTransitiveInjectedDependencyVersionQueue\n        );\n        processInjectedDependencies(\n          optionalDependencies,\n          injectedDependencyToVersion,\n          potentialTransitiveInjectedDependencyVersionQueue\n        );\n      }\n    }\n  }\n}\nfunction processInjectedDependencies(\n  dependencies: Record<string, string> | undefined,\n  injectedDependencyToVersion: Map<string, Set<string>>,\n  potentialTransitiveInjectedDependencyVersionQueue: Array<string>\n): void {\n  if (dependencies) {\n    for (const [dependency, version] of Object.entries(dependencies)) {\n      // if the version is set with file: protocol, then it is a transitive injected dependency\n      if (version.startsWith('file:')) {\n        if (!injectedDependencyToVersion.has(dependency)) {\n          injectedDependencyToVersion.set(dependency, new Set());\n        }\n        injectedDependencyToVersion.get(dependency)?.add(version);\n        potentialTransitiveInjectedDependencyVersionQueue.push(version);\n      }\n    }\n  }\n}\n"]}