"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pnpmSyncPrepareAsync = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const yaml_1 = __importDefault(require("yaml"));
const node_process_1 = __importDefault(require("node:process"));
const dependency_path_1 = require("@pnpm/dependency-path");
const interfaces_1 = require("./interfaces");
const utilities_1 = require("./utilities");
/**
 * For each workspace project has injected dependencies in a PNPM workspace, this API
 * should be invoked to prepare its `.pnpm-sync.json` file.  While building projects,
 * that file will be used by {@link pnpmSyncCopyAsync} to recopy the build outputs into
 * injected dependency installation folders under the `node_modules` folder.
 *
 * @beta
 */
async function pnpmSyncPrepareAsync(options) {
    var _a, _b;
    const { lockfileId, ensureFolderAsync, readPnpmLockfile, logMessageCallback } = options;
    let { lockfilePath, dotPnpmFolder } = options;
    // get the pnpm-lock.yaml path
    lockfilePath = path_1.default.resolve(node_process_1.default.cwd(), lockfilePath);
    dotPnpmFolder = path_1.default.resolve(node_process_1.default.cwd(), dotPnpmFolder);
    logMessageCallback({
        message: `Starting operation...\n` +
            `pnpm-lock.yaml file path: ${lockfilePath}\n` +
            `.pnpm folder path: ${dotPnpmFolder}`,
        messageKind: interfaces_1.LogMessageKind.VERBOSE,
        details: {
            messageIdentifier: interfaces_1.LogMessageIdentifier.PREPARE_STARTING,
            lockfilePath,
            dotPnpmFolder
        }
    });
    if (!fs_1.default.existsSync(lockfilePath) || !fs_1.default.existsSync(dotPnpmFolder)) {
        throw Error('The input pnpm-lock.yaml path or the input .pnpm folder path is not correct!');
    }
    const startTime = node_process_1.default.hrtime.bigint();
    const pnpmModulesYamlPath = path_1.default.resolve(dotPnpmFolder, '..');
    const pnpmModulesYaml = yaml_1.default.parse(fs_1.default.readFileSync(`${pnpmModulesYamlPath}/.modules.yaml`, 'utf8'));
    const pnpmVersion = (_a = pnpmModulesYaml === null || pnpmModulesYaml === void 0 ? void 0 : pnpmModulesYaml.packageManager) === null || _a === void 0 ? void 0 : _a.split('@')[1];
    // currently, only support pnpm v8
    if (!pnpmVersion || !pnpmVersion.startsWith('8')) {
        logMessageCallback({
            message: `The pnpm version is not supported; pnpm-sync requires pnpm version 8.x`,
            messageKind: interfaces_1.LogMessageKind.ERROR,
            details: {
                messageIdentifier: interfaces_1.LogMessageIdentifier.PREPARE_ERROR_UNSUPPORTED_PNPM_VERSION,
                lockfilePath,
                pnpmVersion: pnpmVersion
            }
        });
        return;
    }
    // read the pnpm-lock.yaml
    const pnpmLockfile = await readPnpmLockfile(lockfilePath, {
        ignoreIncompatible: true
    });
    // currently, only support lockfileVersion 6.x, which is pnpm v8
    const lockfileVersion = pnpmLockfile === null || pnpmLockfile === void 0 ? void 0 : pnpmLockfile.lockfileVersion.toString();
    if (!lockfileVersion || !lockfileVersion.startsWith('6')) {
        logMessageCallback({
            message: `The pnpm-lock.yaml format is not supported; pnpm-sync requires lockfile version 6`,
            messageKind: interfaces_1.LogMessageKind.ERROR,
            details: {
                messageIdentifier: interfaces_1.LogMessageIdentifier.PREPARE_ERROR_UNSUPPORTED_FORMAT,
                lockfilePath,
                lockfileVersion
            }
        });
        return;
    }
    // find injected dependency and all its available versions
    const injectedDependencyToVersion = new Map();
    for (const importerItem of Object.values((pnpmLockfile === null || pnpmLockfile === void 0 ? void 0 : pnpmLockfile.importers) || {})) {
        // based on https://pnpm.io/package_json#dependenciesmeta
        // the injected dependencies could available inside dependencies, optionalDependencies, and devDependencies.
        getInjectedDependencyToVersion(importerItem === null || importerItem === void 0 ? void 0 : importerItem.dependencies, injectedDependencyToVersion);
        getInjectedDependencyToVersion(importerItem === null || importerItem === void 0 ? void 0 : importerItem.devDependencies, injectedDependencyToVersion);
        getInjectedDependencyToVersion(importerItem === null || importerItem === void 0 ? void 0 : importerItem.optionalDependencies, injectedDependencyToVersion);
    }
    // check and process transitive injected dependency
    processTransitiveInjectedDependency(pnpmLockfile, injectedDependencyToVersion);
    // get pnpm-lock.yaml folder path
    const pnpmLockFolder = path_1.default.dirname(lockfilePath);
    // generate a map, where key is the absolute path of the injectedDependency, value is all available paths in .pnpm folder
    const injectedDependencyToFilePathSet = new Map();
    for (const [injectedDependency, injectedDependencyVersionSet] of injectedDependencyToVersion) {
        for (const injectedDependencyVersion of injectedDependencyVersionSet) {
            // this logic is heavily depends on pnpm-lock formate
            // the current logic is for pnpm v8
            // for example: file:../../libraries/lib1(react@16.0.0) -> ../../libraries/lib1
            let injectedDependencyPath = injectedDependencyVersion.split('(')[0].slice('file:'.length);
            injectedDependencyPath = path_1.default.resolve(pnpmLockFolder, injectedDependencyPath);
            if (!injectedDependencyToFilePathSet.has(injectedDependencyPath)) {
                injectedDependencyToFilePathSet.set(injectedDependencyPath, new Set());
            }
            const fullPackagePath = path_1.default.join(dotPnpmFolder, (0, dependency_path_1.depPathToFilename)(injectedDependencyVersion), 'node_modules', injectedDependency);
            (_b = injectedDependencyToFilePathSet.get(injectedDependencyPath)) === null || _b === void 0 ? void 0 : _b.add(fullPackagePath);
        }
    }
    // now, we have everything we need to generate the the .pnpm-sync.json
    // console.log('injectedDependencyToFilePathSet =>', injectedDependencyToFilePathSet);
    for (const [projectFolder, targetFolderSet] of injectedDependencyToFilePathSet) {
        if (targetFolderSet.size === 0) {
            continue;
        }
        const pnpmSyncJsonFolder = `${projectFolder}/node_modules`;
        const pnpmSyncJsonPath = `${pnpmSyncJsonFolder}/.pnpm-sync.json`;
        logMessageCallback({
            message: `Writing ${pnpmSyncJsonPath}`,
            messageKind: interfaces_1.LogMessageKind.VERBOSE,
            details: {
                messageIdentifier: interfaces_1.LogMessageIdentifier.PREPARE_WRITING_FILE,
                pnpmSyncJsonPath,
                projectFolder
            }
        });
        // make sure the node_modules folder exists, if not, create it
        // why?
        // in the transitive injected dependencies case
        // it is possible that node_modules folder for a package is not exist yet
        // but we need to generate .pnpm-sync.json for that package
        if (!fs_1.default.existsSync(pnpmSyncJsonFolder)) {
            await ensureFolderAsync(pnpmSyncJsonFolder);
        }
        const expectedPnpmSyncJsonVersion = (0, utilities_1.pnpmSyncGetJsonVersion)();
        let pnpmSyncJsonFile = {
            version: expectedPnpmSyncJsonVersion,
            postbuildInjectedCopy: {
                sourceFolder: '..', // path from pnpmSyncJsonFolder to projectFolder
                targetFolders: []
            }
        };
        // if .pnpm-sync.json already exists, read it first
        if (fs_1.default.existsSync(pnpmSyncJsonPath)) {
            let existingPnpmSyncJsonFile;
            try {
                existingPnpmSyncJsonFile = JSON.parse(fs_1.default.readFileSync(pnpmSyncJsonPath).toString());
            }
            catch (e) {
                // no-catch
                // Regenerate .pnpm-sync.json when failed to load the current one
            }
            if (existingPnpmSyncJsonFile) {
                const actualPnpmSyncJsonVersion = existingPnpmSyncJsonFile.version;
                if (actualPnpmSyncJsonVersion === expectedPnpmSyncJsonVersion) {
                    // If a lockfileId is provided
                    // then all entries with this lockfileId should be deleted
                    // they will be regenerated later
                    if (lockfileId) {
                        const filteredTargetFolders = existingPnpmSyncJsonFile.postbuildInjectedCopy.targetFolders.filter((targetFolder) => (targetFolder === null || targetFolder === void 0 ? void 0 : targetFolder.lockfileId) !== lockfileId);
                        existingPnpmSyncJsonFile.postbuildInjectedCopy.targetFolders = filteredTargetFolders;
                    }
                    pnpmSyncJsonFile = existingPnpmSyncJsonFile;
                }
                else {
                    logMessageCallback({
                        message: `The .pnpm-sync.json file in ${pnpmSyncJsonFolder} has an incompatible version; pnpm-sync will regenerate it.`,
                        messageKind: interfaces_1.LogMessageKind.VERBOSE,
                        details: {
                            messageIdentifier: interfaces_1.LogMessageIdentifier.PREPARE_REPLACING_FILE,
                            pnpmSyncJsonPath,
                            projectFolder,
                            actualVersion: actualPnpmSyncJsonVersion,
                            expectedVersion: expectedPnpmSyncJsonVersion
                        }
                    });
                }
            }
        }
        const existingTargetFolderSet = new Set();
        for (const targetFolder of pnpmSyncJsonFile.postbuildInjectedCopy.targetFolders) {
            existingTargetFolderSet.add(targetFolder.folderPath);
        }
        for (const targetFolder of targetFolderSet) {
            let relativePath = path_1.default.relative(pnpmSyncJsonFolder, targetFolder);
            // the final path in .pnpm-sync.json will always in posix style
            relativePath = relativePath.split(path_1.default.sep).join(path_1.default.posix.sep);
            if (!existingTargetFolderSet.has(relativePath)) {
                const targetFolderItem = {
                    folderPath: relativePath
                };
                if (lockfileId) {
                    targetFolderItem.lockfileId = lockfileId;
                }
                pnpmSyncJsonFile.postbuildInjectedCopy.targetFolders.push(targetFolderItem);
            }
        }
        await fs_1.default.promises.writeFile(pnpmSyncJsonPath, JSON.stringify(pnpmSyncJsonFile, null, 2));
    }
    const endTime = node_process_1.default.hrtime.bigint();
    const executionTimeInMs = Number(endTime - startTime) / 1e6;
    logMessageCallback({
        message: `Regenerated .pnpm-sync.json in ${executionTimeInMs.toFixed(3)} ms for ${lockfilePath}`,
        messageKind: interfaces_1.LogMessageKind.INFO,
        details: {
            messageIdentifier: interfaces_1.LogMessageIdentifier.PREPARE_FINISHING,
            lockfilePath,
            dotPnpmFolder,
            executionTimeInMs
        }
    });
}
exports.pnpmSyncPrepareAsync = pnpmSyncPrepareAsync;
function getInjectedDependencyToVersion(dependencies, injectedDependencyToVersion) {
    var _a;
    if (dependencies) {
        for (const [dependency, specifier] of Object.entries(dependencies)) {
            const specifierToUse = typeof specifier === 'string' ? specifier : specifier.version;
            // the injected dependency should always start with file protocol
            // and exclude tarball installation
            // what is the tarball installation, learn more: https://pnpm.io/cli/add#install-from-local-file-system
            const tarballSuffix = ['.tar', '.tar.gz', '.tgz'];
            if (specifierToUse.startsWith('file:') &&
                !tarballSuffix.some((suffix) => specifierToUse.endsWith(suffix))) {
                if (!injectedDependencyToVersion.has(dependency)) {
                    injectedDependencyToVersion.set(dependency, new Set());
                }
                (_a = injectedDependencyToVersion.get(dependency)) === null || _a === void 0 ? void 0 : _a.add(specifierToUse);
            }
        }
    }
}
// process all dependencies and devDependencies to find potential transitive injected dependencies
// and add to injectedDependencyToFilePath map
function processTransitiveInjectedDependency(pnpmLockfile, injectedDependencyToVersion) {
    const potentialTransitiveInjectedDependencyVersionQueue = [];
    for (const injectedDependencyVersion of [...injectedDependencyToVersion.values()]) {
        potentialTransitiveInjectedDependencyVersionQueue.push(...injectedDependencyVersion);
    }
    const lockfilePackages = pnpmLockfile === null || pnpmLockfile === void 0 ? void 0 : pnpmLockfile.packages;
    if (lockfilePackages) {
        while (potentialTransitiveInjectedDependencyVersionQueue.length > 0) {
            const transitiveInjectedDependencyVersion = potentialTransitiveInjectedDependencyVersionQueue.shift();
            if (transitiveInjectedDependencyVersion) {
                const { dependencies, optionalDependencies } = lockfilePackages[transitiveInjectedDependencyVersion];
                processInjectedDependencies(dependencies, injectedDependencyToVersion, potentialTransitiveInjectedDependencyVersionQueue);
                processInjectedDependencies(optionalDependencies, injectedDependencyToVersion, potentialTransitiveInjectedDependencyVersionQueue);
            }
        }
    }
}
function processInjectedDependencies(dependencies, injectedDependencyToVersion, potentialTransitiveInjectedDependencyVersionQueue) {
    var _a;
    if (dependencies) {
        for (const [dependency, version] of Object.entries(dependencies)) {
            // if the version is set with file: protocol, then it is a transitive injected dependency
            if (version.startsWith('file:')) {
                if (!injectedDependencyToVersion.has(dependency)) {
                    injectedDependencyToVersion.set(dependency, new Set());
                }
                (_a = injectedDependencyToVersion.get(dependency)) === null || _a === void 0 ? void 0 : _a.add(version);
                potentialTransitiveInjectedDependencyVersionQueue.push(version);
            }
        }
    }
}
//# sourceMappingURL=pnpmSyncPrepare.js.map