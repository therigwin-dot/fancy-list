"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pnpmSyncCopyAsync = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const node_process_1 = __importDefault(require("node:process"));
const interfaces_1 = require("./interfaces");
const utilities_1 = require("./utilities");
/**
 * For each library project that acts as an injected dependency of other consuming projects
 * within a PNPM workspace, this operation should be invoked whenever that library is rebuilt.
 * It will copy the latest build output into the `node_modules` installation folder.
 *
 * @remarks
 * This operation reads the `.npm-sync.json` file which should have been prepared after
 * `pnpm install` by calling the {@link pnpmSyncPrepareAsync} function.
 *
 * @beta
 */
async function pnpmSyncCopyAsync(options) {
    const { getPackageIncludedFiles, forEachAsyncWithConcurrency, ensureFolderAsync, logMessageCallback } = options;
    let pnpmSyncJsonPath = options.pnpmSyncJsonPath;
    pnpmSyncJsonPath = path_1.default.resolve(node_process_1.default.cwd(), pnpmSyncJsonPath);
    logMessageCallback({
        message: `Starting operation for ` + pnpmSyncJsonPath,
        messageKind: interfaces_1.LogMessageKind.VERBOSE,
        details: {
            messageIdentifier: interfaces_1.LogMessageIdentifier.COPY_STARTING,
            pnpmSyncJsonPath
        }
    });
    let pnpmSyncJsonContents;
    try {
        pnpmSyncJsonContents = (await fs_1.default.promises.readFile(pnpmSyncJsonPath)).toString();
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            logMessageCallback({
                message: 'The .pnpm-sync.json file was not found under the node_modules folder; was this project prepared?',
                messageKind: interfaces_1.LogMessageKind.ERROR,
                details: {
                    messageIdentifier: interfaces_1.LogMessageIdentifier.COPY_ERROR_NO_SYNC_FILE,
                    pnpmSyncJsonPath
                }
            });
            return;
        }
        else {
            throw e;
        }
    }
    const pnpmSyncJsonFolder = path_1.default.dirname(pnpmSyncJsonPath);
    // read the .pnpm-sync.json
    const pnpmSyncJson = JSON.parse(pnpmSyncJsonContents);
    // verify if the version is incompatible
    const expectedPnpmSyncJsonVersion = (0, utilities_1.pnpmSyncGetJsonVersion)();
    const actualPnpmSyncJsonVersion = pnpmSyncJson.version;
    if (expectedPnpmSyncJsonVersion !== actualPnpmSyncJsonVersion) {
        const errorMessage = `The .pnpm-sync.json file in ${pnpmSyncJsonFolder} has an incompatible version; regenerate it and try again.`;
        logMessageCallback({
            message: errorMessage,
            messageKind: interfaces_1.LogMessageKind.ERROR,
            details: {
                messageIdentifier: interfaces_1.LogMessageIdentifier.COPY_ERROR_INCOMPATIBLE_SYNC_FILE,
                pnpmSyncJsonPath,
                actualVersion: actualPnpmSyncJsonVersion,
                expectedVersion: expectedPnpmSyncJsonVersion
            }
        });
        throw Error(errorMessage);
    }
    const { sourceFolder, targetFolders } = pnpmSyncJson.postbuildInjectedCopy;
    const sourcePath = path_1.default.resolve(pnpmSyncJsonFolder, sourceFolder);
    // get npmPackFiles
    const npmPackFiles = await getPackageIncludedFiles(sourcePath);
    const startTime = node_process_1.default.hrtime.bigint();
    // init the map to track files that already processed
    const targetFolderFileToIsProcessed = new Map();
    for (const targetFolder of targetFolders) {
        const destinationPath = path_1.default.resolve(pnpmSyncJsonFolder, targetFolder.folderPath);
        if (!fs_1.default.existsSync(destinationPath)) {
            continue;
        }
        const existFileStatInoInTargetFolder = await (0, utilities_1.getFilesInDirectory)(destinationPath);
        // all files are not processed in the beginning
        for (const item of existFileStatInoInTargetFolder) {
            targetFolderFileToIsProcessed.set(item.absolutePath, item);
        }
    }
    await forEachAsyncWithConcurrency(npmPackFiles, async (npmPackFile) => {
        for (const targetFolder of targetFolders) {
            const destinationPath = path_1.default.resolve(pnpmSyncJsonFolder, targetFolder.folderPath);
            const copySourcePath = path_1.default.join(sourcePath, npmPackFile);
            const copyDestinationPath = path_1.default.join(destinationPath, npmPackFile);
            if (!targetFolderFileToIsProcessed.has(copyDestinationPath)) {
                // if not exist in target folder, we just copy it
                await ensureFolderAsync(path_1.default.dirname(copyDestinationPath));
                await fs_1.default.promises.link(copySourcePath, copyDestinationPath);
            }
            else {
                // if exist in target folder, check if it still point to the source Inode number
                // in our copy implementation, we use hard link to copy files
                // so that, we can utilize the file inode info to determine the equality of two files
                const sourceFileIno = (await fs_1.default.promises.stat(copySourcePath)).ino;
                const destinationFileIno = (await fs_1.default.promises.stat(copyDestinationPath)).ino;
                if (sourceFileIno !== destinationFileIno) {
                    await fs_1.default.promises.unlink(copyDestinationPath);
                    await fs_1.default.promises.link(copySourcePath, copyDestinationPath);
                }
                // to keep track which file already processed
                targetFolderFileToIsProcessed.delete(copyDestinationPath);
            }
        }
    }, {
        concurrency: 10
    });
    // delete unprocessed files in target folders
    const unprocessedDirectories = [];
    for (const [absolutePath, item] of targetFolderFileToIsProcessed) {
        if (item.isFile) {
            await fs_1.default.promises.unlink(absolutePath);
        }
        else {
            unprocessedDirectories.push(absolutePath);
        }
    }
    // delete empty folders in target folders as well
    for (const directory of unprocessedDirectories) {
        if ((await fs_1.default.promises.readdir(directory)).length === 0) {
            await fs_1.default.promises.rmdir(directory);
        }
    }
    const endTime = node_process_1.default.hrtime.bigint();
    const executionTimeInMs = Number(endTime - startTime) / 1e6;
    const infoMessage = `Synced ${npmPackFiles.length} ` +
        (npmPackFiles.length === 1 ? 'file' : 'files') +
        ` in ${executionTimeInMs.toFixed(3)} ms from ${sourcePath}`;
    logMessageCallback({
        message: infoMessage,
        messageKind: interfaces_1.LogMessageKind.INFO,
        details: {
            messageIdentifier: interfaces_1.LogMessageIdentifier.COPY_FINISHING,
            pnpmSyncJsonPath,
            fileCount: npmPackFiles.length,
            sourcePath,
            executionTimeInMs
        }
    });
}
exports.pnpmSyncCopyAsync = pnpmSyncCopyAsync;
//# sourceMappingURL=pnpmSyncCopy.js.map