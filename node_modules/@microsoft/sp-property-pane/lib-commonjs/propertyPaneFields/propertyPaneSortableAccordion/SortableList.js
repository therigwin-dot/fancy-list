"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InnerSortableListLegacy = exports.InnerSortableList = exports.SortableList = exports.DRAG_IMAGE_TAG = exports.DRAG_HANDLE_TAG = exports.DRAG_LEAF_TAG = void 0;
var tslib_1 = require("tslib");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var sp_component_utilities_1 = require("@ms/sp-component-utilities");
var sp_telemetry_1 = require("@ms/sp-telemetry");
var React = tslib_1.__importStar(require("react"));
var KillSwitches_1 = require("../../common/KillSwitches");
exports.DRAG_LEAF_TAG = 'drag-leaf';
exports.DRAG_HANDLE_TAG = 'drag-handler';
exports.DRAG_IMAGE_TAG = 'drag-image';
var suffix = Math.random().toString().substr(2, 5);
var dragHandlerClassName = "".concat(exports.DRAG_HANDLE_TAG, "-").concat(suffix);
var dragHandlerSelector = "[data-drag-handle=".concat(exports.DRAG_HANDLE_TAG, "]");
function SortableList(props) {
    return !(0, KillSwitches_1.isCollapseAndCustomizeDragImageKSActivated)()
        ? InnerSortableList(props)
        : InnerSortableListLegacy(props);
}
exports.SortableList = SortableList;
function InnerSortableList(props) {
    var onDragStart = props.onDragStart, onReorderItem = props.onReorderItem;
    var listRef = React.useRef(null);
    var sortableRef = React.useRef(undefined);
    var handleStart = React.useCallback(function (event) {
        onDragStart(event.oldIndex);
    }, [onDragStart]);
    var handleEnd = React.useCallback(function (event) {
        var oldIndex = event.oldIndex;
        var newIndex = event.newIndex;
        if (oldIndex !== newIndex) {
            onReorderItem(oldIndex, newIndex);
        }
    }, [onReorderItem]);
    React.useEffect(function () {
        if (listRef.current) {
            // Sortable only support class name for handler. Here is a workaround to move the attribute to class list.
            var dragElements = [].slice.apply(listRef.current.querySelectorAll(dragHandlerSelector));
            dragElements.forEach(function (dragElement) {
                dragElement.classList.add(dragHandlerClassName);
            });
            var monitor_1 = new sp_telemetry_1._QosMonitor('SortableList.createSortable');
            var handleSetData_1 = function (dataTransfer, draggedElement) {
                // Set the element with the `[data-drag-image=${DRAG_IMAGE_TAG}]` tag to drag image.
                var dragImage = draggedElement.querySelector("[data-drag-image=".concat(exports.DRAG_IMAGE_TAG, "]"));
                if (dragImage) {
                    dataTransfer.setDragImage(dragImage, 0, 0);
                }
            };
            var browser_1 = sp_core_library_1._BrowserDetection.getBrowserInformation().browser;
            sp_component_utilities_1.SortableLoader.GetSortable()
                .then(function (module) {
                sortableRef.current = module.create(listRef.current, {
                    // Set forceFallback for IE and Edge. See https://onedrive.visualstudio.com/SOX/_workitems/edit/620195
                    forceFallback: browser_1 === sp_core_library_1._Browser.IE || browser_1 === sp_core_library_1._Browser.Edge,
                    handle: ".".concat(dragHandlerClassName),
                    onStart: handleStart,
                    onEnd: handleEnd,
                    setData: handleSetData_1,
                    animation: 200
                });
                monitor_1.writeSuccess();
            })
                .catch(function (error) {
                monitor_1.writeUnexpectedFailure(undefined, error);
                throw error;
            });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    React.useEffect(function () {
        if (listRef.current) {
            var dragElements = [].slice.apply(listRef.current.querySelectorAll(dragHandlerSelector));
            dragElements.forEach(function (dragElement) {
                if (!dragElement.classList.contains(dragHandlerClassName)) {
                    dragElement.classList.add(dragHandlerClassName);
                }
            });
        }
        sp_component_utilities_1.SortableLoader.GetSortable()
            .then(function () {
            if (sortableRef.current) {
                sortableRef.current.option('onStart', handleStart);
                sortableRef.current.option('onEnd', handleEnd);
            }
        })
            .catch(function (error) {
            throw error;
        });
    }, [handleStart, handleEnd]);
    React.useEffect(function () {
        return function () {
            var _a;
            (_a = sortableRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
        };
    }, []);
    return (React.createElement("div", { className: 'sortable', ref: listRef }, props.children));
}
exports.InnerSortableList = InnerSortableList;
function InnerSortableListLegacy(props) {
    var listRef = React.useRef(null);
    var sortableRef = React.useRef(undefined);
    React.useEffect(function () {
        var isMounted = true;
        if (props.onReorderItem && listRef.current) {
            // Exclude the elements without `DRAG_LEAF_TAG` from sortable animation.
            // The workaround here is to always set it `animated` field to exclude it.
            for (var i = 0; i < listRef.current.children.length; i++) {
                var child = listRef.current.children.item(i);
                if (child && child.querySelector("[data-drag-tag=".concat(exports.DRAG_LEAF_TAG, "]")) === null) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    child.animated = -1;
                }
            }
            // Sortable only support class name for handler. Here is a workaround to move the attribute to class list.
            var elements = [].slice.apply(listRef.current.querySelectorAll(dragHandlerSelector));
            elements.forEach(function (handler) {
                handler.classList.add(dragHandlerClassName);
            });
            // Set forceFallback on IE and Edge. See details in https://onedrive.visualstudio.com/SOX/_workitems/edit/620195
            var browser = sp_core_library_1._BrowserDetection.getBrowserInformation().browser;
            var forceFallback_1 = browser === sp_core_library_1._Browser.IE || browser === sp_core_library_1._Browser.Edge;
            var monitor_2 = new sp_telemetry_1._QosMonitor('SortableList.createSortable');
            sp_component_utilities_1.SortableLoader.GetSortable()
                .then(function (module) {
                var _a;
                if (isMounted) {
                    sortableRef.current = module.create(listRef.current, {
                        forceFallback: forceFallback_1,
                        handle: ".".concat(dragHandlerClassName),
                        onStart: handleStart,
                        onEnd: handleEnd,
                        animation: 200
                    });
                }
                else {
                    (_a = sortableRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
                    sortableRef.current = undefined;
                }
                monitor_2.writeSuccess();
            })
                .catch(function (error) {
                monitor_2.writeUnexpectedFailure(undefined, error);
                throw error;
            });
        }
        return function () {
            var _a;
            isMounted = false;
            (_a = sortableRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
            sortableRef.current = undefined;
        };
    });
    function handleStart() {
        if (listRef.current) {
            listRef.current.classList.add('dragging');
        }
    }
    function handleEnd(event) {
        // This is a very tricky workaround to mitigate webkit bug: https://bugs.webkit.org/show_bug.cgi?id=134555
        // After user drops the element and moves the mouse a little bit, it considers the dragging action completes.
        // The class `sortable` and `dragging` can be leveraged to skip dragging styles to mitigate the bug.
        document.body.addEventListener('mousemove', function () {
            if (listRef.current) {
                listRef.current.classList.remove('dragging');
            }
        }, { once: true });
        var oldIndex = event.oldIndex;
        var newIndex = event.newIndex;
        if (oldIndex === newIndex) {
            return;
        }
        // Restore the real DOM structure. Otherwise, the React virtual DOM is out of sync with real DOM.
        if (listRef.current) {
            var targetElement = event.item;
            var originalNextIndex = oldIndex < newIndex ? oldIndex : oldIndex + 1;
            var originalNextElement = listRef.current.children.item(originalNextIndex);
            listRef.current.insertBefore(targetElement, originalNextElement);
        }
        // Call `onReorderItem` callback to notify parent to re-render with React.
        if (props.onReorderItem) {
            props.onReorderItem(event.oldIndex, event.newIndex);
        }
    }
    return (React.createElement("div", { className: 'sortable', ref: listRef }, props.children));
}
exports.InnerSortableListLegacy = InnerSortableListLegacy;
//# sourceMappingURL=SortableList.js.map