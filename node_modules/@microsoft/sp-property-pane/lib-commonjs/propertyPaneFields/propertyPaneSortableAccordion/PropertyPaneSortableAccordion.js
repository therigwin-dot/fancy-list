"use strict";
// Copyright (c) Microsoft. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SortableAccordion = exports.PropertyPaneSortableAccordion = void 0;
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var react_components_1 = require("@fluentui/react-components");
var react_icons_1 = require("@fluentui/react-icons");
var react_tabster_1 = require("@fluentui/react-tabster");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var screen_reader_alert_1 = require("@ms/screen-reader-alert");
var odsp_utilities_bundle_1 = require("@ms/odsp-utilities-bundle");
var SortableList_1 = require("./SortableList");
var IPropertyPaneField_1 = require("../propertyPaneField/IPropertyPaneField");
var hooks_1 = require("./hooks");
var PropertyPaneSortableAccordion_styles_1 = require("./PropertyPaneSortableAccordion.styles");
var PropertyPaneSortableAccordionStrings_resx_1 = tslib_1.__importDefault(require("./PropertyPaneSortableAccordionStrings.resx"));
var KillSwitches_1 = require("../../common/KillSwitches");
/**
 * Helper method to create a sortable accordion on the PropertyPane.
 * @param targetProperty - Target property the sortable accordion is associated to.
 * @param properties - Strongly typed sortable accordion properties.
 *
 * @internal
 */
function PropertyPaneSortableAccordion(targetProperty, properties) {
    return {
        type: IPropertyPaneField_1.PropertyPaneFieldType.SortableAccordion,
        targetProperty: targetProperty,
        properties: properties
    };
}
exports.PropertyPaneSortableAccordion = PropertyPaneSortableAccordion;
function SortableAccordion(props) {
    var styles = (0, PropertyPaneSortableAccordion_styles_1.useStyles)();
    var groupField = props.groupField, onUpdateData = props.onUpdateData;
    var targetProperty = groupField.targetProperty;
    var _a = groupField.properties, items = _a.items, activeItem = _a.activeItem, defaultActiveItem = _a.defaultActiveItem, itemEntityName = _a.itemEntityName, disableAccordion = _a.disableAccordion, enableMovedAlerts = _a.enableMovedAlerts, enableDeletedAlerts = _a.enableDeletedAlerts, onUpdateActiveItem = _a.onUpdateActiveItem, onReorderItem = _a.onReorderItem, onDeleteItem = _a.onDeleteItem, onRenderPlaceholder = _a.onRenderPlaceholder;
    // `activeItemState` represents the state of currently activated item.
    // If no item is active, it will be undefined.
    var _b = (0, hooks_1.useActiveItemState)(activeItem, defaultActiveItem), activeItemState = _b[0], setActiveItemState = _b[1];
    var focusItemIndex = React.useRef(null);
    var itemsRef = React.useRef(new Array(items.length));
    // Set the activeItemState when the activeItem changes.
    React.useEffect(function () {
        if (activeItem && activeItem.id !== '') {
            setActiveItemState(activeItem);
        }
    }, [activeItem, activeItem === null || activeItem === void 0 ? void 0 : activeItem.id, activeItem === null || activeItem === void 0 ? void 0 : activeItem.expanded, setActiveItemState]);
    React.useLayoutEffect(function () {
        if (focusItemIndex.current !== null) {
            itemsRef.current[focusItemIndex.current].focus();
            focusItemIndex.current = null;
        }
    }, [items, itemsRef]);
    var listItemTabsterAttributes = (0, react_tabster_1.useMergedTabsterAttributes_unstable)((0, react_tabster_1.useArrowNavigationGroup)({
        axis: 'horizontal'
    }), (0, react_tabster_1.useFocusableGroup)({
        tabBehavior: 'limited-trap-focus',
        ignoreDefaultKeydown: { Enter: true }
    }));
    var handleListItemKeyDown = React.useCallback(function (e) {
        if (e.defaultPrevented) {
            return;
        }
        // if an event is triggered from an element inside the list item
        if (e.target !== e.currentTarget) {
            // for arrow left and right, leave it for horizontal navigation
            // for up and down, we need to manually move focus to the next/previous item
            switch (e.key) {
                case 'ArrowDown':
                case 'ArrowUp':
                    e.preventDefault();
                    e.target.dispatchEvent(new react_tabster_1.GroupperMoveFocusEvent({ action: react_tabster_1.GroupperMoveFocusActions.Escape }));
                    e.currentTarget.dispatchEvent(new react_tabster_1.MoverMoveFocusEvent({ key: react_tabster_1.MoverKeys[e.key] }));
            }
            return;
        }
        // if an event is triggered from the list item itself, we need to manually move focus into the inside items
        switch (e.key) {
            case 'ArrowLeft':
            case 'ArrowRight':
                e.preventDefault();
                e.target.dispatchEvent(new react_tabster_1.GroupperMoveFocusEvent({ action: react_tabster_1.GroupperMoveFocusActions.Enter }));
        }
    }, []);
    var handleClickItem = function (itemId) {
        var expanded = (activeItemState === null || activeItemState === void 0 ? void 0 : activeItemState.id) === itemId ? !(activeItemState === null || activeItemState === void 0 ? void 0 : activeItemState.expanded) : true;
        setActiveItemState({ id: itemId, expanded: expanded });
        onUpdateActiveItem === null || onUpdateActiveItem === void 0 ? void 0 : onUpdateActiveItem(!(0, KillSwitches_1.isEnableHighlightItemExpandedStateKSActivated)()
            ? { id: itemId, expanded: expanded }
            : { id: expanded ? itemId : '', expanded: undefined });
    };
    var handleDeleteItem = function (index) {
        var itemNameToBeRemoved = items[index].title;
        if (onDeleteItem) {
            onDeleteItem(index);
        }
        else {
            var newItems = items.map(function (item) { return item.itemData; });
            newItems.splice(index, 1);
            onUpdateData(targetProperty, newItems);
        }
        focusItemIndex.current = index < items.length - 1 ? index : Math.max(0, index - 1);
        if (enableDeletedAlerts) {
            screen_reader_alert_1.ScreenReaderAlert.read(odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.DeletedAlert, itemNameToBeRemoved), screen_reader_alert_1.ReadingMode.ReadImmediately);
        }
    };
    var handleReorderItems = React.useCallback(function (oldIndex, newIndex) {
        var itemNameToBeMoved = items[oldIndex].title;
        if (onReorderItem) {
            onReorderItem(oldIndex, newIndex);
        }
        else {
            var newItems = items.map(function (item) { return item.itemData; });
            var moved = newItems.splice(oldIndex, 1)[0];
            newItems.splice(newIndex, 0, moved);
            onUpdateData(targetProperty, newItems);
        }
        if (enableMovedAlerts) {
            screen_reader_alert_1.ScreenReaderAlert.read(odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.ReorderAlerts, itemNameToBeMoved, odsp_utilities_bundle_1.StringHelper.getLocaleNumberString(oldIndex + 1), odsp_utilities_bundle_1.StringHelper.getLocaleNumberString(newIndex + 1)), screen_reader_alert_1.ReadingMode.ReadImmediately);
        }
    }, [items, onReorderItem, enableMovedAlerts, targetProperty, onUpdateData]);
    var handleDragStart = React.useCallback(function (oldIndex) {
        setActiveItemState({ id: items[oldIndex].id, expanded: false });
        onUpdateActiveItem === null || onUpdateActiveItem === void 0 ? void 0 : onUpdateActiveItem({ id: items[oldIndex].id, expanded: false });
    }, [items, setActiveItemState, onUpdateActiveItem]);
    var handleUpdateItemData = function (index, newValue) {
        onUpdateData("".concat(targetProperty, "[").concat(index, "]"), newValue);
    };
    var handleUpdateGroupData = function (newValue) {
        onUpdateData(targetProperty, newValue);
    };
    var handleDragIconKeyDown = function (index, event) {
        var isMac = sp_core_library_1._BrowserDetection.getBrowserInformation().os === sp_core_library_1._OS.Mac;
        var mainKey = isMac ? event.metaKey : event.ctrlKey;
        switch (event.key) {
            case 'ArrowUp':
                if (mainKey) {
                    var newIndex = index === 0 ? items.length - 1 : index - 1;
                    event.preventDefault();
                    handleReorderItems(index, newIndex);
                }
                break;
            case 'ArrowDown':
                if (mainKey) {
                    var newIndex = index === items.length - 1 ? 0 : index + 1;
                    event.preventDefault();
                    handleReorderItems(index, newIndex);
                }
                break;
        }
    };
    return (React.createElement(React.Fragment, null, onRenderPlaceholder === null || onRenderPlaceholder === void 0 ? void 0 :
        onRenderPlaceholder(handleUpdateGroupData),
        items.length > 0 && (
        // The sticky position is a workaround to fix the wired drag preview issue caused by some dummy elements added by tabster for focus management.
        React.createElement("div", { style: { position: 'sticky', paddingTop: '8px' }, "data-automation-id": 'PropertyPaneSortableAccordion' },
            React.createElement(SortableList_1.SortableList, { onReorderItem: handleReorderItems, onDragStart: handleDragStart }, items.map(function (item, index) {
                var _a, _b;
                var isItemExpanded = (activeItemState === null || activeItemState === void 0 ? void 0 : activeItemState.id) === item.id && activeItemState.expanded;
                var isItemActive = (activeItemState === null || activeItemState === void 0 ? void 0 : activeItemState.id) === item.id;
                var enableMoveUpButton = index !== 0 && !item.disableSorting;
                var enableMoveDownButton = index < items.length - 1 && !item.disableSorting;
                return (React.createElement("div", { key: item.id, style: { position: 'sticky' }, "data-automation-id": "AccordionItem-".concat(index) },
                    React.createElement("div", { "data-drag-tag": SortableList_1.DRAG_LEAF_TAG },
                        React.createElement("div", tslib_1.__assign({ className: styles.accordionItem, style: {
                                '--focusIndicatorDisplay': isItemExpanded ? 'block' : 'none'
                            }, role: 'group', 
                            // eslint-disable-next-line react/jsx-no-bind
                            ref: function (node) {
                                if (node) {
                                    itemsRef.current[index] = node;
                                }
                                else {
                                    itemsRef.current.splice(index, 1);
                                }
                            }, "aria-label": item.title, tabIndex: 0, onKeyDown: handleListItemKeyDown }, listItemTabsterAttributes),
                            React.createElement("div", { className: styles.accordionItemHeader, "data-drag-image": SortableList_1.DRAG_IMAGE_TAG },
                                React.createElement(react_components_1.Button, { icon: isItemActive ? (React.createElement(react_icons_1.ReOrderDotsVertical20Filled, { color: react_components_1.tokens.colorBrandBackground })) : (React.createElement(react_icons_1.ReOrderDotsVertical20Regular, null)), "data-automation-id": "ReorderButton-".concat(index), "data-drag-handle": SortableList_1.DRAG_HANDLE_TAG, className: styles.dragButton, title: odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.ReorderButtonTooltip, itemEntityName), "aria-label": odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.ReorderButtonAriaLabel, itemEntityName), 
                                    // eslint-disable-next-line react/jsx-no-bind
                                    onKeyDown: function (evt) { return handleDragIconKeyDown(index, evt); }, disabled: item.disableSorting }),
                                React.createElement("span", tslib_1.__assign({ className: styles.accordionItemTitle }, (!item.disableToggle && {
                                    onClick: function () { return handleClickItem(item.id); },
                                    style: tslib_1.__assign({ cursor: 'pointer' }, (isItemActive && {
                                        color: react_components_1.tokens.colorBrandBackground,
                                        fontWeight: react_components_1.tokens.fontWeightSemibold
                                    }))
                                })), item.title),
                                React.createElement("div", { className: styles.accordionItemButtons },
                                    (((_a = item.additionalMenuItems) !== null && _a !== void 0 ? _a : []).length !== 0 ||
                                        enableMoveUpButton ||
                                        enableMoveDownButton ||
                                        item.enableDelete) && (React.createElement(react_components_1.Menu, null,
                                        React.createElement(react_components_1.MenuTrigger, null,
                                            React.createElement(react_components_1.Button, { "data-automation-id": "MenuButton-".concat(index), className: styles.iconButton, icon: React.createElement(react_icons_1.MoreHorizontal20Regular, null), title: PropertyPaneSortableAccordionStrings_resx_1.default.MoreOptionsButtonLabel })),
                                        React.createElement(react_components_1.MenuPopover, null,
                                            React.createElement(react_components_1.MenuList, null, (_b = item.additionalMenuItems) === null || _b === void 0 ? void 0 :
                                                _b.map(function (menuItemProps, menuItemIndex) { return (React.createElement(react_components_1.MenuItem, tslib_1.__assign({ key: menuItemIndex }, menuItemProps, { "data-automation-id": "AdditonMenu-".concat(menuItemIndex) }), menuItemProps.name)); }),
                                                enableMoveUpButton && (React.createElement(react_components_1.MenuItem, { "data-automation-id": "MoveUpButton", 
                                                    // eslint-disable-next-line react/jsx-no-bind
                                                    onClick: function () { return handleReorderItems(index, index - 1); } }, PropertyPaneSortableAccordionStrings_resx_1.default.MoveUpLabel)),
                                                enableMoveDownButton && (React.createElement(react_components_1.MenuItem, { "data-automation-id": "MoveDownButton", disabled: item.disableSorting, 
                                                    // eslint-disable-next-line react/jsx-no-bind
                                                    onClick: function () { return handleReorderItems(index, index + 1); } }, PropertyPaneSortableAccordionStrings_resx_1.default.MoveDownLabel)),
                                                item.enableDelete && (React.createElement(react_components_1.MenuItem, { "data-automation-id": "DeleteButton", 
                                                    // eslint-disable-next-line react/jsx-no-bind
                                                    onClick: function () { return handleDeleteItem(index); }, "aria-label": odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.DeleteAriaLabel, item.title) }, PropertyPaneSortableAccordionStrings_resx_1.default.DeleteTooltip)))))),
                                    !disableAccordion && (React.createElement(react_components_1.Button, { "data-automation-id": "CollapseButton-".concat(index), icon: isItemExpanded ? React.createElement(react_icons_1.ChevronUp20Regular, null) : React.createElement(react_icons_1.ChevronDown20Regular, null), className: styles.iconButton, 
                                        // eslint-disable-next-line react/jsx-no-bind
                                        onClick: function () {
                                            handleClickItem(item.id);
                                        }, title: isItemExpanded
                                            ? odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.HideItemButtonAriaLabel, itemEntityName)
                                            : odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.ShowItemButtonAriaLabel, itemEntityName), disabled: item.disableToggle }))))),
                        !disableAccordion && isItemExpanded && (React.createElement("div", { className: styles.itemConfigurePane }, item.onRenderItemConfiguration(function (itemData) {
                            handleUpdateItemData(index, itemData);
                        }))))));
            }))))));
}
exports.SortableAccordion = SortableAccordion;
//# sourceMappingURL=PropertyPaneSortableAccordion.js.map