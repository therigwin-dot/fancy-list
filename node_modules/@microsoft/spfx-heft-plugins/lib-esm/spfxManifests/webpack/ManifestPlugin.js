function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import * as path from 'node:path';
import crypto from 'node:crypto';
import * as lodash from 'lodash';
import { FileSystem, NewlineKind, JsonFile } from '@rushstack/node-core-library';
import { parseLocFile } from '@rushstack/localization-utilities';
import { DependencyDiscoveryMode } from '../cumulativeManifestProcessor/CumulativeManifestProcessor';
import { LocalizedManifestModuleProcessor } from './LocalizedManifestModuleProcessor';
import { IconHandler } from '../utilities/IconHandler';
import { TerminalHelper } from '../utilities/TerminalHelper';
import { normalizeLocaleName } from '../../utilities/normalizeLocaleName';
import { CHUNK_COMPONENT_MAP, isExternalModule } from '../../plugins/webpackConfigurationPlugin/webpackPlugins/AsyncComponentPlugin';
const PLUGIN_NAME = 'manifest';
const HOT_UPDATE_FILENAME_REGEXP = /\.hot-update\.js$/;
const INTEGRITY_ALGORITHM_NAME = 'sha256';
/**
 * @internal
 */ export function computeIntegrity(source) {
    const hash = crypto.createHash(INTEGRITY_ALGORITHM_NAME);
    if (typeof source === 'string') {
        hash.update(source);
    } else {
        if (!Array.isArray(source)) {
            source = [
                source
            ];
        }
        for (const buffer of source){
            hash.update(buffer);
        }
    }
    const hashDigest = hash.digest('base64');
    return `${INTEGRITY_ALGORITHM_NAME}-${hashDigest}`;
}
function _getChunkName(chunk) {
    return chunk.name || `Unnamed Chunk (#${chunk.id})`;
}
function _isDynamicExternalProject(project) {
    return 'getVersion' in project;
}
/**
 * @internal
 */ export class ManifestPlugin {
    apply(compiler) {
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation)=>{
            const thisWebpack = compiler.webpack;
            class DevReleaseManifestSource extends thisWebpack.sources.RawSource {
                constructor({ serializedDebugManifest, serializedReleaseManifest }){
                    super(serializedDebugManifest);
                    _define_property(this, "releaseManifest", void 0);
                    this.releaseManifest = serializedReleaseManifest;
                }
            }
            const { WebpackError } = thisWebpack;
            compilation.hooks.processAssets.tapPromise({
                name: PLUGIN_NAME,
                stage: thisWebpack.Compilation.PROCESS_ASSETS_STAGE_REPORT
            }, async ()=>{
                const producedManifests = [];
                const asyncOnlyDependencies = new Set(this._options.asyncOnlyDependencies?.asyncOnlyDependencyNames || []);
                const asyncOnlyDependenciesViolationsAsErrors = !!this._options.asyncOnlyDependencies?.violationsAsErrors;
                const terminal = TerminalHelper.getTerminalForWebpackPlugin(compilation);
                const componentDependenciesAuditFile = {
                    bundles: {}
                };
                for (const bundleEntry of this._options.bundleEntries){
                    try {
                        const dependenciesForAudit = new Map();
                        const baseLoaderConfiguration = await this._generateLoaderConfigurationAsync(terminal, thisWebpack, bundleEntry.bundleName, compilation, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit);
                        for (const [componentId, bundleComponent] of Object.entries(bundleEntry.components)){
                            const manifest = this._generateComponentManifest(terminal, thisWebpack, compilation, bundleComponent, baseLoaderConfiguration);
                            // Generate debug component manifest
                            manifest.loaderConfig.internalModuleBaseUrls = this._options.debugInternalModuleBaseUrls;
                            const serializedDebugManifest = JSON.stringify(manifest, undefined, 2);
                            producedManifests.push(manifest);
                            // Generate release component manifest
                            const releaseManifest = JSON.parse(JSON.stringify(manifest));
                            releaseManifest.loaderConfig.internalModuleBaseUrls = this._options.internalModuleBaseUrls;
                            const serializedReleaseManifest = JSON.stringify(releaseManifest, undefined, 2);
                            const manifestFilename = `${componentId}.manifest.json`;
                            compilation.emitAsset(manifestFilename, new DevReleaseManifestSource({
                                serializedDebugManifest,
                                serializedReleaseManifest
                            }));
                        }
                        const componentDependenciesAuditFileBundle = {
                            dependencies: Array.from(dependenciesForAudit.values())
                        };
                        componentDependenciesAuditFile.bundles[bundleEntry.bundleName] = componentDependenciesAuditFileBundle;
                    } catch (error) {
                        compilation.errors.push(error);
                    // Unable to generate manifest entrypoint - continue to the next bundle entry
                    }
                }
                if (this._options.componentDependenciesAuditDropPath) {
                    for (const untypedChunk of compilation.chunks){
                        const chunk = untypedChunk;
                        if (chunk.hasRuntime()) {
                            const asyncChunks = {};
                            if (chunk[CHUNK_COMPONENT_MAP]) {
                                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                for (const [asyncChunk, externalComponents] of chunk[CHUNK_COMPONENT_MAP].entries()){
                                    const dependenciesForAudit = new Map();
                                    for (const externalComponent of externalComponents){
                                        this._populateLinkedExternalComponentInDependencyMap(externalComponent.componentName, externalComponent.componentId, externalComponent.componentVersion, true, dependenciesForAudit);
                                    }
                                    asyncChunks[_getChunkName(asyncChunk)] = {
                                        asyncComponentDependencies: Array.from(dependenciesForAudit.values())
                                    };
                                }
                            }
                            const chunkName = _getChunkName(chunk);
                            const entry = componentDependenciesAuditFile.bundles[chunkName];
                            if (entry) {
                                entry.asyncChunks = asyncChunks;
                            } else {
                                // Allow the process to continue so that webpack can report the upstream error.
                                compilation.errors.push(new WebpackError(`ManifestPlugin: Unable to find entry point for async bundle "${chunkName}" in the manifest.`));
                            }
                        }
                    }
                    await JsonFile.saveAsync(componentDependenciesAuditFile, this._options.componentDependenciesAuditDropPath, {
                        ensureFolderExists: true,
                        ignoreUndefinedValues: true
                    });
                }
                await this._options.cumulativeManifestProcessor.generateCumulativeManifestAsync(producedManifests, this._options.manifestsJsFileMetadata, this._options.useManifestsJsonForComponentDependencies ? DependencyDiscoveryMode.shallow : DependencyDiscoveryMode.deepSparseIgnoreFirstProject);
            });
        });
    }
    /**
   * @virtual
   */ async _generateLoaderConfigurationAsync(terminal, thisWebpack, bundleName, compilation, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit) {
        const entrypoint = compilation.entrypoints.get(bundleName);
        if (!entrypoint) {
            throw new Error(`Expected to find an entrypoint with name "${bundleName}".`);
        }
        const runtimeChunk = this._getRuntimeChunk(bundleName, entrypoint);
        const scriptResources = await this._getExternalsScriptResourcesAsync(terminal, thisWebpack, bundleName, compilation, runtimeChunk, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit);
        const entrypointManifestModule = this._getEntryManifestModule(bundleName, runtimeChunk, compilation.assets);
        const loaderConfiguration = {
            internalModuleBaseUrls: this._options.internalModuleBaseUrls,
            entryModuleId: bundleName,
            scriptResources: {
                [bundleName]: entrypointManifestModule,
                ...scriptResources
            }
        };
        return loaderConfiguration;
    }
    _getRuntimeChunk(bundleName, entrypoint) {
        const runtimeChunk = entrypoint.getRuntimeChunk();
        if (!runtimeChunk) {
            throw new Error(`Expected to find an runtime chunk with name "${bundleName}".`);
        } else {
            return runtimeChunk;
        }
    }
    async _getExternalsScriptResourcesAsync(terminal, thisWebpack, bundleName, compilation, runtimeChunk, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit) {
        const scriptResources = {};
        for (const module of compilation.chunkGraph.getChunkModules(runtimeChunk)){
            if (isExternalModule(module)) {
                const externalName = module.userRequest;
                if (asyncOnlyDependencies.has(externalName)) {
                    const message = `Dependency "${externalName}" is marked as async-only, but is used ` + `synchronously in bundle "${bundleName}"`;
                    if (asyncOnlyDependenciesViolationsAsErrors) {
                        terminal.writeError(message);
                    } else {
                        terminal.writeWarning(message);
                    }
                }
                if (bundleName === externalName) {
                    throw new Error(`Bundle name "${bundleName}" collides with a dependent component name.`);
                }
                let externalManifestModules;
                const externalComponent = this._options.linkedExternals.get(externalName);
                if (externalComponent) {
                    let version = externalComponent.version;
                    const { id, name } = externalComponent;
                    if (!version) {
                        if (_isDynamicExternalProject(externalComponent)) {
                            const dependentPackagePaths = new Set();
                            const originModules = Array.from(compilation.moduleGraph.getIncomingConnectionsByOriginModule(module).keys());
                            for (const originModule of originModules){
                                if (originModule instanceof thisWebpack.NormalModule) {
                                    const descriptionFileRoot = originModule.resourceResolveData?.descriptionFileRoot;
                                    if (descriptionFileRoot) {
                                        dependentPackagePaths.add(descriptionFileRoot);
                                    }
                                } else if (originModule) {
                                    const modules = originModule.modules;
                                    if (modules) {
                                        for (const subModule of modules){
                                            originModules.push(subModule);
                                        }
                                    }
                                }
                            }
                            for (const dependentPackagePath of dependentPackagePaths){
                                version = externalComponent.getVersion(dependentPackagePath, this._options.referencedProjects);
                                if (version) {
                                    terminal.writeVerboseLine(`Found version "${version}" for external "${externalName}", resolved from "${dependentPackagePath}".`);
                                    break;
                                }
                            }
                        }
                        if (!version) {
                            throw new Error(`External "${externalName}" has an unresolved version.`);
                        }
                    }
                    const externalComponentModule = {
                        type: 'component',
                        id,
                        version
                    };
                    this._populateLinkedExternalComponentInDependencyMap(name, id, version, true, dependenciesForAudit);
                    externalManifestModules = {
                        [externalName]: externalComponentModule
                    };
                } else {
                    const legacyExternal = this._options.tryGetLegacyExternalByNameAsync ? await this._options.tryGetLegacyExternalByNameAsync(externalName) : undefined;
                    if (legacyExternal) {
                        externalManifestModules = legacyExternal.moduleConfigurations;
                        for (const [assetName, assetContents] of Object.entries(legacyExternal.assets)){
                            compilation.emitAsset(assetName, new thisWebpack.sources.RawSource(assetContents));
                        }
                    } else {
                        throw new Error(`Did not find linked external "${externalName}" for bundle "${bundleName}".`);
                    }
                }
                for (const [name, external] of Object.entries(externalManifestModules)){
                    scriptResources[name] = external;
                }
            }
        }
        return scriptResources;
    }
    _getRuntimeChunkInfo(bundleName, runtimeChunk, assets) {
        let filename;
        for (const file of runtimeChunk.files){
            const isCandidate = path.extname(file) === '.js' && // TODO - figure out if there is a way to determine this from module metadata
            !HOT_UPDATE_FILENAME_REGEXP.test(file);
            if (isCandidate) {
                if (filename) {
                    throw new Error(`Found more than one .js file in the runtime chunk for the "${bundleName}" bundle.`);
                } else {
                    filename = file;
                }
            }
        }
        if (!filename) {
            throw new Error(`Did not find a .js file in the runtime chunk for the "${bundleName}" bundle.`);
        } else {
            if (this._options.includeIntegrity) {
                const asset = assets[filename];
                if (!asset) {
                    throw new Error(`Did not find asset "${filename}" for the "${bundleName}" bundle.`);
                } else {
                    const integrity = computeIntegrity(asset.buffer());
                    return {
                        path: filename,
                        integrity
                    };
                }
            } else {
                return filename;
            }
        }
    }
    _generateComponentManifest(terminal, thisWebpack, compilation, bundleComponent, baseLoaderConfiguration) {
        const loaderConfig = {
            ...baseLoaderConfiguration
        };
        if (bundleComponent.exportName) {
            loaderConfig.exportName = bundleComponent.exportName;
        }
        const inputManifest = lodash.cloneDeep(bundleComponent.manifestData);
        delete inputManifest.$schema;
        switch(inputManifest.componentType){
            case 'AdaptiveCardExtension':
            case 'WebPart':
                {
                    this._processWebpartManifest(terminal, thisWebpack, compilation, bundleComponent.manifestPath, inputManifest);
                    break;
                }
            case 'Application':
                {
                    this._processApplicationManifest(terminal, thisWebpack, compilation, bundleComponent.manifestPath, inputManifest);
                    break;
                }
            case 'Extension':
                {
                    this._processExtensionsManifest(terminal, thisWebpack, compilation, bundleComponent.manifestPath, inputManifest);
                    break;
                }
        }
        inputManifest.loaderConfig = loaderConfig;
        return inputManifest;
    }
    /**
   * Process and localize WebPart manifest.
   * @remarks Also used for AdaptiveCardExtension manifests
   */ _processWebpartManifest(terminal, thisWebpack, compilation, manifestPath, manifest) {
        for (const entry of manifest.preconfiguredEntries){
            entry.title = this._localizeString(terminal, thisWebpack, compilation, manifestPath, entry.title);
            entry.description = this._localizeString(terminal, thisWebpack, compilation, manifestPath, entry.description);
            if (entry.group) {
                entry.group = this._localizeString(terminal, thisWebpack, compilation, manifestPath, entry.group);
            }
            if (entry.tags) {
                // We don't allow more than 10 tags
                entry.tags = entry.tags.slice(0, 10).map((tag)=>this._localizeString(terminal, thisWebpack, compilation, manifestPath, tag));
            }
            entry.iconImageUrl = IconHandler.processIconPath(this._options.terminal, compilation, manifestPath, entry.iconImageUrl);
        }
    }
    _processApplicationManifest(terminal, thisWebpack, compilation, manifestPath, manifest) {
        manifest.title = this._localizeString(terminal, thisWebpack, compilation, manifestPath, manifest.title);
        manifest.description = this._localizeString(terminal, thisWebpack, compilation, manifestPath, manifest.description);
    }
    /**
   * Does extension-specific manifest processing.
   */ _processExtensionsManifest(terminal, thisWebpack, compilation, manifestPath, manifest) {
        switch(manifest.extensionType){
            case 'ListViewCommandSet':
                const commandSetManifest = manifest;
                for(const itemId in commandSetManifest.items){
                    if (commandSetManifest.items.hasOwnProperty(itemId)) {
                        const item = commandSetManifest.items[itemId];
                        item.title = this._localizeString(terminal, thisWebpack, compilation, manifestPath, item.title);
                        if (item.ariaLabel) {
                            item.ariaLabel = this._localizeString(terminal, thisWebpack, compilation, manifestPath, item.ariaLabel);
                        }
                        item.iconImageUrl = IconHandler.processIconPath(this._options.terminal, compilation, manifestPath, item.iconImageUrl);
                    }
                }
                break;
            case 'Unknown':
            case 'ApplicationCustomizer':
            case 'FieldCustomizer':
                break;
        }
    }
    /**
   * Localizes a string with an ID in the form of $<path-to-loc-file>:<string-name>;
   * If the string to localize is not based on an id, it returns the input param untouched.
   */ _localizeString(terminal, thisWebpack, compilation, manifestPath, stringToLocalize) {
        // If there is no id, assume the property is either not localized, or the localized values are
        // hardcoded.
        if (!stringToLocalize.id) {
            return stringToLocalize;
        }
        const EMPTY_LOCALIZED_STRING = {
            default: ''
        };
        const regex = /^(?:\$)([^:]+)(?:\:)(.+)(?:\;)$/; // Test $<path-to-loc-file>:<string-name>;
        const matches = stringToLocalize.id.match(regex);
        if (matches?.length === 3) {
            this._options.terminal.writeVerboseLine(`Localizing string '${matches[0]}'`);
            const locFilePath = matches[1];
            const stringName = matches[2];
            const locFileAbsolutePath = path.resolve(path.dirname(manifestPath), locFilePath);
            if (!FileSystem.exists(locFileAbsolutePath)) {
                compilation.errors.push(new thisWebpack.WebpackError(`Loc file missing from resolved path "${locFileAbsolutePath}". The manifest string will be missing.`));
                return EMPTY_LOCALIZED_STRING;
            } else {
                const localizedStrings = {};
                const normalizedSourceLocaleName = normalizeLocaleName(this._options.sourceLocaleName);
                const translationsForLocFile = this._options.tryGetLocFileTranslations(locFileAbsolutePath) || {};
                let locFile = translationsForLocFile?.[this._options.sourceLocaleName];
                if (!locFile) {
                    locFile = this._parsedLocFileCache.get(locFileAbsolutePath);
                    if (!locFile) {
                        const parsedSourceFile = parseLocFile({
                            filePath: locFileAbsolutePath,
                            content: FileSystem.readFile(locFileAbsolutePath),
                            terminal,
                            resxNewlineNormalization: NewlineKind.Lf,
                            ignoreMissingResxComments: false
                        });
                        locFile = {};
                        for (const [strName, { value }] of Object.entries(parsedSourceFile)){
                            locFile[strName] = value;
                        }
                        this._parsedLocFileCache.set(locFileAbsolutePath, locFile);
                    }
                }
                if (!locFile[stringName]) {
                    compilation.errors.push(new thisWebpack.WebpackError(`Loc file "${locFileAbsolutePath}" doesn't contain a string with name "${stringName}".`));
                    return EMPTY_LOCALIZED_STRING;
                } else {
                    const selectedLocales = this._options.selectedLocales || Object.keys(translationsForLocFile);
                    for (const localeName of selectedLocales){
                        const translatedLocFile = translationsForLocFile[localeName];
                        const normalizedLocaleName = normalizeLocaleName(localeName);
                        if (!translatedLocFile[stringName]) {
                            terminal.writeVerboseLine(`Loc file "${locFilePath}" for locale ${normalizedLocaleName} is either missing or is missing string ` + `"${stringName}". Falling back to the string from ${normalizedSourceLocaleName}`);
                            localizedStrings[normalizedLocaleName] = locFile[stringName];
                        } else {
                            localizedStrings[normalizedLocaleName] = translatedLocFile[stringName];
                        }
                    }
                    if (this._options.firstPassLocaleRemapping) {
                        LocalizedManifestModuleProcessor.applyLocaleRemapping(localizedStrings, this._options.firstPassLocaleRemapping);
                    }
                    LocalizedManifestModuleProcessor.applyLocaleRemapping(localizedStrings, LocalizedManifestModuleProcessor.LOCALE_MAPPING);
                    // Do this twice because some locales (like en-gb) appear both as values and as keys
                    LocalizedManifestModuleProcessor.applyLocaleRemapping(localizedStrings, LocalizedManifestModuleProcessor.LOCALE_MAPPING);
                    const defaultString = LocalizedManifestModuleProcessor.findDefaultString(localizedStrings);
                    if (defaultString) {
                        localizedStrings.default = defaultString;
                    } else {
                        compilation.errors.push(new thisWebpack.WebpackError(`Unable to select a default string for the localized string "${stringToLocalize.id}"`));
                        localizedStrings.default = '';
                    }
                    return localizedStrings;
                }
            }
        } else {
            compilation.errors.push(new thisWebpack.WebpackError(`String id '${stringToLocalize.id}' has wrong format. It is not $<moduleName>:<expression>;`));
            return EMPTY_LOCALIZED_STRING;
        }
    }
    _getEntryManifestModule(bundleName, runtimeChunk, assets) {
        if (runtimeChunk.localizedFiles) {
            // We have localized files, so this is a localized component
            return LocalizedManifestModuleProcessor.generateLocalizedManifestModule({
                bundleName,
                localizedPaths: runtimeChunk.localizedFiles,
                firstPassLocaleRemapping: this._options.firstPassLocaleRemapping,
                production: this._options.production,
                generateIntegrity: this._options.includeIntegrity,
                selectedLocales: this._options.selectedLocales,
                assets
            });
        } else {
            // No localized files, so this isn't a localized component
            const runtimeChunkPath = this._getRuntimeChunkInfo(bundleName, runtimeChunk, assets);
            const moduleConfiguration = {
                type: 'path',
                path: runtimeChunkPath
            };
            return moduleConfiguration;
        }
    }
    _populateLinkedExternalComponentInDependencyMap(dependencyName, dependencyId, dependencyVersion, isDirectDependency, dependenciesForAudit) {
        const nameWithVersion = dependencyVersion ? `${dependencyName}@${dependencyVersion}` : dependencyName;
        if (dependenciesForAudit.has(nameWithVersion)) {
            // A dependency name with this version already exists, skip
            return;
        }
        const existingAuditDependency = dependenciesForAudit.get(dependencyName);
        let nameToRecord = dependencyName;
        if (existingAuditDependency) {
            if (existingAuditDependency.componentVersion !== dependencyVersion) {
                // Remove and re-add this dependency to include the version
                dependenciesForAudit.delete(dependencyName);
                dependenciesForAudit.set(`${existingAuditDependency.componentName}@${existingAuditDependency.componentVersion}`, existingAuditDependency);
                nameToRecord = nameWithVersion;
            } else {
                // We've already recorded this dependency with this version
                return;
            }
        }
        if (!dependenciesForAudit.has(dependencyName)) {
            dependenciesForAudit.set(nameToRecord, {
                componentId: dependencyId,
                componentName: dependencyName,
                componentVersion: dependencyVersion,
                isDirectDependency
            });
            const referencedDependencyVersions = this._options.referencedProjects[dependencyId];
            if (!referencedDependencyVersions) {
                // If there is no project in referencedProjects, this is probably a non-standard external, so
                // it doesn't have conventional SPFx dependencies
                return;
            }
            let referencedDependency;
            if (dependencyVersion) {
                referencedDependency = referencedDependencyVersions[dependencyVersion];
                if (!referencedDependency) {
                    throw new Error(`Unable to find version "${dependencyVersion}" of component "${dependencyName}"`);
                }
            } else {
                const versions = Object.entries(referencedDependencyVersions);
                if (versions.length === 1) {
                    referencedDependency = versions[0][1];
                } else if (versions.length === 0) {
                    throw new Error(`No versions exist for dependency "${dependencyName}". This is not expected.`);
                } else {
                    throw new Error(`No version specified for "${dependencyName}" and multiple dependency versions exist.`);
                }
            }
            for (const [depName, dep] of Object.entries(referencedDependency.manifestData.loaderConfig.scriptResources)){
                if (dep.type === 'component') {
                    const componentDependency = dep;
                    this._populateLinkedExternalComponentInDependencyMap(depName, componentDependency.id, componentDependency.version, false, dependenciesForAudit);
                }
            }
        }
    }
    constructor(options){
        /**
   * @internal
   */ _define_property(this, "_options", void 0);
        _define_property(this, "_parsedLocFileCache", new Map());
        this._options = options;
    }
}

//#sourceMappingUrl=./ManifestPlugin.js.map