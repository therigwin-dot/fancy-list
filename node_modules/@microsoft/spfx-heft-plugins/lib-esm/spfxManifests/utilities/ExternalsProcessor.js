// This class does not really belong in this package.
// TODO: Move this class to a different package.
import * as path from 'path';
import { Import, PackageJsonLookup } from '@rushstack/node-core-library';
let _nonStandardExternalMapIsInitialized = false;
const _nonStandardExternalMap = new Map([
    [
        'react',
        {
            name: 'react',
            version: undefined,
            id: '0d910c1c-13b9-4e1c-9aa4-b008c5e42d7d',
            getFailoverPath: (packageRoot)=>path.join(packageRoot, 'index.js'),
            getVersion: getVersionFromPackageJson('react')
        }
    ],
    [
        'react-dom',
        {
            name: 'react-dom',
            version: undefined,
            id: 'aa0a46ec-1505-43cd-a44a-93f3a5aa460a',
            getFailoverPath: (packageRoot)=>path.join(packageRoot, 'index.js'),
            getVersion: getVersionFromPackageJson('react-dom')
        }
    ],
    [
        '@microsoft/microsoft-graph-client',
        {
            name: '@microsoft/microsoft-graph-client',
            version: undefined,
            id: '32b9363b-09ff-4959-929a-cab2663fb223',
            getFailoverPath: (packageRoot)=>`${packageRoot}/lib/index.js`,
            getVersion: getVersionFromPackageJson('@microsoft/microsoft-graph-client')
        }
    ]
]);
/**
 * @internal
 */ export function includeNonStandardExternal(name, external) {
    if (_nonStandardExternalMapIsInitialized) {
        throw new Error("The non-standard external map has already been initialized, which means it's probably already " + 'been used. Adding an additional non-standard external is likely to not have any effect.');
    }
    _nonStandardExternalMap.set(name, external);
}
/**
 * This is a temporary function that will soon be replaced by something more robust. It
 *  currently serves to include linked externals referenced in projects that don't have manifests.
 */ export function getNonStandardExternals(projectRootPath, referencedProjects) {
    const result = new Map();
    _initializeNonStandardExternalMap(projectRootPath, referencedProjects);
    for (const [dependencyName, dependency] of _nonStandardExternalMap){
        _tryFillFailoverPath(projectRootPath, dependency);
        result.set(dependencyName, dependency);
    }
    return result;
}
function _initializeNonStandardExternalMap(projectRootPath, referencedProjects) {
    if (!_nonStandardExternalMapIsInitialized) {
        for (const project of _nonStandardExternalMap.values()){
            project.version = project.getVersion?.(projectRootPath, referencedProjects);
        }
        _nonStandardExternalMapIsInitialized = true;
    }
}
/**
 * @internal
 */ export function getVersionFromPackageJson(packageName) {
    return (projectRootPath)=>{
        try {
            const resolvedPath = Import.resolvePackage({
                packageName: packageName,
                baseFolderPath: projectRootPath
            });
            if (resolvedPath) {
                const packageJson = PackageJsonLookup.instance.loadPackageJson(`${resolvedPath}/package.json`);
                const version = packageJson.version;
                const matches = version.match(/([^-]*)(?:.*)/);
                const matchIndex = 1;
                if (!matches || matches.length < matchIndex + 1) {
                    return undefined;
                }
                return matches[matchIndex];
            }
        } catch (e) {
            return undefined;
        }
    };
}
function _tryFillFailoverPath(projectRootPath, dependency) {
    if (!dependency.failoverPath && dependency.getFailoverPath) {
        try {
            const resolvedPath = Import.resolvePackage({
                packageName: dependency.name,
                baseFolderPath: projectRootPath
            });
            dependency.failoverPath = dependency.getFailoverPath(resolvedPath);
        } catch (e) {
        /* no-op */ }
    }
}

//#sourceMappingUrl=./ExternalsProcessor.js.map