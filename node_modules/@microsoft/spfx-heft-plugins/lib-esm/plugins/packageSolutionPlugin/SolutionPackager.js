function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import glob from 'fast-glob';
import path from 'path';
import { ConfigurationFile } from '@rushstack/heft-config-file';
import { Async, JsonFile, FileSystem } from '@rushstack/node-core-library';
import { Colorize } from '@rushstack/terminal';
import createPackageAsync from './packageSolution/createPackage';
import { default as WebpackConfigurationPlugin } from '../webpackConfigurationPlugin/WebpackConfigurationPlugin';
import { UrlUtilities } from '../../utilities/UrlUtilities';
import schema from './package-solution.schema.json';
const DEFAULT_CONFIG = {
    paths: {
        packageDir: 'sharepoint',
        debugDir: 'solution/debug',
        zippedPackage: 'solution/ClientSolution.sppkg',
        featureXmlDir: 'feature_xml',
        sharepointAssetDir: 'assets',
        teamsDir: 'teams'
    },
    contentTypes: {
        xml: 'text/xml',
        rels: 'application/vnd.openxmlformats-package.relationships+xml',
        webpart: 'text/xml',
        htm: 'text/html',
        html: 'text/html',
        aspx: 'text/xml',
        resx: 'text/xml',
        js: 'application/javascript',
        json: 'application/json',
        png: 'image/png',
        jpg: 'image/jpeg',
        bmp: 'image/bmp',
        gif: 'image/gif'
    },
    solution: {
        name: 'A Sample Solution',
        id: '00000000-0000-0000-0000-000000000000'
    }
};
/**
 * @internal
 */ export class SolutionPackager {
    async packageSolutionAsync(production, prettyPrintXml = false, noSpppkg = false) {
        const config = await this._ensureConfigFileAsync();
        if (!config) {
            this._emitError(new Error(`A ${SolutionPackager._configFile.projectRelativeFilePath} file does not ` + `exist in this project, so this project cannot produce a SharePoint solution package.`));
            return;
        }
        if (config.solution.includeClientSideAssets && !production) {
            this._emitWarning(new Error('This is not a production build (--production), therefore the ' + '"includeClientSideAssets" setting will be ignored.'));
            config.solution.includeClientSideAssets = false;
        }
        const ignoredAssets = [
            '**/*.map'
        ];
        let assetsFolderPath;
        let manifestsFolderPath;
        if (production) {
            manifestsFolderPath = `${this._webpackOutputFolderPaths.releaseFolder}/manifests`;
            assetsFolderPath = `${this._webpackOutputFolderPaths.releaseFolder}/assets`;
        } else {
            manifestsFolderPath = assetsFolderPath = this._webpackOutputFolderPaths.outputFolder;
        }
        const manifestMap = new Map();
        let foundAnyManifests = false;
        const manifestFilenames = await glob('*.manifest.json', {
            cwd: manifestsFolderPath
        });
        await Async.forEachAsync(manifestFilenames, async (manifestFilename)=>{
            foundAnyManifests = true;
            const manifest = await JsonFile.loadAsync(`${manifestsFolderPath}/${manifestFilename}`);
            if (manifest.componentType === 'WebPart') {
                const webpartManifest = manifest;
                if (webpartManifest.supportedHosts) {
                    let foundTeamsTab = false;
                    let foundMeetingsTab = false;
                    for (const supportedHost of webpartManifest.supportedHosts){
                        if (supportedHost === 'TeamsMeetingApp') {
                            foundMeetingsTab = true;
                        } else if (supportedHost === 'TeamsPersonalApp' || supportedHost === 'TeamsTab') {
                            foundTeamsTab = true;
                        }
                    }
                    if (foundTeamsTab && foundMeetingsTab) {
                        this._emitError(new Error(`Manifest contains supported host of TeamsMeetingApp as well as another tab type and is not compatible`));
                    }
                }
            }
            // Re-enable fail on validation error https://onedrive.visualstudio.com/WEX!/_workitems/edit/1056377
            this._terminal.writeLine(`Found manifest: ${manifestFilename}`);
            ignoredAssets.push(manifestFilename);
            manifestMap.set(manifest.id, manifest);
        }, {
            concurrency: 5
        });
        if (!manifestMap.size) {
            if (foundAnyManifests) {
                this._emitError(new Error(`Manifests were found in '${manifestsFolderPath}', but were not valid.`));
            } else {
                this._emitError(new Error(`No manifests were found in '${manifestsFolderPath}'. Ensure a build has completed successfully`));
            }
            return;
        }
        // Collect all the assets, if necessary
        let assets;
        if (config.solution.includeClientSideAssets) {
            const assetsPaths = await glob('**/*.*', {
                ignore: ignoredAssets,
                cwd: assetsFolderPath
            });
            assets = assetsPaths.map((filename)=>{
                this._terminal.writeLine(Colorize.cyan(`Found client-side build resource: ${filename}`));
                return {
                    originalFilename: `${assetsFolderPath}/${filename}`,
                    packageFilename: filename
                };
            });
        } else {
            assets = [];
        }
        // Always copy everything from the teams folder
        const teamsIconPaths = await glob('**/*.*', {
            ignore: ignoredAssets,
            cwd: config.paths.teamsDir
        });
        const teamsIcons = teamsIconPaths.map((filename)=>{
            this._terminal.writeLine(Colorize.cyan(`Found teams icons: ${filename}`));
            return {
                originalFilename: `${config.paths.teamsDir}/${filename}`,
                packageFilename: filename
            };
        });
        // eslint-disable-next-line require-atomic-updates
        config.solution.clientSideAssets = [
            ...assets,
            ...teamsIcons
        ];
        // Adding screenshots to the list of client side assets
        const { metadata } = config.solution;
        if (metadata && metadata.screenshotPaths) {
            const screenshots = [];
            for(let screenshotPathIdx = 0, screenshotPathsLen = metadata.screenshotPaths.length; screenshotPathIdx < screenshotPathsLen; screenshotPathIdx++){
                let screenshotPath = metadata.screenshotPaths[screenshotPathIdx];
                if (!UrlUtilities.isUrl(screenshotPath)) {
                    screenshotPath = path.join(config.paths.packageDir, metadata.screenshotPaths[screenshotPathIdx]);
                    const screenshotExists = await FileSystem.existsAsync(screenshotPath);
                    if (screenshotExists) {
                        const screenshotFilename = path.basename(screenshotPath);
                        this._terminal.writeLine(Colorize.cyan(`Found screenshot: ${screenshotFilename}`));
                        screenshots.push({
                            originalFilename: screenshotPath,
                            packageFilename: screenshotFilename
                        });
                        // updating screenshot to store filename - for XML generation
                        metadata.screenshotPaths[screenshotPathIdx] = screenshotFilename;
                    } else {
                        this._emitError(new Error(`Can't find the screenshot at ${screenshotPath}. Ensure the file exists.`));
                    }
                }
            }
            config.solution.clientSideAssets.push(...screenshots);
            if (config.solution.iconPath) {
                const iconPath = path.join(config.paths.packageDir, config.solution.iconPath);
                const iconExists = await FileSystem.existsAsync(iconPath);
                if (iconExists) {
                    const iconName = path.basename(iconPath);
                    this._terminal.writeLine(Colorize.cyan(`Found icon: ${iconName}`));
                    const iconClientSideAsset = {
                        originalFilename: iconPath,
                        packageFilename: iconName
                    };
                    config.solution.clientSideAssets.push(iconClientSideAsset);
                } else {
                    this._emitError(new Error(`Can't find the icon at ${iconPath}. Ensure the file exists.`));
                }
            }
        }
        const xmlSerializationOptions = {
            indent: prettyPrintXml ? '  ' : undefined,
            declaration: {
                encoding: 'utf-8'
            }
        };
        await createPackageAsync(this._terminal, xmlSerializationOptions, config, manifestMap, noSpppkg);
    }
    async getCleanPathsAsync() {
        const config = await this._ensureConfigFileAsync();
        if (config) {
            return [
                config.paths.debugDir,
                config.paths.zippedPackage
            ];
        } else {
            return [];
        }
    }
    async _ensureConfigFileAsync() {
        if (!this._alreadyTriedToLoadConfig) {
            let config = await SolutionPackager._configFile.tryLoadConfigurationFileForProjectAsync(this._terminal, this._buildFolder);
            this._alreadyTriedToLoadConfig = true;
            if (config) {
                // Include defaults
                config = {
                    ...DEFAULT_CONFIG,
                    ...config
                };
                config.paths = {
                    ...DEFAULT_CONFIG.paths,
                    ...config.paths
                };
                // Resolve paths
                const packageDir = `${this._buildFolder}/${config.paths.packageDir}`;
                config.paths = {
                    packageDir: packageDir,
                    debugDir: `${packageDir}/${config.paths.debugDir}`,
                    zippedPackage: `${packageDir}/${config.paths.zippedPackage}`,
                    featureXmlDir: `${packageDir}/${config.paths.featureXmlDir}`,
                    sharepointAssetDir: `${packageDir}/${config.paths.sharepointAssetDir}`,
                    teamsDir: `${this._buildFolder}/${config.paths.teamsDir}`
                };
                this._updateContentTypes(config);
            }
            this._config = config;
        }
        return this._config;
    }
    _updateContentTypes(config) {
        if (!config.solution || !config.solution.features) {
            return;
        }
        if (!config.contentTypes) {
            config.contentTypes = {};
        }
        for (const feature of config.solution.features){
            const { assets } = feature;
            if (assets) {
                const { elementFiles } = assets;
                if (elementFiles) {
                    const fileExtensions = this._getFilesExtensions(elementFiles);
                    for (const fileExtension of fileExtensions){
                        if (!config.contentTypes[fileExtension]) {
                            config.contentTypes[fileExtension] = 'application/octet-stream';
                        }
                    }
                }
            }
        }
    }
    _getFilesExtensions(filePaths) {
        return filePaths.map((filePath)=>filePath.slice(filePath.lastIndexOf('.') + 1));
    }
    constructor(options){
        _define_property(this, "_buildFolder", void 0);
        _define_property(this, "_webpackOutputFolderPaths", void 0);
        _define_property(this, "_terminal", void 0);
        _define_property(this, "_emitError", void 0);
        _define_property(this, "_emitWarning", void 0);
        _define_property(this, "_alreadyTriedToLoadConfig", false);
        _define_property(this, "_config", void 0);
        this._buildFolder = options.buildFolder;
        this._webpackOutputFolderPaths = WebpackConfigurationPlugin.getSpfxWebpackFolders(this._buildFolder);
        this._terminal = options.terminal;
        this._emitError = options.emitError;
        this._emitWarning = options.emitWarning;
    }
}
_define_property(SolutionPackager, "_configFile", new ConfigurationFile({
    projectRelativeFilePath: 'config/package-solution.json',
    jsonSchemaObject: schema
}));

//#sourceMappingUrl=./SolutionPackager.js.map