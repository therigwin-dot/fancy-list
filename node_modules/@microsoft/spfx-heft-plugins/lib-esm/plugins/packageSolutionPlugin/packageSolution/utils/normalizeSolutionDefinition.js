/**
 * Using a manifest map, creates component definitions and updates a package definition's element guids with
 * actual objects
 */ import * as path from 'path';
import * as uuid from 'uuid';
import { FileSystem, Import } from '@rushstack/node-core-library';
// NOTE: this value is required for the client side asset packaging feature. The base URL value must match exactly
// with the server-side value in the file SPClientSideThirdPartyComponentProvider.cs. This informs the server-side
// third-party component provider that it needs to replace this URL with the public CDN URL.
const clientSideAssetLibraryPseudoUrl = 'HTTPS://SPCLIENTSIDEASSETLIBRARY/';
function createComponent(terminal, manifest) {
    if (!manifest.id || !manifest || !manifest.componentType) {
        return undefined;
    }
    if (manifest.componentType === 'Application') {
        return createApplicationComponent(manifest);
    } else if (manifest.componentType === 'WebPart') {
        return createWebPartComponent(manifest);
    } else if (manifest.componentType === 'Extension') {
        return createExtensionComponent(manifest);
    } else if (manifest.componentType === 'Library') {
        return createLibraryComponent(manifest);
    } else if (manifest.componentType === 'AdaptiveCardExtension') {
        return createLibraryComponent(manifest);
    } else {
        terminal.writeLine(`Component type '${manifest.componentType}' not recognized. Skipping manifest.`);
        return undefined;
    }
}
function getRequiresCustomScriptProperty(manifest) {
    // a manifest either has requiresCustomScript or the deprecated safeWithCustomScriptDisabled
    // however, we are now ignoring the value of safeWithCustomScriptDisabled since it was formerly
    // set to false in the generator's templates
    // if they have the value set to 'false', we will print a warning
    const requiresCustomScript = !!manifest.requiresCustomScript;
    delete manifest.requiresCustomScript;
    delete manifest.safeWithCustomScriptDisabled;
    return requiresCustomScript; // this will default this value to false
}
function createExtensionComponent(manifest) {
    const requiresCustomScript = getRequiresCustomScriptProperty(manifest);
    return {
        name: manifest.alias,
        description: `${manifest.extensionType} - ${manifest.alias}`,
        id: manifest.id,
        manifest,
        requiresCustomScript,
        componentDefinition: {}
    };
}
function createLibraryComponent(manifest) {
    const requiresCustomScript = getRequiresCustomScriptProperty(manifest);
    return {
        name: manifest.alias,
        description: `Library - ${manifest.alias}`,
        id: manifest.id,
        manifest,
        requiresCustomScript,
        componentDefinition: {}
    };
}
function createApplicationComponent(manifest) {
    const requiresCustomScript = getRequiresCustomScriptProperty(manifest);
    return {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        name: manifest.title.default,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        description: manifest.description.default,
        id: manifest.id,
        manifest,
        requiresCustomScript,
        componentDefinition: {}
    };
}
function createWebPartComponent(manifest) {
    let i = 0;
    const entries = manifest.preconfiguredEntries.map((entry)=>{
        return {
            id: manifest.id + '_' + i++,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            name: entry.title.default,
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            description: entry.description.default,
            webPartData: buildWebPartData(manifest, entry)
        };
    });
    const requiresCustomScript = getRequiresCustomScriptProperty(manifest);
    // Use the first entry name and description for the component
    return {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        name: manifest.preconfiguredEntries[0].title.default,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        description: manifest.preconfiguredEntries[0].description.default,
        id: manifest.id,
        manifest,
        requiresCustomScript,
        componentDefinition: {
            entries: entries
        }
    };
}
function buildWebPartData(manifest, entry) {
    return JSON.stringify({
        id: manifest.id,
        instanceId: undefined,
        title: entry.title.default,
        description: entry.description.default,
        version: manifest.version,
        properties: entry.properties
    });
}
function createComponentMapFromManifests(terminal, manifests) {
    terminal.writeLine(`Attempting creating component definitions for {${manifests.size}} manifests`);
    const components = new Map();
    manifests.forEach((manifest, key)=>{
        const component = createComponent(terminal, manifest);
        if (component) {
            components.set(key, component);
        }
    });
    terminal.writeLine(`Created component definitions for {${components.size}} manifests`);
    return components;
}
function createFeatureFromComponent(component) {
    return {
        title: `${component.name} Feature`,
        description: `A feature which activates the Client-Side ${component.manifest.componentType} named ` + `${component.name}`,
        id: component.id || uuid.v4(),
        // or generate a new uuid if it doesn't (e.g. for client-side assets feature)
        components: [
            component
        ],
        assets: {
            elementFiles: [],
            elementManifests: [],
            upgradeActions: []
        }
    };
}
/**
 * Normalizes the passed in solution definition by cross referencing componentIds with the collected list
 * of manifests in the repo. If, for any feature, the componentId list is missing or empty, we add all the
 * components to that feature. Similarly, if the list of features in the solution is empty or missing, a
 * feature is automatically created for all solutions.
 */ export default function normalizeSolutionDefinition(terminal, options, manifests) {
    if (options.solution.includeClientSideAssets) {
        manifests.forEach((manifest)=>{
            manifest.loaderConfig.internalModuleBaseUrls = [
                clientSideAssetLibraryPseudoUrl
            ];
        });
    }
    const componentMap = createComponentMapFromManifests(terminal, manifests);
    const numManifests = componentMap.size;
    if (numManifests === 0) {
        throw new Error('Could not find any valid manifests. Please double check paths.manifestsMatch in the task config.');
    }
    // Then, replace the guids in the solution definition with the component definition
    if (options.solution && options.solution.features) {
        const { features } = options.solution;
        // sort the array to have features without componentIds last
        if (features.length > 1) {
            features.sort((a, b)=>{
                if (a.componentIds && !b.componentIds) {
                    return -1;
                } else if (!a.componentIds && b.componentIds) {
                    return 1;
                } else {
                    return 0;
                }
            });
        }
        // set of componentIds that have already been added to features
        const assignedComponentIds = new Set();
        for (const feature of options.solution.features){
            if (feature.componentIds && feature.componentIds.length > 0) {
                feature.components = feature.componentIds.map((componentId)=>{
                    const manifest = componentMap.get(componentId);
                    if (!manifest) {
                        throw new Error(`Component {${componentId}} does not exist in feature '${feature.title}'. ` + 'Please update your configuration.');
                    }
                    assignedComponentIds.add(componentId);
                    return manifest;
                });
            } else {
                terminal.writeLine('feature.componentIds not set! ' + `Adding ${numManifests - assignedComponentIds.size} components to feature { ${feature.title} }.`);
                feature.components = [];
                componentMap.forEach((component)=>{
                    if (!assignedComponentIds.has(component.id)) {
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        feature.components.push(component);
                    }
                });
            }
            if (!feature.assets) {
                feature.assets = {
                    elementFiles: [],
                    elementManifests: [],
                    upgradeActions: []
                };
            }
            feature.assets.elementFiles = resolveFeatureFiles(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            feature.assets.elementFiles, options.paths.sharepointAssetDir);
            feature.assets.elementManifests = resolveFeatureFiles(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            feature.assets.elementManifests, options.paths.sharepointAssetDir);
            feature.assets.upgradeActions = resolveFeatureFiles(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            feature.assets.upgradeActions, options.paths.sharepointAssetDir);
        }
    } else {
        terminal.writeLine('config.solution.features not set! Instead generating a feature for each component.');
        options.solution.features = [];
        componentMap.forEach((component)=>{
            terminal.writeLine(`Creating feature for ${component.name}...`);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            options.solution.features.push(createFeatureFromComponent(component));
        });
    }
}
function resolveFeatureFiles(files, basePath) {
    if (files) {
        return files.map((filename)=>resolveFeatureFile(filename, basePath));
    } else {
        return [];
    }
}
function resolveFeatureFile(filename, basePath) {
    let modulePath = filename;
    if (!FileSystem.exists(basePath)) {
        //
        // Import.resolveModule fails if the baseFolderPath doesn't exist.
        // But it will not if the modulePath is an absolute path
        //
        modulePath = path.join(basePath, filename);
    }
    try {
        return Import.resolveModule({
            modulePath: modulePath,
            baseFolderPath: basePath
        });
    } catch (e) {
        // the previous call will fail if the filename is actual file name or relative path starting with folder name (e.g. 'schema.xml' or 'subfolder/schema.xml')
        if (!path.isAbsolute(modulePath) && !modulePath.startsWith('.')) {
            return Import.resolveModule({
                modulePath: `./${modulePath}`,
                baseFolderPath: basePath
            });
        }
        throw e;
    }
}

//#sourceMappingUrl=./normalizeSolutionDefinition.js.map