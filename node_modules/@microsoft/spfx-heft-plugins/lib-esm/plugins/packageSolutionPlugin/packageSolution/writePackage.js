/**
 * Writes a package xml object to disk, in both raw and zipped format
 */ import * as path from 'path';
import JSZip from 'jszip';
import { FileSystem } from '@rushstack/node-core-library';
import { serialAsync } from '../utilities';
/**
 * Writes the ISolutionXml object containing the solution package xml to the disk using provided config
 */ export async function writePackageAsync(terminal, solution, config, noSpppkg) {
    const zip = new JSZip();
    await cleanRawPackageDirectoryAsync(terminal, config);
    await Promise.all([
        writeODCFileAsync(terminal, solution.manifest, config, zip),
        writeXmlFileAsync(terminal, solution.relationships, config, zip),
        writeXmlFileAsync(terminal, solution.contentTypesXml, config, zip),
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        writeIconAsync(terminal, solution.icon, config, zip)
    ].concat(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    solution.customFiles.map((customFile)=>writeXmlFileAsync(terminal, customFile, config, zip))).concat(solution.features.map((feature)=>writeFeatureAsync(terminal, feature, config, zip))));
    if (!noSpppkg) {
        const zipFile = await zip.generateAsync({
            type: 'nodebuffer',
            compression: 'DEFLATE',
            compressionOptions: {
                level: 9
            }
        });
        await writeFileAsync(terminal, config.paths.zippedPackage, zipFile);
    }
}
/**
 * Ensures that the contents of config.paths.debugDir have been deleted
 */ export async function cleanRawPackageDirectoryAsync(terminal, config) {
    await FileSystem.deleteFolderAsync(config.paths.debugDir);
    terminal.writeLine(`Cleaned ${config.paths.debugDir}`);
}
export async function writeFeatureAsync(terminal, feature, config, zip) {
    await Promise.all([
        writeODCFileAsync(terminal, feature, config, zip),
        writeXmlFileAsync(terminal, feature.config, config, zip)
    ].concat((feature.clientSideResources || []).map((resource)=>writeXmlFileAsync(terminal, resource, config, zip))).concat(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    feature.assets.elementFiles.map((asset)=>writeXmlFileAsync(terminal, asset, config, zip))).concat(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    feature.assets.elementManifests.map((asset)=>writeXmlFileAsync(terminal, asset, config, zip))).concat(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    feature.assets.upgradeActions.map((asset)=>writeXmlFileAsync(terminal, asset, config, zip))).concat(feature.components.map((component)=>writeXmlFileAsync(terminal, component, config, zip))));
}
/**
 * Write the app icon related files: The icon file itself, and the config.xml
 * If there is no icon it does nothing.
 * If the icon path is invalid, it throws an error.
 */ export async function writeIconAsync(terminal, icon, config, zip) {
    if (icon) {
        const filepath = path.join(config.paths.packageDir, icon.path);
        if (FileSystem.getStatistics(filepath).isFile()) {
            await Promise.all([
                FileSystem.readFileToBufferAsync(filepath).then((data)=>{
                    return writeFileToPathAsync(terminal, icon.path, data, config, zip);
                }),
                writeXmlFileAsync(terminal, icon.config, config, zip),
                writeXmlFileAsync(terminal, icon.relationships, config, zip)
            ]);
        } else {
            throw new Error(`Icon with path "${icon.path}" was not found.`);
        }
    }
}
export async function writeXmlFileAsync(terminal, file, config, zip) {
    await writeFileToPathAsync(terminal, file.filename, file.contents, config, zip);
}
export async function writeODCFileAsync(terminal, file, config, zip) {
    await Promise.all([
        writeFileToPathAsync(terminal, file.filename, file.contents, config, zip),
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        writeXmlFileAsync(terminal, file.relationships, config, zip)
    ]);
}
/**
 * Physically writes a file to disk, and adds to an in-memory zip package
 */ async function writeFileToPathAsync(terminal, filename, contents, config, zip) {
    const filepath = path.join(config.paths.debugDir, filename);
    await serialAsync([
        ()=>writeFileAsync(terminal, filepath, contents),
        ()=>addFileToZipAsync(filename, contents, zip)
    ]);
}
/**
 * Wraps fsx.writeFile in a promise
 */ async function writeFileAsync(terminal, filename, contents) {
    FileSystem.writeFile(filename, contents, {
        ensureFolderExists: true
    });
    terminal.writeLine(`Created file: ${filename}`);
}
/**
 * Adds a file to a zip package
 */ async function addFileToZipAsync(filepath, content, zip) {
    const directories = filepath.split(path.sep);
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const file = directories.pop();
    for (const dir of directories){
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        zip = zip.folder(dir);
    }
    zip.file(file, content);
}

//#sourceMappingUrl=./writePackage.js.map