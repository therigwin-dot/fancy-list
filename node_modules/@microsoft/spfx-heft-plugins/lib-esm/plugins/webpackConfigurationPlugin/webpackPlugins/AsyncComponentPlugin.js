function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const PLUGIN_NAME = 'async-component';
const GET_ASYNC_COMPONENTS_FUNCTION_NAME = 'getAsyncSpfxComponents';
const SPFX_LOADER_VARIABLE_NAME = 'spfxLoader';
const SPFX_LOADER_COMPONENT_NAME = '@microsoft/sp-loader';
const COMPONENT_MODULE_ID_PROPERTY_NAME = 'm';
const COMPONENT_ID_PROPERTY_NAME = 'i';
const COMPONENT_VERSION_PROPERTY_NAME = 'v';
const CHUNK_COMPONENT_IDS = Symbol('chunkComponents');
const RUNTIME_CHUNK_HAS_ASYNC_COMPONENTS = Symbol('runtimeChunkHasAsyncComponents');
export const CHUNK_COMPONENT_MAP = Symbol('chunkComponentMap');
export function isExternalModule(module) {
    const typedModule = module;
    return !!(typedModule.externalType && typedModule.userRequest);
}
export class AsyncComponentPlugin {
    apply(compiler) {
        const { WebpackError, ChunkGraph, ExternalModule, RuntimeGlobals, Template } = compiler.webpack;
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation)=>{
            const componentModuleCache = new Map();
            const modulesToRemoveFromChunks = new Map();
            let spfxLoaderModule;
            compilation.hooks.afterOptimizeChunkModules.tap(PLUGIN_NAME, (baseChunks, modules)=>{
                const { chunkGraph, moduleGraph } = compilation;
                const chunks = baseChunks;
                for (const chunk of chunks){
                    chunk[CHUNK_COMPONENT_IDS] = new Set();
                    modulesToRemoveFromChunks.set(chunk, []);
                }
                for (const module of modules){
                    if (isExternalModule(module)) {
                        const externalComponent = this._externalComponents.get(module.userRequest);
                        if (externalComponent) {
                            componentModuleCache.set(externalComponent.componentId, {
                                ...externalComponent,
                                module: module
                            });
                            if (externalComponent.componentName === SPFX_LOADER_COMPONENT_NAME) {
                                spfxLoaderModule = module;
                            } else {
                                for (const originModule of moduleGraph.getIncomingConnectionsByOriginModule(module).keys()){
                                    if (originModule) {
                                        for (const chunk of chunkGraph.getModuleChunksIterable(originModule)){
                                            // If a developer imports a component via `import('spfx-component')`, that is treated as being a dependency of the
                                            // the calling chunk, since no chunk will be created for the import
                                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                            chunk[CHUNK_COMPONENT_IDS].add(externalComponent.componentId);
                                        }
                                    }
                                }
                                for (const chunk of chunkGraph.getModuleChunksIterable(module)){
                                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                    if (!chunk[CHUNK_COMPONENT_IDS].has(externalComponent.componentId)) {
                                        // This module isn't used in this chunk - remove it after it was assigned an ID
                                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                        modulesToRemoveFromChunks.get(chunk).push(module);
                                    }
                                }
                            }
                        }
                    }
                }
                if (!spfxLoaderModule) {
                    const spfxLoaderModuleLibraryType = compiler.options.output.library?.type;
                    if (!spfxLoaderModuleLibraryType) {
                        compilation.errors.push(new WebpackError(`The ${SPFX_LOADER_COMPONENT_NAME} external module is required but the output.library.type option is not set.`));
                        return;
                    }
                    spfxLoaderModule = new ExternalModule(SPFX_LOADER_COMPONENT_NAME, spfxLoaderModuleLibraryType, SPFX_LOADER_COMPONENT_NAME);
                    spfxLoaderModule.build(compilation.options, compilation, compilation.resolverFactory.get('normal', spfxLoaderModule.resolveOptions), compilation.inputFileSystem, (error)=>{
                        if (error) {
                            compilation.errors.push(error);
                        }
                    });
                    compilation.addModule(spfxLoaderModule, (error)=>{
                        if (error) {
                            compilation.errors.push(error);
                        }
                    });
                    ChunkGraph.setChunkGraphForModule(spfxLoaderModule, compilation.chunkGraph);
                    compilation.modules.add(spfxLoaderModule);
                }
                for (const runtimeChunk of chunks){
                    if (runtimeChunk.hasRuntime()) {
                        let runtimeChunkHasAsyncComponents = false;
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const runtimeChunkComponentIds = runtimeChunk[CHUNK_COMPONENT_IDS];
                        for (const asyncChunk of runtimeChunk.getAllAsyncChunks()){
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            for (const chunkComponentId of asyncChunk[CHUNK_COMPONENT_IDS]){
                                if (!runtimeChunkComponentIds.has(chunkComponentId)) {
                                    // Is this a component that's used in the async chunk but not in the runtime chunk?
                                    runtimeChunkHasAsyncComponents = true;
                                    break;
                                }
                            }
                            if (runtimeChunkHasAsyncComponents) {
                                compilation.chunkGraph.connectChunkAndModule(runtimeChunk, spfxLoaderModule);
                            }
                        }
                    }
                }
            });
            compilation.hooks.afterOptimizeModuleIds.tap(PLUGIN_NAME, (modules)=>{
                for (const [chunk, modulesToRemove] of modulesToRemoveFromChunks){
                    for (const moduleToRemove of modulesToRemove){
                        compilation.chunkGraph.disconnectChunkAndModule(chunk, moduleToRemove);
                    }
                }
            });
            // TODO: Replace this with webpack's `RuntimeModule`
            compilation.mainTemplate.hooks.requireEnsure.tap(PLUGIN_NAME, (existingRequireEnsure, baseChunk)=>{
                const chunk = baseChunk;
                if (!chunk[RUNTIME_CHUNK_HAS_ASYNC_COMPONENTS]) {
                    return existingRequireEnsure;
                }
                const PROMISES_VAR_NAME = 'promises';
                const CHUNK_ID_VAR_NAME = 'chunkId';
                const extraCode = [
                    '// SPFx Component async loading',
                    '',
                    `var chunkAsyncComponents = ${GET_ASYNC_COMPONENTS_FUNCTION_NAME}(${CHUNK_ID_VAR_NAME});`,
                    'for (var i = 0; i < chunkAsyncComponents.length; i++) {',
                    Template.indent([
                        '// Has the component already been loaded into the modules object?',
                        `if (!${RuntimeGlobals.moduleFactories}[chunkAsyncComponents[i].${COMPONENT_MODULE_ID_PROPERTY_NAME}]) {`,
                        Template.indent([
                            '((chunkComponent) => {',
                            Template.indent([
                                `${PROMISES_VAR_NAME}.push(${SPFX_LOADER_VARIABLE_NAME}.SPComponentLoader.loadComponentById(`,
                                Template.indent([
                                    `chunkComponent.${COMPONENT_ID_PROPERTY_NAME},`,
                                    `chunkComponent.${COMPONENT_VERSION_PROPERTY_NAME}`
                                ]),
                                ').then((component) => {',
                                Template.indent([
                                    `${RuntimeGlobals.moduleFactories}[chunkComponent.${COMPONENT_MODULE_ID_PROPERTY_NAME}] = (module) => module.exports = component;`
                                ]),
                                '}));'
                            ]),
                            '})(chunkAsyncComponents[i]);'
                        ]),
                        '}'
                    ]),
                    '}'
                ];
                return Template.asString([
                    existingRequireEnsure,
                    ...extraCode
                ]);
            });
            // TODO: Replace this with webpack's `RuntimeModule`
            compilation.mainTemplate.hooks.localVars.tap(PLUGIN_NAME, (existing, baseRuntimeChunk)=>{
                const runtimeChunk = baseRuntimeChunk;
                if (!runtimeChunk.hasRuntime()) {
                    return existing;
                }
                const runtimeChunkComponentIds = runtimeChunk[CHUNK_COMPONENT_IDS] || new Set();
                let chunkVariableCounter = 0;
                const componentVariables = new Map(); // Key is the component ID
                const chunkComponentMap = new Map();
                for (const asyncChunk of runtimeChunk.getAllAsyncChunks()){
                    const chunkComponentIds = asyncChunk[CHUNK_COMPONENT_IDS];
                    if (chunkComponentIds) {
                        const filteredChunkComponents = [];
                        for (const chunkComponentId of chunkComponentIds){
                            if (!runtimeChunkComponentIds.has(chunkComponentId)) {
                                const chunkComponent = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                componentModuleCache.get(chunkComponentId);
                                filteredChunkComponents.push(chunkComponent);
                                if (!componentVariables.has(chunkComponent.componentId)) {
                                    componentVariables.set(chunkComponent.componentId, {
                                        ...chunkComponent,
                                        variableName: `component_${chunkVariableCounter++}`
                                    });
                                }
                            }
                        }
                        if (filteredChunkComponents.length > 0) {
                            chunkComponentMap.set(asyncChunk, filteredChunkComponents);
                        }
                    }
                }
                runtimeChunk[CHUNK_COMPONENT_MAP] = chunkComponentMap;
                if (chunkComponentMap.size === 0) {
                    runtimeChunk[RUNTIME_CHUNK_HAS_ASYNC_COMPONENTS] = false;
                    return existing;
                } else {
                    runtimeChunk[RUNTIME_CHUNK_HAS_ASYNC_COMPONENTS] = true;
                    const chunkComponentVariables = [];
                    for (const [{ id }, externalComponents] of chunkComponentMap.entries()){
                        const componentIdVariablesArray = externalComponents// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        .map(({ componentId })=>componentVariables.get(componentId).variableName).join(', ');
                        chunkComponentVariables.push(`${JSON.stringify(id)}: [${componentIdVariablesArray}]`);
                    }
                    const extraCode = [
                        '',
                        '// Returns a list of SPFx components used in a given chunk but not used in the runtime chunk',
                        `function ${GET_ASYNC_COMPONENTS_FUNCTION_NAME}(chunkId) {`,
                        Template.indent([
                            ...Array.from(componentVariables.values()).map((component)=>Template.asString([
                                    `var ${component.variableName} = { // ${component.componentName}`,
                                    Template.indent([
                                        `${COMPONENT_ID_PROPERTY_NAME}: ${JSON.stringify(component.componentId)},`,
                                        component.componentVersion ? `${COMPONENT_VERSION_PROPERTY_NAME}: ${JSON.stringify(component.componentVersion)},` : '',
                                        `${COMPONENT_MODULE_ID_PROPERTY_NAME}: ${JSON.stringify(compilation.chunkGraph.getModuleId(component.module))}`
                                    ]),
                                    '};'
                                ])),
                            '',
                            `return {${chunkComponentVariables.join(',')}}[chunkId] || [];`
                        ]),
                        '}'
                    ];
                    return Template.asString([
                        existing,
                        ...extraCode
                    ]);
                }
            });
            // TODO: Replace this with webpack's `RuntimeModule`
            compilation.mainTemplate.hooks.requireExtensions.tap(PLUGIN_NAME, (existing, baseRuntimeChunk)=>{
                const runtimeChunk = baseRuntimeChunk;
                if (!runtimeChunk.hasRuntime() || !runtimeChunk[RUNTIME_CHUNK_HAS_ASYNC_COMPONENTS]) {
                    return existing;
                }
                let spfxLoaderModuleId = undefined;
                if (spfxLoaderModule) {
                    const moduleId = compilation.chunkGraph.getModuleId(spfxLoaderModule);
                    spfxLoaderModuleId = moduleId === null ? undefined : moduleId;
                } else {
                    compilation.errors.push(new WebpackError(`Missing ${SPFX_LOADER_COMPONENT_NAME} external.`));
                }
                const extraCode = [
                    '',
                    `var ${SPFX_LOADER_VARIABLE_NAME} = ${RuntimeGlobals.require}(${JSON.stringify(spfxLoaderModuleId)});`
                ];
                return Template.asString([
                    existing,
                    ...extraCode
                ]);
            });
        });
    }
    constructor(options){
        _define_property(this, "_options", void 0);
        _define_property(this, "_externalComponents", new Map());
        this._options = options;
        for (const externalComponent of this._options.externalComponents){
            this._externalComponents.set(externalComponent.componentName, externalComponent);
        }
    }
}

//#sourceMappingUrl=./AsyncComponentPlugin.js.map