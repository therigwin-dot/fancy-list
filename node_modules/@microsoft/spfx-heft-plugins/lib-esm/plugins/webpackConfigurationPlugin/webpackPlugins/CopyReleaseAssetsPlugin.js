function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import path from 'path';
const PLUGIN_NAME = 'copy-release-assets';
const IGNORED_FILE_EXTENSIONS_DEBUG = [
    '.stats.json',
    '.stats.html'
];
const IGNORED_FILE_EXTENSIONS_PRODUCTION = [
    ...IGNORED_FILE_EXTENSIONS_DEBUG
];
const DEFAULT_ASSETS_FOLDER_NAME = 'assets';
const MANIFESTS_FOLDER_NAME = 'manifests';
export class CopyReleaseAssetsPlugin {
    apply(compiler) {
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation)=>{
            const thisWebpack = compiler.webpack;
            compilation.hooks.processAssets.tapPromise({
                stage: thisWebpack.Compilation.PROCESS_ASSETS_STAGE_REPORT + 1,
                name: PLUGIN_NAME
            }, async ()=>{
                const { releasePath, isDebug, assetsFolderName = DEFAULT_ASSETS_FOLDER_NAME, manifestsFolderName = MANIFESTS_FOLDER_NAME } = this._options;
                const assetsReleasePath = `${releasePath}/${assetsFolderName}`;
                const manifestsReleasePath = `${releasePath}/${manifestsFolderName}`;
                const relativeAssetsReleasePath = path.relative(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                compiler.options.output.path, assetsReleasePath);
                const relativeManifestsReleasePath = path.relative(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                compiler.options.output.path, manifestsReleasePath);
                const ignoredFileExtensions = isDebug ? IGNORED_FILE_EXTENSIONS_DEBUG : IGNORED_FILE_EXTENSIONS_PRODUCTION;
                for (const [assetName, assetSource] of Object.entries(compilation.assets)){
                    let shouldCopyAssetToRelease = true;
                    for (const ignoredExtension of ignoredFileExtensions){
                        if (assetName.endsWith(ignoredExtension)) {
                            shouldCopyAssetToRelease = false;
                            break;
                        }
                    }
                    if (shouldCopyAssetToRelease) {
                        const releaseManifestVariant = assetSource.releaseManifest;
                        if (releaseManifestVariant) {
                            // This is a manifest
                            compilation.emitAsset(`${relativeManifestsReleasePath}/${assetName}`, new thisWebpack.sources.RawSource(releaseManifestVariant));
                        } else {
                            // This isn't a manifest
                            compilation.emitAsset(`${relativeAssetsReleasePath}/${assetName}`, assetSource);
                        }
                    }
                }
            });
        });
    }
    constructor(options){
        _define_property(this, "_options", void 0);
        this._options = options;
        if (!this._options.releaseMapFiles) {
            IGNORED_FILE_EXTENSIONS_PRODUCTION.push('.map');
        }
    }
}

//#sourceMappingUrl=./CopyReleaseAssetsPlugin.js.map