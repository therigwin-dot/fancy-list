import * as path from 'node:path';
import cors from 'cors';
import express from 'express';
import { ConfigureServe } from './ConfigureServe';
import { ServeInfoPlugin } from './webpackPlugins/ServeInfoPlugin';
import { CumulativeManifestProcessor, DependencyDiscoveryMode } from '../../spfxManifests/cumulativeManifestProcessor/CumulativeManifestProcessor';
import { DEFAULT_TEMP_FOLDER, DEFAULT_OUTPUT_FOLDER, SP_LOADER_ASSEMBLY_ID } from '../../utilities/constants';
export const TENANT_DOMAIN_PLACEHOLDER = '{tenantdomain}';
export async function updateServeConfigAsync(taskSession, heftConfiguration, additionalServePathsFromAccessor, webpackConfiguration) {
    const logger = taskSession.logger;
    const terminal = logger.terminal;
    const { buildFolderPath } = heftConfiguration;
    // Webpack Dev Server will only consider the first config if multiple are defined.
    if (Array.isArray(webpackConfiguration)) {
        webpackConfiguration = webpackConfiguration[0];
    }
    const serve = new ConfigureServe(heftConfiguration, terminal);
    const serveConfig = serve.generateServeConfig();
    // Project serve paths
    const projectServeMap = new Map();
    const { contentBasePublicPath = '/' } = serveConfig;
    if (serveConfig.contentBase) {
        if (Array.isArray(serveConfig.contentBase)) {
            for (const contentPath of serveConfig.contentBase){
                projectServeMap.set(path.resolve(buildFolderPath, contentPath), contentBasePublicPath);
            }
        } else {
            projectServeMap.set(path.resolve(buildFolderPath, serveConfig.contentBase), contentBasePublicPath);
        }
    } else {
        projectServeMap.set(path.resolve(buildFolderPath), contentBasePublicPath);
    }
    // Additional serve paths
    const dependencyServeMap = _getDependencyServeMap(buildFolderPath, terminal);
    const serveMap = new Map([
        ...projectServeMap,
        ...dependencyServeMap,
        ...additionalServePathsFromAccessor || []
    ]);
    // eslint-disable-next-line @rushstack/security/no-unsafe-regexp
    const tenantDomainRegEx = new RegExp(TENANT_DOMAIN_PLACEHOLDER, 'i');
    if (serveConfig?.initialPage && tenantDomainRegEx.test(serveConfig.initialPage) && process.env.SPFX_SERVE_TENANT_DOMAIN) {
        serveConfig.initialPage = serveConfig.initialPage.replace(tenantDomainRegEx, process.env.SPFX_SERVE_TENANT_DOMAIN);
    }
    // Webpack Dev Server config
    // eslint-disable-next-line require-atomic-updates
    webpackConfiguration.devServer = {
        static: false,
        devMiddleware: {
            publicPath: '/dist',
            stats: {
                assets: false,
                chunks: false,
                modules: false,
                warningsFilter: [
                    /export .* was not found in/
                ]
            },
            writeToDisk: true
        },
        host: '127.0.0.1',
        port: serveConfig.port,
        hot: true,
        historyApiFallback: false,
        compress: true,
        allowedHosts: 'all',
        setupMiddlewares: (middlewares, server)=>{
            const { app } = server;
            if (!app) {
                throw new Error(`express is not initialized!`);
            }
            app.use((req, res, next)=>{
                // Need to support CORS because we access this from a different origin
                res.setHeader('Access-Control-Allow-Origin', '*');
                res.setHeader('Access-Control-Allow-Methods', 'HEAD, GET, OPTIONS');
                res.setHeader('Access-Control-Allow-Private-Network', 'true'); // Allow access from other devices on the same network
                next();
            });
            app.options('*', cors({
            }));
            if (serveConfig.apiMap) {
                for (const [route, handler] of Object.entries(serveConfig.apiMap)){
                    // Don't include universal route handlers.
                    if (route.startsWith('*')) {
                        continue;
                    }
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    app.get(route, handler);
                }
            }
            middlewares.unshift(serve.logRequestsMiddleware());
            for (const [contentPath, route] of serveMap){
                middlewares.push({
                    name: 'express-static',
                    path: route,
                    middleware: express.static(contentPath, {
                        index: false
                    })
                });
            }
            return middlewares;
        },
        open: serveConfig.initialPage
    };
    // Webpack Dev Server plugins
    webpackConfiguration.plugins = [
        ...webpackConfiguration.plugins ? webpackConfiguration.plugins : [],
        new ServeInfoPlugin({
            terminal,
            port: serveConfig.port,
            tempFolderName: DEFAULT_TEMP_FOLDER
        })
    ];
    return webpackConfiguration;
}
function _getDependencyServeMap(buildFolder, terminal) {
    const dependencyServeMap = new Map();
    const referencedProjects = _getReferencedProjects(buildFolder, terminal);
    for (const versionMap of Object.values(referencedProjects)){
        for (const referencedProject of Object.values(versionMap)){
            if (referencedProject.packageName && !referencedProject.isAssembly) {
                const projectOutputPath = path.dirname(referencedProject.manifestPath);
                if (referencedProject.manifestPath) {
                    dependencyServeMap.set(projectOutputPath, '/');
                } else {
                    terminal.writeWarning(referencedProject.packageName + ' not found.');
                }
            }
        }
    }
    return dependencyServeMap;
}
function _getReferencedProjects(buildFolder, terminal) {
    const cumulativeManifestProcessor = new CumulativeManifestProcessor({
        explicitInclude: [
            SP_LOADER_ASSEMBLY_ID
        ],
        rootPath: buildFolder,
        tempFolderName: DEFAULT_TEMP_FOLDER,
        distFolderName: DEFAULT_OUTPUT_FOLDER,
        includeAssemblies: true,
        terminal
    });
    const referencedProjects = cumulativeManifestProcessor.discoverManifests(buildFolder, DependencyDiscoveryMode.deepSparseIgnoreFirstProject);
    return referencedProjects;
}

//#sourceMappingUrl=./updateServeConfigAsync.js.map