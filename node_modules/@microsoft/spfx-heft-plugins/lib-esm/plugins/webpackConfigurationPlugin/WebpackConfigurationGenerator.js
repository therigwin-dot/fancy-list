// NodeJS
import * as fs from 'fs';
import * as path from 'path';
import * as webpack from 'webpack';
import * as os from 'os';
import * as crypto from 'crypto';
// Externals
import { ModuleMinifierPlugin } from '@rushstack/webpack5-module-minifier-plugin';
import { WorkerPoolMinifier } from '@rushstack/module-minifier';
import { FileSystem, PackageJsonLookup, JsonFile, Import, Text, Path } from '@rushstack/node-core-library';
import { SetPublicPathCurrentScriptPlugin } from '@rushstack/set-webpack-public-path-plugin';
// Local
import { CopyReleaseAssetsPlugin } from './webpackPlugins/CopyReleaseAssetsPlugin';
import { WebpackStatsPlugin } from './webpackPlugins/WebpackStatsPlugin';
import { AsyncComponentPlugin } from './webpackPlugins/AsyncComponentPlugin';
import { CumulativeManifestProcessor, DependencyDiscoveryMode } from '../../spfxManifests/cumulativeManifestProcessor/CumulativeManifestProcessor';
import { getNonStandardExternals } from '../../spfxManifests/utilities/ExternalsProcessor';
import { getFullHash } from '../../spfxManifests/utilities/getFullHash';
import { DEFAULT_LOCALE } from '../../utilities/constants';
import { ManifestPlugin } from '../../spfxManifests/webpack/ManifestPlugin';
import { VariableNameGenerator } from '../../utilities/VariableNameGenerator';
/**
 * @public
 */ export const FILE_LOADER_EXTENSIONS = [
    'jpg',
    'png',
    'woff',
    'woff2',
    'eot',
    'ttf',
    'svg',
    'gif',
    'dds',
    'cur',
    'webp',
    'mp4'
];
/**
 * @public
 */ export const IS_SPFX_WEBPACK_CONFIGURATION_SYMBOL = Symbol('IS_SPFX_WEBPACK_CONFIGURATION');
/**
 * @public
 */ export const CONFIG_JSON_SYMBOL = Symbol('CONFIG_JSON');
/**
 * @internal
 */ export const FILE_LOADER_RULE_TEST = {
    or: FILE_LOADER_EXTENSIONS.map(// eslint-disable-next-line @rushstack/security/no-unsafe-regexp
    (ext)=>new RegExp(`\\.${Text.escapeRegExp(ext)}((\\?|\\#).+)?$`))
};
const ASSET_RESOURCE_RULE_OPTIONS = {
    type: 'asset/resource',
    generator: {
        filename: '[name]_[contenthash][ext]'
    }
};
/**
 * @internal
 */ export const COMMON_RULE_OPTIONS = {
    dependency: {
        not: [
            'url'
        ]
    }
};
const VERSIONED_ASSETS_FOLDER_NAME = 'assets-versioned';
const LIBRARY_TARGET = 'amd';
const cssHashCache = new Map();
const DEFAULT_GENERATE_CSS_CLASS_NAME = (existingClassName, cssFilename, cssContent)=>{
    let hash = cssHashCache.get(cssFilename);
    if (!hash) {
        hash = crypto.createHmac('sha1', cssFilename).update(cssContent).digest('hex').substring(0, 8);
        cssHashCache.set(cssFilename, hash);
    }
    return `${existingClassName}_${hash}`;
};
/**
 * @public
 */ export class WebpackConfigurationGenerator {
    static async generateWebpackConfigurationAsync(options) {
        WebpackConfigurationGenerator._validateEntries(options.configJson, options.folders.buildFolder);
        const terminal = options.terminal;
        const configBundleEntries = options.configJson.bundles || {};
        const { buildFolder, outputFolder, tempFolder } = options.folders;
        const distFolderName = path.relative(buildFolder, outputFolder).replace(/^\.[\\\/]/, '');
        const tempFolderName = path.relative(buildFolder, tempFolder).replace(/^\.[\\\/]/, '');
        //#region EXTERNAL COMPONENTS
        // Discover packages that should be externalized because they have manifests
        const cumulativeManifestProcessor = new CumulativeManifestProcessor({
            terminal: options.terminal,
            rootPath: options.folders.buildFolder,
            tempFolderName,
            distFolderName,
            includeAssemblies: true
        });
        const referencedProjects = cumulativeManifestProcessor.discoverManifests(options.folders.buildFolder, options._useManifestsJsonForComponentDependencies ? DependencyDiscoveryMode.shallow : DependencyDiscoveryMode.deepSparseIgnoreFirstProject);
        const linkedExternals = new Map();
        // Add these projects to externalized packages
        for (const [manifestId, versionMap] of Object.entries(referencedProjects)){
            for (const { packageName, isAssembly, manifestData: { version } } of Object.values(versionMap)){
                if (packageName && !isAssembly) {
                    linkedExternals.set(packageName, {
                        id: manifestId,
                        name: packageName,
                        version: version
                    });
                }
            }
        }
        const nonStandardExternals = getNonStandardExternals(options.folders.buildFolder, referencedProjects);
        for (const [externalName, external] of nonStandardExternals){
            linkedExternals.set(externalName, external);
        }
        const externalsKeys = new Set(linkedExternals.keys());
        if (options.configJson.externals) {
            for (const externalKey of Object.keys(options.configJson.externals)){
                externalsKeys.add(externalKey);
            }
        }
        // Remove the specified linked externals to ensure they're bundled
        if (options.linkedExternalsToBundle?.length) {
            for (const linkedExternalToBundle of options.linkedExternalsToBundle){
                externalsKeys.delete(linkedExternalToBundle);
            }
        }
        // Don't list the project being built as an external
        externalsKeys.delete(options.projectPackageJson.name);
        //#endregion
        const configBundleEntriesCount = Object.keys(configBundleEntries).length;
        if (configBundleEntriesCount === 0) {
            terminal.writeWarningLine('No entries are defined, so no bundles will be produced.');
            return undefined;
        }
        terminal.writeVerboseLine(`${configBundleEntriesCount} entries specified.`);
        terminal.writeVerboseLine(`${externalsKeys.size} externals specified.`);
        const bundleEntries = [];
        const webpackEntries = {};
        const webpackUniqueNameParts = [];
        for (const [bundleName, configEntry] of Object.entries(configBundleEntries)){
            const bundleEntry = {
                bundleName,
                components: {}
            };
            for (const componentEntry of configEntry.components){
                const manifestData = await JsonFile.loadAsync(path.resolve(options.folders.buildFolder, componentEntry.manifest));
                // If the manifest version is "*", replace it with the package version. Do this here to make sure the
                //  bundle's name doesn't contain the "*" version
                if (manifestData.version === '*') {
                    const packageJson = PackageJsonLookup.instance.tryLoadPackageJsonFor(options.folders.buildFolder);
                    if (!packageJson) {
                        throw new Error(`Unable to find package.json for "${options.folders.buildFolder}"`);
                    }
                    // Remove pre-release name if any, because pre-release is not handled by SPFx yet.
                    const indexOfDelimiter = packageJson.version.indexOf('-');
                    const manifestVersion = indexOfDelimiter > 0 ? packageJson.version.substr(0, indexOfDelimiter) : packageJson.version;
                    manifestData.version = manifestVersion;
                }
                // Keep a counter of the manifests inside the bundle so we can set the exportName property in the produced
                //  manifest(s) and generate a JS file to bundle both components' entrypoints
                bundleEntry.components[manifestData.id] = {
                    ...componentEntry,
                    manifestData,
                    manifestPath: path.join(options.folders.buildFolder, componentEntry.manifest),
                    exportName: undefined
                };
                webpackUniqueNameParts.push(WebpackConfigurationGenerator.getComponentBundleId(manifestData));
            }
            const components = Object.values(bundleEntry.components);
            let entryImport;
            if (components.length === 1) {
                // Single component, just point to its entrypoint in the webpack config
                entryImport = await Import.resolveModuleAsync({
                    modulePath: components[0].entrypoint,
                    baseFolderPath: options.folders.buildFolder
                });
            } else {
                // Multiple components, we need to generate an entry to point the webpack config in the temp folder
                entryImport = await this._generateBundleEntrypointFileAsync({
                    bundleEntry,
                    buildFolder: options.folders.buildFolder,
                    tempFolder: options.folders.tempFolder
                });
            }
            webpackEntries[bundleName] = {
                import: entryImport,
                library: {
                    type: LIBRARY_TARGET,
                    name: webpackUniqueNameParts.length === 1 ? webpackUniqueNameParts[0] : undefined
                }
            };
            bundleEntries.push(bundleEntry);
        }
        let webpackUniqueName;
        if (webpackUniqueNameParts.length === 1) {
            // We're producing one bundle, so we can generate a simple name
            webpackUniqueName = webpackUniqueNameParts[0];
        } else {
            // There are multiple bundles. Because we need something unique for the webpack JSONP function, we'll just
            // concatenate the IDs and then hash them.
            webpackUniqueName = getFullHash(webpackUniqueNameParts.join(''));
        }
        const generateCssClassName = options.generateCssClassName || DEFAULT_GENERATE_CSS_CLASS_NAME;
        const simpleCssLoaderPath = WebpackConfigurationGenerator._requireResolveWithCorrectCase('@microsoft/sp-css-loader');
        const simpleCssLoaderOptions = {
            async: true,
            loadThemedStylesImportPath: options.loadThemedStylesImportPath,
            production: options.production
        };
        const cssLoaders = [
            {
                loader: simpleCssLoaderPath,
                options: simpleCssLoaderOptions
            }
        ];
        const moduleScssCssLoaders = [
            {
                loader: simpleCssLoaderPath,
                options: {
                    ...simpleCssLoaderOptions,
                    generateCssClassName: generateCssClassName
                }
            }
        ];
        const outputFilenameParts = [
            '[name]'
        ];
        if (options.getLocalization) {
            outputFilenameParts.push('_[locale]');
        }
        if (!options.serveMode && options.production) {
            // The "contenthash" template is the hash of file contents and is preferred over "hash".
            // Serve mode does not support "contenthash" and 3rd party developers may use deployed
            // manifests files for local development, which precludes the use of dynamic hashes.
            outputFilenameParts.push('_[contenthash]');
        }
        const devtool = options.production ? options.buildSourceMaps ? 'hidden-source-map' : undefined : 'source-map';
        outputFilenameParts.push('.js');
        const outputFilename = outputFilenameParts.join('');
        const config = {
            [IS_SPFX_WEBPACK_CONFIGURATION_SYMBOL]: true,
            [CONFIG_JSON_SYMBOL]: options.configJson,
            module: {
                rules: [
                    // Allow importing JS files that don't have explicit extensions
                    {
                        ...ASSET_RESOURCE_RULE_OPTIONS,
                        dependency: 'url',
                        test: []
                    },
                    {
                        ...COMMON_RULE_OPTIONS,
                        test: /\.js$/,
                        resolve: {
                            fullySpecified: false
                        }
                    },
                    {
                        ...COMMON_RULE_OPTIONS,
                        use: moduleScssCssLoaders,
                        test: /\.module(?:\.scss)?\.css$/i
                    },
                    {
                        ...COMMON_RULE_OPTIONS,
                        use: cssLoaders,
                        test: RegExp("(?<!\\.module(?:\\.scss)?)\\.css$")
                    },
                    {
                        ...COMMON_RULE_OPTIONS,
                        ...ASSET_RESOURCE_RULE_OPTIONS,
                        test: FILE_LOADER_RULE_TEST
                    },
                    {
                        ...COMMON_RULE_OPTIONS,
                        test: /\.html$/,
                        use: {
                            loader: WebpackConfigurationGenerator._requireResolveWithCorrectCase('html-loader')
                        }
                    }
                ],
                noParse: [
                    /\.map$/
                ]
            },
            resolve: {
                alias: {},
                modules: [
                    'node_modules'
                ],
                extensions: [
                    '.wasm',
                    '.mjs',
                    '.js',
                    '.json',
                    '.css',
                    '.jsx'
                ]
            },
            context: options.folders.buildFolder,
            devtool,
            mode: options.production ? 'production' : 'development',
            entry: webpackEntries,
            externals: Array.from(externalsKeys),
            output: {
                hashFunction: 'md5',
                chunkFilename: `chunk.${outputFilename}`,
                filename: outputFilename,
                chunkLoadingGlobal: `webpackJsonp_${webpackUniqueName}`,
                libraryTarget: LIBRARY_TARGET,
                uniqueName: webpackUniqueName,
                path: options.folders.outputFolder,
                devtoolModuleFilenameTemplate: 'webpack:///../[resource-path]',
                devtoolFallbackModuleFilenameTemplate: 'webpack:///../[resource-path]?[contenthash]',
                crossOriginLoading: options.crossOriginLoading !== false && 'anonymous'
            },
            optimization: {
                moduleIds: 'deterministic',
                usedExports: !!options.production,
                // Always enable these since they help reduce output sizes in a readable manner.
                sideEffects: true,
                removeEmptyChunks: true,
                // TODO: turn this on when weback5-localization-plugin can suppress RealHashPlugin re-processing files.
                realContentHash: false,
                avoidEntryIife: false
            },
            performance: {
                hints: false
            }
        };
        const plugins = [
            new SetPublicPathCurrentScriptPlugin(),
            new webpack.DefinePlugin({
                DEBUG: !options.production,
                DEPRECATED_UNIT_TEST: false,
                'process.env': {
                    NODE_ENV: options.production ? '"production"' : '"development"'
                }
            })
        ];
        config.plugins = plugins;
        // Stats are incredibly expensive to write and generate.
        // Leave this option behind a flag for generation
        if (options.emitStats) {
            plugins.push(new WebpackStatsPlugin({
                dropPath: path.resolve(options.folders.releaseFolder, 'webpack-stats', `${path.basename(options.folders.buildFolder)}.stats.json`)
            }));
        }
        if (!options.disableAsyncComponentLoading) {
            const asyncComponentPluginExternalComponents = [];
            for (const { id: componentId, name: componentName, version: componentVersion } of linkedExternals.values()){
                asyncComponentPluginExternalComponents.push({
                    componentId,
                    componentName,
                    componentVersion
                });
            }
            plugins.push(new AsyncComponentPlugin({
                externalComponents: asyncComponentPluginExternalComponents
            }));
        }
        let tryGetLocFileTranslations = ()=>undefined;
        let localizedData = {};
        let selectedLocales = new Set([
            DEFAULT_LOCALE
        ]);
        if (options.getLocalization) {
            const localizationPackage = options.getLocalization();
            localizedData = await localizationPackage.getProjectLocalizedStringsAsync();
            tryGetLocFileTranslations = localizationPackage.getLocFileTranslations.bind(localizationPackage);
            const localizedDataKeys = Object.keys(localizedData);
            if (localizedDataKeys.length > 0) {
                if (options.selectedLocales) {
                    for (const selectedLocale of options.selectedLocales){
                        if (selectedLocale !== DEFAULT_LOCALE && !localizedData.hasOwnProperty(selectedLocale)) {
                            throw new Error(`The selected locale (${selectedLocale}) is not present in the localized data.`);
                        }
                    }
                    selectedLocales = new Set([
                        DEFAULT_LOCALE,
                        ...options.selectedLocales
                    ]);
                } else if (options.production) {
                    selectedLocales = new Set([
                        DEFAULT_LOCALE,
                        ...localizedDataKeys
                    ]);
                }
            }
            const { localizationPlugin, stringsLoaders } = await localizationPackage.getLocalizationConfigurationAsync(selectedLocales);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            config.module.rules.push(...stringsLoaders);
            plugins.push(localizationPlugin);
        }
        let serveConfig = {};
        try {
            serveConfig = await JsonFile.loadAsync(path.join(options.folders.buildFolder, 'config', 'serve.json'));
        } catch (e) {
            if (!FileSystem.isNotExistError(e)) {
                throw e;
            }
        }
        const debugBaseUrl = `${serveConfig.https ? 'https' : 'http'}://${serveConfig.hostname || 'localhost'}:${serveConfig.port || 4321}/${distFolderName}/`;
        let cdnBaseUrl;
        try {
            const writeManifestsConfig = await JsonFile.loadAsync(path.join(options.folders.buildFolder, 'config', 'write-manifests.json'));
            cdnBaseUrl = writeManifestsConfig.cdnBasePath;
        } catch (e) {
            if (!FileSystem.isFileDoesNotExistError(e)) {
                throw e;
            }
        }
        plugins.push(new ManifestPlugin({
            terminal,
            selectedLocales,
            production: options.production,
            includeIntegrity: options._includeIntegrityInManifestPaths,
            sourceLocaleName: DEFAULT_LOCALE,
            bundleEntries,
            internalModuleBaseUrls: cdnBaseUrl ? [
                cdnBaseUrl
            ] : [],
            debugInternalModuleBaseUrls: [
                debugBaseUrl
            ],
            linkedExternals,
            referencedProjects,
            cumulativeManifestProcessor,
            useManifestsJsonForComponentDependencies: options._useManifestsJsonForComponentDependencies,
            tryGetLocFileTranslations,
            asyncOnlyDependencies: {
                asyncOnlyDependencyNames: options.configJson.asyncComponents || [],
                violationsAsErrors: options.production
            },
            componentDependenciesAuditDropPath: path.join(options.folders.releaseFolder, 'component-dependency-audit', `${path.basename(options.folders.buildFolder)}.json`),
            manifestsJsFileMetadata: options._manifestsJsFileMetadata
        }));
        if (options.production) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            config.optimization.minimize = true;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            config.optimization.minimizer = [
                new ModuleMinifierPlugin({
                    minifier: new WorkerPoolMinifier({
                        // Cap the number of worker processes to avoid CPU saturation.
                        maxThreads: Math.min(8, os.cpus().length),
                        terserOptions: {
                            compress: {
                                passes: 3
                            },
                            mangle: true,
                            output: {
                                comments: false,
                                // eslint-disable-next-line @typescript-eslint/naming-convention
                                wrap_func_args: false
                            }
                        }
                    }),
                    sourceMap: !!devtool
                })
            ];
        }
        if (devtool) {
            const defaultFilter = (url, resourcePath)=>{
                return resourcePath.indexOf('node_modules') === -1;
            };
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            config.module.rules.push({
                test: /\.js$/,
                enforce: 'pre',
                use: {
                    loader: WebpackConfigurationGenerator._requireResolveWithCorrectCase('source-map-loader'),
                    options: {
                        filterSourceMappingUrl: options.sourceMapUrlFilter ?? defaultFilter
                    }
                }
            });
        }
        // Always produce the release/ folder
        plugins.push(new CopyReleaseAssetsPlugin({
            releasePath: options.folders.releaseFolder,
            isDebug: !options.production,
            assetsFolderName: options.assetsAreVersioned ? VERSIONED_ASSETS_FOLDER_NAME : undefined,
            manifestsFolderName: options.releaseManifestFolderName,
            releaseMapFiles: options.releaseMapFiles
        }));
        return config;
    }
    /**
   * @internal
   */ static getComponentBundleId(manifest) {
        return `${manifest.id}_${manifest.version}`;
    }
    /**
   * Writes the entrypoint file to the temp directory and returns the path to the file.
   */ static async _generateBundleEntrypointFileAsync(options) {
        const entrypointFileFolderPath = `${options.tempFolder}/bundle-entries`;
        const filePath = `${entrypointFileFolderPath}/${options.bundleEntry.bundleName}.js`;
        const variableNameGenerator = await VariableNameGenerator.initializeAsync();
        const fileLines = [];
        for (const bundleComponent of Object.values(options.bundleEntry.components)){
            const fullEntrypointPath = await Import.resolveModuleAsync({
                modulePath: bundleComponent.entrypoint,
                baseFolderPath: options.buildFolder
            });
            const relativeEntrypointPath = path.relative(entrypointFileFolderPath, fullEntrypointPath);
            const exportName = variableNameGenerator.getNextVariableName();
            bundleComponent.exportName = exportName;
            fileLines.push(`// ${bundleComponent.manifestData.alias}`);
            fileLines.push(`export * as ${exportName} from '${Path.convertToSlashes(relativeEntrypointPath)}';`);
            fileLines.push('');
        }
        const fileContents = fileLines.join('\n');
        await FileSystem.writeFileAsync(filePath, fileContents, {
            ensureFolderExists: true
        });
        return filePath;
    }
    static _requireResolveWithCorrectCase(packageName) {
        const resolveResult = Import.resolvePackage({
            packageName,
            baseFolderPath: __dirname,
            // fs.realpathSync.native fixes casing issues on Windows
            getRealPath: (filePath)=>{
                try {
                    return fs.realpathSync.native(filePath);
                } catch (error) {
                    if (FileSystem.isNotExistError(error)) {
                        // This is only being used to correct the casing of the path; if it doesn't exist, return requested path
                        return filePath;
                    }
                    throw error;
                }
            }
        });
        return resolveResult;
    }
    static _validateEntries(configJson, rootPath) {
        if (configJson.bundles) {
            const entrypointPaths = new Set();
            const manifestPaths = new Set();
            for (const [, bundleEntry] of Object.entries(configJson.bundles)){
                for (const component of bundleEntry.components){
                    const entrypointPath = Import.resolveModule({
                        modulePath: component.entrypoint,
                        baseFolderPath: rootPath
                    }).toUpperCase();
                    if (entrypointPaths.has(entrypointPath)) {
                        throw new Error(`Entry path "${entrypointPath}" occurs in multiple config.json components. This is not supported.`);
                    } else {
                        entrypointPaths.add(entrypointPath);
                    }
                    const manifestPath = path.resolve(path.join(rootPath, component.manifest)).toUpperCase();
                    if (manifestPaths.has(manifestPath)) {
                        throw new Error(`Manifest path "${manifestPath}" occurs in multiple config.json components. This is not ` + 'supported.');
                    } else {
                        manifestPaths.add(manifestPath);
                    }
                }
            }
        }
    }
}

//#sourceMappingUrl=./WebpackConfigurationGenerator.js.map