function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { SyncHook, AsyncSeriesWaterfallHook, SyncWaterfallHook, AsyncSeriesHook, AsyncParallelHook } from 'tapable';
import { Colorize } from '@rushstack/terminal';
import { SpDevDeploy } from './SpDevDeploy';
import { DevDeployHelper } from './DevDeployHelper';
import { DevDeployPlugin as PLUGIN_NAME } from '../PluginNames';
import { AzureUploader } from '../../utilities/AzureUploader';
/**
 * @public
 */ export class DevDeployHooks {
    constructor(){
        /**
   * Initialize
   */ _define_property(this, "init", new AsyncParallelHook([
            'deployOptions'
        ]));
        /**
   * Perform any pre processing such as delete any existing deployment info json, clean up dist folder, etc.
   */ _define_property(this, "preProcess", new SyncHook());
        /**
   * Gets the files to be deployed to the CDN
   */ _define_property(this, "getFiles", new AsyncSeriesWaterfallHook([
            'files'
        ]));
        /**
   * Gets the name of the folder in the container into which files should be uploaded
   */ _define_property(this, "getContainerFolderName", new SyncWaterfallHook([
            'containerFolderName'
        ]));
        /**
   * Gets the name of the Azure storage account
   */ _define_property(this, "getStorageAccountName", new SyncWaterfallHook([
            'storageAccountName'
        ]));
        /**
   * Gets the name of the container
   */ _define_property(this, "getContainerName", new SyncWaterfallHook([
            'containerName'
        ]));
        /**
   * Gets the URL to the container that will be used when reading files
   */ _define_property(this, "getContainerUrlForRead", new SyncWaterfallHook([
            'containerUrl'
        ]));
        /**
   * Gets a SAS for the storage container
   */ _define_property(this, "getStorageSas", new AsyncSeriesWaterfallHook([
            'storageSas'
        ]));
        /**
   * Returns true if the deployment is in a prod environment
   */ _define_property(this, "isProd", new SyncWaterfallHook([
            'isProd'
        ]));
        /**
   * Perform any post processing, usually print the deploy link, save deployment info json, collect library files, etc.
   */ _define_property(this, "postProcess", new AsyncSeriesHook());
    }
}
class DevDeployPlugin {
    get accessor() {
        if (!this._accessor) {
            this._accessor = {
                hooks: new DevDeployHooks(),
                properties: {}
            };
        }
        return this._accessor;
    }
    apply(taskSession, heftConfiguration) {
        const logger = taskSession.logger;
        const rushParameter = taskSession.parameters.getFlagParameter('--rush');
        const maxRetriesParameter = taskSession.parameters.getIntegerParameter('--max-retries');
        this._installDefaultHooks();
        taskSession.hooks.run.tapPromise(PLUGIN_NAME, async ()=>{
            logger.terminal.writeLine('Starting DevDeploy...');
            try {
                await this._deployAsync({
                    useRush: rushParameter.value,
                    maxRetries: maxRetriesParameter.value,
                    terminal: logger.terminal,
                    rootPath: heftConfiguration.buildFolderPath
                });
                logger.terminal.writeLine(Colorize.green('DevDeploy completed successfully.'));
            } catch (e) {
                logger.emitError(e);
            }
        });
    }
    _installDefaultHooks() {
        const hooks = this.accessor.hooks;
        let devDeployProcessor;
        hooks.init.tapPromise(PLUGIN_NAME, async (options)=>{
            devDeployProcessor = await SpDevDeploy.initializeAsync({
                _manifestsJsFileMetadata: this.accessor.properties._manifestsJsFileMetadata,
                ...options
            });
        });
        hooks.preProcess.tap(PLUGIN_NAME, ()=>{
            devDeployProcessor.preProcess();
        });
        hooks.getContainerFolderName.tap(PLUGIN_NAME, ()=>{
            return SpDevDeploy.getDevDeployContainerDirectoryName();
        });
        hooks.isProd.tap(PLUGIN_NAME, ()=>{
            return false;
        });
        hooks.getFiles.tapPromise(PLUGIN_NAME, async ()=>{
            return await devDeployProcessor.getFilesAsync();
        });
        hooks.postProcess.tapPromise(PLUGIN_NAME, async ()=>{
            devDeployProcessor.postProcess();
        });
    }
    async _deployAsync(options) {
        const hooks = this.accessor.hooks;
        const accountName = hooks.getStorageAccountName.call();
        const sas = await hooks.getStorageSas.promise();
        const isProd = hooks.isProd.call(false);
        const containerName = hooks.getContainerName.call();
        const folderNameInContainer = hooks.getContainerFolderName.call();
        if (!accountName) {
            throw new Error('Azure storage account not set.');
        }
        if (!sas) {
            throw new Error('Azure storage account SAS not set.');
        }
        if (!containerName) {
            throw new Error('Azure container name not set.');
        }
        const containerUrlForRead = hooks.getContainerUrlForRead.call() ?? `https://${accountName}.blob.core.windows.net/${containerName}/`;
        const deployConfig = {
            accountName,
            sas,
            isProd,
            containerName,
            folderNameInContainer,
            containerUrlForRead,
            useRush: options.useRush,
            maxRetries: options.maxRetries || AzureUploader.DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES
        };
        await hooks.init.promise({
            isolateProjects: false,
            rootPath: options.rootPath,
            terminal: options.terminal,
            devDeployConfig: deployConfig
        });
        hooks.preProcess.call();
        const deployData = await hooks.getFiles.promise();
        await DevDeployHelper.deployFilesAsync(options.terminal, deployConfig, deployData);
        await hooks.postProcess.promise();
    }
    constructor(){
        _define_property(this, "_accessor", void 0);
    }
}
/**
 * @internal
 */ export { DevDeployPlugin as default };

//#sourceMappingUrl=./DevDeployPlugin.js.map