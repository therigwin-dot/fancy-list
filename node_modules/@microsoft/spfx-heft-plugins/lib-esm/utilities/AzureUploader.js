/**
 * file uploadFilesTots
 * Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * Uploads a list of files to an Azure Blob Service instance
 */ function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { BlobServiceClient, StorageSharedKeyCredential } from '@azure/storage-blob';
import { Async } from '@rushstack/node-core-library';
import * as mime from 'mime';
import { getStorageAccountUrl } from './devDeployUtilities';
const ALREADY_EXISTS_STATUS_CODE = 409;
/**
 * @internal
 */ export class AzureUploader {
    /**
   * Upload file to Azure
   */ async uploadFileToAzureAsync(terminal, localFilename, serverFilename, blobHeaders) {
        // Manually set contentType, otherwise it will be 'application/octet-stream'
        blobHeaders = {
            ...blobHeaders,
            // Use server file name in case of writing the same blob to different file paths
            blobContentType: mime.getType(serverFilename) || undefined
        };
        try {
            const blockBlobClient = this._getBlockBlobClient(serverFilename);
            await blockBlobClient.uploadFile(localFilename, {
                blobHTTPHeaders: blobHeaders
            });
            terminal?.writeLine(`Uploaded file: ${serverFilename}`);
        } catch (e) {
            if (Number(e.statusCode) === ALREADY_EXISTS_STATUS_CODE) {
                terminal?.writeVerboseLine(`File "${serverFilename}" already exists. Skipping.`);
                return;
            }
            throw new Error(`Unable to upload file "${serverFilename}" from "${localFilename}": ${e} ${e.statusCode} ${e.code}`);
        }
    }
    async uploadToAzureAsync(terminal, contents, serverFilename, blobMetadata) {
        try {
            const blockBlobClient = this._getBlockBlobClient(serverFilename);
            await blockBlobClient.upload(contents, contents.length, {
                metadata: blobMetadata
            });
            terminal.writeLine(`Uploaded file: ${serverFilename}`);
        } catch (e) {
            if (Number(e.statusCode) === ALREADY_EXISTS_STATUS_CODE) {
                terminal.writeVerboseLine(`File "${serverFilename}" already exists. Skipping.`);
                return;
            }
            throw new Error(`Unable to upload data to "${serverFilename}": ${e} ${e.statusCode} ${e.code}`);
        }
    }
    /**
   * Upload files to Azure
   */ async uploadFilesToAzureAsync(terminal, files, maxParallelism = AzureUploader.DEFAULT_AZURE_MAX_PARALLELISM, maxRetries = AzureUploader.DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES, retryDelayMs = AzureUploader.DEFAULT_AZURE_RETRY_DELAY_MILLISECONDS, onFileUploaded) {
        terminal.writeLine(`Uploading ${files.length} files to Azure...`);
        const childTerminal = onFileUploaded ? undefined : terminal;
        await Async.forEachAsync(files, async (file)=>{
            await Async.runWithRetriesAsync({
                action: ()=>this.uploadFileToAzureAsync(childTerminal, file.localPath, file.azurePath, file.blobHeaders),
                maxRetries,
                retryDelayMs
            });
            onFileUploaded?.(file.azurePath);
        }, {
            concurrency: maxParallelism
        });
        terminal.writeLine(`Finished uploading.`);
    }
    async ensureContainerExistsAsync(terminal) {
        try {
            await this._containerClient.create({
                access: 'blob'
            });
            terminal.writeLine(`Created container: ${this._containerClient.containerName}`);
        } catch (e) {
            if (Number(e.statusCode) === ALREADY_EXISTS_STATUS_CODE) {
                return;
            }
            throw new Error(`Unable to create container ${e} ${e.statusCode} ${e.code}`);
        }
    }
    _getBlockBlobClient(serverFilename) {
        const blobClient = this._containerClient.getBlobClient(serverFilename);
        const blockBlobClient = blobClient.getBlockBlobClient();
        return blockBlobClient;
    }
    constructor(options){
        _define_property(this, "_containerClient", void 0);
        const sasOptions = options;
        const keyOptions = options;
        const storageAccountUrl = getStorageAccountUrl(options.storageAccountName);
        let blobServiceClient;
        if (sasOptions.sas && keyOptions.storageKey) {
            throw new Error('Either a SAS or a storage key must be provided, but not both.');
        } else if (sasOptions.sas) {
            blobServiceClient = BlobServiceClient.fromConnectionString(`BlobEndpoint=${storageAccountUrl};SharedAccessSignature=${sasOptions.sas}`);
        } else if (keyOptions.storageKey) {
            const keyCredential = new StorageSharedKeyCredential(options.storageAccountName, keyOptions.storageKey);
            blobServiceClient = new BlobServiceClient(storageAccountUrl, keyCredential);
        } else {
            throw new Error('Either a SAS or a storage key must be provided.');
        }
        this._containerClient = blobServiceClient.getContainerClient(options.containerName);
    }
}
_define_property(AzureUploader, "DEFAULT_AZURE_MAX_PARALLELISM", 20);
_define_property(AzureUploader, "DEFAULT_AZURE_RETRY_DELAY_MILLISECONDS", 5000);
_define_property(AzureUploader, "DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES", 10);

//#sourceMappingUrl=./AzureUploader.js.map