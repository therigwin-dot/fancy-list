/// <reference types="node" />
/// <reference types="node" />
import type webpack from 'webpack';
import type { ITerminal } from '@rushstack/terminal';
import type { ILocalizedWebpackChunk } from '@rushstack/webpack5-localization-plugin';
import type { IModuleConfiguration, IClientSideComponentLoaderConfiguration, IIntegrityPath } from '@microsoft/sp-module-interfaces';
import type { _IManifestsFileMetadata as IManifestsFileMetadata } from '@ms/spfx-manifests-file';
import type { IExternalProject } from '../utilities/ExternalsProcessor';
import type { IBundleEntry } from '../interfaces';
import { type CumulativeManifestProcessor, type IReferencedProjectMap } from '../cumulativeManifestProcessor/CumulativeManifestProcessor';
import type { ITranslationsForLocFile } from '../../plugins/webpackConfigurationPlugin/ILocalization';
import type { Entrypoint, WebpackAssets } from '../../plugins/webpackConfigurationPlugin/webpackPlugins/webpackTypes';
/**
 * @internal
 */
export interface IAsyncOnlyDependenciesOptions {
    asyncOnlyDependencyNames: string[];
    violationsAsErrors: boolean;
}
/**
 * @internal
 */
export interface ILegacyExternal {
    moduleConfigurations: {
        [externalName: string]: IModuleConfiguration;
    };
    assets: {
        [name: string]: string;
    };
}
/**
 * @internal
 */
export interface IManifestPluginOptions {
    terminal: ITerminal;
    bundleEntries: IBundleEntry[];
    internalModuleBaseUrls: string[];
    debugInternalModuleBaseUrls: string[];
    linkedExternals: Map<string, IExternalProject>;
    referencedProjects: IReferencedProjectMap;
    cumulativeManifestProcessor: CumulativeManifestProcessor;
    useManifestsJsonForComponentDependencies?: boolean;
    sourceLocaleName: string;
    tryGetLocFileTranslations: (absoluteFilePath: string) => ITranslationsForLocFile | undefined;
    selectedLocales: Set<string> | undefined;
    production: boolean;
    includeIntegrity?: boolean;
    firstPassLocaleRemapping?: Map<string, string[]>;
    asyncOnlyDependencies?: IAsyncOnlyDependenciesOptions;
    componentDependenciesAuditDropPath?: string;
    tryGetLegacyExternalByNameAsync?: (name: string) => Promise<ILegacyExternal | undefined>;
    manifestsJsFileMetadata: IManifestsFileMetadata | undefined;
}
/**
 * @internal
 */
export interface IComponentDependenciesAuditFile {
    bundles: {
        [bundleName: string]: IComponentDependenciesAuditFileBundle;
    };
}
/**
 * @internal
 */
export interface IComponentDependenciesAuditFileBundle {
    dependencies: IComponentDependenciesAuditFileDependency[];
    asyncChunks?: IComponentDependenciesAuditFileBundleAsyncChunks;
}
/**
 * @internal
 */
export interface IComponentDependenciesAuditFileBundleAsyncChunks {
    [chunkName: string]: {
        asyncComponentDependencies: IComponentDependenciesAuditFileDependency[];
    };
}
/**
 * @internal
 */
export interface IComponentDependenciesAuditFileDependency {
    componentId: string;
    componentName: string;
    componentVersion: string | undefined;
    isDirectDependency: boolean;
}
/**
 * @internal
 */
export interface IWebpackEntrypoint {
    readonly runtimeChunk: ILocalizedWebpackChunk;
}
/**
 * @internal
 */
export declare function computeIntegrity(source: string | Buffer | Buffer[]): string;
export interface IDevReleaseManifestSource extends webpack.sources.RawSource {
    releaseManifest: string;
}
/**
 * @internal
 */
export declare class ManifestPlugin implements webpack.WebpackPluginInstance {
    /**
     * @internal
     */
    _options: IManifestPluginOptions;
    private _parsedLocFileCache;
    constructor(options: IManifestPluginOptions);
    apply(compiler: webpack.Compiler): void;
    /**
     * @virtual
     */
    protected _generateLoaderConfigurationAsync(terminal: ITerminal, thisWebpack: typeof webpack, bundleName: string, compilation: webpack.Compilation, asyncOnlyDependencies: Set<string>, asyncOnlyDependenciesViolationsAsErrors: boolean, dependenciesForAudit: Map<string, IComponentDependenciesAuditFileDependency>): Promise<IClientSideComponentLoaderConfiguration>;
    protected _getRuntimeChunk(bundleName: string, entrypoint: Entrypoint): ILocalizedWebpackChunk;
    protected _getExternalsScriptResourcesAsync(terminal: ITerminal, thisWebpack: typeof webpack, bundleName: string, compilation: webpack.Compilation, runtimeChunk: webpack.Chunk, asyncOnlyDependencies: Set<string>, asyncOnlyDependenciesViolationsAsErrors: boolean, dependenciesForAudit: Map<string, IComponentDependenciesAuditFileDependency>): Promise<{
        [name: string]: IModuleConfiguration;
    }>;
    protected _getRuntimeChunkInfo(bundleName: string, runtimeChunk: webpack.Chunk, assets: WebpackAssets): string | IIntegrityPath;
    private _generateComponentManifest;
    /**
     * Process and localize WebPart manifest.
     * @remarks Also used for AdaptiveCardExtension manifests
     */
    private _processWebpartManifest;
    private _processApplicationManifest;
    /**
     * Does extension-specific manifest processing.
     */
    private _processExtensionsManifest;
    /**
     * Localizes a string with an ID in the form of $<path-to-loc-file>:<string-name>;
     * If the string to localize is not based on an id, it returns the input param untouched.
     */
    private _localizeString;
    private _getEntryManifestModule;
    private _populateLinkedExternalComponentInDependencyMap;
}
//# sourceMappingURL=ManifestPlugin.d.ts.map