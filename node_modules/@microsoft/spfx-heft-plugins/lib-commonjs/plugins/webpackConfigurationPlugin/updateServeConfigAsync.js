"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    TENANT_DOMAIN_PLACEHOLDER: function() {
        return TENANT_DOMAIN_PLACEHOLDER;
    },
    updateServeConfigAsync: function() {
        return updateServeConfigAsync;
    }
});
const _nodepath = /*#__PURE__*/ _interop_require_wildcard(require("node:path"));
const _cors = /*#__PURE__*/ _interop_require_default(require("cors"));
const _express = /*#__PURE__*/ _interop_require_default(require("express"));
const _ConfigureServe = require("./ConfigureServe");
const _ServeInfoPlugin = require("./webpackPlugins/ServeInfoPlugin");
const _CumulativeManifestProcessor = require("../../spfxManifests/cumulativeManifestProcessor/CumulativeManifestProcessor");
const _constants = require("../../utilities/constants");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const TENANT_DOMAIN_PLACEHOLDER = '{tenantdomain}';
async function updateServeConfigAsync(taskSession, heftConfiguration, additionalServePathsFromAccessor, webpackConfiguration) {
    const logger = taskSession.logger;
    const terminal = logger.terminal;
    const { buildFolderPath } = heftConfiguration;
    // Webpack Dev Server will only consider the first config if multiple are defined.
    if (Array.isArray(webpackConfiguration)) {
        webpackConfiguration = webpackConfiguration[0];
    }
    const serve = new _ConfigureServe.ConfigureServe(heftConfiguration, terminal);
    const serveConfig = serve.generateServeConfig();
    // Project serve paths
    const projectServeMap = new Map();
    const { contentBasePublicPath = '/' } = serveConfig;
    if (serveConfig.contentBase) {
        if (Array.isArray(serveConfig.contentBase)) {
            for (const contentPath of serveConfig.contentBase){
                projectServeMap.set(_nodepath.resolve(buildFolderPath, contentPath), contentBasePublicPath);
            }
        } else {
            projectServeMap.set(_nodepath.resolve(buildFolderPath, serveConfig.contentBase), contentBasePublicPath);
        }
    } else {
        projectServeMap.set(_nodepath.resolve(buildFolderPath), contentBasePublicPath);
    }
    // Additional serve paths
    const dependencyServeMap = _getDependencyServeMap(buildFolderPath, terminal);
    const serveMap = new Map([
        ...projectServeMap,
        ...dependencyServeMap,
        ...additionalServePathsFromAccessor || []
    ]);
    // eslint-disable-next-line @rushstack/security/no-unsafe-regexp
    const tenantDomainRegEx = new RegExp(TENANT_DOMAIN_PLACEHOLDER, 'i');
    if (serveConfig?.initialPage && tenantDomainRegEx.test(serveConfig.initialPage) && process.env.SPFX_SERVE_TENANT_DOMAIN) {
        serveConfig.initialPage = serveConfig.initialPage.replace(tenantDomainRegEx, process.env.SPFX_SERVE_TENANT_DOMAIN);
    }
    // Webpack Dev Server config
    // eslint-disable-next-line require-atomic-updates
    webpackConfiguration.devServer = {
        static: false,
        devMiddleware: {
            publicPath: '/dist',
            stats: {
                assets: false,
                chunks: false,
                modules: false,
                warningsFilter: [
                    /export .* was not found in/
                ]
            },
            writeToDisk: true
        },
        host: '127.0.0.1',
        port: serveConfig.port,
        hot: true,
        historyApiFallback: false,
        compress: true,
        allowedHosts: 'all',
        setupMiddlewares: (middlewares, server)=>{
            const { app } = server;
            if (!app) {
                throw new Error(`express is not initialized!`);
            }
            app.use((req, res, next)=>{
                // Need to support CORS because we access this from a different origin
                res.setHeader('Access-Control-Allow-Origin', '*');
                res.setHeader('Access-Control-Allow-Methods', 'HEAD, GET, OPTIONS');
                res.setHeader('Access-Control-Allow-Private-Network', 'true'); // Allow access from other devices on the same network
                next();
            });
            app.options('*', (0, _cors.default)({
            }));
            if (serveConfig.apiMap) {
                for (const [route, handler] of Object.entries(serveConfig.apiMap)){
                    // Don't include universal route handlers.
                    if (route.startsWith('*')) {
                        continue;
                    }
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    app.get(route, handler);
                }
            }
            middlewares.unshift(serve.logRequestsMiddleware());
            for (const [contentPath, route] of serveMap){
                middlewares.push({
                    name: 'express-static',
                    path: route,
                    middleware: _express.default.static(contentPath, {
                        index: false
                    })
                });
            }
            return middlewares;
        },
        open: serveConfig.initialPage
    };
    // Webpack Dev Server plugins
    webpackConfiguration.plugins = [
        ...webpackConfiguration.plugins ? webpackConfiguration.plugins : [],
        new _ServeInfoPlugin.ServeInfoPlugin({
            terminal,
            port: serveConfig.port,
            tempFolderName: _constants.DEFAULT_TEMP_FOLDER
        })
    ];
    return webpackConfiguration;
}
function _getDependencyServeMap(buildFolder, terminal) {
    const dependencyServeMap = new Map();
    const referencedProjects = _getReferencedProjects(buildFolder, terminal);
    for (const versionMap of Object.values(referencedProjects)){
        for (const referencedProject of Object.values(versionMap)){
            if (referencedProject.packageName && !referencedProject.isAssembly) {
                const projectOutputPath = _nodepath.dirname(referencedProject.manifestPath);
                if (referencedProject.manifestPath) {
                    dependencyServeMap.set(projectOutputPath, '/');
                } else {
                    terminal.writeWarning(referencedProject.packageName + ' not found.');
                }
            }
        }
    }
    return dependencyServeMap;
}
function _getReferencedProjects(buildFolder, terminal) {
    const cumulativeManifestProcessor = new _CumulativeManifestProcessor.CumulativeManifestProcessor({
        explicitInclude: [
            _constants.SP_LOADER_ASSEMBLY_ID
        ],
        rootPath: buildFolder,
        tempFolderName: _constants.DEFAULT_TEMP_FOLDER,
        distFolderName: _constants.DEFAULT_OUTPUT_FOLDER,
        includeAssemblies: true,
        terminal
    });
    const referencedProjects = cumulativeManifestProcessor.discoverManifests(buildFolder, _CumulativeManifestProcessor.DependencyDiscoveryMode.deepSparseIgnoreFirstProject);
    return referencedProjects;
}

//#sourceMappingUrl=./updateServeConfigAsync.js.map