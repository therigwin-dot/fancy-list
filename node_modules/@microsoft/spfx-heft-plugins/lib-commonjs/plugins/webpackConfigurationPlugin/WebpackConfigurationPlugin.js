"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return WebpackConfigurationPlugin;
    }
});
const _nodecorelibrary = require("@rushstack/node-core-library");
const _PluginNames = require("../PluginNames");
const _WebpackConfigurationGenerator = require("./WebpackConfigurationGenerator");
const _configJsonReader = require("../../spfxConfig/configJsonReader");
const _configJsonMigrator = require("../../spfxConfig/configJsonMigrator");
const _constants = require("../../utilities/constants");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const WEBPACK5_PLUGIN_NAME = 'webpack5-plugin';
class WebpackConfigurationPlugin {
    get accessor() {
        if (!this._accessor) {
            this._accessor = {
                properties: {}
            };
        }
        return this._accessor;
    }
    static getSpfxWebpackFolders(buildFolder) {
        return {
            buildFolder: buildFolder,
            tempFolder: `${buildFolder}/${_constants.DEFAULT_TEMP_FOLDER}`,
            releaseFolder: `${buildFolder}/release`,
            outputFolder: `${buildFolder}/dist`
        };
    }
    /**
   * Generate the SPFx component webpack configuration
   */ apply(taskSession, heftConfiguration) {
        const emitStatsParameter = taskSession.parameters.getFlagParameter('--emit-stats');
        taskSession.requestAccessToPluginByName('@rushstack/heft-webpack5-plugin', WEBPACK5_PLUGIN_NAME, (accessor)=>{
            accessor.hooks.onLoadConfiguration.tapPromise(_PluginNames.SpfxWebpackConfigurationPlugin, async ()=>{
                return await this._generateSpfxWebpackConfigurationAsync(taskSession, heftConfiguration, accessor.parameters.isServeMode, emitStatsParameter.value);
            });
        });
    }
    async _generateSpfxWebpackConfigurationAsync(taskSession, heftConfiguration, isServe, emitStats) {
        const { logger } = taskSession;
        const { properties: accessorProperties } = this.accessor;
        const configJson = await this._loadConfigJsonAsync(heftConfiguration, logger, accessorProperties._allowMissingConfigJson);
        if (configJson) {
            accessorProperties.configJson = configJson;
            const locales = Array.from(taskSession.parameters.locales);
            return await _WebpackConfigurationGenerator.WebpackConfigurationGenerator.generateWebpackConfigurationAsync({
                configJson: configJson,
                folders: WebpackConfigurationPlugin.getSpfxWebpackFolders(heftConfiguration.buildFolderPath),
                terminal: logger.terminal,
                production: taskSession.parameters.production,
                _includeIntegrityInManifestPaths: accessorProperties._includeIntegrityInManifestPaths,
                serveMode: isServe,
                projectPackageJson: heftConfiguration.projectPackageJson,
                getLocalization: accessorProperties.getLocalization,
                selectedLocales: locales?.length ? locales : undefined,
                linkedExternalsToBundle: accessorProperties.linkedExternalsToBundle,
                disableAsyncComponentLoading: accessorProperties.disableAsyncComponentLoading,
                assetsAreVersioned: accessorProperties.assetsAreVersioned,
                generateCssClassName: accessorProperties.generateCssClassName,
                loadThemedStylesImportPath: accessorProperties.loadThemedStylesImportPath,
                releaseManifestFolderName: accessorProperties.releaseManifestFolderName,
                _manifestsJsFileMetadata: accessorProperties._manifestsJsFileMetadata,
                _useManifestsJsonForComponentDependencies: accessorProperties._useManifestsJsonForComponentDependencies,
                buildSourceMaps: accessorProperties.buildSourceMaps,
                releaseMapFiles: accessorProperties.releaseMapFiles,
                sourceMapUrlFilter: accessorProperties.sourceMapUrlFilter,
                emitStats
            });
        } else {
            return undefined;
        }
    }
    async _loadConfigJsonAsync(heftConfiguration, scopedLogger, allowMissingConfigJson) {
        const configFilePath = `${heftConfiguration.buildFolderPath}/config/config.json`;
        const configResult = await (0, _configJsonReader.readConfigFileAsync)(scopedLogger.terminal.writeVerboseLine.bind(scopedLogger.terminal), configFilePath);
        if (configResult.missingFile && !allowMissingConfigJson) {
            scopedLogger.emitWarning(new Error('Missing config.json file. If this is a non-web project, consider using a non-web build rig ' + 'like @rushstack/heft-node-rig'));
        }
        if (configResult.readError) {
            scopedLogger.emitError(new Error(`Error reading config.json file: ${configResult.readError}`));
            return undefined;
        }
        if (!configResult.isLatestVersion && !configResult.missingFile) {
            (0, _configJsonMigrator.migrateToLatestVersion)(scopedLogger.terminal.writeWarningLine.bind(scopedLogger.terminal), // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            configResult.configData);
            await _nodecorelibrary.JsonFile.saveAsync(configResult.configData, configFilePath, {
                prettyFormatting: true
            });
            scopedLogger.emitWarning(new Error(`This project is using an old config.json file version (${configResult.version}). The ` + 'config.json file has been migrated to the latest version.'));
        }
        return configResult.configData;
    }
    constructor(){
        _define_property(this, "_accessor", void 0);
    }
}

//#sourceMappingUrl=./WebpackConfigurationPlugin.js.map