/**
 * Writes a package xml object to disk, in both raw and zipped format
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    cleanRawPackageDirectoryAsync: function() {
        return cleanRawPackageDirectoryAsync;
    },
    writeFeatureAsync: function() {
        return writeFeatureAsync;
    },
    writeIconAsync: function() {
        return writeIconAsync;
    },
    writeODCFileAsync: function() {
        return writeODCFileAsync;
    },
    writePackageAsync: function() {
        return writePackageAsync;
    },
    writeXmlFileAsync: function() {
        return writeXmlFileAsync;
    }
});
const _path = /*#__PURE__*/ _interop_require_wildcard(require("path"));
const _jszip = /*#__PURE__*/ _interop_require_default(require("jszip"));
const _nodecorelibrary = require("@rushstack/node-core-library");
const _utilities = require("../utilities");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
async function writePackageAsync(terminal, solution, config, noSpppkg) {
    const zip = new _jszip.default();
    await cleanRawPackageDirectoryAsync(terminal, config);
    await Promise.all([
        writeODCFileAsync(terminal, solution.manifest, config, zip),
        writeXmlFileAsync(terminal, solution.relationships, config, zip),
        writeXmlFileAsync(terminal, solution.contentTypesXml, config, zip),
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        writeIconAsync(terminal, solution.icon, config, zip)
    ].concat(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    solution.customFiles.map((customFile)=>writeXmlFileAsync(terminal, customFile, config, zip))).concat(solution.features.map((feature)=>writeFeatureAsync(terminal, feature, config, zip))));
    if (!noSpppkg) {
        const zipFile = await zip.generateAsync({
            type: 'nodebuffer',
            compression: 'DEFLATE',
            compressionOptions: {
                level: 9
            }
        });
        await writeFileAsync(terminal, config.paths.zippedPackage, zipFile);
    }
}
async function cleanRawPackageDirectoryAsync(terminal, config) {
    await _nodecorelibrary.FileSystem.deleteFolderAsync(config.paths.debugDir);
    terminal.writeLine(`Cleaned ${config.paths.debugDir}`);
}
async function writeFeatureAsync(terminal, feature, config, zip) {
    await Promise.all([
        writeODCFileAsync(terminal, feature, config, zip),
        writeXmlFileAsync(terminal, feature.config, config, zip)
    ].concat((feature.clientSideResources || []).map((resource)=>writeXmlFileAsync(terminal, resource, config, zip))).concat(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    feature.assets.elementFiles.map((asset)=>writeXmlFileAsync(terminal, asset, config, zip))).concat(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    feature.assets.elementManifests.map((asset)=>writeXmlFileAsync(terminal, asset, config, zip))).concat(// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    feature.assets.upgradeActions.map((asset)=>writeXmlFileAsync(terminal, asset, config, zip))).concat(feature.components.map((component)=>writeXmlFileAsync(terminal, component, config, zip))));
}
async function writeIconAsync(terminal, icon, config, zip) {
    if (icon) {
        const filepath = _path.join(config.paths.packageDir, icon.path);
        if (_nodecorelibrary.FileSystem.getStatistics(filepath).isFile()) {
            await Promise.all([
                _nodecorelibrary.FileSystem.readFileToBufferAsync(filepath).then((data)=>{
                    return writeFileToPathAsync(terminal, icon.path, data, config, zip);
                }),
                writeXmlFileAsync(terminal, icon.config, config, zip),
                writeXmlFileAsync(terminal, icon.relationships, config, zip)
            ]);
        } else {
            throw new Error(`Icon with path "${icon.path}" was not found.`);
        }
    }
}
async function writeXmlFileAsync(terminal, file, config, zip) {
    await writeFileToPathAsync(terminal, file.filename, file.contents, config, zip);
}
async function writeODCFileAsync(terminal, file, config, zip) {
    await Promise.all([
        writeFileToPathAsync(terminal, file.filename, file.contents, config, zip),
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        writeXmlFileAsync(terminal, file.relationships, config, zip)
    ]);
}
/**
 * Physically writes a file to disk, and adds to an in-memory zip package
 */ async function writeFileToPathAsync(terminal, filename, contents, config, zip) {
    const filepath = _path.join(config.paths.debugDir, filename);
    await (0, _utilities.serialAsync)([
        ()=>writeFileAsync(terminal, filepath, contents),
        ()=>addFileToZipAsync(filename, contents, zip)
    ]);
}
/**
 * Wraps fsx.writeFile in a promise
 */ async function writeFileAsync(terminal, filename, contents) {
    _nodecorelibrary.FileSystem.writeFile(filename, contents, {
        ensureFolderExists: true
    });
    terminal.writeLine(`Created file: ${filename}`);
}
/**
 * Adds a file to a zip package
 */ async function addFileToZipAsync(filepath, content, zip) {
    const directories = filepath.split(_path.sep);
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const file = directories.pop();
    for (const dir of directories){
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        zip = zip.folder(dir);
    }
    zip.file(file, content);
}

//#sourceMappingUrl=./writePackage.js.map