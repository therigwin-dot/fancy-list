"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    DevDeployHooks: function() {
        return DevDeployHooks;
    },
    default: function() {
        return DevDeployPlugin;
    }
});
const _tapable = require("tapable");
const _terminal = require("@rushstack/terminal");
const _SpDevDeploy = require("./SpDevDeploy");
const _DevDeployHelper = require("./DevDeployHelper");
const _PluginNames = require("../PluginNames");
const _AzureUploader = require("../../utilities/AzureUploader");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class DevDeployHooks {
    constructor(){
        /**
   * Initialize
   */ _define_property(this, "init", new _tapable.AsyncParallelHook([
            'deployOptions'
        ]));
        /**
   * Perform any pre processing such as delete any existing deployment info json, clean up dist folder, etc.
   */ _define_property(this, "preProcess", new _tapable.SyncHook());
        /**
   * Gets the files to be deployed to the CDN
   */ _define_property(this, "getFiles", new _tapable.AsyncSeriesWaterfallHook([
            'files'
        ]));
        /**
   * Gets the name of the folder in the container into which files should be uploaded
   */ _define_property(this, "getContainerFolderName", new _tapable.SyncWaterfallHook([
            'containerFolderName'
        ]));
        /**
   * Gets the name of the Azure storage account
   */ _define_property(this, "getStorageAccountName", new _tapable.SyncWaterfallHook([
            'storageAccountName'
        ]));
        /**
   * Gets the name of the container
   */ _define_property(this, "getContainerName", new _tapable.SyncWaterfallHook([
            'containerName'
        ]));
        /**
   * Gets the URL to the container that will be used when reading files
   */ _define_property(this, "getContainerUrlForRead", new _tapable.SyncWaterfallHook([
            'containerUrl'
        ]));
        /**
   * Gets a SAS for the storage container
   */ _define_property(this, "getStorageSas", new _tapable.AsyncSeriesWaterfallHook([
            'storageSas'
        ]));
        /**
   * Returns true if the deployment is in a prod environment
   */ _define_property(this, "isProd", new _tapable.SyncWaterfallHook([
            'isProd'
        ]));
        /**
   * Perform any post processing, usually print the deploy link, save deployment info json, collect library files, etc.
   */ _define_property(this, "postProcess", new _tapable.AsyncSeriesHook());
    }
}
class DevDeployPlugin {
    get accessor() {
        if (!this._accessor) {
            this._accessor = {
                hooks: new DevDeployHooks(),
                properties: {}
            };
        }
        return this._accessor;
    }
    apply(taskSession, heftConfiguration) {
        const logger = taskSession.logger;
        const rushParameter = taskSession.parameters.getFlagParameter('--rush');
        const maxRetriesParameter = taskSession.parameters.getIntegerParameter('--max-retries');
        this._installDefaultHooks();
        taskSession.hooks.run.tapPromise(_PluginNames.DevDeployPlugin, async ()=>{
            logger.terminal.writeLine('Starting DevDeploy...');
            try {
                await this._deployAsync({
                    useRush: rushParameter.value,
                    maxRetries: maxRetriesParameter.value,
                    terminal: logger.terminal,
                    rootPath: heftConfiguration.buildFolderPath
                });
                logger.terminal.writeLine(_terminal.Colorize.green('DevDeploy completed successfully.'));
            } catch (e) {
                logger.emitError(e);
            }
        });
    }
    _installDefaultHooks() {
        const hooks = this.accessor.hooks;
        let devDeployProcessor;
        hooks.init.tapPromise(_PluginNames.DevDeployPlugin, async (options)=>{
            devDeployProcessor = await _SpDevDeploy.SpDevDeploy.initializeAsync({
                _manifestsJsFileMetadata: this.accessor.properties._manifestsJsFileMetadata,
                ...options
            });
        });
        hooks.preProcess.tap(_PluginNames.DevDeployPlugin, ()=>{
            devDeployProcessor.preProcess();
        });
        hooks.getContainerFolderName.tap(_PluginNames.DevDeployPlugin, ()=>{
            return _SpDevDeploy.SpDevDeploy.getDevDeployContainerDirectoryName();
        });
        hooks.isProd.tap(_PluginNames.DevDeployPlugin, ()=>{
            return false;
        });
        hooks.getFiles.tapPromise(_PluginNames.DevDeployPlugin, async ()=>{
            return await devDeployProcessor.getFilesAsync();
        });
        hooks.postProcess.tapPromise(_PluginNames.DevDeployPlugin, async ()=>{
            devDeployProcessor.postProcess();
        });
    }
    async _deployAsync(options) {
        const hooks = this.accessor.hooks;
        const accountName = hooks.getStorageAccountName.call();
        const sas = await hooks.getStorageSas.promise();
        const isProd = hooks.isProd.call(false);
        const containerName = hooks.getContainerName.call();
        const folderNameInContainer = hooks.getContainerFolderName.call();
        if (!accountName) {
            throw new Error('Azure storage account not set.');
        }
        if (!sas) {
            throw new Error('Azure storage account SAS not set.');
        }
        if (!containerName) {
            throw new Error('Azure container name not set.');
        }
        const containerUrlForRead = hooks.getContainerUrlForRead.call() ?? `https://${accountName}.blob.core.windows.net/${containerName}/`;
        const deployConfig = {
            accountName,
            sas,
            isProd,
            containerName,
            folderNameInContainer,
            containerUrlForRead,
            useRush: options.useRush,
            maxRetries: options.maxRetries || _AzureUploader.AzureUploader.DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES
        };
        await hooks.init.promise({
            isolateProjects: false,
            rootPath: options.rootPath,
            terminal: options.terminal,
            devDeployConfig: deployConfig
        });
        hooks.preProcess.call();
        const deployData = await hooks.getFiles.promise();
        await _DevDeployHelper.DevDeployHelper.deployFilesAsync(options.terminal, deployConfig, deployData);
        await hooks.postProcess.promise();
    }
    constructor(){
        _define_property(this, "_accessor", void 0);
    }
}

//#sourceMappingUrl=./DevDeployPlugin.js.map