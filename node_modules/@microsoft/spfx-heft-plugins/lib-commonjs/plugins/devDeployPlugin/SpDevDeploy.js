"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SpDevDeploy", {
    enumerable: true,
    get: function() {
        return SpDevDeploy;
    }
});
const _url = /*#__PURE__*/ _interop_require_wildcard(require("url"));
const _path = /*#__PURE__*/ _interop_require_wildcard(require("path"));
const _lodash = /*#__PURE__*/ _interop_require_default(require("lodash"));
const _rushlib = require("@microsoft/rush-lib");
const _nodecorelibrary = require("@rushstack/node-core-library");
const _heftconfigfile = require("@rushstack/heft-config-file");
const _DevDeployLinkPrinter = require("./DevDeployLinkPrinter");
const _UrlUtilities = require("../../utilities/UrlUtilities");
const _ManifestsFileBuilder = require("../../spfxManifests/manifestFileBuilder/ManifestsFileBuilder");
const _CumulativeManifestProcessor = require("../../spfxManifests/cumulativeManifestProcessor/CumulativeManifestProcessor");
const _constants = require("../../utilities/constants");
const _IconHandler = require("../../spfxManifests/utilities/IconHandler");
const _devDeployUtilities = require("../../utilities/devDeployUtilities");
const _spdevdeployschemajson = /*#__PURE__*/ _interop_require_default(require("./sp-dev-deploy.schema.json"));
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const MANIFESTS_JS_FILENAME = 'manifests.js';
class SpDevDeploy {
    static get _spDevDeployConfigFile() {
        if (!SpDevDeploy.__spDevDeployConfigFile) {
            SpDevDeploy.__spDevDeployConfigFile = new _heftconfigfile.ConfigurationFile({
                projectRelativeFilePath: 'config/sp-dev-deploy.json',
                jsonSchemaObject: _spdevdeployschemajson.default
            });
        }
        return SpDevDeploy.__spDevDeployConfigFile;
    }
    static getDevDeployContainerDirectoryName() {
        return (0, _devDeployUtilities.getDevDeployContainerDirectoryName)();
    }
    static async initializeAsync(options) {
        const configFileData = await SpDevDeploy._spDevDeployConfigFile.tryLoadConfigurationFileForProjectAsync(options.terminal, options.rootPath);
        return new SpDevDeploy(options, configFileData);
    }
    preProcess() {
        const metadataFilePath = this._getMetadataDropPath();
        // Proactively delete the metadata file so we aren't left with invalid metadata from a previous deploy if
        // this deploy fails
        _nodecorelibrary.FileSystem.deleteFile(metadataFilePath);
    }
    async getFilesAsync() {
        const cumulativeManifestProcessor = new _CumulativeManifestProcessor.CumulativeManifestProcessor({
            explicitInclude: [
                _constants.SP_LOADER_ASSEMBLY_ID
            ],
            rootPath: this._options.rootPath,
            tempFolderName: _constants.DEFAULT_TEMP_FOLDER,
            distFolderName: 'dist',
            includeAssemblies: true,
            ignoreNonSpfxManifests: true,
            terminal: this._options.terminal
        });
        const manifests = this._getManifests(cumulativeManifestProcessor);
        const manifestsArray = [];
        this._options.terminal.writeVerboseLine(`Discovered ${Object.keys(manifests).length} projects.`);
        const foldersToUpload = new Map();
        const projectContainerNames = new Map(); // Ensure we don't reuse a name
        let spLoaderFolderPath;
        let debugSPLoader;
        // Loop through the manifests and collect files and directories to be uploaded, and fix up manifest fields
        for(const id in manifests){
            if (manifests.hasOwnProperty(id)) {
                for(const version in manifests[id]){
                    if (manifests[id].hasOwnProperty(version)) {
                        const referencedProject = manifests[id][version];
                        const manifest = referencedProject.manifestData;
                        const loaderConfig = manifest.loaderConfig;
                        this._options.terminal.writeVerboseLine(`Processing ${id}@${version} (${manifest.alias}) in "${referencedProject.manifestPath}"...`);
                        manifestsArray.push(manifest);
                        const projectContainerName = this._options.isolateProjects ? this._getDestinationDirName(projectContainerNames, referencedProject.manifestPath) : '.';
                        // A relative base URL applies when the paths are based on the tenant URL.
                        // This applies, for example, in the JSOM library, that takes the JS files from a known place
                        // available on every tenant.
                        const isBaseUrlRelative = loaderConfig.internalModuleBaseUrls.length > 0 && !_url.parse(loaderConfig.internalModuleBaseUrls[0]).protocol;
                        // If the Base URL is a relative path, keep the relative path
                        if (!isBaseUrlRelative) {
                            loaderConfig.internalModuleBaseUrls = [];
                        }
                        const manifestFolderPath = _path.dirname(referencedProject.manifestPath);
                        const processPath = (resourcePath)=>{
                            if (typeof resourcePath === 'object') {
                                resourcePath = resourcePath.path;
                            }
                            // If the base URL was relative, a relative path for a resource doesn't need to be fixed up
                            if (_UrlUtilities.UrlUtilities.isUrl(resourcePath) || isBaseUrlRelative) {
                                return resourcePath; // Do not deal with fully-qualified URL.
                            } else {
                                this._options.terminal.writeVerboseLine(`    Processing resource path ${resourcePath}`);
                                const filesystemPath = _path.join(manifestFolderPath, resourcePath);
                                const filename = _path.basename(resourcePath);
                                // Path resources are in the 'dist' folder by default and usually have some secondary
                                // references, so let's just upload the whole folder.
                                const filesystemFolder = _path.dirname(filesystemPath);
                                this._options.terminal.writeVerboseLine(`    Added ${filesystemFolder} to folders to upload`);
                                foldersToUpload.set(filesystemFolder, projectContainerName);
                                if (!spLoaderFolderPath && id === _constants.SP_LOADER_ASSEMBLY_ID) {
                                    spLoaderFolderPath = projectContainerName;
                                    debugSPLoader = filename;
                                }
                                return _UrlUtilities.UrlUtilities.joinUrlSegments(projectContainerName, filename);
                            }
                        };
                        this._doComponentTypeSpecificFixup(manifest, processPath);
                        this._processAllPathsInManifest(manifest, processPath);
                        this._options.terminal.writeVerboseLine(`Processing ${id}@${version} (${manifest.alias})...DONE`);
                    }
                }
            }
        }
        // Expand directories to individual files
        const filesToUpload = [];
        await _nodecorelibrary.Async.forEachAsync(foldersToUpload, async ([localDirPath, deployDirName])=>{
            const filesIterable = this._getFilesInFolderInnerAsync(localDirPath, deployDirName);
            for await (const file of filesIterable){
                filesToUpload.push(file);
            }
        }, {
            concurrency: 10
        });
        const manifestsFileFullPath = _path.join(this._options.rootPath, 'temp', 'dev-deploy', MANIFESTS_JS_FILENAME);
        await (0, _ManifestsFileBuilder.buildManifestsJsAsync)(manifestsArray, manifestsFileFullPath, undefined, this._options._manifestsJsFileMetadata);
        filesToUpload.push({
            localPath: manifestsFileFullPath,
            deployPath: MANIFESTS_JS_FILENAME
        });
        const deployBaseUrl = this._getDeployBaseUrl();
        this._devDeployManifestFileUrl = _UrlUtilities.UrlUtilities.joinUrlSegments(deployBaseUrl, SpDevDeploy._debugManifestPath);
        if (spLoaderFolderPath && debugSPLoader) {
            this._devDeployModuleLoaderUrl = _UrlUtilities.UrlUtilities.joinUrlSegments(deployBaseUrl, spLoaderFolderPath, debugSPLoader);
        }
        return {
            filesToUpload,
            loaderPath: this._devDeployModuleLoaderUrl
        };
    }
    async getFilesInFolderAsync(localDirPath, deployDirName) {
        const files = [];
        const filesIterable = this._getFilesInFolderInnerAsync(localDirPath, deployDirName);
        for await (const file of filesIterable){
            files.push(file);
        }
        return files;
    }
    postProcess() {
        if (!this._options.ignoreCollisions) {
            this._printCollisionWarnings();
        }
        this._options.terminal.writeLine();
        this._printDevDeployLink();
        this._options.terminal.writeLine();
        this._saveDevDeployMetadata();
    }
    async *_getFilesInFolderInnerAsync(localDirPath, deployDirName) {
        const localDirEntries = await _nodecorelibrary.FileSystem.readFolderItemsAsync(localDirPath);
        for (const localDirEntry of localDirEntries){
            const localDirEntryName = localDirEntry.name;
            const deployPath = _UrlUtilities.UrlUtilities.joinUrlSegments(deployDirName, localDirEntryName);
            const localPath = `${localDirPath}/${localDirEntryName}`;
            if (localDirEntry.isFile()) {
                yield {
                    localPath,
                    deployPath
                };
                if (!this._options.isolateProjects) {
                    let collisionsForPath = this._collisionDetectionMap.get(deployPath);
                    if (!collisionsForPath) {
                        collisionsForPath = [];
                        this._collisionDetectionMap.set(deployPath, collisionsForPath);
                    }
                    collisionsForPath.push(localPath);
                }
            } else {
                yield* this._getFilesInFolderInnerAsync(localPath, deployPath);
            }
        }
    }
    _printCollisionWarnings() {
        // Warn about collisions
        this._collisionDetectionMap.forEach((localPaths, url)=>{
            if (localPaths.length > 1 && !this._doesFilenameAppearToContainHash(localPaths[0])) {
                this._options.terminal.writeWarningLine(`COLLISION DETECTED AS ${url} IN THESE:\n${localPaths.join('\n')}\n` + `It is very probable that the dev-deploy will not work as expected. This may indicate a ` + `serious issue for production environments as well.`);
            }
        });
    }
    _saveDevDeployMetadata() {
        const dropPath = this._getMetadataDropPath();
        _nodecorelibrary.JsonFile.save(this._devDeployMetadata, dropPath, {
            ensureFolderExists: true
        });
    }
    _printDevDeployLink() {
        const deployBaseUrl = this._getDeployBaseUrl();
        if (!this._devDeployManifestFileUrl) {
            throw new Error('"_devDeployManifestFileUrl" must be defined');
        }
        this._devDeployMetadata = {
            deployUrl: deployBaseUrl,
            debugManifestUrl: this._devDeployManifestFileUrl
        };
        if (this._devDeployModuleLoaderUrl) {
            this._devDeployMetadata.loaderUrl = this._devDeployModuleLoaderUrl;
        }
        (0, _DevDeployLinkPrinter.printDevDeployLink)({
            terminal: this._options.terminal,
            metadata: this._devDeployMetadata,
            testingPageUrl: this._configFileData?.testingPageUrl
        });
    }
    _getDeployBaseUrl() {
        const { folderNameInContainer, containerUrlForRead } = this._options.devDeployConfig;
        return _UrlUtilities.UrlUtilities.joinUrlSegments(containerUrlForRead, folderNameInContainer ?? '');
    }
    _processAllPathsInManifest({ loaderConfig }, pathProcessFunction) {
        for(const scriptResourceId in loaderConfig.scriptResources){
            if (loaderConfig.scriptResources.hasOwnProperty(scriptResourceId)) {
                const scriptResource = loaderConfig.scriptResources[scriptResourceId];
                switch(scriptResource.type){
                    case 'path':
                        {
                            // Path script resource, we need to fix up its path and upload it
                            const pathResource = scriptResource;
                            pathResource.path = pathProcessFunction(pathResource.path);
                            break;
                        }
                    case 'component':
                        {
                            // We probably don't need to upload the fallback file, and it's nigh-impossible to tell if we'll
                            // miss secondary dependencies by only uploading the file at the failoverPath, so we'll just clear
                            // it out and hope this dependency is either satisfied by another dev-deploy manifest or by the OOB
                            // framework
                            const componentResource = scriptResource;
                            componentResource.failoverPath = undefined;
                            break;
                        }
                    case 'localizedPath':
                        {
                            // Localized path script resource, we need to fix up the paths for each locale and upload each file
                            const localizedPathResource = scriptResource;
                            // Select en-us if it exists, otherwise pass through the default path.
                            const pathToProcess = (localizedPathResource.paths ? localizedPathResource.paths[_constants.DEFAULT_LOCALE] : localizedPathResource.defaultPath) || localizedPathResource.defaultPath;
                            if (!pathToProcess) {
                                // eslint-disable-next-line no-console
                                console.warn('module ' + loaderConfig.entryModuleId + ' has a localized resorce with no default path');
                            } else {
                                localizedPathResource.defaultPath = pathProcessFunction(pathToProcess);
                            }
                            if (localizedPathResource.paths) {
                                for(const locale in localizedPathResource.paths){
                                    if (localizedPathResource.paths.hasOwnProperty(locale)) {
                                        localizedPathResource.paths[locale] = pathProcessFunction(localizedPathResource.paths[locale]);
                                    }
                                }
                            }
                            break;
                        }
                }
            }
        }
    }
    /**
   * This function returns a directory name to be used in a directory in the destination, ensuring that the name does
   * not collide with another directory's name. It also ensures that if the specified filesystem path has already
   * been mapped to a destination directory, the same name is used in the destination.
   */ _getDestinationDirName(directoryMap, filesystemPath) {
        const projectFolder = _nodecorelibrary.PackageJsonLookup.instance.tryGetPackageFolderFor(filesystemPath);
        if (!projectFolder) {
            throw new Error(`Unable to find a project folder for "${filesystemPath}"`);
        }
        let destinationDirName = _path.basename(projectFolder).toLowerCase();
        if (directoryMap.has(destinationDirName)) {
            const existingPaths = directoryMap.get(destinationDirName);
            if (!existingPaths) {
                throw new Error("Couldn't get paths");
            }
            const currentPathId = existingPaths.indexOf(filesystemPath);
            if (currentPathId === -1) {
                destinationDirName = `${destinationDirName}_${existingPaths.length}`;
                existingPaths.push(filesystemPath);
            } else if (currentPathId > 0) {
                destinationDirName = `${destinationDirName}_${currentPathId}`;
            }
        } else {
            directoryMap.set(destinationDirName, [
                filesystemPath
            ]);
        }
        return destinationDirName;
    }
    _getManifests(cumulativeManifestProcessor) {
        if (this._options.devDeployConfig.useRush) {
            const rushConfig = this._getRushConfig();
            if (!rushConfig) {
                throw new Error('Unable to find the rush configuration file.');
            }
            let manifests;
            const directories = rushConfig.projects.map((proj)=>proj.projectFolder);
            manifests = cumulativeManifestProcessor.discoverManifests(directories[0], this._options._projectDiscoveryMode);
            for(let i = 1; i < directories.length; i++){
                const projectManifests = cumulativeManifestProcessor.discoverManifests(directories[i], this._options._projectDiscoveryMode);
                manifests = this._mergeReferencedProjectLists(manifests, projectManifests);
            }
            return manifests;
        } else {
            return cumulativeManifestProcessor.discoverManifests(this._options.rootPath, this._options._projectDiscoveryMode);
        }
    }
    _mergeReferencedProjectLists(list1, list2) {
        const ids = new Set();
        Object.keys(list1).concat(Object.keys(list2)).forEach((id)=>ids.add(id));
        const result = {};
        ids.forEach((id)=>{
            const list1Versions = list1[id];
            const list2Versions = list2[id];
            if (!list1Versions || !list2Versions) {
                // Element is only present in one list
                result[id] = list1Versions || list2Versions;
            } else {
                // Arrays are present in both lists, merge them together
                const versionMapping = {};
                function addVersionsToMapping(referencedVersions) {
                    for(const version in referencedVersions){
                        if (!versionMapping[version] || referencedVersions[version].manifestCreationTime > versionMapping[version].manifestCreationTime) {
                            versionMapping[version] = referencedVersions[version];
                        }
                    }
                }
                addVersionsToMapping(list1Versions);
                addVersionsToMapping(list2Versions);
                result[id] = versionMapping;
            }
        });
        return result;
    }
    _doComponentTypeSpecificFixup(manifest, processPath) {
        switch(manifest.componentType){
            case 'WebPart':
                const webpartManifest = manifest;
                for (const preconfiguredEntry of webpartManifest.preconfiguredEntries){
                    if (preconfiguredEntry.iconImageUrl) {
                        preconfiguredEntry.iconImageUrl = this._fixupIconPath(preconfiguredEntry.iconImageUrl, processPath);
                    }
                }
                break;
            case 'Extension':
                const extensionManifest = manifest;
                switch(extensionManifest.extensionType){
                    case 'ListViewCommandSet':
                        const commandSetManifest = extensionManifest;
                        for(const itemId in commandSetManifest.items){
                            if (commandSetManifest.items.hasOwnProperty(itemId)) {
                                const item = commandSetManifest.items[itemId];
                                if (item.iconImageUrl) {
                                    item.iconImageUrl = this._fixupIconPath(item.iconImageUrl, processPath);
                                }
                            }
                        }
                        break;
                    default:
                        break;
                }
                break;
            default:
                break;
        }
    }
    _fixupIconPath(iconPath, processPath) {
        if (_IconHandler.IconHandler.getIconPathType(iconPath) === _IconHandler.IconPathType.RelativeUrl) {
            const relativeIconPath = _lodash.default.trimStart(iconPath, '/');
            return processPath(relativeIconPath);
        } else {
            return iconPath;
        }
    }
    _getRushConfig() {
        if (!this._rushConfig) {
            this._rushConfig = _rushlib.RushConfiguration.loadFromDefaultLocation();
        }
        return this._rushConfig;
    }
    _getMetadataDropPath() {
        const METADATA_FILENAME = 'dev-deploy-metadata.json';
        const rushConfig = this._getRushConfig();
        if (!rushConfig) {
            throw new Error('Unable to find the rush configuration file.');
        }
        const commonTempDirectory = rushConfig.commonTempFolder;
        return _path.join(commonTempDirectory, METADATA_FILENAME);
    }
    _doesFilenameAppearToContainHash(filePath) {
        const filename = _path.basename(filePath, _path.extname(filePath));
        // Look for a hexadecimal string at the end of the filename that is at least 5 characters long and
        // starts with an underscore (_) or a hyphen (-).
        return !!filename.match(/[_-][a-f0-9]{5,}$/i);
    }
    constructor(options, configFileData){
        _define_property(this, "_rushConfig", void 0);
        _define_property(this, "_options", void 0);
        _define_property(this, "_devDeployManifestFileUrl", void 0);
        _define_property(this, "_devDeployModuleLoaderUrl", void 0);
        _define_property(this, "_devDeployMetadata", void 0);
        _define_property(this, "_collisionDetectionMap", new Map());
        _define_property(this, "_configFileData", void 0);
        this._configFileData = configFileData;
        this._options = {
            isolateProjects: true,
            ignoreCollisions: false,
            _projectDiscoveryMode: _CumulativeManifestProcessor.DependencyDiscoveryMode.deepSparse,
            ...options
        };
        if (!this._options.rootPath) {
            throw new Error('rootPath must be provided.');
        }
        if (!this._options.terminal) {
            throw new Error('Terminal must be provided.');
        }
    }
}
_define_property(SpDevDeploy, "_debugManifestPath", MANIFESTS_JS_FILENAME);
_define_property(SpDevDeploy, "__spDevDeployConfigFile", void 0);

//#sourceMappingUrl=./SpDevDeploy.js.map