/**
 * file uploadFilesTots
 * Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * Uploads a list of files to an Azure Blob Service instance
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AzureUploader", {
    enumerable: true,
    get: function() {
        return AzureUploader;
    }
});
const _storageblob = require("@azure/storage-blob");
const _nodecorelibrary = require("@rushstack/node-core-library");
const _mime = /*#__PURE__*/ _interop_require_wildcard(require("mime"));
const _devDeployUtilities = require("./devDeployUtilities");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const ALREADY_EXISTS_STATUS_CODE = 409;
class AzureUploader {
    /**
   * Upload file to Azure
   */ async uploadFileToAzureAsync(terminal, localFilename, serverFilename, blobHeaders) {
        // Manually set contentType, otherwise it will be 'application/octet-stream'
        blobHeaders = {
            ...blobHeaders,
            // Use server file name in case of writing the same blob to different file paths
            blobContentType: _mime.getType(serverFilename) || undefined
        };
        try {
            const blockBlobClient = this._getBlockBlobClient(serverFilename);
            await blockBlobClient.uploadFile(localFilename, {
                blobHTTPHeaders: blobHeaders
            });
            terminal?.writeLine(`Uploaded file: ${serverFilename}`);
        } catch (e) {
            if (Number(e.statusCode) === ALREADY_EXISTS_STATUS_CODE) {
                terminal?.writeVerboseLine(`File "${serverFilename}" already exists. Skipping.`);
                return;
            }
            throw new Error(`Unable to upload file "${serverFilename}" from "${localFilename}": ${e} ${e.statusCode} ${e.code}`);
        }
    }
    async uploadToAzureAsync(terminal, contents, serverFilename, blobMetadata) {
        try {
            const blockBlobClient = this._getBlockBlobClient(serverFilename);
            await blockBlobClient.upload(contents, contents.length, {
                metadata: blobMetadata
            });
            terminal.writeLine(`Uploaded file: ${serverFilename}`);
        } catch (e) {
            if (Number(e.statusCode) === ALREADY_EXISTS_STATUS_CODE) {
                terminal.writeVerboseLine(`File "${serverFilename}" already exists. Skipping.`);
                return;
            }
            throw new Error(`Unable to upload data to "${serverFilename}": ${e} ${e.statusCode} ${e.code}`);
        }
    }
    /**
   * Upload files to Azure
   */ async uploadFilesToAzureAsync(terminal, files, maxParallelism = AzureUploader.DEFAULT_AZURE_MAX_PARALLELISM, maxRetries = AzureUploader.DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES, retryDelayMs = AzureUploader.DEFAULT_AZURE_RETRY_DELAY_MILLISECONDS, onFileUploaded) {
        terminal.writeLine(`Uploading ${files.length} files to Azure...`);
        const childTerminal = onFileUploaded ? undefined : terminal;
        await _nodecorelibrary.Async.forEachAsync(files, async (file)=>{
            await _nodecorelibrary.Async.runWithRetriesAsync({
                action: ()=>this.uploadFileToAzureAsync(childTerminal, file.localPath, file.azurePath, file.blobHeaders),
                maxRetries,
                retryDelayMs
            });
            onFileUploaded?.(file.azurePath);
        }, {
            concurrency: maxParallelism
        });
        terminal.writeLine(`Finished uploading.`);
    }
    async ensureContainerExistsAsync(terminal) {
        try {
            await this._containerClient.create({
                access: 'blob'
            });
            terminal.writeLine(`Created container: ${this._containerClient.containerName}`);
        } catch (e) {
            if (Number(e.statusCode) === ALREADY_EXISTS_STATUS_CODE) {
                return;
            }
            throw new Error(`Unable to create container ${e} ${e.statusCode} ${e.code}`);
        }
    }
    _getBlockBlobClient(serverFilename) {
        const blobClient = this._containerClient.getBlobClient(serverFilename);
        const blockBlobClient = blobClient.getBlockBlobClient();
        return blockBlobClient;
    }
    constructor(options){
        _define_property(this, "_containerClient", void 0);
        const sasOptions = options;
        const keyOptions = options;
        const storageAccountUrl = (0, _devDeployUtilities.getStorageAccountUrl)(options.storageAccountName);
        let blobServiceClient;
        if (sasOptions.sas && keyOptions.storageKey) {
            throw new Error('Either a SAS or a storage key must be provided, but not both.');
        } else if (sasOptions.sas) {
            blobServiceClient = _storageblob.BlobServiceClient.fromConnectionString(`BlobEndpoint=${storageAccountUrl};SharedAccessSignature=${sasOptions.sas}`);
        } else if (keyOptions.storageKey) {
            const keyCredential = new _storageblob.StorageSharedKeyCredential(options.storageAccountName, keyOptions.storageKey);
            blobServiceClient = new _storageblob.BlobServiceClient(storageAccountUrl, keyCredential);
        } else {
            throw new Error('Either a SAS or a storage key must be provided.');
        }
        this._containerClient = blobServiceClient.getContainerClient(options.containerName);
    }
}
_define_property(AzureUploader, "DEFAULT_AZURE_MAX_PARALLELISM", 20);
_define_property(AzureUploader, "DEFAULT_AZURE_RETRY_DELAY_MILLISECONDS", 5000);
_define_property(AzureUploader, "DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES", 10);

//#sourceMappingUrl=./AzureUploader.js.map