"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    CumulativeManifestProcessor: function() {
        return CumulativeManifestProcessor;
    },
    DependencyDiscoveryMode: function() {
        return DependencyDiscoveryMode;
    }
});
const _path = /*#__PURE__*/ _interop_require_wildcard(require("path"));
const _lodash = require("lodash");
const _resolve = /*#__PURE__*/ _interop_require_wildcard(require("resolve"));
const _nodecorelibrary = require("@rushstack/node-core-library");
const _ManifestsFileBuilder = require("../manifestFileBuilder/ManifestsFileBuilder");
const _ManifestUrlProcessor = require("./ManifestUrlProcessor");
const _constants = require("../../utilities/constants");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const CUMULATIVE_MANIFEST_FILENAME = 'manifests';
// These values are only used when the manifests.json file is used to aggregate manifests.
// This feature is opt-in only and the manifests.json file is not published.
const TIMESTAMP_LOCALLY_BUILT = Number.MAX_SAFE_INTEGER;
const TIMESTAMP_EXTERNAL = 0;
var DependencyDiscoveryMode;
(function(DependencyDiscoveryMode) {
    /**
   * Don't force a manifest search anywhere. Use the manifests.json file everywhere if it's found.
   */ DependencyDiscoveryMode[DependencyDiscoveryMode["none"] = 0] = "none";
    /**
   * Don't force a manifest search in the first project, but use the manifests.json file in other packages.
   */ DependencyDiscoveryMode[DependencyDiscoveryMode["shallow"] = 1] = "shallow";
    /**
   * Don't use the manifests.json file anywhere, and search every single package.
   */ DependencyDiscoveryMode[DependencyDiscoveryMode["deep"] = 2] = "deep";
    /**
   * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found.
   */ DependencyDiscoveryMode[DependencyDiscoveryMode["deepSparse"] = 3] = "deepSparse";
    /**
   * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found,
   * except for the first project. Always recurse from the first project. This option is useful if it's uncertain
   * whether the first project has been built, but otherwise "deepSparse" is intended behavior.
   */ DependencyDiscoveryMode[DependencyDiscoveryMode["deepSparseIgnoreFirstProject"] = 4] = "deepSparseIgnoreFirstProject";
})(DependencyDiscoveryMode || (DependencyDiscoveryMode = {}));
class CumulativeManifestProcessor {
    /**
   * Ths function:
   *  1. discovers all packages referenced in package.json
   *  2a. looks for a file in each discovered project's temp folder called manifests.json
   *  2b. looks for <id>.manifest.json files in the dist folder
   *  3. keeps a record of all of the manifests discovered in the referenced projects, and resolves duplicates by
   *      taking the newest file
   *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when "gulp serve"
   *      is run from this current project's directory
   *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all
   *      manifests
   *  6. filters this array by the ignoreOutputManifestIds options
   *  7. drops a JSON file in the temp directory called manifests.json containing this array
   *  8. drops an initialization script in the temp directory called manifests.js that
   *      exports two functions. One that returns the array with the manifests' base URLs as fully-qualified, and the
   *      other with manifests' base URLs as relative to the page root.
   */ async generateCumulativeManifestAsync(debugManifests, manifestsJsFileMetadata, discoveryMode) {
        if (!this._options) {
            // TODO: use terminal object for logging
            // eslint-disable-next-line no-console
            console.log('No cumulative manifest options specified. Skipping cumulative manifest generation.');
            return;
        }
        const referencedProjectManifests = this.discoverManifests(this._options.rootPath, discoveryMode ?? 4);
        const flattenedReferences = new Map();
        const computeKey = (id, version)=>`${id}@${version}`;
        const baseUrl = this._options.baseUrl || 'https://localhost:4321'; // Default if one isn't already defined
        const ignoreOutputManifestIds = new Set(this._options.ignoreOutputManifestIds);
        const packageJsonPath = `${this._options.rootPath}/package.json`;
        let currentPackageName;
        if (debugManifests.length > 0 && debugManifests.length <= 2) {
            try {
                const packageJson = _nodecorelibrary.PackageJsonLookup.instance.loadPackageJson(packageJsonPath);
                currentPackageName = packageJson.name;
            } catch (e) {
            /* empty */ }
        }
        // With deepSparseIgnoreFirstProject, we set the local timestamp to the current date.
        // If using cache files, we set it to the constant value TIMESTAMP_LOCALLY_BUILT so that the value is stable.
        const now = discoveryMode === 1 ? TIMESTAMP_LOCALLY_BUILT : Date.now();
        for (const manifest of debugManifests){
            const { id, version } = manifest;
            if (ignoreOutputManifestIds.has(id)) {
                continue;
            }
            const key = computeKey(id, version);
            flattenedReferences.set(key, {
                manifestCreationTime: now,
                manifestData: manifest,
                relativeManifestPath: `${this._options.distFolderName}/${id}.manifest.json`,
                packageName: currentPackageName
            });
        }
        for (const [id, referencedProject] of Object.entries(referencedProjectManifests)){
            if (ignoreOutputManifestIds.has(id)) {
                continue;
            }
            for (const [version, reference] of Object.entries(referencedProject)){
                const key = computeKey(id, version);
                if (flattenedReferences.has(key)) {
                    continue;
                }
                flattenedReferences.set(key, {
                    manifestCreationTime: reference.manifestCreationTime,
                    manifestData: reference.manifestData,
                    relativeManifestPath: _nodecorelibrary.Path.convertToSlashes(_path.relative(this._options.rootPath, reference.manifestPath)),
                    packageName: reference.packageName
                });
            }
        }
        const referencesArray = Array.from(flattenedReferences.values());
        // Write the manifests.json file only if configured to use it.
        if (discoveryMode === 1 || discoveryMode === 0) {
            const cacheFilePath = `${this._options.rootPath}/${this._options.tempFolderName}/${CUMULATIVE_MANIFEST_FILENAME}.json`;
            const newCacheFileBuffer = Buffer.from(JSON.stringify(referencesArray));
            let existingCacheFileBuffer;
            try {
                existingCacheFileBuffer = await _nodecorelibrary.FileSystem.readFileToBufferAsync(cacheFilePath);
            } catch (e) {
                if (_nodecorelibrary.FileSystem.isNotExistError(e)) {
                // This is fine, it just means the file doesn't exist yet
                }
            }
            // Only write the manifests.json file if the content has changed.
            // This is relevant when running under build orchestrators that cache the files
            if (!existingCacheFileBuffer?.equals(newCacheFileBuffer)) {
                await _nodecorelibrary.FileSystem.writeFileAsync(cacheFilePath, newCacheFileBuffer, {
                    ensureFolderExists: true
                });
            }
        }
        const manifestsArray = Array.from(flattenedReferences.values(), (reference)=>{
            const relativePath = _path.dirname(reference.relativeManifestPath);
            const { manifestData } = reference;
            const { loaderConfig } = manifestData;
            const manifest = {
                ...manifestData,
                loaderConfig: {
                    ...loaderConfig,
                    internalModuleBaseUrls: loaderConfig.internalModuleBaseUrls?.slice() ?? []
                }
            };
            // WARNING: This currently mutates the manifest object, hence the copy above
            _ManifestUrlProcessor.ManifestUrlProcessor.processInternalModuleBaseUrls(manifest, relativePath, baseUrl);
            return manifest;
        });
        await (0, _ManifestsFileBuilder.buildManifestsJsAsync)(manifestsArray, `${this._options.rootPath}/${this._options.tempFolderName}/${CUMULATIVE_MANIFEST_FILENAME}.js`, undefined, manifestsJsFileMetadata);
    }
    reset() {
        this._discoveryCache.clear();
    }
    discoverManifests(packagePath, forceSearchMode, options = {}) {
        const { projectTargetFolder = this._options.distFolderName || 'dist', manifestFileRegex = /^[^\.\\\/]+\.manifest\.json$/, preserveSymlinks = true } = options;
        const optionsToUse = {
            ...options,
            projectTargetFolder,
            manifestFileRegex,
            preserveSymlinks
        };
        return this._discoverManifestsInner(packagePath, forceSearchMode, optionsToUse, false);
    }
    _discoverManifestsInner(packagePath, forceSearchMode, options, canSkipPackage) {
        const { projectTargetFolder, manifestFileRegex, preserveSymlinks } = options;
        const resolvedPackagePath = _nodecorelibrary.FileSystem.getRealPath(packagePath);
        if (preserveSymlinks === false) {
            packagePath = resolvedPackagePath;
        }
        let cache = this._discoveryCache.get(forceSearchMode);
        const cacheResult = cache?.get(resolvedPackagePath);
        if (cacheResult) {
            return cacheResult;
        }
        if (!cache) {
            cache = new Map();
            this._discoveryCache.set(forceSearchMode, cache);
        }
        const referencedProjectManifests = {};
        const tempPath = `${packagePath}/${this._options.tempFolderName || _constants.DEFAULT_TEMP_FOLDER}`;
        const targetFolderPath = `${packagePath}/${projectTargetFolder}`;
        const packageJsonPath = `${packagePath}/package.json`;
        let linkedProjectManifests = undefined;
        let foundCumulativeManifestsFile = false;
        if (forceSearchMode === 0) {
            try {
                const manifestMapPath = `${tempPath}/${CUMULATIVE_MANIFEST_FILENAME}.json`;
                const manifestsJson = _nodecorelibrary.FileSystem.readFile(manifestMapPath);
                // This file is machine-generated, so use JSON.parse instead of JsonFile.load for performance
                const manifestReferences = JSON.parse(manifestsJson);
                for (const reference of manifestReferences){
                    const { manifestData } = reference;
                    const isAssembly = !!manifestData.rootComponentId;
                    if (!isAssembly || this._options.includeAssemblies || this._options.explicitInclude.includes(manifestData.id)) {
                        // Since the manifests.json file aggregates manifests from other sources, it needs to track
                        // the creation time of each referenced manifest individually.
                        const { relativeManifestPath, manifestCreationTime } = reference;
                        // If the relative path walks up the folder tree, need to evaluate relative to the real package path.
                        // This scenario arises when using symlinked external npm packages.
                        const preferredPackagePath = relativeManifestPath.startsWith('../') ? resolvedPackagePath : packagePath;
                        this._insertManifestIntoMap(referencedProjectManifests, _path.join(preferredPackagePath, relativeManifestPath), reference.packageName ?? '', manifestCreationTime, manifestData, isAssembly);
                    }
                    foundCumulativeManifestsFile = true;
                }
            } catch (e) {
                this._options.terminal.writeVerboseLine(`Unable to get "manifests.json" file for project in "${packagePath}". We'll ` + 'try to get each manifest separately');
            }
        }
        // If we didn't find a manifests.json file, we should look for individual <id>.manifest.json files.
        if (!foundCumulativeManifestsFile) {
            linkedProjectManifests = [];
            // Look for files called something like "abc123.manifest.json" without any leading slashes or extra periods
            try {
                for (const targetFilename of _nodecorelibrary.FileSystem.readFolderItemNames(targetFolderPath)){
                    if (targetFilename.match(manifestFileRegex)) {
                        const targetFilePath = `${targetFolderPath}/${targetFilename}`;
                        try {
                            const fileStats = _nodecorelibrary.FileSystem.getStatistics(targetFilePath);
                            // Use JsonFile.load to allow comments in JSON.
                            // However, need Object.prototype for some parts of the code to work, hence the cloneDeep call.
                            const manifestData = (0, _lodash.cloneDeep)(_nodecorelibrary.JsonFile.load(targetFilePath));
                            if (this._options.ignoreNonSpfxManifests) {
                                // Ensure that some expected values exist. Validating against the real schema is
                                // unnecessarily complex
                                if (!manifestData.id) {
                                    continue;
                                }
                                if (manifestData.manifestVersion === 2) {
                                    if (!manifestData.loaderConfig) {
                                        continue;
                                    }
                                } else if (manifestData.manifestVersion === 1) {
                                    if (!manifestData.versions) {
                                        continue;
                                    }
                                }
                            }
                            // When forcing usage of the manifests.json file, a project without a manifests.json file is assumed older
                            // So we set its timestamp to the constant value TIMESTAMP_EXTERNAL so that locally built projects will win.
                            // The value is constant so that the file content is stable across builds.
                            const manifestCreationTime = forceSearchMode === 0 ? TIMESTAMP_EXTERNAL : fileStats.mtime.getTime();
                            linkedProjectManifests.push({
                                manifestCreationTime,
                                manifestData: manifestData,
                                manifestPath: targetFilePath
                            });
                        } catch (e) {
                            this._options.terminal.writeErrorLine(`Unable to process manifest file at "${targetFilePath}", ${e}`);
                        }
                    }
                }
            } catch (e) {
            /* Error getting manifest file data */ }
            if (forceSearchMode === 2 || forceSearchMode === 4 || forceSearchMode === 1 || linkedProjectManifests.length > 0) {
                // If this project has manifests, or we're forcing search, let's look in its references in other projects
                const packages = new Map();
                const packageJson = _nodecorelibrary.PackageJsonLookup.instance.loadPackageJson(`${packagePath}/package.json`);
                if (!canSkipPackage || !packageJson.skipInDependencyScan) {
                    const getPackages = (refs, optional)=>{
                        if (refs) {
                            for (const packageName of Object.keys(refs)){
                                packages.set(packageName, optional);
                            }
                        }
                    };
                    getPackages(packageJson.dependencies, false);
                    getPackages(packageJson.devDependencies, true);
                    getPackages(packageJson.optionalDependencies, true);
                    const recursiveForceSearchMode = forceSearchMode === 1 ? 0 : forceSearchMode === 4 ? 3 : forceSearchMode;
                    // Search each referenced project for manifests
                    for (const [packageName, optional] of packages){
                        let referencedPackagePath;
                        try {
                            // First, try to resolve the package. Don't resolve symlinks under the assumption that
                            // the dependency a monorepo-linked project. If it is a project in the same Rush monorepo,
                            // this will resolve correctly and will return a path under the project being built.
                            //
                            // The resolved package path should be the path under the project being built, in the cae of
                            // a monorepo-linked project because `heft start` serves the project root and
                            // provides monorepo-linked projects in the `manifests.js` file. The paths to these
                            // projects must be relative to the folder being served. If the package root was
                            // realpathed, transitive dependencies inside the monorepo would be resolved outside
                            // of the project root and could not be accessed by the browser.
                            referencedPackagePath = this._resolvePackage(packageName, packagePath, false);
                        } catch (e) {
                            try {
                                // Try again, this time resolving symlinks.
                                referencedPackagePath = this._resolvePackage(packageName, packagePath, true);
                            } catch (f) {
                                if (!optional) {
                                    // Only warn if this isn't an optional package
                                    this._options.terminal.writeWarningLine(`Unable to resolve project "${packageName}". Ensure it has been linked.`);
                                }
                            }
                        }
                        if (referencedPackagePath) {
                            const manifests = this._discoverManifestsInner(referencedPackagePath, recursiveForceSearchMode, options, true);
                            for (const [manifestId, manifestVersions] of Object.entries(manifests)){
                                const existingVersions = referencedProjectManifests[manifestId] ?? (referencedProjectManifests[manifestId] = {});
                                for (const [version, manifest] of Object.entries(manifestVersions)){
                                    const existingVersion = existingVersions[version];
                                    // When pulling the same manifest from different sources, we want the newest reference to the given version.
                                    if (!existingVersion?.manifestCreationTime || existingVersion.manifestCreationTime < manifest.manifestCreationTime) {
                                        existingVersions[version] = manifest;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            const assemblyIds = new Set();
            // If we found any manifests directly linked to this project, merge them into the manifests discovered in other
            // projects
            if (linkedProjectManifests) {
                let packageName = '';
                const manifestsToFilter = new Set();
                // Include the package name if we found a single project manifest in the target folder
                let isSinglePackage = linkedProjectManifests.length === 1;
                if (!isSinglePackage && linkedProjectManifests.length === 2) {
                    const manifestA = linkedProjectManifests[0].manifestData;
                    const manifestB = linkedProjectManifests[1].manifestData;
                    if (manifestA.id === manifestB.rootComponentId || manifestB.id === manifestA.rootComponentId) {
                        // If we have two manifests, determine if one is the assembly of the other
                        isSinglePackage = true;
                        const assemblyId = manifestB.rootComponentId ? manifestB.id : manifestA.id;
                        assemblyIds.add(assemblyId);
                        if (!this._options.includeAssemblies && this._options.explicitInclude.indexOf(assemblyId) === -1) {
                            // We want to filter the assemblies manifest because we never want an assembly's ID to be a dependency
                            manifestsToFilter.add(assemblyId);
                        }
                    }
                }
                if (isSinglePackage) {
                    try {
                        // Package.json must always be strict JSON, so use require instead o JsonFile.load for performance.
                        // Allow use of the require cache across separate invocations.
                        const packageJson = require(packageJsonPath);
                        packageName = packageJson.name;
                    } catch (e) {
                    /* empty */ }
                }
                for (const manifest of linkedProjectManifests){
                    const manifestData = manifest.manifestData;
                    if (!manifestsToFilter.has(manifestData.id)) {
                        const id = manifestData.id;
                        const componentManifest = manifestData;
                        const multiversionManifest = manifestData;
                        const isAssembly = assemblyIds.has(id);
                        const { manifestCreationTime, manifestPath } = manifest;
                        if (componentManifest.version) {
                            // Single-version manifest
                            this._insertManifestIntoMap(referencedProjectManifests, manifestPath, packageName, manifestCreationTime, componentManifest, isAssembly);
                        } else if (multiversionManifest.versions) {
                            // Multiversion manifest
                            for (const versionManifest of Object.values(multiversionManifest.versions)){
                                this._insertManifestIntoMap(referencedProjectManifests, manifestPath, packageName, manifestCreationTime, versionManifest, isAssembly);
                            }
                        } else {
                            throw new Error(`Invalid manifest with id "${id}" in ${packagePath}.`);
                        }
                    }
                }
            }
        }
        cache.set(resolvedPackagePath, referencedProjectManifests);
        return referencedProjectManifests;
    }
    _insertManifestIntoMap(referencedProjectManifests, manifestPath, packageName, manifestCreationTime, manifest, isAssembly) {
        const id = manifest.id;
        const version = manifest.version;
        const existingVersions = referencedProjectManifests[id] ?? (referencedProjectManifests[id] = {});
        manifest = this._doTemporaryManifestFixups(manifest);
        const existingReference = existingVersions[version];
        // We always want the most recently generated entry for a given manifest id and version
        if (!existingReference?.manifestCreationTime || existingReference.manifestCreationTime < manifestCreationTime) {
            existingVersions[version] = {
                manifestCreationTime,
                id: manifest.id,
                version: version,
                manifestPath: manifestPath,
                packageName: packageName,
                manifestData: manifest,
                isAssembly: isAssembly
            };
        }
    }
    _doTemporaryManifestFixups(manifestData) {
        function trimLeadingDist() {
            const DIST_SLASH = 'dist/';
            const { loaderConfig } = manifestData;
            const { scriptResources, entryModuleId } = loaderConfig;
            const entryModule = {
                ...scriptResources[entryModuleId]
            };
            manifestData = {
                ...manifestData,
                loaderConfig: {
                    ...loaderConfig,
                    scriptResources: {
                        ...scriptResources,
                        [entryModuleId]: entryModule
                    }
                }
            };
            if (entryModule.type !== 'path') {
                throw new Error('Expected to find path module type');
            } else {
                let pathStr;
                let isIntegrityPath;
                if (typeof entryModule.path === 'string') {
                    pathStr = entryModule.path;
                    isIntegrityPath = false;
                } else {
                    pathStr = entryModule.path.path;
                    isIntegrityPath = true;
                }
                if (pathStr.startsWith(DIST_SLASH)) {
                    pathStr = pathStr.substr(DIST_SLASH.length);
                    if (isIntegrityPath) {
                        entryModule.path.path = pathStr;
                    } else {
                        entryModule.path = pathStr;
                    }
                }
            }
        }
        switch(manifestData.id){
            case '229b8d08-79f3-438b-8c21-4613fc877abd':
                trimLeadingDist();
        }
        return manifestData;
    }
    _resolvePackage(packageName, rootPath, resolveSymlinks) {
        // This is inspired by the "resolvePackage" function in
        // https://github.com/microsoft/rushstack/blob/master/libraries/node-core-library/src/Import.ts, except that
        // it adds support for not resolving symlinks
        let normalizedRootPath = resolveSymlinks ? _nodecorelibrary.FileSystem.getRealPath(rootPath) : rootPath;
        normalizedRootPath = _nodecorelibrary.PackageJsonLookup.instance.tryGetPackageFolderFor(normalizedRootPath) || normalizedRootPath;
        // Append a slash to the package name to ensure `Resolve.sync` doesn't attempt to return a system package
        const normalizedPackageName = `${packageName}/`;
        try {
            return _path.dirname(_resolve.sync(normalizedPackageName, {
                basedir: normalizedRootPath,
                packageFilter: (pkg)=>{
                    // Hardwire "main" to point to a file that is guaranteed to exist.
                    // This helps resolve packages such as @types/node that have no entry point.
                    // And then we can use path.dirname() below to locate the package folder,
                    // even if the real entry point was in an subfolder with arbitrary nesting.
                    pkg.main = 'package.json';
                    return pkg;
                }
            }));
        } catch (e1) {
            try {
                // If we fail, see if we're trying to resolve to the current package
                const currentPackageJson = _nodecorelibrary.PackageJsonLookup.instance.loadPackageJson(`${normalizedRootPath}/package.json`);
                if (currentPackageJson.name === packageName) {
                    return normalizedRootPath;
                } else {
                    throw e1;
                }
            } catch (e2) {
                throw e1;
            }
        }
    }
    constructor(options){
        _define_property(this, "_options", void 0);
        _define_property(this, "_discoveryCache", void 0);
        this._options = {
            includeAssemblies: false,
            ignoreNonSpfxManifests: false,
            ignoreOutputManifestIds: [],
            explicitInclude: [],
            ...options
        };
        this._discoveryCache = new Map();
    }
}

//#sourceMappingUrl=./CumulativeManifestProcessor.js.map