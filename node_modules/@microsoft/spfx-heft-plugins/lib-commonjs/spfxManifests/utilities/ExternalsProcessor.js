// This class does not really belong in this package.
// TODO: Move this class to a different package.
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getNonStandardExternals: function() {
        return getNonStandardExternals;
    },
    getVersionFromPackageJson: function() {
        return getVersionFromPackageJson;
    },
    includeNonStandardExternal: function() {
        return includeNonStandardExternal;
    }
});
const _path = /*#__PURE__*/ _interop_require_wildcard(require("path"));
const _nodecorelibrary = require("@rushstack/node-core-library");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
let _nonStandardExternalMapIsInitialized = false;
const _nonStandardExternalMap = new Map([
    [
        'react',
        {
            name: 'react',
            version: undefined,
            id: '0d910c1c-13b9-4e1c-9aa4-b008c5e42d7d',
            getFailoverPath: (packageRoot)=>_path.join(packageRoot, 'index.js'),
            getVersion: getVersionFromPackageJson('react')
        }
    ],
    [
        'react-dom',
        {
            name: 'react-dom',
            version: undefined,
            id: 'aa0a46ec-1505-43cd-a44a-93f3a5aa460a',
            getFailoverPath: (packageRoot)=>_path.join(packageRoot, 'index.js'),
            getVersion: getVersionFromPackageJson('react-dom')
        }
    ],
    [
        '@microsoft/microsoft-graph-client',
        {
            name: '@microsoft/microsoft-graph-client',
            version: undefined,
            id: '32b9363b-09ff-4959-929a-cab2663fb223',
            getFailoverPath: (packageRoot)=>`${packageRoot}/lib/index.js`,
            getVersion: getVersionFromPackageJson('@microsoft/microsoft-graph-client')
        }
    ]
]);
function includeNonStandardExternal(name, external) {
    if (_nonStandardExternalMapIsInitialized) {
        throw new Error("The non-standard external map has already been initialized, which means it's probably already " + 'been used. Adding an additional non-standard external is likely to not have any effect.');
    }
    _nonStandardExternalMap.set(name, external);
}
function getNonStandardExternals(projectRootPath, referencedProjects) {
    const result = new Map();
    _initializeNonStandardExternalMap(projectRootPath, referencedProjects);
    for (const [dependencyName, dependency] of _nonStandardExternalMap){
        _tryFillFailoverPath(projectRootPath, dependency);
        result.set(dependencyName, dependency);
    }
    return result;
}
function _initializeNonStandardExternalMap(projectRootPath, referencedProjects) {
    if (!_nonStandardExternalMapIsInitialized) {
        for (const project of _nonStandardExternalMap.values()){
            project.version = project.getVersion?.(projectRootPath, referencedProjects);
        }
        _nonStandardExternalMapIsInitialized = true;
    }
}
function getVersionFromPackageJson(packageName) {
    return (projectRootPath)=>{
        try {
            const resolvedPath = _nodecorelibrary.Import.resolvePackage({
                packageName: packageName,
                baseFolderPath: projectRootPath
            });
            if (resolvedPath) {
                const packageJson = _nodecorelibrary.PackageJsonLookup.instance.loadPackageJson(`${resolvedPath}/package.json`);
                const version = packageJson.version;
                const matches = version.match(/([^-]*)(?:.*)/);
                const matchIndex = 1;
                if (!matches || matches.length < matchIndex + 1) {
                    return undefined;
                }
                return matches[matchIndex];
            }
        } catch (e) {
            return undefined;
        }
    };
}
function _tryFillFailoverPath(projectRootPath, dependency) {
    if (!dependency.failoverPath && dependency.getFailoverPath) {
        try {
            const resolvedPath = _nodecorelibrary.Import.resolvePackage({
                packageName: dependency.name,
                baseFolderPath: projectRootPath
            });
            dependency.failoverPath = dependency.getFailoverPath(resolvedPath);
        } catch (e) {
        /* no-op */ }
    }
}

//#sourceMappingUrl=./ExternalsProcessor.js.map