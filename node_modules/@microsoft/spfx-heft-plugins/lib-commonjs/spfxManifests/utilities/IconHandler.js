"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    IconHandler: function() {
        return IconHandler;
    },
    IconPathType: function() {
        return IconPathType;
    }
});
const _nodecorelibrary = require("@rushstack/node-core-library");
const _path = /*#__PURE__*/ _interop_require_wildcard(require("path"));
const _getFullHash = require("./getFullHash");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
var IconPathType;
(function(IconPathType) {
    /**
   * Something that doesn't fit into another category. A warning will be printed.
   */ IconPathType[IconPathType["Malformed"] = 0] = "Malformed";
    /**
   * An absolute URL. Something that begins with a protocol (i.e. - http://...).
   */ IconPathType[IconPathType["AbsoluteUrl"] = 1] = "AbsoluteUrl";
    /**
   * A relative URL. Something that begins with an alphanumeric character, but doesn't look like a protocol.
   */ IconPathType[IconPathType["RelativeUrl"] = 2] = "RelativeUrl";
    /**
   * A relative filesystem path. Something that begins with "./" or "../"
   */ IconPathType[IconPathType["RelativePath"] = 3] = "RelativePath";
    /**
   * A data:image;... url
   */ IconPathType[IconPathType["DataUrl"] = 4] = "DataUrl";
})(IconPathType || (IconPathType = {}));
class IconHandler {
    static getIconPathType(iconPath) {
        if (!iconPath) {
            return undefined;
        } else if (iconPath.match(/^\.{1,2}\/.+/)) {
            return 3;
        } else if (iconPath.match(/^data:image\/.+/)) {
            return 4;
        } else if (iconPath.match(/^\w+:\/\/.+/)) {
            return 1;
        } else if (iconPath.match(/^\w+/)) {
            return 2;
        } else {
            return 0;
        }
    }
    static processIconPath(terminal, compilation, manifestPath, iconPath) {
        const iconPathType = IconHandler.getIconPathType(iconPath);
        const { WebpackError, sources: { RawSource } } = compilation.compiler.webpack;
        switch(iconPathType){
            case 3:
                {
                    const iconAbsolutePath = _path.resolve(_path.dirname(manifestPath), iconPath || '');
                    terminal.writeVerboseLine(`Found relative icon path "${iconPath}", resolved to "${iconAbsolutePath}"`);
                    if (!_nodecorelibrary.FileSystem.exists(iconAbsolutePath)) {
                        compilation.errors.push(new WebpackError(`Icon file missing from resolved path "${iconAbsolutePath}". The manifest icon will be missing.`));
                        return undefined;
                    } else {
                        const ext = _path.extname(iconAbsolutePath);
                        const iconBaseName = _path.basename(iconAbsolutePath, ext);
                        const iconContent = _nodecorelibrary.FileSystem.readFileToBuffer(iconAbsolutePath);
                        const hash = (0, _getFullHash.getFullHash)(iconContent, compilation.outputOptions.hashSalt);
                        const iconFilename = `${iconBaseName}_${hash}${ext}`;
                        compilation.fileDependencies.add(iconAbsolutePath);
                        compilation.assets[iconFilename] = new RawSource(iconContent);
                        return iconFilename;
                    }
                }
            case 1:
                {
                    terminal.writeVerboseLine(`Found absolute icon URL "${iconPath}"`);
                    break;
                }
            case 4:
                {
                    terminal.writeVerboseLine(`Found data:image icon URL "${iconPath}"`);
                    break;
                }
            case 2:
                {
                    compilation.warnings.push(new WebpackError(`The icon path "${iconPath}" appears to be a relative web URL. This means that when the ` + 'icon is rendered, this URL will be relative to the CDN url for the rest of the package assets. If a ' + 'relative filesystem path was intended, prepend the path with "./".'));
                    break;
                }
            case undefined:
                {
                    break;
                }
            default:
                {
                    compilation.warnings.push(new WebpackError(`The icon path "${iconPath}" appears to be malformed. The icon may not render as expected.`));
                    break;
                }
        }
        return iconPath;
    }
}

//#sourceMappingUrl=./IconHandler.js.map