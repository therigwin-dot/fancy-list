/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  buildManifestsJs: () => (/* binding */ buildManifestsJs)
});

;// external "@rushstack/node-core-library/lib/FileSystem"
const FileSystem_namespaceObject = require("@rushstack/node-core-library/lib/FileSystem");
;// external "path"
const external_path_namespaceObject = require("path");
var external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_namespaceObject);
;// ./lib-esm/manifests-file-bundled/bundled.js?raw
const bundledraw_namespaceObject = "(()=>{\"use strict\";var e={};e.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(e){if(\"object\"==typeof window)return window}}(),(()=>{var t;e.g.importScripts&&(t=e.g.location+\"\");var n=e.g.document;if(!t&&n&&(n.currentScript&&\"SCRIPT\"===n.currentScript.tagName.toUpperCase()&&(t=n.currentScript.src),!t)){var a=n.getElementsByTagName(\"script\");if(a.length)for(var i=a.length-1;i>-1&&(!t||!/^http(s?):/.test(t));)t=a[i--].src}if(!t)throw new Error(\"Automatic publicPath is not supported in this browser\");t=t.replace(/#.*$/,\"\").replace(/\\?.*$/,\"\").replace(/\\/[^\\/]+$/,\"/\"),e.p=t})();const t=MANIFESTS_ARRAY_PROXY;function n(e){e=e.replace(/[\\[]/,\"\\\\[\").replace(/[\\]]/,\"\\\\]\");const t=new RegExp(\"[\\\\?&]\"+e+\"=([^&#]*)\").exec(window.location.search);return null===t?\"\":decodeURIComponent(t[1].replace(/\\+/g,\" \"))}const a={_metadata:MANIFESTS_FILE_METADATA,getManifests:function(){const a=JSON.parse(JSON.stringify(t),function(e,t){if(\"paths\"===e){const e=t,n={};for(const[t,a]of Object.entries(e.l)){let i,r,o,s=!1;\"string\"==typeof a?r=a:(s=!0,[r,o]=a),i=e.p+r+e.s,s&&(i={path:i,integrity:o}),n[t]=i}return n}return t}),i=DEPLOYED_ASSET_PATH_OVERRIDE||e.p;let r=n(\"market\")||n(\"locale\");r&&(r=r.toLowerCase()),i||console.error(`Unable to determine ${MANIFESTS_FILE_NAME} file URL. Using default base URL. This is expected if you are running \"gulp serve.\"`);for(const e of a){const{loaderConfig:t}=e;if(i&&(t.internalModuleBaseUrls&&0!==t.internalModuleBaseUrls.length||(t.internalModuleBaseUrls=[i])),r){const{scriptResources:e}=t;for(const t of Object.keys(e)){const n=e[t];if(\"localizedPath\"===n.type){const e=n,{paths:t}=e;if(t)for(const n of Object.keys(t))if(n.toLowerCase()===r){e.defaultPath=t[n],delete e.paths;break}}}}}return a}};self.debugManifests=a,define([],()=>a)})();";
;// ./lib-esm/ManifestsFileBuilder.js



async function buildManifestsJs(options) {
    const { manifestsArray, outputFilePath, azurePathOverride, manifestsJsFileMetadata, stripOutIntegrities } = options;
    const formattedManifests = JSON.stringify(manifestsArray, getManifestCompressor(stripOutIntegrities));
    const outputFileName = external_path_default().basename(outputFilePath);
    const filledTemplate = bundledraw_namespaceObject.replace(/MANIFESTS_ARRAY_PROXY/g, formattedManifests).replace(/DEPLOYED_ASSET_PATH_OVERRIDE/g, JSON.stringify(azurePathOverride || '')).replace(/MANIFESTS_FILE_METADATA/g, manifestsJsFileMetadata ? JSON.stringify(manifestsJsFileMetadata) : 'undefined').replace(/MANIFESTS_FILE_NAME/g, JSON.stringify(outputFileName));
    // Write the manifest file
    await FileSystem_namespaceObject.FileSystem.writeFileAsync(outputFilePath, filledTemplate, {
        ensureFolderExists: true
    });
}
function getManifestCompressor(stripOutIntegrities) {
    return (key, value)=>{
        switch(key){
            case 'path':
                {
                    return stripOutIntegrities ? stripOutIntegrity(value) : value;
                }
            case 'paths':
                {
                    // Compress path mapping as prefix, localized, suffix
                    const entries = Object.entries(value);
                    // Empty object, short-circuit
                    if (entries.length === 0) {
                        return value;
                    }
                    let prefix = stripOutIntegrity(entries[0][1]);
                    let suffix = prefix;
                    // Iterate once to find the maximum shared prefix and shared suffix
                    for (const [, localizedPath] of entries){
                        const normalizedLocalizedPath = stripOutIntegrity(localizedPath);
                        while(prefix && !normalizedLocalizedPath.startsWith(prefix)){
                            prefix = prefix.slice(0, -1);
                        }
                        while(suffix && !normalizedLocalizedPath.endsWith(suffix)){
                            suffix = suffix.slice(1);
                        }
                    }
                    const localized = {};
                    for (const [locale, localizedPathFromManifest] of entries){
                        let processedEntry;
                        if (typeof localizedPathFromManifest === 'string') {
                            processedEntry = localizedPathFromManifest.slice(prefix.length, -suffix.length);
                        } else {
                            processedEntry = localizedPathFromManifest.path.slice(prefix.length, -suffix.length);
                            if (localizedPathFromManifest.integrity !== undefined && !stripOutIntegrities) {
                                processedEntry = [
                                    processedEntry,
                                    localizedPathFromManifest.integrity
                                ];
                            } else {
                                processedEntry = [
                                    processedEntry
                                ];
                            }
                        }
                        localized[locale] = processedEntry;
                    }
                    const newPathsObj = {
                        p: prefix,
                        l: localized,
                        s: suffix
                    };
                    return newPathsObj;
                }
            default:
                {
                    return value;
                }
        }
    };
}
function stripOutIntegrity(p) {
    return typeof p === 'string' ? p : p.path;
}

//#sourceMappingUrl=./ManifestsFileBuilder.js.map
module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=ManifestsFileBuilder.js.map