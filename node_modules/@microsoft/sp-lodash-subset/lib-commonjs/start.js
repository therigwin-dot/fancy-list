"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "runAsync", {
    enumerable: true,
    get: function() {
        return runAsync;
    }
});
const _crypto = /*#__PURE__*/ _interop_require_default(require("crypto"));
const _nodecorelibrary = require("@rushstack/node-core-library");
const _spfxheftplugins = require("@microsoft/spfx-heft-plugins");
const _spfxinternalheftplugins = require("@ms/spfx-internal-heft-plugins");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const PROJECT_NAME = 'sp-lodash-subset';
async function runAsync(options) {
    const { heftTaskSession, heftConfiguration } = options;
    const { logger } = heftTaskSession;
    try {
        const lodashEntries = await _nodecorelibrary.JsonFile.loadAsync(`${heftConfiguration.buildFolderPath}/config/lodash-entries.json`);
        const manifest = await _nodecorelibrary.JsonFile.loadAsync(`${heftConfiguration.buildFolderPath}/src/sp-lodash-subset.manifest.json`);
        // Drop the prerelease from the manifest version
        const simplifiedVersion = heftConfiguration.projectPackageJson.version.split('-')[0];
        manifest.version = simplifiedVersion;
        const bundleId = _spfxheftplugins.WebpackConfigurationGenerator.getComponentBundleId(manifest);
        const wrapperCode = [
            `define("${bundleId}", [], function() {`,
            '  %output%',
            '',
            // Make lodash an object, not a function
            '  var moduleExports = {};',
            '  lodash.each(Object.keys(lodash), function (key) {',
            '    moduleExports[key] = lodash[key];',
            '  });',
            '  return moduleExports;',
            '})'
        ];
        const lodashCliParameters = [
            `include=${lodashEntries.join(',')}`,
            'strict',
            'exports=none',
            `iife=${wrapperCode.join('\n')}`,
            '--production',
            '--stdout',
            '--source-map' // Adding this option improves minification for some reason
        ];
        const lodashPackagePath = _nodecorelibrary.Import.resolveModule({
            modulePath: 'lodash-cli/bin/lodash',
            baseFolderPath: heftConfiguration.buildFolderPath
        });
        const result = _nodecorelibrary.Executable.spawnSync(process.argv0, [
            lodashPackagePath,
            ...lodashCliParameters
        ]);
        if (result.status !== 0) {
            throw new Error(`lodash-cli exited with code ${result.status}`);
        }
        const compiledOutputLines = result.stdout.split('\n');
        const trimmedLines = [];
        for (const compiledOutputLine of compiledOutputLines){
            if (// Drop the line containing the command
            !compiledOutputLine.match(/^ \* Build: `/) && // Drop the line pointing to the sourcemap
            !compiledOutputLine.match(/^\/\/\# sourceMappingURL/)) {
                trimmedLines.push(compiledOutputLine);
            }
        }
        const compiledOutput = trimmedLines.join('\n');
        const outputHash = _crypto.default.createHash('md5').update(compiledOutput).digest('hex').substring(0, 20);
        const outputFilename = `${PROJECT_NAME}_${outputHash}.js`;
        delete manifest.$schema;
        manifest.loaderConfig = {
            internalModuleBaseUrls: [],
            entryModuleId: PROJECT_NAME,
            scriptResources: {
                [PROJECT_NAME]: {
                    type: 'path',
                    path: outputFilename
                }
            }
        };
        const manifestFilename = `${manifest.id}.manifest.json`;
        const serializedManifest = _nodecorelibrary.JsonFile.stringify(manifest, {
            prettyFormatting: true
        });
        const libIndexJsOutput = [
            'function define(id, deps, fn) {',
            '  module.exports = fn();',
            '}',
            compiledOutput
        ].join('\n');
        const libIndexDTsOutput = [
            ...lodashEntries.map((entry)=>`import ${entry} = require('lodash/${entry}');`),
            '',
            `export { ${lodashEntries.join(', ')} };`,
            `export * from './fixups'`
        ].join('\n');
        const libCjsFolderPath = `${heftConfiguration.buildFolderPath}/lib-commonjs`;
        const libEsmFolderPath = `${heftConfiguration.buildFolderPath}/lib-esm`;
        const libDtsFolderPath = `${heftConfiguration.buildFolderPath}/lib-dts`;
        const distFolderPath = `${heftConfiguration.buildFolderPath}/dist`;
        const releaseFolderPath = `${heftConfiguration.buildFolderPath}/release`;
        const distOutputPath = `${distFolderPath}/${outputFilename}`;
        await Promise.all([
            _nodecorelibrary.FileSystem.writeFileAsync(`${libCjsFolderPath}/index.js`, libIndexJsOutput),
            _nodecorelibrary.FileSystem.writeFileAsync(`${libEsmFolderPath}/index.js`, libIndexJsOutput),
            _nodecorelibrary.FileSystem.writeFileAsync(`${libDtsFolderPath}/index.d.ts`, libIndexDTsOutput),
            _nodecorelibrary.FileSystem.writeFileAsync(distOutputPath, compiledOutput, {
                ensureFolderExists: true
            }),
            _nodecorelibrary.FileSystem.writeFileAsync(`${releaseFolderPath}/assets/${outputFilename}`, compiledOutput, {
                ensureFolderExists: true
            }),
            _nodecorelibrary.FileSystem.writeFileAsync(`${distFolderPath}/${manifestFilename}`, serializedManifest, {
                ensureFolderExists: true
            }),
            _nodecorelibrary.FileSystem.writeFileAsync(`${releaseFolderPath}/${_spfxinternalheftplugins.UpdateWebpackConfigPlugin.deploymentPoolManifestsFolderName}/${manifestFilename}`, serializedManifest, {
                ensureFolderExists: true
            })
        ]);
        const assetSize = await (await _nodecorelibrary.FileSystem.getStatisticsAsync(distOutputPath)).size;
        const sizeAuditData = {
            projectName: PROJECT_NAME,
            chunks: {
                [PROJECT_NAME]: {
                    webpackSize: assetSize,
                    actualSize: assetSize
                }
            },
            assemblies: {}
        };
        await _nodecorelibrary.JsonFile.saveAsync(sizeAuditData, `${releaseFolderPath}/size-audit/${PROJECT_NAME}.json`, {
            ensureFolderExists: true
        });
        logger.terminal.writeLine('Successfully bundled lodash.');
    } catch (e) {
        logger.emitError(e);
        throw e;
    }
}

//#sourceMappingUrl=./start.js.map