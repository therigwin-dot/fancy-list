import crypto from 'crypto';
import { FileSystem, JsonFile, Executable, Import } from '@rushstack/node-core-library';
import { WebpackConfigurationGenerator } from '@microsoft/spfx-heft-plugins';
import { UpdateWebpackConfigPlugin } from '@ms/spfx-internal-heft-plugins';
const PROJECT_NAME = 'sp-lodash-subset';
export async function runAsync(options) {
    const { heftTaskSession, heftConfiguration } = options;
    const { logger } = heftTaskSession;
    try {
        const lodashEntries = await JsonFile.loadAsync(`${heftConfiguration.buildFolderPath}/config/lodash-entries.json`);
        const manifest = await JsonFile.loadAsync(`${heftConfiguration.buildFolderPath}/src/sp-lodash-subset.manifest.json`);
        // Drop the prerelease from the manifest version
        const simplifiedVersion = heftConfiguration.projectPackageJson.version.split('-')[0];
        manifest.version = simplifiedVersion;
        const bundleId = WebpackConfigurationGenerator.getComponentBundleId(manifest);
        const wrapperCode = [
            `define("${bundleId}", [], function() {`,
            '  %output%',
            '',
            // Make lodash an object, not a function
            '  var moduleExports = {};',
            '  lodash.each(Object.keys(lodash), function (key) {',
            '    moduleExports[key] = lodash[key];',
            '  });',
            '  return moduleExports;',
            '})'
        ];
        const lodashCliParameters = [
            `include=${lodashEntries.join(',')}`,
            'strict',
            'exports=none',
            `iife=${wrapperCode.join('\n')}`,
            '--production',
            '--stdout',
            '--source-map' // Adding this option improves minification for some reason
        ];
        const lodashPackagePath = Import.resolveModule({
            modulePath: 'lodash-cli/bin/lodash',
            baseFolderPath: heftConfiguration.buildFolderPath
        });
        const result = Executable.spawnSync(process.argv0, [
            lodashPackagePath,
            ...lodashCliParameters
        ]);
        if (result.status !== 0) {
            throw new Error(`lodash-cli exited with code ${result.status}`);
        }
        const compiledOutputLines = result.stdout.split('\n');
        const trimmedLines = [];
        for (const compiledOutputLine of compiledOutputLines){
            if (// Drop the line containing the command
            !compiledOutputLine.match(/^ \* Build: `/) && // Drop the line pointing to the sourcemap
            !compiledOutputLine.match(/^\/\/\# sourceMappingURL/)) {
                trimmedLines.push(compiledOutputLine);
            }
        }
        const compiledOutput = trimmedLines.join('\n');
        const outputHash = crypto.createHash('md5').update(compiledOutput).digest('hex').substring(0, 20);
        const outputFilename = `${PROJECT_NAME}_${outputHash}.js`;
        delete manifest.$schema;
        manifest.loaderConfig = {
            internalModuleBaseUrls: [],
            entryModuleId: PROJECT_NAME,
            scriptResources: {
                [PROJECT_NAME]: {
                    type: 'path',
                    path: outputFilename
                }
            }
        };
        const manifestFilename = `${manifest.id}.manifest.json`;
        const serializedManifest = JsonFile.stringify(manifest, {
            prettyFormatting: true
        });
        const libIndexJsOutput = [
            'function define(id, deps, fn) {',
            '  module.exports = fn();',
            '}',
            compiledOutput
        ].join('\n');
        const libIndexDTsOutput = [
            ...lodashEntries.map((entry)=>`import ${entry} = require('lodash/${entry}');`),
            '',
            `export { ${lodashEntries.join(', ')} };`,
            `export * from './fixups'`
        ].join('\n');
        const libCjsFolderPath = `${heftConfiguration.buildFolderPath}/lib-commonjs`;
        const libEsmFolderPath = `${heftConfiguration.buildFolderPath}/lib-esm`;
        const libDtsFolderPath = `${heftConfiguration.buildFolderPath}/lib-dts`;
        const distFolderPath = `${heftConfiguration.buildFolderPath}/dist`;
        const releaseFolderPath = `${heftConfiguration.buildFolderPath}/release`;
        const distOutputPath = `${distFolderPath}/${outputFilename}`;
        await Promise.all([
            FileSystem.writeFileAsync(`${libCjsFolderPath}/index.js`, libIndexJsOutput),
            FileSystem.writeFileAsync(`${libEsmFolderPath}/index.js`, libIndexJsOutput),
            FileSystem.writeFileAsync(`${libDtsFolderPath}/index.d.ts`, libIndexDTsOutput),
            FileSystem.writeFileAsync(distOutputPath, compiledOutput, {
                ensureFolderExists: true
            }),
            FileSystem.writeFileAsync(`${releaseFolderPath}/assets/${outputFilename}`, compiledOutput, {
                ensureFolderExists: true
            }),
            FileSystem.writeFileAsync(`${distFolderPath}/${manifestFilename}`, serializedManifest, {
                ensureFolderExists: true
            }),
            FileSystem.writeFileAsync(`${releaseFolderPath}/${UpdateWebpackConfigPlugin.deploymentPoolManifestsFolderName}/${manifestFilename}`, serializedManifest, {
                ensureFolderExists: true
            })
        ]);
        const assetSize = await (await FileSystem.getStatisticsAsync(distOutputPath)).size;
        const sizeAuditData = {
            projectName: PROJECT_NAME,
            chunks: {
                [PROJECT_NAME]: {
                    webpackSize: assetSize,
                    actualSize: assetSize
                }
            },
            assemblies: {}
        };
        await JsonFile.saveAsync(sizeAuditData, `${releaseFolderPath}/size-audit/${PROJECT_NAME}.json`, {
            ensureFolderExists: true
        });
        logger.terminal.writeLine('Successfully bundled lodash.');
    } catch (e) {
        logger.emitError(e);
        throw e;
    }
}

//#sourceMappingUrl=./start.js.map