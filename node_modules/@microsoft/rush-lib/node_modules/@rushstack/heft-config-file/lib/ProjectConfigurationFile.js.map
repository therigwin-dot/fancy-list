{"version":3,"file":"ProjectConfigurationFile.js","sourceRoot":"","sources":["../src/ProjectConfigurationFile.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as nodeJsPath from 'path';\nimport { FileSystem } from '@rushstack/node-core-library';\nimport type { ITerminal } from '@rushstack/terminal';\nimport type { IRigConfig } from '@rushstack/rig-package';\n\nimport { ConfigurationFileBase, type IConfigurationFileOptions } from './ConfigurationFileBase';\n\n/**\n * @beta\n */\nexport interface IProjectConfigurationFileOptions {\n  /**\n   * A project root-relative path to the configuration file that should be loaded.\n   */\n  projectRelativeFilePath: string;\n}\n\n/**\n * @beta\n */\nexport class ProjectConfigurationFile<TConfigurationFile> extends ConfigurationFileBase<\n  TConfigurationFile,\n  IProjectConfigurationFileOptions\n> {\n  /** {@inheritDoc IProjectConfigurationFileOptions.projectRelativeFilePath} */\n  public readonly projectRelativeFilePath: string;\n\n  public constructor(\n    options: IConfigurationFileOptions<TConfigurationFile, IProjectConfigurationFileOptions>\n  ) {\n    super(options);\n    this.projectRelativeFilePath = options.projectRelativeFilePath;\n  }\n\n  /**\n   * Find and return a configuration file for the specified project, automatically resolving\n   * `extends` properties and handling rigged configuration files. Will throw an error if a configuration\n   * file cannot be found in the rig or project config folder.\n   */\n  public loadConfigurationFileForProject(\n    terminal: ITerminal,\n    projectPath: string,\n    rigConfig?: IRigConfig\n  ): TConfigurationFile {\n    const projectConfigurationFilePath: string = this._getConfigurationFilePathForProject(projectPath);\n    return this._loadConfigurationFileInnerWithCache(\n      terminal,\n      projectConfigurationFilePath,\n      new Set<string>(),\n      rigConfig\n    );\n  }\n\n  /**\n   * Find and return a configuration file for the specified project, automatically resolving\n   * `extends` properties and handling rigged configuration files. Will throw an error if a configuration\n   * file cannot be found in the rig or project config folder.\n   */\n  public async loadConfigurationFileForProjectAsync(\n    terminal: ITerminal,\n    projectPath: string,\n    rigConfig?: IRigConfig\n  ): Promise<TConfigurationFile> {\n    const projectConfigurationFilePath: string = this._getConfigurationFilePathForProject(projectPath);\n    return await this._loadConfigurationFileInnerWithCacheAsync(\n      terminal,\n      projectConfigurationFilePath,\n      new Set<string>(),\n      rigConfig\n    );\n  }\n\n  /**\n   * This function is identical to {@link ProjectConfigurationFile.loadConfigurationFileForProject}, except\n   * that it returns `undefined` instead of throwing an error if the configuration file cannot be found.\n   */\n  public tryLoadConfigurationFileForProject(\n    terminal: ITerminal,\n    projectPath: string,\n    rigConfig?: IRigConfig\n  ): TConfigurationFile | undefined {\n    try {\n      return this.loadConfigurationFileForProject(terminal, projectPath, rigConfig);\n    } catch (e) {\n      if (FileSystem.isNotExistError(e as Error)) {\n        return undefined;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * This function is identical to {@link ProjectConfigurationFile.loadConfigurationFileForProjectAsync}, except\n   * that it returns `undefined` instead of throwing an error if the configuration file cannot be found.\n   */\n  public async tryLoadConfigurationFileForProjectAsync(\n    terminal: ITerminal,\n    projectPath: string,\n    rigConfig?: IRigConfig\n  ): Promise<TConfigurationFile | undefined> {\n    try {\n      return await this.loadConfigurationFileForProjectAsync(terminal, projectPath, rigConfig);\n    } catch (e) {\n      if (FileSystem.isNotExistError(e as Error)) {\n        return undefined;\n      }\n      throw e;\n    }\n  }\n\n  protected _tryLoadConfigurationFileInRig(\n    terminal: ITerminal,\n    rigConfig: IRigConfig,\n    visitedConfigurationFilePaths: Set<string>\n  ): TConfigurationFile | undefined {\n    if (rigConfig.rigFound) {\n      const rigProfileFolder: string = rigConfig.getResolvedProfileFolder();\n      try {\n        return this._loadConfigurationFileInnerWithCache(\n          terminal,\n          nodeJsPath.resolve(rigProfileFolder, this.projectRelativeFilePath),\n          visitedConfigurationFilePaths,\n          undefined\n        );\n      } catch (e) {\n        // Ignore cases where a configuration file doesn't exist in a rig\n        if (!FileSystem.isNotExistError(e as Error)) {\n          throw e;\n        } else {\n          terminal.writeDebugLine(\n            `Configuration file \"${\n              this.projectRelativeFilePath\n            }\" not found in rig (\"${ConfigurationFileBase._formatPathForLogging(rigProfileFolder)}\")`\n          );\n        }\n      }\n    } else {\n      terminal.writeDebugLine(\n        `No rig found for \"${ConfigurationFileBase._formatPathForLogging(rigConfig.projectFolderPath)}\"`\n      );\n    }\n\n    return undefined;\n  }\n\n  protected async _tryLoadConfigurationFileInRigAsync(\n    terminal: ITerminal,\n    rigConfig: IRigConfig,\n    visitedConfigurationFilePaths: Set<string>\n  ): Promise<TConfigurationFile | undefined> {\n    if (rigConfig.rigFound) {\n      const rigProfileFolder: string = await rigConfig.getResolvedProfileFolderAsync();\n      try {\n        return await this._loadConfigurationFileInnerWithCacheAsync(\n          terminal,\n          nodeJsPath.resolve(rigProfileFolder, this.projectRelativeFilePath),\n          visitedConfigurationFilePaths,\n          undefined\n        );\n      } catch (e) {\n        // Ignore cases where a configuration file doesn't exist in a rig\n        if (!FileSystem.isNotExistError(e as Error)) {\n          throw e;\n        } else {\n          terminal.writeDebugLine(\n            `Configuration file \"${\n              this.projectRelativeFilePath\n            }\" not found in rig (\"${ConfigurationFileBase._formatPathForLogging(rigProfileFolder)}\")`\n          );\n        }\n      }\n    } else {\n      terminal.writeDebugLine(\n        `No rig found for \"${ConfigurationFileBase._formatPathForLogging(rigConfig.projectFolderPath)}\"`\n      );\n    }\n\n    return undefined;\n  }\n\n  private _getConfigurationFilePathForProject(projectPath: string): string {\n    return nodeJsPath.resolve(projectPath, this.projectRelativeFilePath);\n  }\n}\n"]}