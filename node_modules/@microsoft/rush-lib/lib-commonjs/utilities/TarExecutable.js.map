{"version":3,"file":"TarExecutable.js","sourceRoot":"","sources":["../../src/utilities/TarExecutable.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,2CAA6B;AAC7B,4CAAoB;AACpB,oEAAkF;AAGlF,oDAA4B;AAG5B,8EAA2E;AAiB3E,MAAa,aAAa;IAGxB,YAAoB,iBAAyB;QAC3C,IAAI,CAAC,kBAAkB,GAAG,iBAAiB,CAAC;IAC9C,CAAC;IAEM,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC,QAAmB;QACxD,QAAQ,CAAC,gBAAgB,CAAC,6BAA6B,CAAC,CAAC;QACzD,MAAM,iBAAiB,GACrB,mDAAwB,CAAC,aAAa,IAAI,CAAC,MAAM,aAAa,CAAC,8BAA8B,EAAE,CAAC,CAAC;QACnG,IAAI,CAAC,iBAAiB,EAAE,CAAC;YACvB,QAAQ,CAAC,gBAAgB,CAAC,iCAAiC,CAAC,CAAC;YAC7D,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,OAAO,IAAI,aAAa,CAAC,iBAAiB,CAAC,CAAC;IAC9C,CAAC;IAED;;;OAGG;IACI,KAAK,CAAC,aAAa,CAAC,OAAsB;QAC/C,OAAO,MAAM,IAAI,CAAC,yBAAyB;QACzC,8GAA8G;QAC9G;YACE,gEAAgE;YAChE,IAAI;YACJ,gEAAgE;YAChE,IAAI;YACJ,gFAAgF;YAChF,IAAI;YACJ,OAAO,CAAC,WAAW;SACpB,EACD,OAAO,CAAC,gBAAgB,EACxB,OAAO,CAAC,WAAW,CACpB,CAAC;IACJ,CAAC;IAED;;;OAGG;IACI,KAAK,CAAC,qCAAqC,CAAC,OAA8B;QAC/E,MAAM,EAAE,OAAO,EAAE,WAAW,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,OAAO,CAAC;QAE7D,MAAM,QAAQ,GAAW,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAE1C,+FAA+F;QAC/F,gCAAgC;QAChC,MAAM,8BAAU,CAAC,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC;QAE9D,MAAM,iBAAiB,GAAW,OAAO,CAAC,aAAa,CAAC;QACxD,MAAM,WAAW,GAAW,MAAM,IAAI,CAAC,yBAAyB;QAC9D,8GAA8G;QAC9G;YACE,mCAAmC;YACnC,IAAI;YACJ,gFAAgF;YAChF,IAAI;YACJ,WAAW;YACX,sFAAsF;YACtF,IAAI;YACJ,qFAAqF;YACrF,EAAE;YACF,2EAA2E;YAC3E,gBAAgB;SACjB,EACD,iBAAiB,EACjB,WAAW,EACX,QAAQ,CACT,CAAC;QAEF,OAAO,WAAW,CAAC;IACrB,CAAC;IAEO,KAAK,CAAC,yBAAyB,CACrC,IAAc,EACd,uBAA+B,EAC/B,WAAmB,EACnB,KAAc;QAEd,oFAAoF;QACpF,gCAAgC;QAChC,EAAE;QACF,WAAW;QACX,wEAAwE;QACxE,sGAAsG;QACtG,EAAE;QACF,uCAAuC;QACvC,+BAA+B;QAC/B,+BAA+B;QAC/B,uCAAuC;QACvC,EAAE;QACF,uBAAuB;QACvB,EAAE;QACF,SAAS;QACT,wEAAwE;QACxE,+FAA+F;QAC/F,EAAE;QACF,uCAAuC;QACvC,+BAA+B;QAC/B,+BAA+B;QAC/B,uCAAuC;QACvC,EAAE;QACF,uBAAuB;QAEvB,MAAM,8BAAU,CAAC,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC;QAC9D,MAAM,UAAU,GAAe,8BAAU,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC5D,UAAU,CAAC,KAAK,CACd;YACE,eAAe,IAAI,IAAI,EAAE,CAAC,QAAQ,EAAE,EAAE;YACtC,aAAa,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;YACzD,EAAE;YACF,oCAAoC;YACpC,KAAK,IAAI,EAAE;YACX,oCAAoC;YACpC,sCAAsC;YACtC,EAAE;SACH,CAAC,IAAI,CAAC,IAAI,CAAC,CACb,CAAC;QAEF,MAAM,YAAY,GAAiB,8BAAU,CAAC,KAAK,CAAC,IAAI,CAAC,kBAAkB,EAAE,IAAI,EAAE;YACjF,uBAAuB,EAAE,uBAAuB;SACjD,CAAC,CAAC;QAEH,YAAY,CAAC,MAAO,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,YAAY,KAAK,EAAE,CAAC,CAAC,CAAC;QAClF,YAAY,CAAC,MAAO,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,YAAY,KAAK,EAAE,CAAC,CAAC,CAAC;QAElF,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACxB,YAAY,CAAC,KAAM,CAAC,KAAK,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YAC1C,YAAY,CAAC,KAAM,CAAC,GAAG,EAAE,CAAC;QAC5B,CAAC;QAED,oDAAoD;QACpD,MAAM,CAAC,WAAW,CAAC,GAAG,MAAM,gBAAM,CAAC,IAAI,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;QAE/D,UAAU,CAAC,KAAK,CACd,CAAC,sCAAsC,EAAE,EAAE,EAAE,qBAAqB,WAAW,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAC7F,CAAC;QACF,UAAU,CAAC,KAAK,EAAE,CAAC;QAEnB,OAAO,WAAW,CAAC;IACrB,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,8BAA8B;QACjD,IAAI,YAAE,CAAC,QAAQ,EAAE,KAAK,OAAO,EAAE,CAAC;YAC9B,2EAA2E;YAC3E,+EAA+E;YAC/E,gCAAgC;YAChC,wCAAwC;YACxC,MAAM,iBAAiB,GAAuB,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YACpE,IAAI,iBAAiB,EAAE,CAAC;gBACtB,MAAM,+BAA+B,GAAW,GAAG,iBAAiB,qBAAqB,CAAC;gBAC1F,IAAI,MAAM,8BAAU,CAAC,WAAW,CAAC,+BAA+B,CAAC,EAAE,CAAC;oBAClE,OAAO,+BAA+B,CAAC;gBACzC,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO,8BAAU,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;CACF;AAnKD,sCAmKC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport os from 'os';\nimport { Executable, FileSystem, FileWriter } from '@rushstack/node-core-library';\nimport type { ITerminal } from '@rushstack/terminal';\nimport type { ChildProcess } from 'child_process';\nimport events from 'events';\n\nimport type { RushConfigurationProject } from '../api/RushConfigurationProject';\nimport { EnvironmentConfiguration } from '../api/EnvironmentConfiguration';\n\nexport interface ITarOptionsBase {\n  logFilePath: string;\n}\n\nexport interface IUntarOptions extends ITarOptionsBase {\n  archivePath: string;\n  outputFolderPath: string;\n}\n\nexport interface ICreateArchiveOptions extends ITarOptionsBase {\n  archivePath: string;\n  paths: string[];\n  project: RushConfigurationProject;\n}\n\nexport class TarExecutable {\n  private _tarExecutablePath: string;\n\n  private constructor(tarExecutablePath: string) {\n    this._tarExecutablePath = tarExecutablePath;\n  }\n\n  public static async tryInitializeAsync(terminal: ITerminal): Promise<TarExecutable | undefined> {\n    terminal.writeVerboseLine('Trying to find \"tar\" binary');\n    const tarExecutablePath: string | undefined =\n      EnvironmentConfiguration.tarBinaryPath || (await TarExecutable._tryFindTarExecutablePathAsync());\n    if (!tarExecutablePath) {\n      terminal.writeVerboseLine('\"tar\" was not found on the PATH');\n      return undefined;\n    }\n\n    return new TarExecutable(tarExecutablePath);\n  }\n\n  /**\n   * @returns\n   * The \"tar\" exit code\n   */\n  public async tryUntarAsync(options: IUntarOptions): Promise<number> {\n    return await this._spawnTarWithLoggingAsync(\n      // These parameters are chosen for compatibility with the very primitive bsdtar 3.3.2 shipped with Windows 10.\n      [\n        // [Windows bsdtar 3.3.2] Extract: tar -x [options] [<patterns>]\n        '-x',\n        // [Windows bsdtar 3.3.2] -m    Don't restore modification times\n        '-m',\n        // [Windows bsdtar 3.3.2] -f <filename>  Location of archive (default \\\\.\\tape0)\n        '-f',\n        options.archivePath\n      ],\n      options.outputFolderPath,\n      options.logFilePath\n    );\n  }\n\n  /**\n   * @returns\n   * The \"tar\" exit code\n   */\n  public async tryCreateArchiveFromProjectPathsAsync(options: ICreateArchiveOptions): Promise<number> {\n    const { project, archivePath, paths, logFilePath } = options;\n\n    const tarInput: string = paths.join('\\n');\n\n    // On Windows, tar.exe will report a \"Failed to clean up compressor\" error if the target folder\n    // does not exist (GitHub #2622)\n    await FileSystem.ensureFolderAsync(path.dirname(archivePath));\n\n    const projectFolderPath: string = project.projectFolder;\n    const tarExitCode: number = await this._spawnTarWithLoggingAsync(\n      // These parameters are chosen for compatibility with the very primitive bsdtar 3.3.2 shipped with Windows 10.\n      [\n        // [Windows bsdtar 3.3.2] -c Create\n        '-c',\n        // [Windows bsdtar 3.3.2] -f <filename>  Location of archive (default \\\\.\\tape0)\n        '-f',\n        archivePath,\n        // [Windows bsdtar 3.3.2] -z, -j, -J, --lzma  Compress archive with gzip/bzip2/xz/lzma\n        '-z',\n        // [GNU tar 1.33] -T, --files-from=FILE      get names to extract or create from FILE\n        //\n        // Windows bsdtar does not document this parameter, but seems to accept it.\n        '--files-from=-'\n      ],\n      projectFolderPath,\n      logFilePath,\n      tarInput\n    );\n\n    return tarExitCode;\n  }\n\n  private async _spawnTarWithLoggingAsync(\n    args: string[],\n    currentWorkingDirectory: string,\n    logFilePath: string,\n    input?: string\n  ): Promise<number> {\n    // Runs \"tar\" with the specified args and logs its output to the specified location.\n    // The log file looks like this:\n    //\n    // Windows:\n    // Start time: Mon Apr 19 2021 13:06:40 GMT-0700 (Pacific Daylight Time)\n    // Invoking \"C:\\WINDOWS\\system32\\tar.exe -x -f E:\\rush-cache\\d18105f7f83eb610b468be4e2421681f4a52e44d\"\n    //\n    // ======= BEGIN PROCESS OUTPUT =======\n    // [stdout] <tar stdout output>\n    // [stderr] <tar stderr output>\n    // ======== END PROCESS OUTPUT ========\n    //\n    // Exited with code \"0\"\n    //\n    // Linux:\n    // Start time: Mon Apr 19 2021 13:06:40 GMT-0700 (Pacific Daylight Time)\n    // Invoking \"/bin/tar -x -f /home/username/rush-cache/d18105f7f83eb610b468be4e2421681f4a52e44d\"\n    //\n    // ======= BEGIN PROCESS OUTPUT =======\n    // [stdout] <tar stdout output>\n    // [stderr] <tar stderr output>\n    // ======== END PROCESS OUTPUT ========\n    //\n    // Exited with code \"0\"\n\n    await FileSystem.ensureFolderAsync(path.dirname(logFilePath));\n    const fileWriter: FileWriter = FileWriter.open(logFilePath);\n    fileWriter.write(\n      [\n        `Start time: ${new Date().toString()}`,\n        `Invoking \"${this._tarExecutablePath} ${args.join(' ')}\"`,\n        '',\n        `======= BEGIN PROCESS INPUT ======`,\n        input || '',\n        '======== END PROCESS INPUT =======',\n        '======= BEGIN PROCESS OUTPUT =======',\n        ''\n      ].join('\\n')\n    );\n\n    const childProcess: ChildProcess = Executable.spawn(this._tarExecutablePath, args, {\n      currentWorkingDirectory: currentWorkingDirectory\n    });\n\n    childProcess.stdout!.on('data', (chunk) => fileWriter.write(`[stdout] ${chunk}`));\n    childProcess.stderr!.on('data', (chunk) => fileWriter.write(`[stderr] ${chunk}`));\n\n    if (input !== undefined) {\n      childProcess.stdin!.write(input, 'utf-8');\n      childProcess.stdin!.end();\n    }\n\n    // Wait for process to exit and all streams to close\n    const [tarExitCode] = await events.once(childProcess, 'close');\n\n    fileWriter.write(\n      ['======== END PROCESS OUTPUT ========', '', `Exited with code \"${tarExitCode}\"`].join('\\n')\n    );\n    fileWriter.close();\n\n    return tarExitCode;\n  }\n\n  private static async _tryFindTarExecutablePathAsync(): Promise<string | undefined> {\n    if (os.platform() === 'win32') {\n      // If we're running on Windows, first try to use the OOB tar executable. If\n      // we're running in the Git Bash, the tar executable on the PATH doesn't handle\n      // Windows file paths correctly.\n      // eslint-disable-next-line dot-notation\n      const windowsFolderPath: string | undefined = process.env['WINDIR'];\n      if (windowsFolderPath) {\n        const defaultWindowsTarExecutablePath: string = `${windowsFolderPath}\\\\system32\\\\tar.exe`;\n        if (await FileSystem.existsAsync(defaultWindowsTarExecutablePath)) {\n          return defaultWindowsTarExecutablePath;\n        }\n      }\n    }\n\n    return Executable.tryResolve('tar');\n  }\n}\n"]}