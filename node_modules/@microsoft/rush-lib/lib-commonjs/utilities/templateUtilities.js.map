{"version":3,"file":"templateUtilities.js","sourceRoot":"","sources":["../../src/utilities/templateUtilities.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { FileSystem, InternalError, NewlineKind } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { Rush } from '../api/Rush';\n\n// Matches a well-formed BEGIN macro starting a block section.\n// Example:  /*[BEGIN \"DEMO\"]*/\n//\n// Group #1 is the indentation spaces before the macro\n// Group #2 is the section name\nconst BEGIN_MARCO_REGEXP: RegExp = /^(\\s*)\\/\\*\\[BEGIN \"([A-Z]+)\"\\]\\s*\\*\\/\\s*$/;\n\n// Matches a well-formed END macro ending a block section.\n// Example:  /*[END \"DEMO\"]*/\n//\n// Group #1 is the indentation spaces before the macro\n// Group #2 is the section name\nconst END_MACRO_REGEXP: RegExp = /^(\\s*)\\/\\*\\[END \"([A-Z]+)\"\\]\\s*\\*\\/\\s*$/;\n\n// Matches a well-formed single-line section, including the space character after it\n// if present.\n// Example:  /*[LINE \"HYPOTHETICAL\"]*/\n//\n// Group #1 is the section name\nconst LINE_MACRO_REGEXP: RegExp = /\\/\\*\\[LINE \"([A-Z]+)\"\\]\\s*\\*\\/\\s?/;\n\n// Matches a variable expansion.\n// Example:  [%RUSH_VERSION%]\n//\n// Group #1 is the variable name including the dollar sign\nconst VARIABLE_MACRO_REGEXP: RegExp = /\\[(%[A-Z0-9_]+%)\\]/;\n\n// Matches anything that starts with \"/*[\" and ends with \"]*/\"\n// Used to catch malformed macro expressions\nconst ANY_MACRO_REGEXP: RegExp = /\\/\\*\\s*\\[.*\\]\\s*\\*\\//;\n\n// Copy the template from sourcePath, transform any macros, and write the output to destinationPath.\n//\n// We implement a simple template engine.  \"Single-line section\" macros have this form:\n//\n//     /*[LINE \"NAME\"]*/ (content goes here)\n//\n// ...and when commented out will look like this:\n//\n//     // (content goes here)\n//\n// \"Block section\" macros have this form:\n//\n//     /*[BEGIN \"NAME\"]*/\n//     (content goes\n//     here)\n//     /*[END \"NAME\"]*/\n//\n// ...and when commented out will look like this:\n//\n//     // (content goes\n//     // here)\n//\n// Lastly, a variable expansion has this form:\n//\n//     // The value is [%NAME%].\n//\n// ...and when expanded with e.g. \"123\" will look like this:\n//\n//     // The value is 123.\n//\n// The section names must be one of the predefined names used by \"rush init\".\n// A single-line section may appear inside a block section, in which case it will get\n// commented twice.\nexport async function copyTemplateFileAsync(\n  sourcePath: string,\n  destinationPath: string,\n  overwrite: boolean,\n  demo: boolean = false\n): Promise<void> {\n  const destinationFileExists: boolean = await FileSystem.existsAsync(destinationPath);\n\n  if (!overwrite) {\n    if (destinationFileExists) {\n      // eslint-disable-next-line no-console\n      console.log(Colorize.yellow('Not overwriting already existing file: ') + destinationPath);\n      return;\n    }\n  }\n\n  if (destinationFileExists) {\n    // eslint-disable-next-line no-console\n    console.log(Colorize.yellow(`Overwriting: ${destinationPath}`));\n  } else {\n    // eslint-disable-next-line no-console\n    console.log(`Generating: ${destinationPath}`);\n  }\n\n  const outputLines: string[] = [];\n  const lines: string[] = (\n    await FileSystem.readFileAsync(sourcePath, { convertLineEndings: NewlineKind.Lf })\n  ).split('\\n');\n\n  let activeBlockSectionName: string | undefined = undefined;\n  let activeBlockIndent: string = '';\n\n  for (const line of lines) {\n    let match: RegExpMatchArray | null;\n\n    // Check for a block section start\n    // Example:  /*[BEGIN \"DEMO\"]*/\n    match = line.match(BEGIN_MARCO_REGEXP);\n    if (match) {\n      if (activeBlockSectionName) {\n        // If this happens, please report a Rush bug\n        throw new InternalError(\n          `The template contains an unmatched BEGIN macro for \"${activeBlockSectionName}\"`\n        );\n      }\n\n      activeBlockSectionName = match[2];\n      activeBlockIndent = match[1];\n      // Remove the entire line containing the macro\n      continue;\n    }\n\n    // Check for a block section end\n    // Example:  /*[END \"DEMO\"]*/\n    match = line.match(END_MACRO_REGEXP);\n    if (match) {\n      if (activeBlockSectionName === undefined) {\n        // If this happens, please report a Rush bug\n        throw new InternalError(\n          `The template contains an unmatched END macro for \"${activeBlockSectionName}\"`\n        );\n      }\n\n      if (activeBlockSectionName !== match[2]) {\n        // If this happens, please report a Rush bug\n        throw new InternalError(\n          `The template contains an mismatched END macro for \"${activeBlockSectionName}\"`\n        );\n      }\n\n      if (activeBlockIndent !== match[1]) {\n        // If this happens, please report a Rush bug\n        throw new InternalError(\n          `The template contains an inconsistently indented section \"${activeBlockSectionName}\"`\n        );\n      }\n\n      activeBlockSectionName = undefined;\n\n      // Remove the entire line containing the macro\n      continue;\n    }\n\n    let transformedLine: string = line;\n\n    // Check for a single-line section\n    // Example:  /*[LINE \"HYPOTHETICAL\"]*/\n    match = transformedLine.match(LINE_MACRO_REGEXP);\n    if (match) {\n      const sectionName: string = match[1];\n      const replacement: string = _isSectionCommented(sectionName, demo) ? '// ' : '';\n      transformedLine = transformedLine.replace(LINE_MACRO_REGEXP, replacement);\n    }\n\n    // Check for variable expansions\n    // Example:  [%RUSH_VERSION%]\n    while ((match = transformedLine.match(VARIABLE_MACRO_REGEXP))) {\n      const variableName: string = match[1];\n      const replacement: string = _expandMacroVariable(variableName);\n      transformedLine = transformedLine.replace(VARIABLE_MACRO_REGEXP, replacement);\n    }\n\n    // Verify that all macros were handled\n    match = transformedLine.match(ANY_MACRO_REGEXP);\n    if (match) {\n      // If this happens, please report a Rush bug\n      throw new InternalError(\n        'The template contains a malformed macro expression: ' + JSON.stringify(match[0])\n      );\n    }\n\n    // If we are inside a block section that is commented out, then insert the \"//\" after indentation\n    if (activeBlockSectionName !== undefined) {\n      if (_isSectionCommented(activeBlockSectionName, demo)) {\n        // Is the line indented properly?\n        if (transformedLine.substr(0, activeBlockIndent.length).trim().length > 0) {\n          // If this happens, please report a Rush bug\n          throw new InternalError(\n            `The template contains inconsistently indented lines inside` +\n              ` the \"${activeBlockSectionName}\" section`\n          );\n        }\n\n        // Insert comment characters after the indentation\n        const contentAfterIndent: string = transformedLine.substr(activeBlockIndent.length);\n        transformedLine = activeBlockIndent + '// ' + contentAfterIndent;\n      }\n    }\n\n    outputLines.push(transformedLine);\n  }\n\n  // Write the output\n  await FileSystem.writeFileAsync(destinationPath, outputLines.join('\\n'), {\n    ensureFolderExists: true\n  });\n}\n\nfunction _isSectionCommented(sectionName: string, demo: boolean): boolean {\n  // The \"HYPOTHETICAL\" sections are always commented out by \"rush init\".\n  // They are uncommented in the \"assets\" source folder so that we can easily validate\n  // that they conform to their JSON schema.\n  if (sectionName === 'HYPOTHETICAL') return true;\n  if (sectionName === 'DEMO') return demo;\n  // If this happens, please report a Rush bug\n  throw new InternalError(`The template references an undefined section name ${sectionName}`);\n}\n\nfunction _expandMacroVariable(variableName: string): string {\n  switch (variableName) {\n    case '%RUSH_VERSION%':\n      return Rush.version;\n    default:\n      throw new InternalError(`The template references an undefined variable \"${variableName}\"`);\n  }\n}\n"]}