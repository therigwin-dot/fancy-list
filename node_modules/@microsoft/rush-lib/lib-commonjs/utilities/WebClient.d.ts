/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { type RequestOptions } from 'node:https';
/**
 * For use with {@link WebClient}.
 */
export interface IWebClientResponse {
    ok: boolean;
    status: number;
    statusText?: string;
    redirected: boolean;
    headers: Record<string, string | string[] | undefined>;
    getTextAsync: () => Promise<string>;
    getJsonAsync: <TJson>() => Promise<TJson>;
    getBufferAsync: () => Promise<Buffer>;
}
/**
 * For use with {@link WebClient}.
 */
export interface IWebFetchOptionsBase {
    timeoutMs?: number;
    headers?: Record<string, string>;
    redirect?: 'follow' | 'error' | 'manual';
    /**
     * If true, the response will not be decoded if a Content-Encoding header is present.
     */
    noDecode?: boolean;
}
/**
 * For use with {@link WebClient}.
 */
export interface IGetFetchOptions extends IWebFetchOptionsBase {
    verb: 'GET' | never;
}
/**
 * For use with {@link WebClient}.
 */
export interface IFetchOptionsWithBody extends IWebFetchOptionsBase {
    verb: 'PUT' | 'POST' | 'PATCH';
    body?: Buffer;
}
/**
 * For use with {@link WebClient}.
 */
export declare enum WebClientProxy {
    None = 0,
    Detect = 1,
    Fiddler = 2
}
export interface IRequestOptions extends RequestOptions, Pick<IFetchOptionsWithBody, 'body' | 'redirect' | 'noDecode'> {
}
export type FetchFn = (url: string, options: IRequestOptions, isRedirect?: boolean) => Promise<IWebClientResponse>;
export declare const AUTHORIZATION_HEADER_NAME: 'Authorization';
/**
 * A helper for issuing HTTP requests.
 */
export declare class WebClient {
    private static _requestFn;
    readonly standardHeaders: Record<string, string>;
    accept: string | undefined;
    userAgent: string | undefined;
    proxy: WebClientProxy;
    static mockRequestFn(fn: FetchFn): void;
    static resetMockRequestFn(): void;
    static mergeHeaders(target: Record<string, string>, source: Record<string, string>): void;
    addBasicAuthHeader(userName: string, password: string): void;
    fetchAsync(url: string, options?: IGetFetchOptions | IFetchOptionsWithBody): Promise<IWebClientResponse>;
}
//# sourceMappingURL=WebClient.d.ts.map