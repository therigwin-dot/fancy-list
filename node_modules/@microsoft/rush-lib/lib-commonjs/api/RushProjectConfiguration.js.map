{"version":3,"file":"RushProjectConfiguration.js","sourceRoot":"","sources":["../../src/api/RushProjectConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { AlreadyReportedError, Async, Path } from '@rushstack/node-core-library';\nimport type { ITerminal } from '@rushstack/terminal';\nimport { ProjectConfigurationFile, InheritanceType } from '@rushstack/heft-config-file';\nimport { RigConfig } from '@rushstack/rig-package';\n\nimport type { RushConfigurationProject } from './RushConfigurationProject';\nimport { RushConstants } from '../logic/RushConstants';\nimport type { IPhase } from './CommandLineConfiguration';\nimport { OverlappingPathAnalyzer } from '../utilities/OverlappingPathAnalyzer';\nimport schemaJson from '../schemas/rush-project.schema.json';\nimport anythingSchemaJson from '../schemas/rush-project.schema.json';\n\n/**\n * Describes the file structure for the `<project root>/config/rush-project.json` config file.\n * @internal\n */\nexport interface IRushProjectJson {\n  /**\n   * The incremental analyzer can skip Rush commands for projects whose input files have\n   * not changed since the last build. Normally, every Git-tracked file under the project\n   * folder is assumed to be an input. Set incrementalBuildIgnoredGlobs to ignore specific\n   * files, specified as globs relative to the project folder. The list of file globs will\n   * be interpreted the same way your .gitignore file is.\n   */\n  incrementalBuildIgnoredGlobs?: string[];\n\n  /**\n   * Disable caching for this project. The project will never be restored from cache.\n   * This may be useful if this project affects state outside of its folder.\n   *\n   * This option is only used when the build cache is enabled for the repo. You can set\n   * disableBuildCacheForProject=true to disable caching for a specific project. This is a useful workaround\n   * if that project's build scripts violate the assumptions of the cache, for example by writing\n   * files outside the project folder. Where possible, a better solution is to improve the build scripts\n   * to be compatible with caching.\n   */\n  disableBuildCacheForProject?: boolean;\n\n  operationSettings?: IOperationSettings[];\n}\n\n/** @alpha */\nexport interface IRushPhaseSharding {\n  /**\n   * The number of shards to create.\n   */\n  count: number;\n\n  /**\n   * The format of the argument to pass to the command to indicate the shard index and count.\n   *\n   * @defaultValue `--shard={shardIndex}/{shardCount}`\n   */\n  shardArgumentFormat?: string;\n\n  /**\n   * An optional argument to pass to the command to indicate the output folder for the shard.\n   *  It must end with `{shardIndex}`.\n   *\n   * @defaultValue `--shard-output-folder=.rush/operations/{phaseName}/shards/{shardIndex}`.\n   */\n  outputFolderArgumentFormat?: string;\n\n  /**\n   * @deprecated Create a separate operation settings object for the shard operation settings with the name `{operationName}:shard`.\n   */\n  shardOperationSettings?: unknown;\n}\n\n/**\n * @alpha\n */\nexport interface IOperationSettings {\n  /**\n   * The name of the operation. This should be a key in the `package.json`'s `scripts` object.\n   */\n  operationName: string;\n\n  /**\n   * Specify the folders where this operation writes its output files. If enabled, the Rush build\n   * cache will restore these folders from the cache. The strings are folder names under the project\n   * root folder.\n   *\n   * These folders should not be tracked by Git. They must not contain symlinks.\n   */\n  outputFolderNames?: string[];\n\n  /**\n   * Disable caching for this operation. The operation will never be restored from cache.\n   * This may be useful if this operation affects state outside of its folder.\n   *\n   * This option is only used when the build cache is enabled for the repo. You can set\n   * disableBuildCacheForOperation=true to disable caching for a specific project operation.\n   * This is a useful workaround if that project's build scripts violate the assumptions of the cache,\n   * for example by writing files outside the project folder. Where possible, a better solution is to improve\n   * the build scripts to be compatible with caching.\n   */\n  disableBuildCacheForOperation?: boolean;\n\n  /**\n   * An optional list of environment variables that can affect this operation. The values of\n   * these environment variables will become part of the hash when reading and writing the build cache.\n   *\n   * Note: generally speaking, all environment variables available to Rush are also available to any\n   * operations performed -- Rush assumes that environment variables do not affect build outputs unless\n   * you list them here.\n   */\n  dependsOnEnvVars?: string[];\n\n  /**\n   * An optional list of glob (minimatch) patterns pointing to files that can affect this operation.\n   * The hash values of the contents of these files will become part of the final hash when reading\n   * and writing the build cache.\n   *\n   * Note: if a particular file will be matched by patterns provided by both `incrementalBuildIgnoredGlobs` and\n   * `dependsOnAdditionalFiles` options - `dependsOnAdditionalFiles` will win and the file will be included\n   * calculating final hash value when reading and writing the build cache\n   */\n  dependsOnAdditionalFiles?: string[];\n\n  /**\n   * An optional config object for sharding the operation. If specified, the operation will be sharded\n   * into multiple invocations. The `count` property specifies the number of shards to create. The\n   * `shardArgumentFormat` property specifies the format of the argument to pass to the command to\n   * indicate the shard index and count. The default value is `--shard={shardIndex}/{shardCount}`.\n   */\n  sharding?: IRushPhaseSharding;\n\n  /**\n   * How many concurrency units this operation should take up during execution. The maximum concurrent units is\n   *  determined by the -p flag.\n   */\n  weight?: number;\n\n  /**\n   * If true, this operation can use cobuilds for orchestration without restoring build cache entries.\n   */\n  allowCobuildWithoutCache?: boolean;\n}\n\ninterface IOldRushProjectJson {\n  projectOutputFolderNames?: unknown;\n  phaseOptions?: unknown;\n  buildCacheOptions?: unknown;\n}\n\nconst RUSH_PROJECT_CONFIGURATION_FILE: ProjectConfigurationFile<IRushProjectJson> =\n  new ProjectConfigurationFile<IRushProjectJson>({\n    projectRelativeFilePath: `config/${RushConstants.rushProjectConfigFilename}`,\n    jsonSchemaObject: schemaJson,\n    propertyInheritance: {\n      operationSettings: {\n        inheritanceType: InheritanceType.custom,\n        inheritanceFunction: (\n          child: IOperationSettings[] | undefined,\n          parent: IOperationSettings[] | undefined\n        ) => {\n          if (!child) {\n            return parent;\n          } else if (!parent) {\n            return child;\n          } else {\n            // Merge any properties that need to be merged\n            const resultOperationSettingsByOperationName: Map<string, IOperationSettings> = new Map();\n            for (const parentOperationSettings of parent) {\n              resultOperationSettingsByOperationName.set(\n                parentOperationSettings.operationName,\n                parentOperationSettings\n              );\n            }\n\n            const childEncounteredOperationNames: Set<string> = new Set();\n            for (const childOperationSettings of child) {\n              const operationName: string = childOperationSettings.operationName;\n              if (childEncounteredOperationNames.has(operationName)) {\n                // If the operation settings already exist, but didn't come from the parent, then\n                // it shows up multiple times in the child.\n                const childSourceFilePath: string =\n                  RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(child)!;\n                throw new Error(\n                  `The operation \"${operationName}\" occurs multiple times in the \"operationSettings\" array ` +\n                    `in \"${childSourceFilePath}\".`\n                );\n              }\n\n              childEncounteredOperationNames.add(operationName);\n\n              let mergedOperationSettings: IOperationSettings | undefined =\n                resultOperationSettingsByOperationName.get(operationName);\n              if (mergedOperationSettings) {\n                // The parent operation settings object already exists\n                const outputFolderNames: string[] | undefined =\n                  mergedOperationSettings.outputFolderNames && childOperationSettings.outputFolderNames\n                    ? [\n                        ...mergedOperationSettings.outputFolderNames,\n                        ...childOperationSettings.outputFolderNames\n                      ]\n                    : mergedOperationSettings.outputFolderNames || childOperationSettings.outputFolderNames;\n\n                const dependsOnEnvVars: string[] | undefined =\n                  mergedOperationSettings.dependsOnEnvVars && childOperationSettings.dependsOnEnvVars\n                    ? [\n                        ...mergedOperationSettings.dependsOnEnvVars,\n                        ...childOperationSettings.dependsOnEnvVars\n                      ]\n                    : mergedOperationSettings.dependsOnEnvVars || childOperationSettings.dependsOnEnvVars;\n\n                mergedOperationSettings = {\n                  ...mergedOperationSettings,\n                  ...childOperationSettings,\n                  ...(outputFolderNames ? { outputFolderNames } : {}),\n                  ...(dependsOnEnvVars ? { dependsOnEnvVars } : {})\n                };\n                resultOperationSettingsByOperationName.set(operationName, mergedOperationSettings);\n              } else {\n                resultOperationSettingsByOperationName.set(operationName, childOperationSettings);\n              }\n            }\n\n            return Array.from(resultOperationSettingsByOperationName.values());\n          }\n        }\n      },\n      incrementalBuildIgnoredGlobs: {\n        inheritanceType: InheritanceType.replace\n      }\n    }\n  });\n\nconst OLD_RUSH_PROJECT_CONFIGURATION_FILE: ProjectConfigurationFile<IOldRushProjectJson> =\n  new ProjectConfigurationFile<IOldRushProjectJson>({\n    projectRelativeFilePath: RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath,\n    jsonSchemaObject: anythingSchemaJson\n  });\n\n/**\n * Use this class to load the \"config/rush-project.json\" config file.\n *\n * This file provides project-specific configuration options.\n * @alpha\n */\nexport class RushProjectConfiguration {\n  private static readonly _configCache: Map<RushConfigurationProject, RushProjectConfiguration | false> =\n    new Map();\n\n  public readonly project: RushConfigurationProject;\n\n  /**\n   * {@inheritdoc _IRushProjectJson.incrementalBuildIgnoredGlobs}\n   */\n  public readonly incrementalBuildIgnoredGlobs: ReadonlyArray<string>;\n\n  /**\n   * {@inheritdoc _IRushProjectJson.disableBuildCacheForProject}\n   */\n  public readonly disableBuildCacheForProject: boolean;\n\n  public readonly operationSettingsByOperationName: ReadonlyMap<string, Readonly<IOperationSettings>>;\n\n  private readonly _validationCache: WeakSet<object> = new WeakSet();\n\n  private constructor(\n    project: RushConfigurationProject,\n    rushProjectJson: IRushProjectJson,\n    operationSettingsByOperationName: ReadonlyMap<string, IOperationSettings>\n  ) {\n    this.project = project;\n    this.incrementalBuildIgnoredGlobs = rushProjectJson.incrementalBuildIgnoredGlobs || [];\n    this.disableBuildCacheForProject = rushProjectJson.disableBuildCacheForProject || false;\n    this.operationSettingsByOperationName = operationSettingsByOperationName;\n  }\n\n  /**\n   * Validates that the requested phases are compatible.\n   * Deferral of this logic to its own method means that Rush no longer eagerly validates\n   * all defined commands in command-line.json. As such, while validation will be run for a given\n   * command upon invoking that command, defining overlapping phases in \"rush custom-command\"\n   * that are not used by \"rush build\" will not cause \"rush build\" to exit with an error.\n   */\n  public validatePhaseConfiguration(phases: Iterable<IPhase>, terminal: ITerminal): void {\n    // Don't repeatedly validate the same set of phases for the same project.\n    if (this._validationCache.has(phases)) {\n      return;\n    }\n\n    const overlappingPathAnalyzer: OverlappingPathAnalyzer<string> = new OverlappingPathAnalyzer<string>();\n\n    const { operationSettingsByOperationName, project } = this;\n\n    let hasErrors: boolean = false;\n\n    for (const phase of phases) {\n      const operationName: string = phase.name;\n      const operationSettings: IOperationSettings | undefined =\n        operationSettingsByOperationName.get(operationName);\n      if (operationSettings) {\n        if (operationSettings.outputFolderNames) {\n          for (const outputFolderName of operationSettings.outputFolderNames) {\n            const otherOverlappingOperationNames: string[] | undefined =\n              overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(outputFolderName, operationName);\n            if (otherOverlappingOperationNames) {\n              const overlapsWithOwnOperation: boolean =\n                otherOverlappingOperationNames?.includes(operationName);\n              if (overlapsWithOwnOperation) {\n                terminal.writeErrorLine(\n                  `The project \"${project.packageName}\" has a ` +\n                    `\"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" configuration that defines an ` +\n                    `operation with overlapping paths in the \"outputFolderNames\" list. The operation is ` +\n                    `\"${operationName}\", and the conflicting path is \"${outputFolderName}\".`\n                );\n              } else {\n                terminal.writeErrorLine(\n                  `The project \"${project.packageName}\" has a ` +\n                    `\"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" configuration that defines ` +\n                    'two operations in the same command whose \"outputFolderNames\" would overlap. ' +\n                    'Operations outputs in the same command must be disjoint so that they can be independently cached. ' +\n                    `The \"${outputFolderName}\" path overlaps between these operations: ` +\n                    `\"${operationName}\", \"${otherOverlappingOperationNames.join('\", \"')}\"`\n                );\n              }\n\n              hasErrors = true;\n            }\n          }\n        }\n      }\n    }\n\n    this._validationCache.add(phases);\n\n    if (hasErrors) {\n      throw new AlreadyReportedError();\n    }\n  }\n\n  /**\n   * Examines the list of source files for the project and the target phase and returns a reason\n   * why the project cannot enable the build cache for that phase, or undefined if it is safe to so do.\n   */\n  public getCacheDisabledReason(\n    trackedFileNames: Iterable<string>,\n    phaseName: string,\n    isNoOp: boolean\n  ): string | undefined {\n    // Skip no-op operations as they won't have any output/cacheable things.\n    if (isNoOp) {\n      return undefined;\n    }\n    if (this.disableBuildCacheForProject) {\n      return 'Caching has been disabled for this project.';\n    }\n\n    const operationSettings: IOperationSettings | undefined =\n      this.operationSettingsByOperationName.get(phaseName);\n    if (!operationSettings) {\n      return `This project does not define the caching behavior of the \"${phaseName}\" command, so caching has been disabled.`;\n    }\n\n    if (operationSettings.disableBuildCacheForOperation) {\n      return `Caching has been disabled for this project's \"${phaseName}\" command.`;\n    }\n\n    const { outputFolderNames } = operationSettings;\n    if (!outputFolderNames) {\n      return;\n    }\n    const normalizedProjectRelativeFolder: string = Path.convertToSlashes(this.project.projectRelativeFolder);\n\n    const normalizedOutputFolders: string[] = outputFolderNames.map(\n      (outputFolderName) => `${normalizedProjectRelativeFolder}/${outputFolderName}/`\n    );\n\n    const inputOutputFiles: string[] = [];\n    for (const file of trackedFileNames) {\n      for (const outputFolder of normalizedOutputFolders) {\n        if (file.startsWith(outputFolder)) {\n          inputOutputFiles.push(file);\n        }\n      }\n    }\n\n    if (inputOutputFiles.length > 0) {\n      return (\n        'The following files are used to calculate project state ' +\n        `and are considered project output: ${inputOutputFiles.join(', ')}`\n      );\n    }\n  }\n\n  /**\n   * Source of truth for whether a project is unable to use the build cache for a given phase.\n   * As some operations may not have a rush-project.json file defined at all, but may be no-op operations\n   *  we'll want to ignore those completely.\n   */\n  public static getCacheDisabledReasonForProject(options: {\n    projectConfiguration: RushProjectConfiguration | undefined;\n    trackedFileNames: Iterable<string>;\n    phaseName: string;\n    isNoOp: boolean;\n  }): string | undefined {\n    const { projectConfiguration, trackedFileNames, phaseName, isNoOp } = options;\n    if (isNoOp) {\n      return undefined;\n    }\n\n    if (!projectConfiguration) {\n      return (\n        `Project does not have a ${RushConstants.rushProjectConfigFilename} configuration file, ` +\n        'or one provided by a rig, so it does not support caching.'\n      );\n    }\n\n    return projectConfiguration.getCacheDisabledReason(trackedFileNames, phaseName, isNoOp);\n  }\n\n  /**\n   * Loads the rush-project.json data for the specified project.\n   */\n  public static async tryLoadForProjectAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<RushProjectConfiguration | undefined> {\n    // false is a signal that the project config does not exist\n    const cacheEntry: RushProjectConfiguration | false | undefined =\n      RushProjectConfiguration._configCache.get(project);\n    if (cacheEntry !== undefined) {\n      return cacheEntry || undefined;\n    }\n\n    const rushProjectJson: IRushProjectJson | undefined = await this._tryLoadJsonForProjectAsync(\n      project,\n      terminal\n    );\n\n    if (rushProjectJson) {\n      const result: RushProjectConfiguration = RushProjectConfiguration._getRushProjectConfiguration(\n        project,\n        rushProjectJson,\n        terminal\n      );\n      RushProjectConfiguration._configCache.set(project, result);\n      return result;\n    } else {\n      RushProjectConfiguration._configCache.set(project, false);\n      return undefined;\n    }\n  }\n\n  /**\n   * Load only the `incrementalBuildIgnoredGlobs` property from the rush-project.json file, skipping\n   * validation of other parts of the config file.\n   *\n   * @remarks\n   * This function exists to allow the ProjectChangeAnalyzer to load just the ignore globs without\n   * having to validate the rest of the `rush-project.json` file against the repo's command-line configuration.\n   */\n  public static async tryLoadIgnoreGlobsForProjectAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<ReadonlyArray<string> | undefined> {\n    const rushProjectJson: IRushProjectJson | undefined = await this._tryLoadJsonForProjectAsync(\n      project,\n      terminal\n    );\n\n    return rushProjectJson?.incrementalBuildIgnoredGlobs;\n  }\n\n  /**\n   * Load the rush-project.json data for all selected projects.\n   * Validate compatibility of output folders across all selected phases.\n   */\n  public static async tryLoadForProjectsAsync(\n    projects: Iterable<RushConfigurationProject>,\n    terminal: ITerminal\n  ): Promise<ReadonlyMap<RushConfigurationProject, RushProjectConfiguration>> {\n    const result: Map<RushConfigurationProject, RushProjectConfiguration> = new Map();\n\n    await Async.forEachAsync(\n      projects,\n      async (project: RushConfigurationProject) => {\n        const projectConfig: RushProjectConfiguration | undefined =\n          await RushProjectConfiguration.tryLoadForProjectAsync(project, terminal);\n        if (projectConfig) {\n          result.set(project, projectConfig);\n        }\n      },\n      { concurrency: 50 }\n    );\n\n    return result;\n  }\n\n  private static async _tryLoadJsonForProjectAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<IRushProjectJson | undefined> {\n    const rigConfig: RigConfig = await RigConfig.loadForProjectFolderAsync({\n      projectFolderPath: project.projectFolder\n    });\n\n    try {\n      return await RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(\n        terminal,\n        project.projectFolder,\n        rigConfig\n      );\n    } catch (e1) {\n      // Detect if the project is using the old rush-project.json schema\n      let oldRushProjectJson: IOldRushProjectJson | undefined;\n      try {\n        oldRushProjectJson =\n          await OLD_RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(\n            terminal,\n            project.projectFolder,\n            rigConfig\n          );\n      } catch (e2) {\n        // Ignore\n      }\n\n      if (\n        oldRushProjectJson?.projectOutputFolderNames ||\n        oldRushProjectJson?.phaseOptions ||\n        oldRushProjectJson?.buildCacheOptions\n      ) {\n        throw new Error(\n          `The ${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file appears to be ` +\n            'in an outdated format. Please see the UPGRADING.md notes for details. ' +\n            'Quick link: https://rushjs.io/link/upgrading'\n        );\n      } else {\n        throw e1;\n      }\n    }\n  }\n\n  private static _getRushProjectConfiguration(\n    project: RushConfigurationProject,\n    rushProjectJson: IRushProjectJson,\n    terminal: ITerminal\n  ): RushProjectConfiguration {\n    const operationSettingsByOperationName: Map<string, IOperationSettings> = new Map<\n      string,\n      IOperationSettings\n    >();\n\n    let hasErrors: boolean = false;\n\n    if (rushProjectJson.operationSettings) {\n      for (const operationSettings of rushProjectJson.operationSettings) {\n        const operationName: string = operationSettings.operationName;\n        const existingOperationSettings: IOperationSettings | undefined =\n          operationSettingsByOperationName.get(operationName);\n        if (existingOperationSettings) {\n          const existingOperationSettingsJsonPath: string | undefined =\n            RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(existingOperationSettings);\n          const operationSettingsJsonPath: string | undefined =\n            RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(operationSettings);\n          hasErrors = true;\n          let errorMessage: string =\n            `The operation \"${operationName}\" appears multiple times in the \"${project.packageName}\" project's ` +\n            `${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file's ` +\n            'operationSettings property.';\n          if (existingOperationSettingsJsonPath && operationSettingsJsonPath) {\n            if (existingOperationSettingsJsonPath !== operationSettingsJsonPath) {\n              errorMessage +=\n                ` It first appears in \"${existingOperationSettingsJsonPath}\" and again ` +\n                `in \"${operationSettingsJsonPath}\".`;\n            } else if (\n              !Path.convertToSlashes(existingOperationSettingsJsonPath).startsWith(\n                Path.convertToSlashes(project.projectFolder)\n              )\n            ) {\n              errorMessage += ` It appears multiple times in \"${operationSettingsJsonPath}\".`;\n            }\n          }\n\n          terminal.writeErrorLine(errorMessage);\n        } else {\n          operationSettingsByOperationName.set(operationName, operationSettings);\n        }\n      }\n\n      for (const [operationName, operationSettings] of operationSettingsByOperationName) {\n        if (operationSettings.sharding?.shardOperationSettings) {\n          terminal.writeWarningLine(\n            `DEPRECATED: The \"sharding.shardOperationSettings\" field is deprecated. Please create a new operation, '${operationName}:shard' to track shard operation settings.`\n          );\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new AlreadyReportedError();\n    }\n\n    return new RushProjectConfiguration(project, rushProjectJson, operationSettingsByOperationName);\n  }\n}\n"]}