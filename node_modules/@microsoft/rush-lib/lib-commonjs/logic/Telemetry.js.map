{"version":3,"file":"Telemetry.js","sourceRoot":"","sources":["../../src/logic/Telemetry.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,uCAAyB;AACzB,2CAA6B;AAC7B,oEAA0F;AAG1F,sCAAmC;AA6HnC,MAAM,cAAc,GAAW,GAAG,CAAC;AACnC,MAAM,qBAAqB,GAAY,OAAO,CAAC;AAE/C,MAAa,SAAS;IAQpB,YAAmB,iBAAoC,EAAE,WAAwB;QAFzE,qBAAgB,GAAuB,IAAI,GAAG,EAAE,CAAC;QAGvD,IAAI,CAAC,kBAAkB,GAAG,iBAAiB,CAAC;QAC5C,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,CAAC;QACzD,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QAEjB,MAAM,UAAU,GAAW,WAAW,CAAC;QACvC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,EAAE,UAAU,CAAC,CAAC;IACrF,CAAC;IAEM,GAAG,CAAC,aAA6B;QACtC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;YACnB,OAAO;QACT,CAAC;QACD,MAAM,IAAI,GAAiB,EAAE,CAAC,IAAI,EAAE,CAAC;QACrC,MAAM,IAAI,mCACL,aAAa,KAChB,WAAW,EAAE,aAAa,CAAC,WAAW,IAAI;gBACxC,mBAAmB,EAAE,EAAE,CAAC,IAAI,EAAE;gBAC9B,sDAAsD;gBACtD,oDAAoD;gBACpD,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE;gBAChC,YAAY,EAAE,IAAI,CAAC,MAAM;gBACzB,qBAAqB,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,QAAQ,EAAE,GAAG,qBAAqB,CAAC;gBACxE,oBAAoB,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,qBAAqB,CAAC;aACvE,EACD,WAAW,EAAE,aAAa,CAAC,WAAW,IAAI,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,EAC9D,QAAQ,EAAE,aAAa,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,EACpD,WAAW,EAAE,aAAa,CAAC,WAAW,IAAI,WAAI,CAAC,OAAO,GACvD,CAAC;QACF,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACzB,CAAC;IAEM,KAAK;QACV,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC/C,OAAO;QACT,CAAC;QAED,MAAM,QAAQ,GAAW,IAAI,CAAC,YAAY,EAAE,CAAC;QAC7C,4BAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,EAAE,EAAE,kBAAkB,EAAE,IAAI,EAAE,qBAAqB,EAAE,IAAI,EAAE,CAAC,CAAC;QAChG,IAAI,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,cAAc,CAAC,MAAM,EAAE,EAAE,CAAC;YACpD;;;eAGG;YACH,MAAM,gBAAgB,GAAkB,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACpG,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;YAC5C,gBAAgB,CAAC,IAAI,CACnB,GAAG,EAAE;gBACH,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;YACjD,CAAC,EACD,GAAG,EAAE;gBACH,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;YACjD,CAAC,CACF,CAAC;QACJ,CAAC;QAED,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,QAAQ,EAAE,CAAC;IAClB,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,kBAAkB;QAC7B,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IAC3C,CAAC;IAED,IAAW,KAAK;QACd,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED;;OAEG;IACK,QAAQ;QACd,IAAI,8BAAU,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC;YACxC,MAAM,KAAK,GAAa,8BAAU,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YACzE,IAAI,KAAK,CAAC,MAAM,GAAG,cAAc,EAAE,CAAC;gBAClC,MAAM,WAAW,GAAa,KAAK;qBAChC,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE;oBAChB,MAAM,QAAQ,GAAW,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;oBAC/D,MAAM,KAAK,GAAoB,8BAAU,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;oBAClE,OAAO;wBACL,QAAQ,EAAE,QAAQ;wBAClB,YAAY,EAAE,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE;wBACnC,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE;qBACvB,CAAC;gBACJ,CAAC,CAAC;qBACD,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;oBAChB,oBAAoB;oBACpB,OAAO,KAAK,CAAC,MAAM,CAAC;gBACtB,CAAC,CAAC;qBACD,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;oBACb,OAAO,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC,YAAY,CAAC;gBACzC,CAAC,CAAC;qBACD,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;oBACT,OAAO,CAAC,CAAC,QAAQ,CAAC;gBACpB,CAAC,CAAC,CAAC;gBACL,MAAM,aAAa,GAAW,WAAW,CAAC,MAAM,GAAG,cAAc,CAAC;gBAClE,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,aAAa,EAAE,CAAC,EAAE,EAAE,CAAC;oBAC/C,8BAAU,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;gBACxC,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAEO,YAAY;QAClB,IAAI,QAAQ,GAAW,aAAa,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,EAAE,CAAC;QAC/D,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,GAAG,OAAO,CAAC;QACxD,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IAC/C,CAAC;CACF;AAxHD,8BAwHC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as os from 'os';\nimport * as path from 'path';\nimport { FileSystem, type FileSystemStats, JsonFile } from '@rushstack/node-core-library';\n\nimport type { RushConfiguration } from '../api/RushConfiguration';\nimport { Rush } from '../api/Rush';\nimport type { RushSession } from '../pluginFramework/RushSession';\n\n/**\n * @beta\n */\nexport interface ITelemetryMachineInfo {\n  /**\n   * The CPU architecture\n   * @example `\"AMD64\"`\n   */\n  machineArchitecture: string;\n\n  /**\n   * The CPU model\n   * * @example `\"AMD Ryzen 7 3700X 8-Core Processor\"`\n   */\n  machineCpu: string;\n\n  /**\n   * The number of logical CPU cores.\n   */\n  machineCores: number;\n\n  /**\n   * The total amount of RAM on the machine, in MiB.\n   */\n  machineTotalMemoryMiB: number;\n\n  /**\n   * The amount of free RAM on the machine at the end of execution, in MiB.\n   */\n  machineFreeMemoryMiB: number;\n}\n\n/**\n * @beta\n */\nexport interface ITelemetryOperationResult {\n  /**\n   * The names of operations that this operation depends on.\n   */\n  dependencies: string[];\n\n  /**\n   * The status code for the operation.\n   */\n  result: string;\n\n  /**\n   * A timestamp in milliseconds (from `performance.now()`) when the operation started.\n   * If the operation was blocked, will be `undefined`.\n   */\n  startTimestampMs?: number;\n\n  /**\n   * A timestamp in milliseconds (from `performance.now()`) when the operation finished.\n   * If the operation was blocked, will be `undefined`.\n   */\n  endTimestampMs?: number;\n\n  /**\n   * Duration in milliseconds when the operation does not hit cache\n   */\n  nonCachedDurationMs?: number;\n\n  /**\n   * Was this operation built on this machine? If so, the duration can be calculated from `startTimestampMs` and `endTimestampMs`.\n   *  If not, you should use the metrics from the machine that built it.\n   */\n  wasExecutedOnThisMachine?: boolean;\n}\n\n/**\n * @beta\n */\nexport interface ITelemetryData {\n  /**\n   * Command name\n   * @example `\"build\"`\n   */\n  readonly name: string;\n\n  /**\n   * Duration in seconds\n   */\n  readonly durationInSeconds: number;\n\n  /**\n   * The result of the command\n   */\n  readonly result: 'Succeeded' | 'Failed';\n\n  /**\n   * The millisecond-resolution timestamp of the telemetry logging\n   * @example 1648001893024\n   */\n  readonly timestampMs?: number;\n\n  /**\n   * The platform the command was executed on, based on the Node.js `process.platform()` API\n   * @example `\"darwin\"`, `\"win32\"`, `\"linux\"`\n   */\n  readonly platform?: string;\n\n  /**\n   * The Rush version\n   * @example `5.63.0`\n   */\n  readonly rushVersion?: string;\n\n  /**\n   * Detailed information about the host machine.\n   */\n  readonly machineInfo?: ITelemetryMachineInfo;\n\n  /**\n   * Only applicable to phased commands. Provides detailed results by operation.\n   * Keys are operation names, values contain result, timing information, and dependencies.\n   */\n  readonly operationResults?: Record<string, ITelemetryOperationResult>;\n\n  readonly extraData?: { [key: string]: string | number | boolean };\n}\n\nconst MAX_FILE_COUNT: number = 100;\nconst ONE_MEGABYTE_IN_BYTES: 1048576 = 1048576;\n\nexport class Telemetry {\n  private _enabled: boolean;\n  private _store: ITelemetryData[];\n  private _dataFolder: string;\n  private _rushConfiguration: RushConfiguration;\n  private _rushSession: RushSession;\n  private _flushAsyncTasks: Set<Promise<void>> = new Set();\n\n  public constructor(rushConfiguration: RushConfiguration, rushSession: RushSession) {\n    this._rushConfiguration = rushConfiguration;\n    this._rushSession = rushSession;\n    this._enabled = this._rushConfiguration.telemetryEnabled;\n    this._store = [];\n\n    const folderName: string = 'telemetry';\n    this._dataFolder = path.join(this._rushConfiguration.commonTempFolder, folderName);\n  }\n\n  public log(telemetryData: ITelemetryData): void {\n    if (!this._enabled) {\n      return;\n    }\n    const cpus: os.CpuInfo[] = os.cpus();\n    const data: ITelemetryData = {\n      ...telemetryData,\n      machineInfo: telemetryData.machineInfo || {\n        machineArchitecture: os.arch(),\n        // The Node.js model is sometimes padded, for example:\n        // \"AMD Ryzen 7 3700X 8-Core Processor             \"\n        machineCpu: cpus[0].model.trim(),\n        machineCores: cpus.length,\n        machineTotalMemoryMiB: Math.round(os.totalmem() / ONE_MEGABYTE_IN_BYTES),\n        machineFreeMemoryMiB: Math.round(os.freemem() / ONE_MEGABYTE_IN_BYTES)\n      },\n      timestampMs: telemetryData.timestampMs || new Date().getTime(),\n      platform: telemetryData.platform || process.platform,\n      rushVersion: telemetryData.rushVersion || Rush.version\n    };\n    this._store.push(data);\n  }\n\n  public flush(): void {\n    if (!this._enabled || this._store.length === 0) {\n      return;\n    }\n\n    const fullPath: string = this._getFilePath();\n    JsonFile.save(this._store, fullPath, { ensureFolderExists: true, ignoreUndefinedValues: true });\n    if (this._rushSession.hooks.flushTelemetry.isUsed()) {\n      /**\n       * User defined flushTelemetry should not block anything, so we don't await here,\n       * and store the promise into a list so that we can await it later.\n       */\n      const asyncTaskPromise: Promise<void> = this._rushSession.hooks.flushTelemetry.promise(this._store);\n      this._flushAsyncTasks.add(asyncTaskPromise);\n      asyncTaskPromise.then(\n        () => {\n          this._flushAsyncTasks.delete(asyncTaskPromise);\n        },\n        () => {\n          this._flushAsyncTasks.delete(asyncTaskPromise);\n        }\n      );\n    }\n\n    this._store = [];\n    this._cleanUp();\n  }\n\n  /**\n   * There are some async tasks that are not finished when the process is exiting.\n   */\n  public async ensureFlushedAsync(): Promise<void> {\n    await Promise.all(this._flushAsyncTasks);\n  }\n\n  public get store(): ITelemetryData[] {\n    return this._store;\n  }\n\n  /**\n   * When there are too many log files, delete the old ones.\n   */\n  private _cleanUp(): void {\n    if (FileSystem.exists(this._dataFolder)) {\n      const files: string[] = FileSystem.readFolderItemNames(this._dataFolder);\n      if (files.length > MAX_FILE_COUNT) {\n        const sortedFiles: string[] = files\n          .map((fileName) => {\n            const filePath: string = path.join(this._dataFolder, fileName);\n            const stats: FileSystemStats = FileSystem.getStatistics(filePath);\n            return {\n              filePath: filePath,\n              modifiedTime: stats.mtime.getTime(),\n              isFile: stats.isFile()\n            };\n          })\n          .filter((value) => {\n            // Only delete files\n            return value.isFile;\n          })\n          .sort((a, b) => {\n            return a.modifiedTime - b.modifiedTime;\n          })\n          .map((s) => {\n            return s.filePath;\n          });\n        const filesToDelete: number = sortedFiles.length - MAX_FILE_COUNT;\n        for (let i: number = 0; i < filesToDelete; i++) {\n          FileSystem.deleteFile(sortedFiles[i]);\n        }\n      }\n    }\n  }\n\n  private _getFilePath(): string {\n    let fileName: string = `telemetry_${new Date().toISOString()}`;\n    fileName = fileName.replace(/[\\-\\:\\.]/g, '_') + '.json';\n    return path.join(this._dataFolder, fileName);\n  }\n}\n"]}