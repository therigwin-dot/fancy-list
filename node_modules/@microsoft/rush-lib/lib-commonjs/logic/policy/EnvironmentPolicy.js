"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAsync = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const RushConstants_1 = require("../RushConstants");
/**
 * Ensures the environment where the Rush repo exists is valid
 */
async function validateAsync(rushConfiguration, options) {
    if (rushConfiguration.experimentsConfiguration.configuration.forbidPhantomResolvableNodeModulesFolders) {
        const pathParts = rushConfiguration.rushJsonFolder.split(/[\/\\]/);
        const existingNodeModulesPaths = [];
        await node_core_library_1.Async.forEachAsync(pathParts, async (pathPart, index) => {
            const potentialNodeModulesPath = `${pathParts.slice(0, index + 1).join('/')}/node_modules`;
            const pathExists = await node_core_library_1.FileSystem.existsAsync(potentialNodeModulesPath);
            if (pathExists) {
                existingNodeModulesPaths.push(potentialNodeModulesPath);
            }
        }, { concurrency: 5 });
        if (existingNodeModulesPaths.length > 0) {
            const paths = existingNodeModulesPaths.sort().join(', ');
            let errorMessage = `The following node_modules folders exist in the path to the Rush repo: ${paths}. ` +
                `This is not supported, and may cause issues.`;
            if (options.bypassPolicyAllowed) {
                errorMessage += ` To ignore, use the "${RushConstants_1.RushConstants.bypassPolicyFlagLongName}" flag.`;
            }
            // eslint-disable-next-line no-console
            console.error(errorMessage);
            throw new node_core_library_1.AlreadyReportedError();
        }
    }
}
exports.validateAsync = validateAsync;
//# sourceMappingURL=EnvironmentPolicy.js.map