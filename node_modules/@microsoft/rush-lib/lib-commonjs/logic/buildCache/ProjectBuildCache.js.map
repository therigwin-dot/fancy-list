{"version":3,"file":"ProjectBuildCache.js","sourceRoot":"","sources":["../../../src/logic/buildCache/ProjectBuildCache.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport * as crypto from 'crypto';\n\nimport { FileSystem, type FolderItem, InternalError, Async } from '@rushstack/node-core-library';\nimport type { ITerminal } from '@rushstack/terminal';\n\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport type { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\nimport type { ICloudBuildCacheProvider } from './ICloudBuildCacheProvider';\nimport type { FileSystemBuildCacheProvider } from './FileSystemBuildCacheProvider';\nimport { TarExecutable } from '../../utilities/TarExecutable';\nimport { EnvironmentVariableNames } from '../../api/EnvironmentConfiguration';\nimport type { OperationExecutionRecord } from '../operations/OperationExecutionRecord';\n\nexport interface IOperationBuildCacheOptions {\n  /**\n   * The repo-wide configuration for the build cache.\n   */\n  buildCacheConfiguration: BuildCacheConfiguration;\n  /**\n   * The terminal to use for logging.\n   */\n  terminal: ITerminal;\n}\n\nexport type IProjectBuildCacheOptions = IOperationBuildCacheOptions & {\n  /**\n   * Value from rush-project.json\n   */\n  projectOutputFolderNames: ReadonlyArray<string>;\n  /**\n   * The project to be cached.\n   */\n  project: RushConfigurationProject;\n  /**\n   * The hash of all relevant inputs and configuration that uniquely identifies this execution.\n   */\n  operationStateHash: string;\n  /**\n   * The name of the phase that is being cached.\n   */\n  phaseName: string;\n};\n\ninterface IPathsToCache {\n  filteredOutputFolderNames: string[];\n  outputFilePaths: string[];\n}\n\nexport class ProjectBuildCache {\n  private static _tarUtilityPromise: Promise<TarExecutable | undefined> | undefined;\n\n  private readonly _project: RushConfigurationProject;\n  private readonly _localBuildCacheProvider: FileSystemBuildCacheProvider;\n  private readonly _cloudBuildCacheProvider: ICloudBuildCacheProvider | undefined;\n  private readonly _buildCacheEnabled: boolean;\n  private readonly _cacheWriteEnabled: boolean;\n  private readonly _projectOutputFolderNames: ReadonlyArray<string>;\n  private readonly _cacheId: string | undefined;\n\n  private constructor(cacheId: string | undefined, options: IProjectBuildCacheOptions) {\n    const {\n      buildCacheConfiguration: {\n        localCacheProvider,\n        cloudCacheProvider,\n        buildCacheEnabled,\n        cacheWriteEnabled\n      },\n      project,\n      projectOutputFolderNames\n    } = options;\n    this._project = project;\n    this._localBuildCacheProvider = localCacheProvider;\n    this._cloudBuildCacheProvider = cloudCacheProvider;\n    this._buildCacheEnabled = buildCacheEnabled;\n    this._cacheWriteEnabled = cacheWriteEnabled;\n    this._projectOutputFolderNames = projectOutputFolderNames || [];\n    this._cacheId = cacheId;\n  }\n\n  private static _tryGetTarUtility(terminal: ITerminal): Promise<TarExecutable | undefined> {\n    if (!ProjectBuildCache._tarUtilityPromise) {\n      ProjectBuildCache._tarUtilityPromise = TarExecutable.tryInitializeAsync(terminal);\n    }\n\n    return ProjectBuildCache._tarUtilityPromise;\n  }\n\n  public get cacheId(): string | undefined {\n    return this._cacheId;\n  }\n\n  public static getProjectBuildCache(options: IProjectBuildCacheOptions): ProjectBuildCache {\n    const cacheId: string | undefined = ProjectBuildCache._getCacheId(options);\n    return new ProjectBuildCache(cacheId, options);\n  }\n\n  public static forOperation(\n    operation: OperationExecutionRecord,\n    options: IOperationBuildCacheOptions\n  ): ProjectBuildCache {\n    if (!operation.associatedProject) {\n      throw new InternalError('Operation must have an associated project');\n    }\n    if (!operation.associatedPhase) {\n      throw new InternalError('Operation must have an associated phase');\n    }\n    const outputFolders: string[] = [...(operation.operation.settings?.outputFolderNames ?? [])];\n    if (operation.metadataFolderPath) {\n      outputFolders.push(operation.metadataFolderPath);\n    }\n    const buildCacheOptions: IProjectBuildCacheOptions = {\n      ...options,\n      project: operation.associatedProject,\n      phaseName: operation.associatedPhase.name,\n      projectOutputFolderNames: outputFolders,\n      operationStateHash: operation.stateHash\n    };\n    const cacheId: string | undefined = ProjectBuildCache._getCacheId(buildCacheOptions);\n    return new ProjectBuildCache(cacheId, buildCacheOptions);\n  }\n\n  public async tryRestoreFromCacheAsync(terminal: ITerminal, specifiedCacheId?: string): Promise<boolean> {\n    const cacheId: string | undefined = specifiedCacheId || this._cacheId;\n    if (!cacheId) {\n      terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\n      return false;\n    }\n\n    if (!this._buildCacheEnabled) {\n      // Skip reading local and cloud build caches, without any noise\n      return false;\n    }\n\n    let localCacheEntryPath: string | undefined =\n      await this._localBuildCacheProvider.tryGetCacheEntryPathByIdAsync(terminal, cacheId);\n    let cacheEntryBuffer: Buffer | undefined;\n    let updateLocalCacheSuccess: boolean | undefined;\n    if (!localCacheEntryPath && this._cloudBuildCacheProvider) {\n      terminal.writeVerboseLine(\n        'This project was not found in the local build cache. Querying the cloud build cache.'\n      );\n\n      cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(\n        terminal,\n        cacheId\n      );\n      if (cacheEntryBuffer) {\n        try {\n          localCacheEntryPath = await this._localBuildCacheProvider.trySetCacheEntryBufferAsync(\n            terminal,\n            cacheId,\n            cacheEntryBuffer\n          );\n          updateLocalCacheSuccess = true;\n        } catch (e) {\n          updateLocalCacheSuccess = false;\n        }\n      }\n    }\n\n    if (!localCacheEntryPath && !cacheEntryBuffer) {\n      terminal.writeVerboseLine('This project was not found in the build cache.');\n      return false;\n    }\n\n    terminal.writeLine('Build cache hit.');\n    terminal.writeVerboseLine(`Cache key: ${cacheId}`);\n\n    const projectFolderPath: string = this._project.projectFolder;\n\n    // Purge output folders\n    terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);\n    await Promise.all(\n      this._projectOutputFolderNames.map((outputFolderName: string) =>\n        FileSystem.deleteFolderAsync(`${projectFolderPath}/${outputFolderName}`)\n      )\n    );\n\n    const tarUtility: TarExecutable | undefined = await ProjectBuildCache._tryGetTarUtility(terminal);\n    let restoreSuccess: boolean = false;\n    if (tarUtility && localCacheEntryPath) {\n      const logFilePath: string = this._getTarLogFilePath(cacheId, 'untar');\n      const tarExitCode: number = await tarUtility.tryUntarAsync({\n        archivePath: localCacheEntryPath,\n        outputFolderPath: projectFolderPath,\n        logFilePath\n      });\n      if (tarExitCode === 0) {\n        restoreSuccess = true;\n        terminal.writeLine('Successfully restored output from the build cache.');\n      } else {\n        terminal.writeWarningLine(\n          'Unable to restore output from the build cache. ' +\n            `See \"${logFilePath}\" for logs from the tar process.`\n        );\n      }\n    }\n\n    if (updateLocalCacheSuccess === false) {\n      terminal.writeWarningLine('Unable to update the local build cache with data from the cloud cache.');\n    }\n\n    return restoreSuccess;\n  }\n\n  public async trySetCacheEntryAsync(terminal: ITerminal, specifiedCacheId?: string): Promise<boolean> {\n    if (!this._cacheWriteEnabled) {\n      // Skip writing local and cloud build caches, without any noise\n      return true;\n    }\n\n    const cacheId: string | undefined = specifiedCacheId || this._cacheId;\n    if (!cacheId) {\n      terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\n      return false;\n    }\n\n    const filesToCache: IPathsToCache | undefined = await this._tryCollectPathsToCacheAsync(terminal);\n    if (!filesToCache) {\n      return false;\n    }\n\n    terminal.writeVerboseLine(\n      `Caching build output folders: ${filesToCache.filteredOutputFolderNames.join(', ')}`\n    );\n\n    let localCacheEntryPath: string | undefined;\n\n    const tarUtility: TarExecutable | undefined = await ProjectBuildCache._tryGetTarUtility(terminal);\n    if (tarUtility) {\n      const finalLocalCacheEntryPath: string = this._localBuildCacheProvider.getCacheEntryPath(cacheId);\n\n      // Derive the temp file from the destination path to ensure they are on the same volume\n      // In the case of a shared network drive containing the build cache, we also need to make\n      // sure the the temp path won't be shared by two parallel rush builds.\n      const randomSuffix: string = crypto.randomBytes(8).toString('hex');\n      const tempLocalCacheEntryPath: string = `${finalLocalCacheEntryPath}-${randomSuffix}.temp`;\n\n      const logFilePath: string = this._getTarLogFilePath(cacheId, 'tar');\n      const tarExitCode: number = await tarUtility.tryCreateArchiveFromProjectPathsAsync({\n        archivePath: tempLocalCacheEntryPath,\n        paths: filesToCache.outputFilePaths,\n        project: this._project,\n        logFilePath\n      });\n\n      if (tarExitCode === 0) {\n        // Move after the archive is finished so that if the process is interrupted we aren't left with an invalid file\n        try {\n          await Async.runWithRetriesAsync({\n            action: () =>\n              FileSystem.moveAsync({\n                sourcePath: tempLocalCacheEntryPath,\n                destinationPath: finalLocalCacheEntryPath,\n                overwrite: true\n              }),\n            maxRetries: 2,\n            retryDelayMs: 500\n          });\n        } catch (moveError) {\n          try {\n            await FileSystem.deleteFileAsync(tempLocalCacheEntryPath);\n          } catch (deleteError) {\n            // Ignored\n          }\n          throw moveError;\n        }\n        localCacheEntryPath = finalLocalCacheEntryPath;\n      } else {\n        terminal.writeWarningLine(\n          `\"tar\" exited with code ${tarExitCode} while attempting to create the cache entry. ` +\n            `See \"${logFilePath}\" for logs from the tar process.`\n        );\n        return false;\n      }\n    } else {\n      terminal.writeWarningLine(\n        `Unable to locate \"tar\". Please ensure that \"tar\" is on your PATH environment variable, or set the ` +\n          `${EnvironmentVariableNames.RUSH_TAR_BINARY_PATH} environment variable to the full path to the \"tar\" binary.`\n      );\n      return false;\n    }\n\n    let cacheEntryBuffer: Buffer | undefined;\n\n    let setCloudCacheEntryPromise: Promise<boolean> | undefined;\n\n    // Note that \"writeAllowed\" settings (whether in config or environment) always apply to\n    // the configured CLOUD cache. If the cache is enabled, rush is always allowed to read from and\n    // write to the local build cache.\n\n    if (this._cloudBuildCacheProvider?.isCacheWriteAllowed) {\n      if (localCacheEntryPath) {\n        cacheEntryBuffer = await FileSystem.readFileToBufferAsync(localCacheEntryPath);\n      } else {\n        throw new InternalError('Expected the local cache entry path to be set.');\n      }\n\n      setCloudCacheEntryPromise = this._cloudBuildCacheProvider?.trySetCacheEntryBufferAsync(\n        terminal,\n        cacheId,\n        cacheEntryBuffer\n      );\n    }\n\n    const updateCloudCacheSuccess: boolean | undefined = (await setCloudCacheEntryPromise) ?? true;\n\n    const success: boolean = updateCloudCacheSuccess && !!localCacheEntryPath;\n    if (success) {\n      terminal.writeLine('Successfully set cache entry.');\n      terminal.writeVerboseLine(`Cache key: ${cacheId}`);\n    } else if (!localCacheEntryPath && updateCloudCacheSuccess) {\n      terminal.writeWarningLine('Unable to set local cache entry.');\n    } else if (localCacheEntryPath && !updateCloudCacheSuccess) {\n      terminal.writeWarningLine('Unable to set cloud cache entry.');\n    } else {\n      terminal.writeWarningLine('Unable to set both cloud and local cache entries.');\n    }\n\n    return success;\n  }\n\n  /**\n   * Walks the declared output folders of the project and collects a list of files.\n   * @returns The list of output files as project-relative paths, or `undefined` if a\n   *   symbolic link was encountered.\n   */\n  private async _tryCollectPathsToCacheAsync(terminal: ITerminal): Promise<IPathsToCache | undefined> {\n    const projectFolderPath: string = this._project.projectFolder;\n    const outputFilePaths: string[] = [];\n    const queue: [string, string][] = [];\n\n    const filteredOutputFolderNames: string[] = [];\n\n    let hasSymbolicLinks: boolean = false;\n\n    // Adds child directories to the queue, files to the path list, and bails on symlinks\n    function processChildren(relativePath: string, diskPath: string, children: FolderItem[]): void {\n      for (const child of children) {\n        const childRelativePath: string = `${relativePath}/${child.name}`;\n        if (child.isSymbolicLink()) {\n          terminal.writeError(\n            `Unable to include \"${childRelativePath}\" in build cache. It is a symbolic link.`\n          );\n          hasSymbolicLinks = true;\n        } else if (child.isDirectory()) {\n          queue.push([childRelativePath, `${diskPath}/${child.name}`]);\n        } else {\n          outputFilePaths.push(childRelativePath);\n        }\n      }\n    }\n\n    // Handle declared output folders.\n    for (const outputFolder of this._projectOutputFolderNames) {\n      const diskPath: string = `${projectFolderPath}/${outputFolder}`;\n      try {\n        const children: FolderItem[] = await FileSystem.readFolderItemsAsync(diskPath);\n        processChildren(outputFolder, diskPath, children);\n        // The folder exists, record it\n        filteredOutputFolderNames.push(outputFolder);\n      } catch (error) {\n        if (!FileSystem.isNotExistError(error as Error)) {\n          throw error;\n        }\n\n        // If the folder does not exist, ignore it.\n      }\n    }\n\n    for (const [relativePath, diskPath] of queue) {\n      const children: FolderItem[] = await FileSystem.readFolderItemsAsync(diskPath);\n      processChildren(relativePath, diskPath, children);\n    }\n\n    if (hasSymbolicLinks) {\n      // Symbolic links do not round-trip safely.\n      return undefined;\n    }\n\n    // Ensure stable output path order.\n    outputFilePaths.sort();\n\n    return {\n      outputFilePaths,\n      filteredOutputFolderNames\n    };\n  }\n\n  private _getTarLogFilePath(cacheId: string, mode: 'tar' | 'untar'): string {\n    return path.join(this._project.projectRushTempFolder, `${cacheId}.${mode}.log`);\n  }\n\n  private static _getCacheId(options: IProjectBuildCacheOptions): string | undefined {\n    const {\n      buildCacheConfiguration,\n      project: { packageName },\n      operationStateHash,\n      phaseName\n    } = options;\n    return buildCacheConfiguration.getCacheEntryId({\n      projectName: packageName,\n      projectStateHash: operationStateHash,\n      phaseName\n    });\n  }\n}\n"]}