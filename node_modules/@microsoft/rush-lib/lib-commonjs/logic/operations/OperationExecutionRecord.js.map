{"version":3,"file":"OperationExecutionRecord.js","sourceRoot":"","sources":["../../../src/logic/operations/OperationExecutionRecord.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as crypto from 'crypto';\n\nimport {\n  type ITerminal,\n  type ITerminalProvider,\n  DiscardStdoutTransform,\n  SplitterTransform,\n  StderrLineTransform,\n  StdioSummarizer,\n  TextRewriterTransform,\n  Terminal,\n  type TerminalWritable\n} from '@rushstack/terminal';\nimport { InternalError, NewlineKind } from '@rushstack/node-core-library';\nimport { CollatedTerminal, type CollatedWriter, type StreamCollator } from '@rushstack/stream-collator';\n\nimport { OperationStatus, TERMINAL_STATUSES } from './OperationStatus';\nimport type { IOperationRunner, IOperationRunnerContext } from './IOperationRunner';\nimport type { Operation } from './Operation';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { OperationMetadataManager } from './OperationMetadataManager';\nimport type { IPhase } from '../../api/CommandLineConfiguration';\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport { CollatedTerminalProvider } from '../../utilities/CollatedTerminalProvider';\nimport {\n  getProjectLogFilePaths,\n  type ILogFilePaths,\n  initializeProjectLogFilesAsync\n} from './ProjectLogWritable';\nimport type { IOperationExecutionResult } from './IOperationExecutionResult';\nimport type { IInputsSnapshot } from '../incremental/InputsSnapshot';\nimport { RushConstants } from '../RushConstants';\nimport type { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\nimport type { IEnvironment } from '../../utilities/Utilities';\n\nexport interface IOperationExecutionRecordContext {\n  streamCollator: StreamCollator;\n  onOperationStatusChanged?: (record: OperationExecutionRecord) => void;\n  createEnvironment?: (record: OperationExecutionRecord) => IEnvironment;\n\n  debugMode: boolean;\n  quietMode: boolean;\n}\n\n/**\n * Internal class representing everything about executing an operation\n *\n * @internal\n */\nexport class OperationExecutionRecord implements IOperationRunnerContext, IOperationExecutionResult {\n  /**\n   * The associated operation.\n   */\n  public readonly operation: Operation;\n\n  /**\n   * The error which occurred while executing this operation, this is stored in case we need\n   * it later (for example to re-print errors at end of execution).\n   */\n  public error: Error | undefined = undefined;\n\n  /**\n   * This number represents how far away this Operation is from the furthest \"root\" operation (i.e.\n   * an operation with no consumers). This helps us to calculate the critical path (i.e. the\n   * longest chain of projects which must be executed in order, thereby limiting execution speed\n   * of the entire operation tree.\n   *\n   * This number is calculated via a memoized depth-first search, and when choosing the next\n   * operation to execute, the operation with the highest criticalPathLength is chosen.\n   *\n   * Example:\n   * ```\n   *        (0) A\n   *             \\\n   *          (1) B     C (0)         (applications)\n   *               \\   /|\\\n   *                \\ / | \\\n   *             (2) D  |  X (1)      (utilities)\n   *                    | / \\\n   *                    |/   \\\n   *                (2) Y     Z (2)   (other utilities)\n   *\n   * All roots (A & C) have a criticalPathLength of 0.\n   * B has a score of 1, since A depends on it.\n   * D has a score of 2, since we look at the longest chain (e.g D->B->A is longer than D->C)\n   * X has a score of 1, since the only package which depends on it is A\n   * Z has a score of 2, since only X depends on it, and X has a score of 1\n   * Y has a score of 2, since the chain Y->X->C is longer than Y->C\n   * ```\n   *\n   * The algorithm is implemented in AsyncOperationQueue.ts as calculateCriticalPathLength()\n   */\n  public criticalPathLength: number | undefined = undefined;\n\n  /**\n   * The set of operations that must complete before this operation executes.\n   */\n  public readonly dependencies: Set<OperationExecutionRecord> = new Set();\n  /**\n   * The set of operations that depend on this operation.\n   */\n  public readonly consumers: Set<OperationExecutionRecord> = new Set();\n\n  public readonly stopwatch: Stopwatch = new Stopwatch();\n  public readonly stdioSummarizer: StdioSummarizer = new StdioSummarizer({\n    // Allow writing to this object after transforms have been closed. We clean it up manually in a finally block.\n    preventAutoclose: true\n  });\n\n  public readonly runner: IOperationRunner;\n  public readonly associatedPhase: IPhase | undefined;\n  public readonly associatedProject: RushConfigurationProject | undefined;\n  public readonly _operationMetadataManager: OperationMetadataManager | undefined;\n\n  public logFilePaths: ILogFilePaths | undefined;\n\n  private readonly _context: IOperationExecutionRecordContext;\n\n  private _collatedWriter: CollatedWriter | undefined = undefined;\n  private _status: OperationStatus;\n  private _stateHash: string | undefined;\n\n  public constructor(operation: Operation, context: IOperationExecutionRecordContext) {\n    const { runner, associatedPhase, associatedProject } = operation;\n\n    if (!runner) {\n      throw new InternalError(\n        `Operation for phase '${associatedPhase?.name}' and project '${associatedProject?.packageName}' has no runner.`\n      );\n    }\n\n    this.operation = operation;\n    this.runner = runner;\n    this.associatedPhase = associatedPhase;\n    this.associatedProject = associatedProject;\n    this.logFilePaths = undefined;\n\n    this._operationMetadataManager =\n      associatedPhase && associatedProject\n        ? new OperationMetadataManager({\n            phase: associatedPhase,\n            rushProject: associatedProject,\n            operation\n          })\n        : undefined;\n\n    this._context = context;\n    this._status = operation.dependencies.size > 0 ? OperationStatus.Waiting : OperationStatus.Ready;\n  }\n\n  public get name(): string {\n    return this.runner.name;\n  }\n\n  public get weight(): number {\n    return this.operation.weight;\n  }\n\n  public get debugMode(): boolean {\n    return this._context.debugMode;\n  }\n\n  public get quietMode(): boolean {\n    return this._context.quietMode;\n  }\n\n  public get collatedWriter(): CollatedWriter {\n    // Lazy instantiate because the registerTask() call affects display ordering\n    if (!this._collatedWriter) {\n      this._collatedWriter = this._context.streamCollator.registerTask(this.name);\n    }\n    return this._collatedWriter;\n  }\n\n  public get nonCachedDurationMs(): number | undefined {\n    // Lazy calculated because the state file is created/restored later on\n    return this._operationMetadataManager?.stateFile.state?.nonCachedDurationMs;\n  }\n\n  public get cobuildRunnerId(): string | undefined {\n    // Lazy calculated because the state file is created/restored later on\n    return this._operationMetadataManager?.stateFile.state?.cobuildRunnerId;\n  }\n\n  public get environment(): IEnvironment | undefined {\n    return this._context.createEnvironment?.(this);\n  }\n\n  public get metadataFolderPath(): string | undefined {\n    return this._operationMetadataManager?.metadataFolderPath;\n  }\n\n  public get isTerminal(): boolean {\n    return TERMINAL_STATUSES.has(this.status);\n  }\n\n  /**\n   * The current execution status of an operation. Operations start in the 'ready' state,\n   * but can be 'blocked' if an upstream operation failed. It is 'executing' when\n   * the operation is executing. Once execution is complete, it is either 'success' or\n   * 'failure'.\n   */\n  public get status(): OperationStatus {\n    return this._status;\n  }\n  public set status(newStatus: OperationStatus) {\n    if (newStatus === this._status) {\n      return;\n    }\n    this._status = newStatus;\n    this._context.onOperationStatusChanged?.(this);\n  }\n\n  public get silent(): boolean {\n    return !this.operation.enabled || this.runner.silent;\n  }\n\n  public get stateHash(): string {\n    if (!this._stateHash) {\n      throw new Error(\n        'Operation state hash is not calculated yet, you must call `calculateStateHash` first.'\n      );\n    }\n    return this._stateHash;\n  }\n\n  /**\n   * {@inheritdoc IOperationRunnerContext.runWithTerminalAsync}\n   */\n  public async runWithTerminalAsync<T>(\n    callback: (terminal: ITerminal, terminalProvider: ITerminalProvider) => Promise<T>,\n    options: {\n      createLogFile: boolean;\n      logFileSuffix: string;\n    }\n  ): Promise<T> {\n    const { associatedPhase, associatedProject, stdioSummarizer } = this;\n    const { createLogFile, logFileSuffix = '' } = options;\n\n    const logFilePaths: ILogFilePaths | undefined =\n      createLogFile && associatedProject && associatedPhase && this._operationMetadataManager\n        ? getProjectLogFilePaths({\n            project: associatedProject,\n            logFilenameIdentifier: `${this._operationMetadataManager.logFilenameIdentifier}${logFileSuffix}`\n          })\n        : undefined;\n    this.logFilePaths = logFilePaths;\n\n    const projectLogWritable: TerminalWritable | undefined = logFilePaths\n      ? await initializeProjectLogFilesAsync({\n          logFilePaths,\n          enableChunkedOutput: true\n        })\n      : undefined;\n\n    try {\n      //#region OPERATION LOGGING\n      // TERMINAL PIPELINE:\n      //\n      //                             +--> quietModeTransform? --> collatedWriter\n      //                             |\n      // normalizeNewlineTransform --1--> stderrLineTransform --2--> projectLogWritable\n      //                                                        |\n      //                                                        +--> stdioSummarizer\n      const destination: TerminalWritable = projectLogWritable\n        ? new SplitterTransform({\n            destinations: [projectLogWritable, stdioSummarizer]\n          })\n        : stdioSummarizer;\n\n      const stderrLineTransform: StderrLineTransform = new StderrLineTransform({\n        destination,\n        newlineKind: NewlineKind.Lf // for StdioSummarizer\n      });\n\n      const splitterTransform1: SplitterTransform = new SplitterTransform({\n        destinations: [\n          this.quietMode\n            ? new DiscardStdoutTransform({ destination: this.collatedWriter })\n            : this.collatedWriter,\n          stderrLineTransform\n        ]\n      });\n\n      const normalizeNewlineTransform: TextRewriterTransform = new TextRewriterTransform({\n        destination: splitterTransform1,\n        normalizeNewlines: NewlineKind.Lf,\n        ensureNewlineAtEnd: true\n      });\n\n      const collatedTerminal: CollatedTerminal = new CollatedTerminal(normalizeNewlineTransform);\n      const terminalProvider: CollatedTerminalProvider = new CollatedTerminalProvider(collatedTerminal, {\n        debugEnabled: this.debugMode\n      });\n      const terminal: Terminal = new Terminal(terminalProvider);\n      //#endregion\n\n      const result: T = await callback(terminal, terminalProvider);\n\n      normalizeNewlineTransform.close();\n\n      // If the pipeline is wired up correctly, then closing normalizeNewlineTransform should\n      // have closed projectLogWritable.\n      if (projectLogWritable?.isOpen) {\n        throw new InternalError('The output file handle was not closed');\n      }\n\n      return result;\n    } finally {\n      projectLogWritable?.close();\n    }\n  }\n\n  public async executeAsync({\n    onStart,\n    onResult\n  }: {\n    onStart: (record: OperationExecutionRecord) => Promise<OperationStatus | undefined>;\n    onResult: (record: OperationExecutionRecord) => Promise<void>;\n  }): Promise<void> {\n    if (!this.isTerminal) {\n      this.stopwatch.reset();\n    }\n    this.stopwatch.start();\n    this.status = OperationStatus.Executing;\n\n    try {\n      const earlyReturnStatus: OperationStatus | undefined = await onStart(this);\n      // When the operation status returns by the hook, bypass the runner execution.\n      if (earlyReturnStatus) {\n        this.status = earlyReturnStatus;\n      } else {\n        // If the operation is disabled, skip the runner and directly mark as Skipped.\n        // However, if the operation is a NoOp, return NoOp so that cache entries can still be written.\n        this.status = this.operation.enabled\n          ? await this.runner.executeAsync(this)\n          : this.runner.isNoOp\n            ? OperationStatus.NoOp\n            : OperationStatus.Skipped;\n      }\n      // Delegate global state reporting\n      await onResult(this);\n    } catch (error) {\n      this.status = OperationStatus.Failure;\n      this.error = error;\n      // Delegate global state reporting\n      await onResult(this);\n    } finally {\n      if (this.isTerminal) {\n        this._collatedWriter?.close();\n        this.stdioSummarizer.close();\n        this.stopwatch.stop();\n      }\n    }\n  }\n\n  public calculateStateHash(options: {\n    inputsSnapshot: IInputsSnapshot;\n    buildCacheConfiguration: BuildCacheConfiguration;\n  }): string {\n    if (!this._stateHash) {\n      const {\n        inputsSnapshot,\n        buildCacheConfiguration: { cacheHashSalt }\n      } = options;\n\n      // Examples of data in the config hash:\n      // - CLI parameters (ShellOperationRunner)\n      const configHash: string = this.runner.getConfigHash();\n\n      const { associatedProject, associatedPhase } = this;\n      // Examples of data in the local state hash:\n      // - Environment variables specified in `dependsOnEnvVars`\n      // - Git hashes of tracked files in the associated project\n      // - Git hash of the shrinkwrap file for the project\n      // - Git hashes of any files specified in `dependsOnAdditionalFiles` (must not be associated with a project)\n      const localStateHash: string | undefined =\n        associatedProject &&\n        inputsSnapshot.getOperationOwnStateHash(associatedProject, associatedPhase?.name);\n\n      // The final state hashes of operation dependencies are factored into the hash to ensure that any\n      // state changes in dependencies will invalidate the cache.\n      const dependencyHashes: string[] = Array.from(this.dependencies, (record) => {\n        return `${RushConstants.hashDelimiter}${record.name}=${record.calculateStateHash(options)}`;\n      }).sort();\n\n      const hasher: crypto.Hash = crypto.createHash('sha1');\n      // This property is used to force cache bust when version changes, e.g. when fixing bugs in the content\n      // of the build cache.\n      hasher.update(`${RushConstants.buildCacheVersion}`);\n\n      if (cacheHashSalt !== undefined) {\n        // This allows repository owners to force a cache bust by changing the salt.\n        // A common use case is to invalidate the cache when adding/removing/updating rush plugins that alter the build output.\n        hasher.update(cacheHashSalt);\n      }\n\n      for (const dependencyHash of dependencyHashes) {\n        hasher.update(dependencyHash);\n      }\n\n      if (localStateHash) {\n        hasher.update(`${RushConstants.hashDelimiter}${localStateHash}`);\n      }\n\n      hasher.update(`${RushConstants.hashDelimiter}${configHash}`);\n\n      const hash: string = hasher.digest('hex');\n      this._stateHash = hash;\n    }\n    return this._stateHash;\n  }\n}\n"]}