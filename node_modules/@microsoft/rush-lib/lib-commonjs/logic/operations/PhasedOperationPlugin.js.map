{"version":3,"file":"PhasedOperationPlugin.js","sourceRoot":"","sources":["../../../src/logic/operations/PhasedOperationPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport type { IPhase } from '../../api/CommandLineConfiguration';\n\nimport { Operation } from './Operation';\nimport type {\n  ICreateOperationsContext,\n  IPhasedCommandPlugin,\n  PhasedCommandHooks\n} from '../../pluginFramework/PhasedCommandHooks';\nimport type { IOperationSettings } from '../../api/RushProjectConfiguration';\n\nconst PLUGIN_NAME: 'PhasedOperationPlugin' = 'PhasedOperationPlugin';\n\n/**\n * Core phased command plugin that provides the functionality for generating a base operation graph\n * from the set of selected projects and phases.\n */\nexport class PhasedOperationPlugin implements IPhasedCommandPlugin {\n  public apply(hooks: PhasedCommandHooks): void {\n    hooks.createOperations.tap(PLUGIN_NAME, createOperations);\n  }\n}\n\nfunction createOperations(\n  existingOperations: Set<Operation>,\n  context: ICreateOperationsContext\n): Set<Operation> {\n  const {\n    projectsInUnknownState: changedProjects,\n    phaseOriginal,\n    phaseSelection,\n    projectSelection,\n    projectConfigurations,\n    includePhaseDeps,\n    isInitial\n  } = context;\n  const operationsWithWork: Set<Operation> = new Set();\n\n  const operations: Map<string, Operation> = new Map();\n\n  // Create tasks for selected phases and projects\n  for (const phase of phaseOriginal) {\n    for (const project of projectSelection) {\n      getOrCreateOperation(phase, project);\n    }\n  }\n\n  // Recursively expand all consumers in the `operationsWithWork` set.\n  for (const operation of operationsWithWork) {\n    for (const consumer of operation.consumers) {\n      operationsWithWork.add(consumer);\n    }\n  }\n\n  for (const operation of operations.values()) {\n    if (!operationsWithWork.has(operation)) {\n      // This operation is in scope, but did not change since it was last executed by the current command.\n      // However, we have no state tracking across executions, so treat as unknown.\n      operation.enabled = false;\n    }\n  }\n\n  return existingOperations;\n\n  // Binds phaseSelection, projectSelection, operations via closure\n  function getOrCreateOperation(phase: IPhase, project: RushConfigurationProject): Operation {\n    const key: string = getOperationKey(phase, project);\n    let operation: Operation | undefined = operations.get(key);\n\n    if (!operation) {\n      const {\n        dependencies: { self, upstream },\n        name,\n        logFilenameIdentifier\n      } = phase;\n      const operationSettings: IOperationSettings | undefined = projectConfigurations\n        .get(project)\n        ?.operationSettingsByOperationName.get(name);\n      operation = new Operation({\n        project,\n        phase,\n        settings: operationSettings,\n        logFilenameIdentifier: logFilenameIdentifier\n      });\n\n      if (!phaseSelection.has(phase) || !projectSelection.has(project)) {\n        if (includePhaseDeps && isInitial) {\n          operationsWithWork.add(operation);\n        } else {\n          // Not in scope. Mark disabled, which will report as OperationStatus.Skipped.\n          operation.enabled = false;\n        }\n      } else if (changedProjects.has(project)) {\n        operationsWithWork.add(operation);\n      }\n\n      operations.set(key, operation);\n      existingOperations.add(operation);\n\n      for (const depPhase of self) {\n        operation.addDependency(getOrCreateOperation(depPhase, project));\n      }\n\n      if (upstream.size) {\n        const { dependencyProjects } = project;\n        if (dependencyProjects.size) {\n          for (const depPhase of upstream) {\n            for (const dependencyProject of dependencyProjects) {\n              operation.addDependency(getOrCreateOperation(depPhase, dependencyProject));\n            }\n          }\n        }\n      }\n    }\n\n    return operation;\n  }\n}\n\n// Convert the [IPhase, RushConfigurationProject] into a value suitable for use as a Map key\nfunction getOperationKey(phase: IPhase, project: RushConfigurationProject): string {\n  return `${project.packageName};${phase.name}`;\n}\n"]}