"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDisplayName = exports.formatCommand = exports.getCustomParameterValuesByPhase = exports.initializeShellOperationRunner = exports.ShellOperationRunnerPlugin = exports.PLUGIN_NAME = void 0;
const RushConstants_1 = require("../RushConstants");
const NullOperationRunner_1 = require("./NullOperationRunner");
const ShellOperationRunner_1 = require("./ShellOperationRunner");
const OperationStatus_1 = require("./OperationStatus");
exports.PLUGIN_NAME = 'ShellOperationRunnerPlugin';
/**
 * Core phased command plugin that provides the functionality for executing an operation via shell command.
 */
class ShellOperationRunnerPlugin {
    apply(hooks) {
        hooks.createOperations.tap(exports.PLUGIN_NAME, function createShellOperations(operations, context) {
            var _a;
            const { rushConfiguration, isInitial } = context;
            const getCustomParameterValuesForPhase = getCustomParameterValuesByPhase();
            for (const operation of operations) {
                const { associatedPhase: phase, associatedProject: project } = operation;
                if (phase && project && !operation.runner) {
                    // This is a shell command. In the future, may consider having a property on the initial operation
                    // to specify a runner type requested in rush-project.json
                    const customParameterValues = getCustomParameterValuesForPhase(phase);
                    const displayName = getDisplayName(phase, project);
                    const { name: phaseName, shellCommand } = phase;
                    const { scripts } = project.packageJson;
                    // This is the command that will be used to identify the cache entry for this operation
                    const commandForHash = shellCommand !== null && shellCommand !== void 0 ? shellCommand : scripts === null || scripts === void 0 ? void 0 : scripts[phaseName];
                    // For execution of non-initial runs, prefer the `:incremental` script if it exists.
                    // However, the `shellCommand` value still takes precedence per the spec for that feature.
                    const commandToRun = (_a = shellCommand !== null && shellCommand !== void 0 ? shellCommand : (!isInitial ? scripts === null || scripts === void 0 ? void 0 : scripts[`${phaseName}:incremental`] : undefined)) !== null && _a !== void 0 ? _a : scripts === null || scripts === void 0 ? void 0 : scripts[phaseName];
                    operation.runner = initializeShellOperationRunner({
                        phase,
                        project,
                        displayName,
                        commandForHash,
                        commandToRun,
                        customParameterValues,
                        rushConfiguration
                    });
                }
            }
            return operations;
        });
    }
}
exports.ShellOperationRunnerPlugin = ShellOperationRunnerPlugin;
function initializeShellOperationRunner(options) {
    const { phase, project, commandToRun: rawCommandToRun, displayName } = options;
    if (typeof rawCommandToRun !== 'string' && phase.missingScriptBehavior === 'error') {
        throw new Error(`The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`);
    }
    if (rawCommandToRun) {
        const { commandForHash: rawCommandForHash, customParameterValues } = options;
        const commandToRun = formatCommand(rawCommandToRun, customParameterValues);
        const commandForHash = rawCommandForHash
            ? formatCommand(rawCommandForHash, customParameterValues)
            : commandToRun;
        return new ShellOperationRunner_1.ShellOperationRunner({
            commandToRun,
            commandForHash,
            displayName,
            phase,
            rushProject: project
        });
    }
    else {
        // Empty build script indicates a no-op, so use a no-op runner
        return new NullOperationRunner_1.NullOperationRunner({
            name: displayName,
            result: OperationStatus_1.OperationStatus.NoOp,
            silent: phase.missingScriptBehavior === 'silent'
        });
    }
}
exports.initializeShellOperationRunner = initializeShellOperationRunner;
/**
 * Memoizer for custom parameter values by phase
 * @returns A function that returns the custom parameter values for a given phase
 */
function getCustomParameterValuesByPhase() {
    const customParametersByPhase = new Map();
    function getCustomParameterValuesForPhase(phase) {
        let customParameterValues = customParametersByPhase.get(phase);
        if (!customParameterValues) {
            customParameterValues = [];
            for (const tsCommandLineParameter of phase.associatedParameters) {
                tsCommandLineParameter.appendToArgList(customParameterValues);
            }
            customParametersByPhase.set(phase, customParameterValues);
        }
        return customParameterValues;
    }
    return getCustomParameterValuesForPhase;
}
exports.getCustomParameterValuesByPhase = getCustomParameterValuesByPhase;
function formatCommand(rawCommand, customParameterValues) {
    if (!rawCommand) {
        return '';
    }
    else {
        const fullCommand = `${rawCommand} ${customParameterValues.join(' ')}`;
        return process.platform === 'win32' ? (0, ShellOperationRunner_1.convertSlashesForWindows)(fullCommand) : fullCommand;
    }
}
exports.formatCommand = formatCommand;
function getDisplayName(phase, project) {
    if (phase.isSynthetic) {
        // Because this is a synthetic phase, just use the project name because there aren't any other phases
        return project.packageName;
    }
    else {
        const phaseNameWithoutPrefix = phase.name.slice(RushConstants_1.RushConstants.phaseNamePrefix.length);
        return `${project.packageName} (${phaseNameWithoutPrefix})`;
    }
}
exports.getDisplayName = getDisplayName;
//# sourceMappingURL=ShellOperationRunnerPlugin.js.map