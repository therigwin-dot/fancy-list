{"version":3,"file":"BuildPlanPlugin.js","sourceRoot":"","sources":["../../../src/logic/operations/BuildPlanPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { ITerminal } from '@rushstack/terminal';\nimport type {\n  IExecuteOperationsContext,\n  IPhasedCommandPlugin,\n  PhasedCommandHooks\n} from '../../pluginFramework/PhasedCommandHooks';\nimport type { Operation } from './Operation';\nimport { clusterOperations, type IOperationBuildCacheContext } from './CacheableOperationPlugin';\nimport { DisjointSet } from '../cobuild/DisjointSet';\nimport type { IOperationExecutionResult } from './IOperationExecutionResult';\nimport { RushProjectConfiguration } from '../../api/RushProjectConfiguration';\n\nconst PLUGIN_NAME: 'BuildPlanPlugin' = 'BuildPlanPlugin';\n\ninterface IBuildPlanOperationCacheContext {\n  cacheDisabledReason: IOperationBuildCacheContext['cacheDisabledReason'];\n}\n\ninterface ICobuildPlan {\n  summary: {\n    maxWidth: number;\n    maxDepth: number;\n    numberOfNodesPerDepth: number[];\n  };\n  operations: Operation[];\n  clusters: Set<Operation>[];\n  buildCacheByOperation: Map<Operation, IBuildPlanOperationCacheContext>;\n  clusterByOperation: Map<Operation, Set<Operation>>;\n}\n\nexport class BuildPlanPlugin implements IPhasedCommandPlugin {\n  private readonly _terminal: ITerminal;\n\n  public constructor(terminal: ITerminal) {\n    this._terminal = terminal;\n  }\n\n  public apply(hooks: PhasedCommandHooks): void {\n    const terminal: ITerminal = this._terminal;\n    hooks.beforeExecuteOperations.tap(PLUGIN_NAME, createBuildPlan);\n\n    function createBuildPlan(\n      recordByOperation: Map<Operation, IOperationExecutionResult>,\n      context: IExecuteOperationsContext\n    ): void {\n      const { projectConfigurations, inputsSnapshot } = context;\n      const disjointSet: DisjointSet<Operation> = new DisjointSet<Operation>();\n      const operations: Operation[] = [...recordByOperation.keys()];\n      for (const operation of operations) {\n        disjointSet.add(operation);\n      }\n      const buildCacheByOperation: Map<Operation, IBuildPlanOperationCacheContext> = new Map<\n        Operation,\n        IBuildPlanOperationCacheContext\n      >();\n\n      for (const operation of operations) {\n        const { associatedProject, associatedPhase } = operation;\n        if (associatedProject && associatedPhase) {\n          const projectConfiguration: RushProjectConfiguration | undefined =\n            projectConfigurations.get(associatedProject);\n          const fileHashes: ReadonlyMap<string, string> | undefined =\n            inputsSnapshot?.getTrackedFileHashesForOperation(associatedProject, associatedPhase.name);\n          if (!fileHashes) {\n            continue;\n          }\n          const cacheDisabledReason: string | undefined =\n            RushProjectConfiguration.getCacheDisabledReasonForProject({\n              projectConfiguration,\n              trackedFileNames: fileHashes.keys(),\n              isNoOp: operation.isNoOp,\n              phaseName: associatedPhase.name\n            });\n          buildCacheByOperation.set(operation, { cacheDisabledReason });\n        }\n      }\n      clusterOperations(disjointSet, buildCacheByOperation);\n      const buildPlan: ICobuildPlan = createCobuildPlan(disjointSet, terminal, buildCacheByOperation);\n      logCobuildBuildPlan(buildPlan, terminal);\n    }\n  }\n}\n\n/**\n * Output the build plan summary, this will include the depth of the build plan, the width of the build plan, and\n * the number of nodes at each depth.\n *\n * Example output:\n```\nBuild Plan Depth (deepest dependency tree): 3\nBuild Plan Width (maximum parallelism): 7\nNumber of Nodes per Depth: 2, 7, 5\nPlan @ Depth 0 has 2 nodes and 0 dependents:\n- b (build)\n- a (build)\nPlan @ Depth 1 has 7 nodes and 2 dependents:\n- c (build)\n- d (build)\n- f (pre-build)\n- g (pre-build)\n- e (build)\n- f (build)\n- g (build)\nPlan @ Depth 2 has 5 nodes and 9 dependents:\n- c (build)\n- d (build)\n- e (build)\n- f (build)\n- g (build)\n```\n * The summary data can be useful for understanding the shape of the build plan. The depth of the build plan is the\n *  longest dependency chain in the build plan. The width of the build plan is the maximum number of operations that\n *  can be executed in parallel. The number of nodes per depth is the number of operations that can be executed in parallel\n *  at each depth. **This does not currently include clustering information, which further restricts which operations can\n *  be executed in parallel.**\n * The depth data can be useful for debugging situations where cobuilds aren't utilizing multiple agents as expected. There may be\n *  some long dependency trees that can't be executed in parallel. Or there may be some key operations at the base of the\n *  build graph that are blocking the rest of the build.\n */\nfunction generateCobuildPlanSummary(operations: Operation[], terminal: ITerminal): ICobuildPlan['summary'] {\n  const numberOfDependenciesByOperation: Map<Operation, number> = new Map<Operation, number>();\n\n  const queue: Operation[] = operations.filter((e) => e.dependencies.size === 0);\n  const seen: Set<Operation> = new Set<Operation>(queue);\n  for (const operation of queue) {\n    numberOfDependenciesByOperation.set(operation, 0);\n  }\n\n  /**\n   * Traverse the build plan to determine the number of dependencies for each operation. This is done by starting\n   *  at the base of the build plan and traversing the graph in a breadth-first manner. We use the parent operation\n   *  to determine the number of dependencies for each child operation. This allows us to detect cases where no-op\n   *  operations are strung together, and correctly mark the first real operation as being a root operation.\n   */\n  while (queue.length > 0) {\n    const operation: Operation = queue.shift()!;\n    const increment: number = operation.isNoOp ? 0 : 1;\n    for (const consumer of operation.consumers) {\n      const numberOfDependencies: number = (numberOfDependenciesByOperation.get(operation) ?? 0) + increment;\n      numberOfDependenciesByOperation.set(consumer, numberOfDependencies);\n      if (!seen.has(consumer)) {\n        queue.push(consumer);\n        seen.add(consumer);\n      }\n    }\n  }\n\n  const layerQueue: Operation[] = [];\n  for (const operation of operations) {\n    if (operation.isNoOp) {\n      continue;\n    }\n\n    const numberOfDependencies: number = numberOfDependenciesByOperation.get(operation) ?? 0;\n    if (numberOfDependencies === 0) {\n      layerQueue.push(operation);\n    }\n  }\n\n  let nextLayer: Set<Operation> = new Set<Operation>();\n  const remainingOperations: Set<Operation> = new Set<Operation>(operations);\n  let depth: number = 0;\n  let maxWidth: number = layerQueue.length;\n  const numberOfNodes: number[] = [maxWidth];\n  const depthToOperationsMap: Map<number, Set<Operation>> = new Map<number, Set<Operation>>();\n  depthToOperationsMap.set(depth, new Set(layerQueue));\n\n  /**\n   * Determine the depth and width of the build plan. We start with the inner layer and gradually traverse layer by\n   *  layer up the tree/graph until we have no more nodes to process. At each layer, we determine the\n   *  number of executable operations.\n   */\n  do {\n    if (layerQueue.length === 0) {\n      layerQueue.push(...nextLayer);\n      const realOperations: Operation[] = layerQueue.filter((e) => !e.isNoOp);\n      if (realOperations.length > 0) {\n        depth += 1;\n        depthToOperationsMap.set(depth, new Set(realOperations));\n        numberOfNodes.push(realOperations.length);\n      }\n      const currentWidth: number = realOperations.length;\n      if (currentWidth > maxWidth) {\n        maxWidth = currentWidth;\n      }\n      nextLayer = new Set();\n\n      if (layerQueue.length === 0) {\n        break;\n      }\n    }\n    const leaf: Operation = layerQueue.shift()!;\n    if (remainingOperations.delete(leaf)) {\n      for (const consumer of leaf.consumers) {\n        nextLayer.add(consumer);\n      }\n    }\n  } while (remainingOperations.size > 0);\n\n  terminal.writeLine(`Build Plan Depth (deepest dependency tree): ${depth + 1}`);\n  terminal.writeLine(`Build Plan Width (maximum parallelism): ${maxWidth}`);\n  terminal.writeLine(`Number of Nodes per Depth: ${numberOfNodes.join(', ')}`);\n  for (const [operationDepth, operationsAtDepth] of depthToOperationsMap) {\n    let numberOfDependents: number = 0;\n    for (let i: number = 0; i < operationDepth; i++) {\n      numberOfDependents += numberOfNodes[i];\n    }\n    terminal.writeLine(\n      `Plan @ Depth ${operationDepth} has ${numberOfNodes[operationDepth]} nodes and ${numberOfDependents} dependents:`\n    );\n    for (const operation of operationsAtDepth) {\n      if (!operation.runner?.isNoOp) {\n        terminal.writeLine(`- ${operation.runner?.name ?? 'unknown'}`);\n      }\n    }\n  }\n\n  return {\n    maxDepth: depth === 0 && numberOfNodes[0] !== 0 ? depth + 1 : 0,\n    maxWidth: maxWidth,\n    numberOfNodesPerDepth: numberOfNodes\n  };\n}\n\nfunction getName(op: Operation): string {\n  return op.runner?.name ?? 'unknown';\n}\n\n/**\n * Log the cobuild build plan by cluster. This is intended to help debug situations where cobuilds aren't\n *  utilizing multiple agents correctly.\n */\nfunction createCobuildPlan(\n  disjointSet: DisjointSet<Operation>,\n  terminal: ITerminal,\n  buildCacheByOperation: Map<Operation, IBuildPlanOperationCacheContext>\n): ICobuildPlan {\n  const clusters: Set<Operation>[] = [...disjointSet.getAllSets()];\n  const operations: Operation[] = clusters.flatMap((e) => Array.from(e));\n\n  const operationToClusterMap: Map<Operation, Set<Operation>> = new Map<Operation, Set<Operation>>();\n  for (const cluster of clusters) {\n    for (const operation of cluster) {\n      operationToClusterMap.set(operation, cluster);\n    }\n  }\n\n  return {\n    summary: generateCobuildPlanSummary(operations, terminal),\n    operations,\n    buildCacheByOperation,\n    clusterByOperation: operationToClusterMap,\n    clusters\n  };\n}\n\n/**\n * This method logs in depth details about the cobuild plan, including the operations in each cluster, the dependencies\n *  for each cluster, and the reason why each operation is clustered.\n */\nfunction logCobuildBuildPlan(buildPlan: ICobuildPlan, terminal: ITerminal): void {\n  const { operations, clusters, buildCacheByOperation, clusterByOperation } = buildPlan;\n\n  const executionPlan: Operation[] = [];\n  for (const operation of operations) {\n    if (!operation.isNoOp) {\n      executionPlan.push(operation);\n    }\n  }\n\n  // This is a lazy way of getting the waterfall chart, basically check for the latest\n  //  dependency and put this operation after that finishes.\n  const spacingByDependencyMap: Map<Operation, number> = new Map<Operation, number>();\n  for (let index: number = 0; index < executionPlan.length; index++) {\n    const operation: Operation = executionPlan[index];\n\n    const spacing: number = Math.max(\n      ...Array.from(operation.dependencies, (e) => {\n        const dependencySpacing: number | undefined = spacingByDependencyMap.get(e);\n        return dependencySpacing !== undefined ? dependencySpacing + 1 : 0;\n      }),\n      0\n    );\n    spacingByDependencyMap.set(operation, spacing);\n  }\n  executionPlan.sort((a, b) => {\n    const aSpacing: number = spacingByDependencyMap.get(a) ?? 0;\n    const bSpacing: number = spacingByDependencyMap.get(b) ?? 0;\n    return aSpacing - bSpacing;\n  });\n\n  terminal.writeLine('##################################################');\n  // Get the maximum name length for left padding.\n  let maxOperationNameLength: number = 1;\n  for (const operation of executionPlan) {\n    const name: string = getName(operation);\n    maxOperationNameLength = Math.max(maxOperationNameLength, name.length);\n  }\n  for (const operation of executionPlan) {\n    const spacing: number = spacingByDependencyMap.get(operation) ?? 0;\n    terminal.writeLine(\n      `${getName(operation).padStart(maxOperationNameLength + 1)}: ${'-'.repeat(spacing)}(${clusters.indexOf(\n        clusterByOperation.get(operation)!\n      )})`\n    );\n  }\n  terminal.writeLine('##################################################');\n\n  function getDependenciesForCluster(cluster: Set<Operation>): Set<Operation> {\n    const dependencies: Set<Operation> = new Set<Operation>();\n    for (const operation of cluster) {\n      for (const dependent of operation.dependencies) {\n        dependencies.add(dependent);\n      }\n    }\n    return dependencies;\n  }\n\n  function dedupeShards(ops: Set<Operation>): string[] {\n    const dedupedOperations: Set<string> = new Set<string>();\n    for (const operation of ops) {\n      dedupedOperations.add(\n        `${operation.associatedProject?.packageName ?? ''} (${operation.associatedPhase?.name})`\n      );\n    }\n    return [...dedupedOperations];\n  }\n\n  for (let clusterIndex: number = 0; clusterIndex < clusters.length; clusterIndex++) {\n    const cluster: Set<Operation> = clusters[clusterIndex];\n    const allClusterDependencies: Set<Operation> = getDependenciesForCluster(cluster);\n    const outOfClusterDependencies: Set<Operation> = new Set(\n      [...allClusterDependencies].filter((e) => !cluster.has(e))\n    );\n\n    terminal.writeLine(`Cluster ${clusterIndex}:`);\n    terminal.writeLine(`- Dependencies: ${dedupeShards(outOfClusterDependencies).join(', ') || 'none'}`);\n    // Only log clustering info, if we did in fact cluster.\n    if (cluster.size > 1) {\n      terminal.writeLine(\n        `- Clustered by: \\n${[...allClusterDependencies]\n          .filter((e) => buildCacheByOperation.get(e)?.cacheDisabledReason)\n          .map((e) => `  - (${e.runner?.name}) \"${buildCacheByOperation.get(e)?.cacheDisabledReason ?? ''}\"`)\n          .join('\\n')}`\n      );\n    }\n    terminal.writeLine(\n      `- Operations: ${Array.from(\n        cluster,\n        (e) => `${getName(e)}${e.runner?.isNoOp ? ' [SKIPPED]' : ''}`\n      ).join(', ')}`\n    );\n    terminal.writeLine('--------------------------------------------------');\n  }\n  terminal.writeLine('##################################################');\n}\n"]}