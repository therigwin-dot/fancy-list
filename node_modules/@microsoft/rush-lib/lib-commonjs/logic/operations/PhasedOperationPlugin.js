"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhasedOperationPlugin = void 0;
const Operation_1 = require("./Operation");
const PLUGIN_NAME = 'PhasedOperationPlugin';
/**
 * Core phased command plugin that provides the functionality for generating a base operation graph
 * from the set of selected projects and phases.
 */
class PhasedOperationPlugin {
    apply(hooks) {
        hooks.createOperations.tap(PLUGIN_NAME, createOperations);
    }
}
exports.PhasedOperationPlugin = PhasedOperationPlugin;
function createOperations(existingOperations, context) {
    const { projectsInUnknownState: changedProjects, phaseOriginal, phaseSelection, projectSelection, projectConfigurations, includePhaseDeps, isInitial } = context;
    const operationsWithWork = new Set();
    const operations = new Map();
    // Create tasks for selected phases and projects
    for (const phase of phaseOriginal) {
        for (const project of projectSelection) {
            getOrCreateOperation(phase, project);
        }
    }
    // Recursively expand all consumers in the `operationsWithWork` set.
    for (const operation of operationsWithWork) {
        for (const consumer of operation.consumers) {
            operationsWithWork.add(consumer);
        }
    }
    for (const operation of operations.values()) {
        if (!operationsWithWork.has(operation)) {
            // This operation is in scope, but did not change since it was last executed by the current command.
            // However, we have no state tracking across executions, so treat as unknown.
            operation.enabled = false;
        }
    }
    return existingOperations;
    // Binds phaseSelection, projectSelection, operations via closure
    function getOrCreateOperation(phase, project) {
        var _a;
        const key = getOperationKey(phase, project);
        let operation = operations.get(key);
        if (!operation) {
            const { dependencies: { self, upstream }, name, logFilenameIdentifier } = phase;
            const operationSettings = (_a = projectConfigurations
                .get(project)) === null || _a === void 0 ? void 0 : _a.operationSettingsByOperationName.get(name);
            operation = new Operation_1.Operation({
                project,
                phase,
                settings: operationSettings,
                logFilenameIdentifier: logFilenameIdentifier
            });
            if (!phaseSelection.has(phase) || !projectSelection.has(project)) {
                if (includePhaseDeps && isInitial) {
                    operationsWithWork.add(operation);
                }
                else {
                    // Not in scope. Mark disabled, which will report as OperationStatus.Skipped.
                    operation.enabled = false;
                }
            }
            else if (changedProjects.has(project)) {
                operationsWithWork.add(operation);
            }
            operations.set(key, operation);
            existingOperations.add(operation);
            for (const depPhase of self) {
                operation.addDependency(getOrCreateOperation(depPhase, project));
            }
            if (upstream.size) {
                const { dependencyProjects } = project;
                if (dependencyProjects.size) {
                    for (const depPhase of upstream) {
                        for (const dependencyProject of dependencyProjects) {
                            operation.addDependency(getOrCreateOperation(depPhase, dependencyProject));
                        }
                    }
                }
            }
        }
        return operation;
    }
}
// Convert the [IPhase, RushConfigurationProject] into a value suitable for use as a Map key
function getOperationKey(phase, project) {
    return `${project.packageName};${phase.name}`;
}
//# sourceMappingURL=PhasedOperationPlugin.js.map