{"version":3,"file":"CacheableOperationPlugin.js","sourceRoot":"","sources":["../../../src/logic/operations/CacheableOperationPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as crypto from 'crypto';\nimport { InternalError, NewlineKind, Sort } from '@rushstack/node-core-library';\nimport { CollatedTerminal, type CollatedWriter } from '@rushstack/stream-collator';\nimport { DiscardStdoutTransform, TextRewriterTransform } from '@rushstack/terminal';\nimport { SplitterTransform, type TerminalWritable, type ITerminal, Terminal } from '@rushstack/terminal';\n\nimport { CollatedTerminalProvider } from '../../utilities/CollatedTerminalProvider';\nimport { OperationStatus } from './OperationStatus';\nimport { CobuildLock, type ICobuildCompletedState } from '../cobuild/CobuildLock';\nimport { ProjectBuildCache } from '../buildCache/ProjectBuildCache';\nimport { RushConstants } from '../RushConstants';\nimport type { RushProjectConfiguration } from '../../api/RushProjectConfiguration';\nimport {\n  initializeProjectLogFilesAsync,\n  getProjectLogFilePaths,\n  type ILogFilePaths\n} from './ProjectLogWritable';\nimport type { CobuildConfiguration } from '../../api/CobuildConfiguration';\nimport { DisjointSet } from '../cobuild/DisjointSet';\nimport { PeriodicCallback } from './PeriodicCallback';\nimport { NullTerminalProvider } from '../../utilities/NullTerminalProvider';\n\nimport type { Operation } from './Operation';\nimport type { IOperationRunnerContext } from './IOperationRunner';\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport type {\n  IExecuteOperationsContext,\n  IPhasedCommandPlugin,\n  PhasedCommandHooks\n} from '../../pluginFramework/PhasedCommandHooks';\nimport type { IPhase } from '../../api/CommandLineConfiguration';\nimport type { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\nimport type { IOperationExecutionResult } from './IOperationExecutionResult';\nimport type { OperationExecutionRecord } from './OperationExecutionRecord';\n\nconst PLUGIN_NAME: 'CacheablePhasedOperationPlugin' = 'CacheablePhasedOperationPlugin';\nconst PERIODIC_CALLBACK_INTERVAL_IN_SECONDS: number = 10;\n\nexport interface IProjectDeps {\n  files: { [filePath: string]: string };\n  arguments: string;\n}\n\nexport interface IOperationBuildCacheContext {\n  isCacheWriteAllowed: boolean;\n  isCacheReadAllowed: boolean;\n\n  stateHash: string;\n\n  operationBuildCache: ProjectBuildCache | undefined;\n  cacheDisabledReason: string | undefined;\n  outputFolderNames: ReadonlyArray<string>;\n\n  cobuildLock: CobuildLock | undefined;\n\n  // The id of the cluster contains the operation, used when acquiring cobuild lock\n  cobuildClusterId: string | undefined;\n\n  // Controls the log for the cache subsystem\n  buildCacheTerminal: ITerminal | undefined;\n  buildCacheTerminalWritable: TerminalWritable | undefined;\n\n  periodicCallback: PeriodicCallback;\n  cacheRestored: boolean;\n  isCacheReadAttempted: boolean;\n}\n\nexport interface ICacheableOperationPluginOptions {\n  allowWarningsInSuccessfulBuild: boolean;\n  buildCacheConfiguration: BuildCacheConfiguration;\n  cobuildConfiguration: CobuildConfiguration | undefined;\n  terminal: ITerminal;\n}\n\nexport class CacheableOperationPlugin implements IPhasedCommandPlugin {\n  private _buildCacheContextByOperation: Map<Operation, IOperationBuildCacheContext> = new Map();\n\n  private readonly _options: ICacheableOperationPluginOptions;\n\n  public constructor(options: ICacheableOperationPluginOptions) {\n    this._options = options;\n  }\n\n  public apply(hooks: PhasedCommandHooks): void {\n    const { allowWarningsInSuccessfulBuild, buildCacheConfiguration, cobuildConfiguration } = this._options;\n\n    hooks.beforeExecuteOperations.tap(\n      PLUGIN_NAME,\n      (\n        recordByOperation: Map<Operation, IOperationExecutionResult>,\n        context: IExecuteOperationsContext\n      ): void => {\n        const { isIncrementalBuildAllowed, inputsSnapshot, projectConfigurations, isInitial } = context;\n\n        if (!inputsSnapshot) {\n          throw new Error(\n            `Build cache is only supported if running in a Git repository. Either disable the build cache or run Rush in a Git repository.`\n          );\n        }\n\n        const disjointSet: DisjointSet<Operation> | undefined = cobuildConfiguration?.cobuildFeatureEnabled\n          ? new DisjointSet()\n          : undefined;\n\n        for (const [operation, record] of recordByOperation) {\n          const stateHash: string = (record as OperationExecutionRecord).calculateStateHash({\n            inputsSnapshot,\n            buildCacheConfiguration\n          });\n          const { associatedProject, associatedPhase, runner, settings: operationSettings } = operation;\n          if (!associatedProject || !associatedPhase || !runner) {\n            return;\n          }\n\n          const { name: phaseName } = associatedPhase;\n\n          const projectConfiguration: RushProjectConfiguration | undefined =\n            projectConfigurations.get(associatedProject);\n\n          // This value can *currently* be cached per-project, but in the future the list of files will vary\n          // depending on the selected phase.\n          const fileHashes: ReadonlyMap<string, string> | undefined =\n            inputsSnapshot.getTrackedFileHashesForOperation(associatedProject, phaseName);\n\n          const cacheDisabledReason: string | undefined = projectConfiguration\n            ? projectConfiguration.getCacheDisabledReason(fileHashes.keys(), phaseName, operation.isNoOp)\n            : `Project does not have a ${RushConstants.rushProjectConfigFilename} configuration file, ` +\n              'or one provided by a rig, so it does not support caching.';\n\n          const metadataFolderPath: string | undefined = record.metadataFolderPath;\n\n          const outputFolderNames: string[] = metadataFolderPath ? [metadataFolderPath] : [];\n          const configuredOutputFolderNames: string[] | undefined = operationSettings?.outputFolderNames;\n          if (configuredOutputFolderNames) {\n            for (const folderName of configuredOutputFolderNames) {\n              outputFolderNames.push(folderName);\n            }\n          }\n\n          disjointSet?.add(operation);\n\n          const buildCacheContext: IOperationBuildCacheContext = {\n            // Supports cache writes by default for initial operations.\n            // Don't write during watch runs for performance reasons (and to avoid flooding the cache)\n            isCacheWriteAllowed: isInitial,\n            isCacheReadAllowed: isIncrementalBuildAllowed,\n            operationBuildCache: undefined,\n            outputFolderNames,\n            stateHash,\n            cacheDisabledReason,\n            cobuildLock: undefined,\n            cobuildClusterId: undefined,\n            buildCacheTerminal: undefined,\n            buildCacheTerminalWritable: undefined,\n            periodicCallback: new PeriodicCallback({\n              interval: PERIODIC_CALLBACK_INTERVAL_IN_SECONDS * 1000\n            }),\n            cacheRestored: false,\n            isCacheReadAttempted: false\n          };\n          // Upstream runners may mutate the property of build cache context for downstream runners\n          this._buildCacheContextByOperation.set(operation, buildCacheContext);\n        }\n\n        if (disjointSet) {\n          clusterOperations(disjointSet, this._buildCacheContextByOperation);\n          for (const operationSet of disjointSet.getAllSets()) {\n            if (cobuildConfiguration?.cobuildFeatureEnabled && cobuildConfiguration.cobuildContextId) {\n              // Get a deterministic ordered array of operations, which is important to get a deterministic cluster id.\n              const groupedOperations: Operation[] = Array.from(operationSet);\n              Sort.sortBy(groupedOperations, (operation: Operation) => {\n                return operation.name;\n              });\n\n              // Generates cluster id, cluster id comes from the project folder and operation name of all operations in the same cluster.\n              const hash: crypto.Hash = crypto.createHash('sha1');\n              for (const operation of groupedOperations) {\n                const { associatedPhase: phase, associatedProject: project } = operation;\n                if (project && phase) {\n                  hash.update(project.projectRelativeFolder);\n                  hash.update(RushConstants.hashDelimiter);\n                  hash.update(operation.name ?? phase.name);\n                  hash.update(RushConstants.hashDelimiter);\n                }\n              }\n              const cobuildClusterId: string = hash.digest('hex');\n\n              // Assign same cluster id to all operations in the same cluster.\n              for (const record of groupedOperations) {\n                const buildCacheContext: IOperationBuildCacheContext =\n                  this._getBuildCacheContextByOperationOrThrow(record);\n                buildCacheContext.cobuildClusterId = cobuildClusterId;\n              }\n            }\n          }\n        }\n      }\n    );\n\n    hooks.beforeExecuteOperation.tapPromise(\n      PLUGIN_NAME,\n      async (\n        runnerContext: IOperationRunnerContext & IOperationExecutionResult\n      ): Promise<OperationStatus | undefined> => {\n        if (this._buildCacheContextByOperation.size === 0) {\n          return;\n        }\n\n        const buildCacheContext: IOperationBuildCacheContext | undefined =\n          this._getBuildCacheContextByOperation(runnerContext.operation);\n\n        if (!buildCacheContext) {\n          return;\n        }\n\n        const record: OperationExecutionRecord = runnerContext as OperationExecutionRecord;\n\n        const {\n          associatedProject: project,\n          associatedPhase: phase,\n          runner,\n          _operationMetadataManager: operationMetadataManager,\n          operation\n        } = record;\n\n        if (\n          !operation.enabled ||\n          !project ||\n          !phase ||\n          !runner?.cacheable ||\n          // this check is just to make the types happy, it will always be defined if project + phase are defined.\n          !operationMetadataManager\n        ) {\n          return;\n        }\n\n        const runBeforeExecute = async (): Promise<OperationStatus | undefined> => {\n          if (\n            !buildCacheContext.buildCacheTerminal ||\n            buildCacheContext.buildCacheTerminalWritable?.isOpen === false\n          ) {\n            // The writable does not exist or has been closed, re-create one\n            // eslint-disable-next-line require-atomic-updates\n            buildCacheContext.buildCacheTerminal = await this._createBuildCacheTerminalAsync({\n              record,\n              buildCacheContext,\n              buildCacheEnabled: buildCacheConfiguration?.buildCacheEnabled,\n              rushProject: project,\n              logFilenameIdentifier: operation.logFilenameIdentifier,\n              quietMode: record.quietMode,\n              debugMode: record.debugMode\n            });\n          }\n\n          const buildCacheTerminal: ITerminal = buildCacheContext.buildCacheTerminal;\n\n          let projectBuildCache: ProjectBuildCache | undefined = this._tryGetProjectBuildCache({\n            buildCacheContext,\n            buildCacheConfiguration,\n            terminal: buildCacheTerminal,\n            record\n          });\n\n          // Try to acquire the cobuild lock\n          let cobuildLock: CobuildLock | undefined;\n          if (cobuildConfiguration?.cobuildFeatureEnabled) {\n            if (\n              cobuildConfiguration?.cobuildLeafProjectLogOnlyAllowed &&\n              operation.consumers.size === 0 &&\n              !projectBuildCache\n            ) {\n              // When the leaf project log only is allowed and the leaf project is build cache \"disabled\", try to get\n              // a log files only project build cache\n              projectBuildCache = await this._tryGetLogOnlyProjectBuildCacheAsync({\n                buildCacheConfiguration,\n                cobuildConfiguration,\n                buildCacheContext,\n                rushProject: project,\n                phase,\n                terminal: buildCacheTerminal\n              });\n              if (projectBuildCache) {\n                buildCacheTerminal.writeVerboseLine(\n                  `Log files only build cache is enabled for the project \"${project.packageName}\" because the cobuild leaf project log only is allowed`\n                );\n              } else {\n                buildCacheTerminal.writeWarningLine(\n                  `Failed to get log files only build cache for the project \"${project.packageName}\"`\n                );\n              }\n            }\n\n            cobuildLock = await this._tryGetCobuildLockAsync({\n              buildCacheContext,\n              projectBuildCache,\n              cobuildConfiguration,\n              packageName: project.packageName,\n              phaseName: phase.name\n            });\n          }\n\n          // eslint-disable-next-line require-atomic-updates -- we are mutating the build cache context intentionally\n          buildCacheContext.cobuildLock = cobuildLock;\n\n          // If possible, we want to skip this operation -- either by restoring it from the\n          // cache, if caching is enabled, or determining that the project\n          // is unchanged (using the older incremental execution logic). These two approaches,\n          // \"caching\" and \"skipping\", are incompatible, so only one applies.\n          //\n          // Note that \"caching\" and \"skipping\" take two different approaches\n          // to tracking dependents:\n          //\n          //   - For caching, \"isCacheReadAllowed\" is set if a project supports\n          //     incremental builds, and determining whether this project or a dependent\n          //     has changed happens inside the hashing logic.\n          //\n\n          const { error: errorLogPath } = getProjectLogFilePaths({\n            project,\n            logFilenameIdentifier: operation.logFilenameIdentifier\n          });\n          const restoreCacheAsync = async (\n            // TODO: Investigate if `projectBuildCacheForRestore` is always the same instance as `projectBuildCache`\n            // above, and if it is, remove this parameter\n            projectBuildCacheForRestore: ProjectBuildCache | undefined,\n            specifiedCacheId?: string\n          ): Promise<boolean> => {\n            buildCacheContext.isCacheReadAttempted = true;\n            const restoreFromCacheSuccess: boolean | undefined =\n              await projectBuildCacheForRestore?.tryRestoreFromCacheAsync(\n                buildCacheTerminal,\n                specifiedCacheId\n              );\n            if (restoreFromCacheSuccess) {\n              buildCacheContext.cacheRestored = true;\n              await runnerContext.runWithTerminalAsync(\n                async (taskTerminal, terminalProvider) => {\n                  // Restore the original state of the operation without cache\n                  await operationMetadataManager?.tryRestoreAsync({\n                    terminalProvider,\n                    terminal: buildCacheTerminal,\n                    errorLogPath\n                  });\n                },\n                { createLogFile: false }\n              );\n            }\n            return !!restoreFromCacheSuccess;\n          };\n          if (cobuildLock) {\n            // handling rebuilds. \"rush rebuild\" or \"rush retest\" command will save operations to\n            // the build cache once completed, but does not retrieve them (since the \"incremental\"\n            // flag is disabled). However, we still need a cobuild to be able to retrieve a finished\n            // build from another cobuild in this case.\n            const cobuildCompletedState: ICobuildCompletedState | undefined =\n              await cobuildLock.getCompletedStateAsync();\n            if (cobuildCompletedState) {\n              const { status, cacheId } = cobuildCompletedState;\n\n              if (record.operation.settings?.allowCobuildWithoutCache) {\n                // This should only be enabled if the experiment for cobuild orchestration is enabled.\n                return status;\n              }\n\n              const restoreFromCacheSuccess: boolean = await restoreCacheAsync(\n                cobuildLock.projectBuildCache,\n                cacheId\n              );\n\n              if (restoreFromCacheSuccess) {\n                return status;\n              }\n            } else if (!buildCacheContext.isCacheReadAttempted && buildCacheContext.isCacheReadAllowed) {\n              const restoreFromCacheSuccess: boolean = await restoreCacheAsync(projectBuildCache);\n\n              if (restoreFromCacheSuccess) {\n                return OperationStatus.FromCache;\n              }\n            }\n          } else if (buildCacheContext.isCacheReadAllowed) {\n            const restoreFromCacheSuccess: boolean = await restoreCacheAsync(projectBuildCache);\n\n            if (restoreFromCacheSuccess) {\n              return OperationStatus.FromCache;\n            }\n          }\n\n          if (buildCacheContext.isCacheWriteAllowed && cobuildLock) {\n            const acquireSuccess: boolean = await cobuildLock.tryAcquireLockAsync();\n            if (acquireSuccess) {\n              const { periodicCallback } = buildCacheContext;\n              periodicCallback.addCallback(async () => {\n                await cobuildLock?.renewLockAsync();\n              });\n              periodicCallback.start();\n            } else {\n              setTimeout(() => {\n                record.status = OperationStatus.Ready;\n              }, 500);\n              return OperationStatus.Executing;\n            }\n          }\n        };\n\n        return await runBeforeExecute();\n      }\n    );\n\n    hooks.afterExecuteOperation.tapPromise(\n      PLUGIN_NAME,\n      async (runnerContext: IOperationRunnerContext): Promise<void> => {\n        const record: OperationExecutionRecord = runnerContext as OperationExecutionRecord;\n        const { status, stopwatch, _operationMetadataManager: operationMetadataManager, operation } = record;\n\n        const { associatedProject: project, associatedPhase: phase, runner, enabled } = operation;\n\n        if (!enabled || !project || !phase || !runner?.cacheable || !operationMetadataManager) {\n          return;\n        }\n\n        const buildCacheContext: IOperationBuildCacheContext | undefined =\n          this._getBuildCacheContextByOperation(operation);\n\n        if (!buildCacheContext) {\n          return;\n        }\n\n        // No need to run for the following operation status\n        if (!record.isTerminal || record.status === OperationStatus.NoOp) {\n          return;\n        }\n\n        const { cobuildLock, operationBuildCache, isCacheWriteAllowed, buildCacheTerminal, cacheRestored } =\n          buildCacheContext;\n\n        try {\n          if (!cacheRestored) {\n            // Save the metadata to disk\n            const { logFilenameIdentifier } = operationMetadataManager;\n            const { duration: durationInSeconds } = stopwatch;\n            const {\n              text: logPath,\n              error: errorLogPath,\n              jsonl: logChunksPath\n            } = getProjectLogFilePaths({\n              project,\n              logFilenameIdentifier\n            });\n            await operationMetadataManager.saveAsync({\n              durationInSeconds,\n              cobuildContextId: cobuildLock?.cobuildConfiguration.cobuildContextId,\n              cobuildRunnerId: cobuildLock?.cobuildConfiguration.cobuildRunnerId,\n              logPath,\n              errorLogPath,\n              logChunksPath\n            });\n          }\n\n          if (!buildCacheTerminal) {\n            // This should not happen\n            throw new InternalError(`Build Cache Terminal is not created`);\n          }\n\n          let setCompletedStatePromiseFunction: (() => Promise<void> | undefined) | undefined;\n          let setCacheEntryPromise: (() => Promise<boolean> | undefined) | undefined;\n          if (cobuildLock && isCacheWriteAllowed) {\n            const { cacheId, contextId } = cobuildLock.cobuildContext;\n\n            let finalCacheId: string = cacheId;\n            if (status === OperationStatus.Failure) {\n              finalCacheId = `${cacheId}-${contextId}-failed`;\n            } else if (status === OperationStatus.SuccessWithWarning && !record.runner.warningsAreAllowed) {\n              finalCacheId = `${cacheId}-${contextId}-warnings`;\n            }\n            switch (status) {\n              case OperationStatus.SuccessWithWarning:\n              case OperationStatus.Success:\n              case OperationStatus.Failure: {\n                const currentStatus: ICobuildCompletedState['status'] = status;\n                setCompletedStatePromiseFunction = () => {\n                  return cobuildLock?.setCompletedStateAsync({\n                    status: currentStatus,\n                    cacheId: finalCacheId\n                  });\n                };\n                setCacheEntryPromise = () =>\n                  cobuildLock.projectBuildCache.trySetCacheEntryAsync(buildCacheTerminal, finalCacheId);\n              }\n            }\n          }\n\n          const taskIsSuccessful: boolean =\n            status === OperationStatus.Success ||\n            (status === OperationStatus.SuccessWithWarning &&\n              record.runner.warningsAreAllowed &&\n              allowWarningsInSuccessfulBuild);\n\n          // If the command is successful, we can calculate project hash, and no dependencies were skipped,\n          // write a new cache entry.\n          if (!setCacheEntryPromise && taskIsSuccessful && isCacheWriteAllowed && operationBuildCache) {\n            setCacheEntryPromise = () => operationBuildCache.trySetCacheEntryAsync(buildCacheTerminal);\n          }\n          if (!cacheRestored) {\n            const cacheWriteSuccess: boolean | undefined = await setCacheEntryPromise?.();\n            await setCompletedStatePromiseFunction?.();\n\n            if (cacheWriteSuccess === false && status === OperationStatus.Success) {\n              record.status = OperationStatus.SuccessWithWarning;\n            }\n          }\n        } finally {\n          buildCacheContext.buildCacheTerminalWritable?.close();\n          buildCacheContext.periodicCallback.stop();\n        }\n      }\n    );\n\n    hooks.afterExecuteOperation.tap(\n      PLUGIN_NAME,\n      (record: IOperationRunnerContext & IOperationExecutionResult): void => {\n        const { operation } = record;\n        const buildCacheContext: IOperationBuildCacheContext | undefined =\n          this._buildCacheContextByOperation.get(operation);\n        // Status changes to direct dependents\n        let blockCacheWrite: boolean = !buildCacheContext?.isCacheWriteAllowed;\n\n        switch (record.status) {\n          case OperationStatus.Skipped: {\n            // Skipping means cannot guarantee integrity, so prevent cache writes in dependents.\n            blockCacheWrite = true;\n            break;\n          }\n        }\n\n        // Apply status changes to direct dependents\n        if (blockCacheWrite) {\n          for (const consumer of operation.consumers) {\n            const consumerBuildCacheContext: IOperationBuildCacheContext | undefined =\n              this._getBuildCacheContextByOperation(consumer);\n            if (consumerBuildCacheContext) {\n              consumerBuildCacheContext.isCacheWriteAllowed = false;\n            }\n          }\n        }\n      }\n    );\n\n    hooks.afterExecuteOperations.tapPromise(PLUGIN_NAME, async () => {\n      this._buildCacheContextByOperation.clear();\n    });\n  }\n\n  private _getBuildCacheContextByOperation(operation: Operation): IOperationBuildCacheContext | undefined {\n    const buildCacheContext: IOperationBuildCacheContext | undefined =\n      this._buildCacheContextByOperation.get(operation);\n    return buildCacheContext;\n  }\n\n  private _getBuildCacheContextByOperationOrThrow(operation: Operation): IOperationBuildCacheContext {\n    const buildCacheContext: IOperationBuildCacheContext | undefined =\n      this._getBuildCacheContextByOperation(operation);\n    if (!buildCacheContext) {\n      // This should not happen\n      throw new InternalError(`Build cache context for operation ${operation.name} should be defined`);\n    }\n    return buildCacheContext;\n  }\n\n  private _tryGetProjectBuildCache({\n    buildCacheConfiguration,\n    buildCacheContext,\n    terminal,\n    record\n  }: {\n    buildCacheContext: IOperationBuildCacheContext;\n    buildCacheConfiguration: BuildCacheConfiguration | undefined;\n    terminal: ITerminal;\n    record: OperationExecutionRecord;\n  }): ProjectBuildCache | undefined {\n    if (!buildCacheContext.operationBuildCache) {\n      const { cacheDisabledReason } = buildCacheContext;\n      if (cacheDisabledReason && !record.operation.settings?.allowCobuildWithoutCache) {\n        terminal.writeVerboseLine(cacheDisabledReason);\n        return;\n      }\n\n      if (!buildCacheConfiguration) {\n        // Unreachable, since this will have set `cacheDisabledReason`.\n        return;\n      }\n\n      // eslint-disable-next-line require-atomic-updates -- This is guaranteed to not be concurrent\n      buildCacheContext.operationBuildCache = ProjectBuildCache.forOperation(record, {\n        buildCacheConfiguration,\n        terminal\n      });\n    }\n\n    return buildCacheContext.operationBuildCache;\n  }\n\n  // Get a ProjectBuildCache only cache/restore log files\n  private async _tryGetLogOnlyProjectBuildCacheAsync({\n    buildCacheContext,\n    rushProject,\n    terminal,\n    buildCacheConfiguration,\n    cobuildConfiguration,\n    phase\n  }: {\n    buildCacheContext: IOperationBuildCacheContext;\n    buildCacheConfiguration: BuildCacheConfiguration | undefined;\n    cobuildConfiguration: CobuildConfiguration;\n    rushProject: RushConfigurationProject;\n    phase: IPhase;\n    terminal: ITerminal;\n  }): Promise<ProjectBuildCache | undefined> {\n    if (!buildCacheConfiguration?.buildCacheEnabled) {\n      return;\n    }\n\n    const { outputFolderNames, stateHash } = buildCacheContext;\n\n    const hasher: crypto.Hash = crypto.createHash('sha1');\n    hasher.update(stateHash);\n\n    if (cobuildConfiguration.cobuildContextId) {\n      hasher.update(`\\ncobuildContextId=${cobuildConfiguration.cobuildContextId}`);\n    }\n\n    hasher.update(`\\nlogFilesOnly=1`);\n\n    const operationStateHash: string = hasher.digest('hex');\n\n    const projectBuildCache: ProjectBuildCache = ProjectBuildCache.getProjectBuildCache({\n      project: rushProject,\n      projectOutputFolderNames: outputFolderNames,\n      buildCacheConfiguration,\n      terminal,\n      operationStateHash,\n      phaseName: phase.name\n    });\n\n    // eslint-disable-next-line require-atomic-updates -- This is guaranteed to not be concurrent\n    buildCacheContext.operationBuildCache = projectBuildCache;\n\n    return projectBuildCache;\n  }\n\n  private async _tryGetCobuildLockAsync({\n    cobuildConfiguration,\n    buildCacheContext,\n    projectBuildCache,\n    packageName,\n    phaseName\n  }: {\n    cobuildConfiguration: CobuildConfiguration | undefined;\n    buildCacheContext: IOperationBuildCacheContext;\n    projectBuildCache: ProjectBuildCache | undefined;\n    packageName: string;\n    phaseName: string;\n  }): Promise<CobuildLock | undefined> {\n    if (!buildCacheContext.cobuildLock) {\n      if (projectBuildCache && cobuildConfiguration?.cobuildFeatureEnabled) {\n        if (!buildCacheContext.cobuildClusterId) {\n          // This should not happen\n          throw new InternalError('Cobuild cluster id is not defined');\n        }\n        buildCacheContext.cobuildLock = new CobuildLock({\n          cobuildConfiguration,\n          projectBuildCache,\n          cobuildClusterId: buildCacheContext.cobuildClusterId,\n          lockExpireTimeInSeconds: PERIODIC_CALLBACK_INTERVAL_IN_SECONDS * 3,\n          packageName,\n          phaseName\n        });\n      }\n    }\n    return buildCacheContext.cobuildLock;\n  }\n\n  private async _createBuildCacheTerminalAsync({\n    record,\n    buildCacheContext,\n    buildCacheEnabled,\n    rushProject,\n    logFilenameIdentifier,\n    quietMode,\n    debugMode\n  }: {\n    record: OperationExecutionRecord;\n    buildCacheContext: IOperationBuildCacheContext;\n    buildCacheEnabled: boolean | undefined;\n    rushProject: RushConfigurationProject;\n    logFilenameIdentifier: string;\n    quietMode: boolean;\n    debugMode: boolean;\n  }): Promise<ITerminal> {\n    const silent: boolean = record.silent;\n    if (silent) {\n      const nullTerminalProvider: NullTerminalProvider = new NullTerminalProvider();\n      return new Terminal(nullTerminalProvider);\n    }\n\n    let cacheConsoleWritable: TerminalWritable;\n    // This creates the writer, only do this if necessary.\n    const collatedWriter: CollatedWriter = record.collatedWriter;\n    const cacheProjectLogWritable: TerminalWritable | undefined =\n      await this._tryGetBuildCacheTerminalWritableAsync({\n        buildCacheContext,\n        buildCacheEnabled,\n        rushProject,\n        logFilenameIdentifier\n      });\n\n    if (quietMode) {\n      const discardTransform: DiscardStdoutTransform = new DiscardStdoutTransform({\n        destination: collatedWriter\n      });\n      const normalizeNewlineTransform: TextRewriterTransform = new TextRewriterTransform({\n        destination: discardTransform,\n        normalizeNewlines: NewlineKind.Lf,\n        ensureNewlineAtEnd: true\n      });\n      cacheConsoleWritable = normalizeNewlineTransform;\n    } else {\n      cacheConsoleWritable = collatedWriter;\n    }\n\n    let cacheCollatedTerminal: CollatedTerminal;\n    if (cacheProjectLogWritable) {\n      const cacheSplitterTransform: SplitterTransform = new SplitterTransform({\n        destinations: [cacheConsoleWritable, cacheProjectLogWritable]\n      });\n      cacheCollatedTerminal = new CollatedTerminal(cacheSplitterTransform);\n    } else {\n      cacheCollatedTerminal = new CollatedTerminal(cacheConsoleWritable);\n    }\n\n    const buildCacheTerminalProvider: CollatedTerminalProvider = new CollatedTerminalProvider(\n      cacheCollatedTerminal,\n      {\n        debugEnabled: debugMode\n      }\n    );\n    return new Terminal(buildCacheTerminalProvider);\n  }\n\n  private async _tryGetBuildCacheTerminalWritableAsync({\n    buildCacheEnabled,\n    rushProject,\n    buildCacheContext,\n    logFilenameIdentifier\n  }: {\n    buildCacheEnabled: boolean | undefined;\n    rushProject: RushConfigurationProject;\n    buildCacheContext: IOperationBuildCacheContext;\n    logFilenameIdentifier: string;\n  }): Promise<TerminalWritable | undefined> {\n    // Only open the *.cache.log file(s) if the cache is enabled.\n    if (!buildCacheEnabled) {\n      return;\n    }\n\n    const logFilePaths: ILogFilePaths = getProjectLogFilePaths({\n      project: rushProject,\n      logFilenameIdentifier: `${logFilenameIdentifier}.cache`\n    });\n\n    buildCacheContext.buildCacheTerminalWritable = await initializeProjectLogFilesAsync({\n      logFilePaths\n    });\n\n    return buildCacheContext.buildCacheTerminalWritable;\n  }\n}\n\nexport function clusterOperations(\n  initialClusters: DisjointSet<Operation>,\n  operationBuildCacheMap: Map<Operation, { cacheDisabledReason: string | undefined }>\n): void {\n  // If disjoint set exists, connect build cache disabled project with its consumers\n  for (const [operation, { cacheDisabledReason }] of operationBuildCacheMap) {\n    const { associatedProject: project, associatedPhase: phase } = operation;\n    if (project && phase) {\n      if (cacheDisabledReason && !operation.settings?.allowCobuildWithoutCache) {\n        /**\n         * Group the project build cache disabled with its consumers. This won't affect too much in\n         * a monorepo with high build cache coverage.\n         *\n         * The mental model is that if X disables the cache, and Y depends on X, then:\n         *   1. Y must be built by the same VM that build X;\n         *   2. OR, Y must be rebuilt on each VM that needs it.\n         * Approach 1 is probably the better choice.\n         */\n        for (const consumer of operation.consumers) {\n          initialClusters?.union(operation, consumer);\n        }\n      }\n    }\n  }\n}\n"]}