"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectWatcher = void 0;
const fs = __importStar(require("fs"));
const os = __importStar(require("os"));
const readline = __importStar(require("readline"));
const events_1 = require("events");
const package_deps_hash_1 = require("@rushstack/package-deps-hash");
const node_core_library_1 = require("@rushstack/node-core-library");
const terminal_1 = require("@rushstack/terminal");
const Git_1 = require("./Git");
/**
 * This class is for incrementally watching a set of projects in the repository for changes.
 *
 * We are manually using fs.watch() instead of `chokidar` because all we want from the file system watcher is a boolean
 * signal indicating that "at least 1 file in a watched project changed". We then defer to getInputsSnapshotAsync (which
 * is responsible for change detection in all incremental builds) to determine what actually chanaged.
 *
 * Calling `waitForChange()` will return a promise that resolves when the package-deps of one or
 * more projects differ from the value the previous time it was invoked. The first time will always resolve with the full selection.
 */
class ProjectWatcher {
    constructor(options) {
        this._forceChangedProjects = new Map();
        this.isPaused = false;
        const { getInputsSnapshotAsync: snapshotProvider, debounceMs = 1000, rushConfiguration, projectsToWatch, terminal, initialSnapshot: initialState } = options;
        this._debounceMs = debounceMs;
        this._rushConfiguration = rushConfiguration;
        this._projectsToWatch = projectsToWatch;
        this._terminal = terminal;
        const gitPath = new Git_1.Git(rushConfiguration).getGitPathOrThrow();
        this._repoRoot = node_core_library_1.Path.convertToSlashes((0, package_deps_hash_1.getRepoRoot)(rushConfiguration.rushJsonFolder, gitPath));
        this._initialSnapshot = initialState;
        this._previousSnapshot = initialState;
        this._renderedStatusLines = 0;
        this._getPromptLines = undefined;
        this._getInputsSnapshotAsync = snapshotProvider;
    }
    pause() {
        this.isPaused = true;
        this._setStatus('Project watcher paused.');
    }
    resume() {
        this.isPaused = false;
        this._setStatus('Project watcher resuming...');
        if (this._resolveIfChanged) {
            this._resolveIfChanged().catch(() => {
                // Suppress unhandled promise rejection error
            });
        }
    }
    invalidateProject(project, reason) {
        if (this._forceChangedProjects.has(project)) {
            return false;
        }
        this._forceChangedProjects.set(project, reason);
        return true;
    }
    invalidateAll(reason) {
        for (const project of this._projectsToWatch) {
            this.invalidateProject(project, reason);
        }
    }
    clearStatus() {
        this._renderedStatusLines = 0;
    }
    setPromptGenerator(promptGenerator) {
        this._getPromptLines = promptGenerator;
    }
    /**
     * Waits for a change to the package-deps of one or more of the selected projects, since the previous invocation.
     * Will return immediately the first time it is invoked, since no state has been recorded.
     * If no change is currently present, watches the source tree of all selected projects for file changes.
     * `waitForChange` is not allowed to be called multiple times concurrently.
     */
    async waitForChangeAsync(onWatchingFiles) {
        const initialChangeResult = await this._computeChangedAsync();
        // Ensure that the new state is recorded so that we don't loop infinitely
        this._commitChanges(initialChangeResult.inputsSnapshot);
        if (initialChangeResult.changedProjects.size) {
            // We can't call `clear()` here due to the async tick in the end of _computeChanged
            for (const project of initialChangeResult.changedProjects) {
                this._forceChangedProjects.delete(project);
            }
            // TODO: _forceChangedProjects might be non-empty here, which will result in an immediate rerun after the next
            // run finishes. This is suboptimal, but the latency of _computeChanged is probably high enough that in practice
            // all invalidations will have been picked up already.
            return initialChangeResult;
        }
        const previousState = initialChangeResult.inputsSnapshot;
        const repoRoot = node_core_library_1.Path.convertToSlashes(this._rushConfiguration.rushJsonFolder);
        // Map of path to whether config for the path
        const pathsToWatch = new Map();
        // Node 12 supports the "recursive" parameter to fs.watch only on win32 and OSX
        // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_caveats
        const useNativeRecursiveWatch = os.platform() === 'win32' || os.platform() === 'darwin';
        if (useNativeRecursiveWatch) {
            // Watch the root non-recursively
            pathsToWatch.set(repoRoot, { recurse: false });
            // Watch the rush config folder non-recursively
            pathsToWatch.set(node_core_library_1.Path.convertToSlashes(this._rushConfiguration.commonRushConfigFolder), {
                recurse: false
            });
            for (const project of this._projectsToWatch) {
                // Use recursive watch in individual project folders
                pathsToWatch.set(node_core_library_1.Path.convertToSlashes(project.projectFolder), { recurse: true });
            }
        }
        else {
            for (const project of this._projectsToWatch) {
                const projectState = previousState.getTrackedFileHashesForOperation(project);
                const prefixLength = project.projectFolder.length - repoRoot.length - 1;
                // Watch files in the root of the project, or
                for (const pathToWatch of ProjectWatcher._enumeratePathsToWatch(projectState.keys(), prefixLength)) {
                    pathsToWatch.set(`${this._repoRoot}/${pathToWatch}`, { recurse: true });
                }
            }
        }
        const watchers = new Map();
        const watchedResult = await new Promise((resolve, reject) => {
            let timeout;
            let terminated = false;
            const terminal = this._terminal;
            const debounceMs = this._debounceMs;
            this.clearStatus();
            const resolveIfChanged = (this._resolveIfChanged = async () => {
                timeout = undefined;
                if (terminated) {
                    return;
                }
                try {
                    if (this.isPaused) {
                        this._setStatus(`Project watcher paused.`);
                        return;
                    }
                    this._setStatus(`Evaluating changes to tracked files...`);
                    const result = await this._computeChangedAsync();
                    this._setStatus(`Finished analyzing.`);
                    // Need an async tick to allow for more file system events to be handled
                    process.nextTick(() => {
                        if (timeout) {
                            // If another file has changed, wait for another pass.
                            this._setStatus(`More file changes detected, aborting.`);
                            return;
                        }
                        // Since there are multiple async ticks since the projects were enumerated in _computeChanged,
                        // more could have been added in the interaval. Check and debounce.
                        for (const project of this._forceChangedProjects.keys()) {
                            if (!result.changedProjects.has(project)) {
                                this._setStatus(`More invalidations occurred, aborting.`);
                                timeout = setTimeout(resolveIfChanged, debounceMs);
                                return;
                            }
                        }
                        this._commitChanges(result.inputsSnapshot);
                        const hasForcedChanges = this._forceChangedProjects.size > 0;
                        if (hasForcedChanges) {
                            this._setStatus(`Projects were invalidated: ${Array.from(new Set(this._forceChangedProjects.values())).join(', ')}`);
                            this.clearStatus();
                        }
                        this._forceChangedProjects.clear();
                        if (result.changedProjects.size) {
                            terminated = true;
                            terminal.writeLine();
                            resolve(result);
                        }
                        else {
                            this._setStatus(`No changes detected to tracked files.`);
                        }
                    });
                }
                catch (err) {
                    // eslint-disable-next-line require-atomic-updates
                    terminated = true;
                    terminal.writeLine();
                    reject(err);
                }
            });
            for (const [pathToWatch, { recurse }] of pathsToWatch) {
                addWatcher(pathToWatch, recurse);
            }
            if (onWatchingFiles) {
                onWatchingFiles();
            }
            this._setStatus(`Waiting for changes...`);
            function onError(err) {
                if (terminated) {
                    return;
                }
                terminated = true;
                terminal.writeLine();
                reject(err);
            }
            function addWatcher(watchedPath, recursive) {
                if (watchers.has(watchedPath)) {
                    return;
                }
                const listener = changeListener(watchedPath, recursive);
                const watcher = fs.watch(watchedPath, {
                    encoding: 'utf-8',
                    recursive: recursive && useNativeRecursiveWatch
                }, listener);
                watchers.set(watchedPath, watcher);
                watcher.on('error', (err) => {
                    watchers.delete(watchedPath);
                    onError(err);
                });
            }
            function innerListener(root, recursive, event, fileName) {
                try {
                    if (terminated) {
                        return;
                    }
                    if (fileName === '.git' || fileName === 'node_modules') {
                        return;
                    }
                    // Handling for added directories
                    if (recursive && !useNativeRecursiveWatch) {
                        const decodedName = fileName ? fileName.toString() : '';
                        const normalizedName = decodedName && node_core_library_1.Path.convertToSlashes(decodedName);
                        const fullName = normalizedName && `${root}/${normalizedName}`;
                        if (fullName && !watchers.has(fullName)) {
                            try {
                                const stat = node_core_library_1.FileSystem.getStatistics(fullName);
                                if (stat.isDirectory()) {
                                    addWatcher(fullName, true);
                                }
                            }
                            catch (err) {
                                const code = err.code;
                                if (code !== 'ENOENT' && code !== 'ENOTDIR') {
                                    throw err;
                                }
                            }
                        }
                    }
                    // Use a timeout to debounce changes, e.g. bulk copying files into the directory while the watcher is running.
                    if (timeout) {
                        clearTimeout(timeout);
                    }
                    timeout = setTimeout(resolveIfChanged, debounceMs);
                }
                catch (err) {
                    terminated = true;
                    terminal.writeLine();
                    reject(err);
                }
            }
            function changeListener(root, recursive) {
                return innerListener.bind(0, root, recursive);
            }
        }).finally(() => {
            this._resolveIfChanged = undefined;
        });
        const closePromises = [];
        for (const [watchedPath, watcher] of watchers) {
            closePromises.push((0, events_1.once)(watcher, 'close').then(() => {
                watchers.delete(watchedPath);
            }));
            watcher.close();
        }
        await Promise.all(closePromises);
        return watchedResult;
    }
    _setStatus(status) {
        var _a, _b;
        const statusLines = [
            `[${this.isPaused ? 'PAUSED' : 'WATCHING'}] Watch Status: ${status}`,
            ...((_b = (_a = this._getPromptLines) === null || _a === void 0 ? void 0 : _a.call(this, this.isPaused)) !== null && _b !== void 0 ? _b : [])
        ];
        if (this._renderedStatusLines > 0) {
            readline.cursorTo(process.stdout, 0);
            readline.moveCursor(process.stdout, 0, -this._renderedStatusLines);
            readline.clearScreenDown(process.stdout);
        }
        this._renderedStatusLines = statusLines.length;
        this._terminal.writeLine(terminal_1.Colorize.bold(terminal_1.Colorize.cyan(statusLines.join('\n'))));
    }
    /**
     * Determines which, if any, projects (within the selection) have new hashes for files that are not in .gitignore
     */
    async _computeChangedAsync() {
        const currentSnapshot = await this._getInputsSnapshotAsync();
        if (!currentSnapshot) {
            throw new node_core_library_1.AlreadyReportedError();
        }
        const previousSnapshot = this._previousSnapshot;
        if (!previousSnapshot) {
            return {
                changedProjects: this._projectsToWatch,
                inputsSnapshot: currentSnapshot
            };
        }
        const changedProjects = new Set();
        for (const project of this._projectsToWatch) {
            const previous = previousSnapshot.getTrackedFileHashesForOperation(project);
            const current = currentSnapshot.getTrackedFileHashesForOperation(project);
            if (ProjectWatcher._haveProjectDepsChanged(previous, current)) {
                // May need to detect if the nature of the change will break the process, e.g. changes to package.json
                changedProjects.add(project);
            }
        }
        for (const project of this._forceChangedProjects.keys()) {
            changedProjects.add(project);
        }
        return {
            changedProjects,
            inputsSnapshot: currentSnapshot
        };
    }
    _commitChanges(state) {
        this._previousSnapshot = state;
        if (!this._initialSnapshot) {
            this._initialSnapshot = state;
        }
    }
    /**
     * Tests for inequality of the passed Maps. Order invariant.
     *
     * @returns `true` if the maps are different, `false` otherwise
     */
    static _haveProjectDepsChanged(prev, next) {
        if (!prev && !next) {
            return false;
        }
        if (!prev || !next) {
            return true;
        }
        if (prev.size !== next.size) {
            return true;
        }
        for (const [key, value] of prev) {
            if (next.get(key) !== value) {
                return true;
            }
        }
        return false;
    }
    static *_enumeratePathsToWatch(paths, prefixLength) {
        for (const path of paths) {
            const rootSlashIndex = path.indexOf('/', prefixLength);
            if (rootSlashIndex < 0) {
                yield path;
                return;
            }
            yield path.slice(0, rootSlashIndex);
            let slashIndex = path.indexOf('/', rootSlashIndex + 1);
            while (slashIndex >= 0) {
                yield path.slice(0, slashIndex);
                slashIndex = path.indexOf('/', slashIndex + 1);
            }
        }
    }
}
exports.ProjectWatcher = ProjectWatcher;
//# sourceMappingURL=ProjectWatcher.js.map