"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionMismatchFinder = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const terminal_1 = require("@rushstack/terminal");
const PackageJsonEditor_1 = require("../../api/PackageJsonEditor");
const VersionMismatchFinderProject_1 = require("./VersionMismatchFinderProject");
const VersionMismatchFinderCommonVersions_1 = require("./VersionMismatchFinderCommonVersions");
const CustomTipsConfiguration_1 = require("../../api/CustomTipsConfiguration");
const TRUNCATE_AFTER_PACKAGE_NAME_COUNT = 5;
class VersionMismatchFinder {
    constructor(projects, allowedAlternativeVersions) {
        this._projects = projects;
        this._mismatches = new Map();
        this._allowedAlternativeVersion = allowedAlternativeVersions || new Map();
        this._analyze();
    }
    static rushCheck(rushConfiguration, terminal, options) {
        const { variant, subspace = rushConfiguration.defaultSubspace, printAsJson, truncateLongPackageNameLists } = options !== null && options !== void 0 ? options : {};
        VersionMismatchFinder._checkForInconsistentVersions(rushConfiguration, {
            variant,
            subspace,
            printAsJson,
            truncateLongPackageNameLists,
            terminal,
            isRushCheckCommand: true
        });
    }
    static ensureConsistentVersions(rushConfiguration, terminal, options) {
        const { variant, subspace = rushConfiguration.defaultSubspace } = options !== null && options !== void 0 ? options : {};
        VersionMismatchFinder._checkForInconsistentVersions(rushConfiguration, {
            subspace,
            variant,
            terminal,
            isRushCheckCommand: false,
            truncateLongPackageNameLists: true
        });
    }
    /**
     * Populates a version mismatch finder object given a Rush Configuration.
     * Intentionally considers preferred versions.
     */
    static getMismatches(rushConfiguration, options) {
        const { subspace = rushConfiguration.defaultSubspace, variant } = options !== null && options !== void 0 ? options : {};
        const commonVersions = subspace.getCommonVersions(variant);
        const projects = [];
        // Create an object for the purposes of reporting conflicts with preferredVersions from common-versions.json
        // Make sure this one is first so it doesn't get truncated when a long list is printed
        projects.push(new VersionMismatchFinderCommonVersions_1.VersionMismatchFinderCommonVersions(commonVersions));
        // If subspace is specified, only go through projects in that subspace
        for (const project of subspace.getProjects()) {
            projects.push(new VersionMismatchFinderProject_1.VersionMismatchFinderProject(project));
        }
        return new VersionMismatchFinder(projects, commonVersions.allowedAlternativeVersions);
    }
    static _checkForInconsistentVersions(rushConfiguration, options) {
        const { variant, isRushCheckCommand, printAsJson, subspace, truncateLongPackageNameLists, terminal } = options;
        if (subspace.shouldEnsureConsistentVersions(variant) || isRushCheckCommand) {
            const mismatchFinder = VersionMismatchFinder.getMismatches(rushConfiguration, options);
            if (printAsJson) {
                mismatchFinder.printAsJson();
            }
            else {
                mismatchFinder.print(truncateLongPackageNameLists);
                if (mismatchFinder.numberOfMismatches > 0) {
                    // eslint-disable-next-line no-console
                    console.log(terminal_1.Colorize.red(`Found ${mismatchFinder.numberOfMismatches} mis-matching dependencies ${(subspace === null || subspace === void 0 ? void 0 : subspace.subspaceName) ? `in subspace: ${subspace === null || subspace === void 0 ? void 0 : subspace.subspaceName}` : ''}`));
                    rushConfiguration.customTipsConfiguration._showErrorTip(terminal, CustomTipsConfiguration_1.CustomTipId.TIP_RUSH_INCONSISTENT_VERSIONS);
                    if (!isRushCheckCommand && truncateLongPackageNameLists) {
                        // There isn't a --verbose flag in `rush install`/`rush update`, so a long list will always be truncated.
                        // eslint-disable-next-line no-console
                        console.log('For more detailed reporting about these version mismatches, use the "rush check --verbose" command.');
                    }
                    throw new node_core_library_1.AlreadyReportedError();
                }
                else {
                    if (isRushCheckCommand) {
                        // eslint-disable-next-line no-console
                        console.log(terminal_1.Colorize.green(`Found no mis-matching dependencies!`));
                    }
                }
            }
        }
    }
    get mismatches() {
        return this._mismatches;
    }
    get numberOfMismatches() {
        return this._mismatches.size;
    }
    getMismatches() {
        return this._getKeys(this._mismatches);
    }
    getVersionsOfMismatch(mismatch) {
        return this._mismatches.has(mismatch) ? this._getKeys(this._mismatches.get(mismatch)) : undefined;
    }
    getConsumersOfMismatch(mismatch, version) {
        const mismatchedPackage = this._mismatches.get(mismatch);
        if (!mismatchedPackage) {
            return undefined;
        }
        const mismatchedVersion = mismatchedPackage.get(version);
        return mismatchedVersion;
    }
    printAsJson() {
        const mismatchDependencies = [];
        this.getMismatches().forEach((dependency) => {
            const mismatchDependencyVersionArray = [];
            this.getVersionsOfMismatch(dependency).forEach((version) => {
                const projects = [];
                this.getConsumersOfMismatch(dependency, version).forEach((project) => {
                    projects.push(project.friendlyName);
                });
                const mismatchDependencyVersion = {
                    version: version,
                    projects: projects
                };
                mismatchDependencyVersionArray.push(mismatchDependencyVersion);
            });
            const mismatchDependency = {
                dependencyName: dependency,
                versions: mismatchDependencyVersionArray
            };
            mismatchDependencies.push(mismatchDependency);
        });
        const output = {
            mismatchedVersions: mismatchDependencies
        };
        // eslint-disable-next-line no-console
        console.log(JSON.stringify(output, undefined, 2));
    }
    print(truncateLongPackageNameLists = false) {
        // Iterate over the list. For any dependency with mismatching versions, print the projects
        this.getMismatches().forEach((dependency) => {
            // eslint-disable-next-line no-console
            console.log(terminal_1.Colorize.yellow(dependency));
            this.getVersionsOfMismatch(dependency).forEach((version) => {
                // eslint-disable-next-line no-console
                console.log(`  ${version}`);
                const consumersOfMismatch = this.getConsumersOfMismatch(dependency, version);
                let numberToPrint = truncateLongPackageNameLists
                    ? TRUNCATE_AFTER_PACKAGE_NAME_COUNT
                    : consumersOfMismatch.length;
                let numberRemaining = consumersOfMismatch.length;
                for (const { friendlyName } of consumersOfMismatch) {
                    if (numberToPrint-- === 0) {
                        break;
                    }
                    numberRemaining--;
                    // eslint-disable-next-line no-console
                    console.log(`   - ${friendlyName}`);
                }
                if (numberRemaining > 0) {
                    // eslint-disable-next-line no-console
                    console.log(`   (and ${numberRemaining} others)`);
                }
            });
            // eslint-disable-next-line no-console
            console.log();
        });
    }
    _analyze() {
        this._projects.forEach((project) => {
            if (!project.skipRushCheck) {
                // NOTE: We do not consider peer dependencies here.  The purpose of "rush check" is
                // mainly to avoid side-by-side duplicates in the node_modules folder, whereas
                // peer dependencies are just a compatibility statement that will be satisfied by a
                // regular dependency.  (It might be useful for Rush to help people keep their peer dependency
                // patterns consistent, but on the other hand different projects may have different
                // levels of compatibility -- we should wait for someone to actually request this feature
                // before we get into that.)
                project.allDependencies.forEach((dependency) => {
                    if (dependency.dependencyType !== PackageJsonEditor_1.DependencyType.Peer) {
                        const version = dependency.version;
                        const isCyclic = project.decoupledLocalDependencies.has(dependency.name);
                        if (this._isVersionAllowedAlternative(dependency.name, version)) {
                            return;
                        }
                        const name = dependency.name + (isCyclic ? ' (cyclic)' : '');
                        let dependencyVersions = this._mismatches.get(name);
                        if (!dependencyVersions) {
                            this._mismatches.set(name, (dependencyVersions = new Map()));
                        }
                        const consumers = dependencyVersions.get(version);
                        if (!consumers) {
                            dependencyVersions.set(version, [project]);
                        }
                        else {
                            consumers.push(project);
                        }
                    }
                });
            }
        });
        this._mismatches.forEach((mismatches, project) => {
            if (mismatches.size <= 1) {
                this._mismatches.delete(project);
            }
        });
    }
    _isVersionAllowedAlternative(dependency, version) {
        const allowedAlternatives = this._allowedAlternativeVersion.get(dependency);
        return Boolean(allowedAlternatives && allowedAlternatives.indexOf(version) > -1);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _getKeys(iterable) {
        const keys = [];
        if (iterable) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            iterable.forEach((value, key) => {
                keys.push(key);
            });
        }
        return keys;
    }
}
exports.VersionMismatchFinder = VersionMismatchFinder;
//# sourceMappingURL=VersionMismatchFinder.js.map