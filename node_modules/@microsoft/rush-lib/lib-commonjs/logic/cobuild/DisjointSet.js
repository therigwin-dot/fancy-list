"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisjointSet = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
/**
 * A disjoint set data structure
 */
class DisjointSet {
    constructor() {
        this._forest = new Set();
        this._parentMap = new Map();
        this._sizeMap = new Map();
        this._setByElement = new Map();
    }
    destroy() {
        var _a;
        this._forest.clear();
        this._parentMap.clear();
        this._sizeMap.clear();
        (_a = this._setByElement) === null || _a === void 0 ? void 0 : _a.clear();
    }
    /**
     * Adds a new set containing specific object
     */
    add(x) {
        if (this._forest.has(x)) {
            return;
        }
        this._forest.add(x);
        this._parentMap.set(x, x);
        this._sizeMap.set(x, 1);
        this._setByElement = undefined;
    }
    /**
     * Unions the sets that contain two objects
     */
    union(a, b) {
        let x = this._find(a);
        let y = this._find(b);
        if (x === y) {
            // x and y are already in the same set
            return;
        }
        const xSize = this._getSize(x);
        const ySize = this._getSize(y);
        if (xSize < ySize) {
            const t = x;
            x = y;
            y = t;
        }
        this._parentMap.set(y, x);
        this._sizeMap.set(x, xSize + ySize);
        this._setByElement = undefined;
    }
    getAllSets() {
        if (this._setByElement === undefined) {
            this._setByElement = new Map();
            for (const element of this._forest) {
                const root = this._find(element);
                let set = this._setByElement.get(root);
                if (set === undefined) {
                    set = new Set();
                    this._setByElement.set(root, set);
                }
                set.add(element);
            }
        }
        return this._setByElement.values();
    }
    /**
     * Returns true if x and y are in the same set
     */
    isConnected(x, y) {
        return this._find(x) === this._find(y);
    }
    _find(a) {
        let x = a;
        let parent = this._getParent(x);
        while (parent !== x) {
            parent = this._getParent(parent);
            this._parentMap.set(x, parent);
            x = parent;
            parent = this._getParent(x);
        }
        return x;
    }
    _getParent(x) {
        const parent = this._parentMap.get(x);
        if (parent === undefined) {
            // This should not happen
            throw new node_core_library_1.InternalError(`Can not find parent`);
        }
        return parent;
    }
    _getSize(x) {
        const size = this._sizeMap.get(x);
        if (size === undefined) {
            // This should not happen
            throw new node_core_library_1.InternalError(`Can not get size`);
        }
        return size;
    }
}
exports.DisjointSet = DisjointSet;
//# sourceMappingURL=DisjointSet.js.map