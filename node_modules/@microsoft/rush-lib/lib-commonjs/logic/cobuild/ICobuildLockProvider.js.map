{"version":3,"file":"ICobuildLockProvider.js","sourceRoot":"","sources":["../../../src/logic/cobuild/ICobuildLockProvider.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { OperationStatus } from '../operations/OperationStatus';\n\n/**\n * @beta\n */\nexport interface ICobuildContext {\n  /**\n   * The key for acquiring lock.\n   */\n  lockKey: string;\n  /**\n   * The expire time of the lock in seconds.\n   */\n  lockExpireTimeInSeconds: number;\n  /**\n   * The key for storing completed state.\n   */\n  completedStateKey: string;\n  /**\n   * The contextId is provided by the monorepo maintainer, it reads from environment variable {@link EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID}.\n   * It ensure only the builds from the same given contextId cooperated.\n   */\n  contextId: string;\n  /**\n   * The id of the cluster. The operations in the same cluster share the same clusterId and\n   * will be executed on the same machine.\n   */\n  clusterId: string;\n  /**\n   * The id of the runner. The identifier for the running machine.\n   *\n   * It can be specified via assigning `RUSH_COBUILD_RUNNER_ID` environment variable.\n   */\n  runnerId: string;\n  /**\n   * The id of the cache entry. It should be kept the same as the normal cacheId from ProjectBuildCache.\n   * Otherwise, there is a discrepancy in the success case wherein turning on cobuilds will\n   * fail to populate the normal build cache.\n   */\n  cacheId: string;\n  /**\n   * The name of NPM package\n   *\n   * Example: `@scope/MyProject`\n   */\n  packageName: string;\n  /**\n   * The name of the phase.\n   *\n   * Example: _phase:build\n   */\n  phaseName: string;\n}\n\n/**\n * @beta\n */\nexport interface ICobuildCompletedState {\n  status: OperationStatus.Success | OperationStatus.SuccessWithWarning | OperationStatus.Failure;\n  /**\n   * Completed state points to the cache id that was used to store the build cache.\n   * Note: Cache failed builds in a separate cache id\n   */\n  cacheId: string;\n}\n\n/**\n * @beta\n */\nexport interface ICobuildLockProvider {\n  /**\n   * The callback function invoked to connect to the lock provider.\n   * For example, initializing the connection to the redis server.\n   */\n  connectAsync(): Promise<void>;\n  /**\n   * The callback function invoked to disconnect the lock provider.\n   */\n  disconnectAsync(): Promise<void>;\n  /**\n   * The callback function to acquire a lock with a lock key and specific contexts.\n   *\n   * NOTE: This lock implementation must be a ReentrantLock. It says the lock might be acquired\n   * multiple times, since tasks in the same cluster can be run in the same VM.\n   */\n  acquireLockAsync(context: Readonly<ICobuildContext>): Promise<boolean>;\n  /**\n   * The callback function to renew a lock with a lock key and specific contexts.\n   *\n   * NOTE: If the lock key expired\n   */\n  renewLockAsync(context: Readonly<ICobuildContext>): Promise<void>;\n  /**\n   * The callback function to set completed state.\n   */\n  setCompletedStateAsync(context: Readonly<ICobuildContext>, state: ICobuildCompletedState): Promise<void>;\n  /**\n   * The callback function to get completed state.\n   */\n  getCompletedStateAsync(context: Readonly<ICobuildContext>): Promise<ICobuildCompletedState | undefined>;\n}\n"]}