import gitInfo from 'git-repo-info';
import { type ITerminal } from '@rushstack/terminal';
import type { RushConfiguration } from '../api/RushConfiguration';
import { type IGitStatusEntry } from './GitStatusParser';
export declare const DEFAULT_GIT_TAG_SEPARATOR: string;
export interface IGetBlobOptions {
    blobSpec: string;
    repositoryRoot: string;
}
export declare class Git {
    private readonly _rushConfiguration;
    private _checkedGitPath;
    private _gitPath;
    private _checkedGitInfo;
    private _gitInfo;
    private _gitEmailResult;
    private _gitHooksPath;
    constructor(rushConfiguration: RushConfiguration);
    /**
     * Returns the path to the Git binary if found. Otherwise, return undefined.
     */
    get gitPath(): string | undefined;
    getGitPathOrThrow(): string;
    /**
     * Returns true if the Git binary can be found.
     */
    isGitPresent(): boolean;
    /**
     * Returns true if the Git binary was found and the current path is under a Git working tree.
     * @param repoInfo - If provided, do the check based on this Git repo info. If not provided,
     * the result of `this.getGitInfo()` is used.
     */
    isPathUnderGitWorkingTree(repoInfo?: gitInfo.GitRepoInfo): boolean;
    /**
     * If a Git email address is configured and is nonempty, this returns it.
     * Otherwise, configuration instructions are printed to the console,
     * and AlreadyReportedError is thrown.
     */
    getGitEmailAsync(): Promise<string>;
    /**
     * If the Git email address is configured and non-empty, this returns it. Otherwise
     * it prints an error message and throws.
     */
    validateGitEmail(userEmail: string | undefined): string;
    /**
     * Get the folder where Git hooks should go for the current working tree.
     * Returns undefined if the current path is not under a Git working tree.
     */
    getHooksFolder(): string | undefined;
    getIsHooksPathDefaultAsync(): Promise<boolean>;
    getConfigHooksPathAsync(): Promise<string>;
    /**
     * Get information about the current Git working tree.
     * Returns undefined if rush.json is not under a Git working tree.
     */
    getGitInfo(): Readonly<gitInfo.GitRepoInfo> | undefined;
    getMergeBaseAsync(targetBranch: string, terminal: ITerminal, shouldFetch?: boolean): Promise<string>;
    getBlobContentAsync({ blobSpec, repositoryRoot }: IGetBlobOptions): Promise<string>;
    /**
     * @param pathPrefix - An optional path prefix "git diff"s should be filtered by.
     * @returns
     * An array of paths of repo-root-relative paths of files that are different from
     * those in the provided {@param targetBranch}. If a {@param pathPrefix} is provided,
     * this function only returns results under the that path.
     */
    getChangedFilesAsync(targetBranch: string, terminal: ITerminal, skipFetch?: boolean, pathPrefix?: string): Promise<string[]>;
    /**
     * Gets the remote default branch that maps to the provided repository url.
     * This method is used by 'Rush change' to find the default remote branch to compare against.
     * If repository url is not provided or if there is no match, returns the default remote's
     * default branch 'origin/main'.
     * If there are more than one matches, returns the first remote's default branch.
     *
     * @param rushConfiguration - rush configuration
     */
    getRemoteDefaultBranchAsync(): Promise<string>;
    hasUncommittedChangesAsync(): Promise<boolean>;
    hasUnstagedChangesAsync(): Promise<boolean>;
    /**
     * The list of files changed but not committed
     */
    getUncommittedChangesAsync(): Promise<ReadonlyArray<string>>;
    getTagSeparator(): string;
    getGitStatusAsync(): Promise<Iterable<IGitStatusEntry>>;
    /**
     * Git remotes can use different URL syntaxes; this converts them all to a normalized HTTPS
     * representation for matching purposes.  IF THE INPUT IS NOT ALREADY HTTPS, THE OUTPUT IS
     * NOT NECESSARILY A VALID GIT URL.
     *
     * @example
     * `git@github.com:ExampleOrg/ExampleProject.git` --> `https://github.com/ExampleOrg/ExampleProject`
     */
    static normalizeGitUrlForComparison(gitUrl: string): string;
    /**
     * This will throw errors only if we cannot find Git commandline.
     * If git email didn't configure, this will return undefined; otherwise,
     * returns user.email config
     */
    tryGetGitEmailAsync(): Promise<string | undefined>;
    /**
     * Returns an object containing either the result of the `git config user.email`
     * command or an error.
     */
    private _tryGetGitEmailAsync;
    private _tryGetGitHooksPathAsync;
    private _tryFetchRemoteBranch;
    private _fetchRemoteBranch;
    /**
     * @internal
     */
    _executeGitCommandAndCaptureOutputAsync(gitPath: string, args: string[], repositoryRoot?: string): Promise<string>;
    /**
     *
     * @param ref Given a ref which can be branch name, commit hash, tag name, etc, check if it is a commit hash
     */
    determineIfRefIsACommitAsync(ref: string): Promise<boolean>;
}
//# sourceMappingURL=Git.d.ts.map