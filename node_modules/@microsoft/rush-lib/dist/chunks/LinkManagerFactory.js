"use strict";
exports.id = "LinkManagerFactory";
exports.ids = ["LinkManagerFactory"];
exports.modules = {

/***/ 94024:
/*!**************************************************!*\
  !*** ./lib-esnext/logic/base/BaseLinkManager.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseLinkManager: () => (/* binding */ BaseLinkManager),
/* harmony export */   SymlinkKind: () => (/* binding */ SymlinkKind)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 16928);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 277275);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/terminal */ 367587);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/Utilities */ 387714);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/Stopwatch */ 74873);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 778261);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../RushConstants */ 195191);
/* harmony import */ var _api_FlagFile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../api/FlagFile */ 251748);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.








var SymlinkKind;
(function (SymlinkKind) {
    SymlinkKind[SymlinkKind["File"] = 0] = "File";
    SymlinkKind[SymlinkKind["Directory"] = 1] = "Directory";
})(SymlinkKind || (SymlinkKind = {}));
class BaseLinkManager {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
    }
    static _createSymlink(options) {
        const newLinkFolder = path__WEBPACK_IMPORTED_MODULE_0__.dirname(options.newLinkPath);
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.ensureFolder(newLinkFolder);
        let targetPath;
        if (_api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_3__.EnvironmentConfiguration.absoluteSymlinks) {
            targetPath = options.linkTargetPath;
        }
        else {
            // Link to the relative path, to avoid going outside containers such as a Docker image
            targetPath = path__WEBPACK_IMPORTED_MODULE_0__.relative(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.getRealPath(newLinkFolder), options.linkTargetPath);
        }
        if (process.platform === 'win32') {
            if (options.symlinkKind === SymlinkKind.Directory) {
                // For directories, we use a Windows "junction".  On Unix, this produces a regular symlink.
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.createSymbolicLinkJunction({
                    linkTargetPath: targetPath,
                    newLinkPath: options.newLinkPath
                });
            }
            else {
                // For files, we use a Windows "hard link", because creating a symbolic link requires
                // administrator permission.
                // NOTE: We cannot use the relative path for hard links
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.createHardLink({
                    linkTargetPath: options.linkTargetPath,
                    newLinkPath: options.newLinkPath
                });
            }
        }
        else {
            // However hard links seem to cause build failures on Mac, so for all other operating systems
            // we use symbolic links for this case.
            if (options.symlinkKind === SymlinkKind.Directory) {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.createSymbolicLinkFolder({
                    linkTargetPath: targetPath,
                    newLinkPath: options.newLinkPath
                });
            }
            else {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.createSymbolicLinkFile({
                    linkTargetPath: targetPath,
                    newLinkPath: options.newLinkPath
                });
            }
        }
    }
    /**
     * For a Package object that represents a top-level Rush project folder
     * (i.e. with source code that we will be building), this clears out its
     * node_modules folder and then recursively creates all the symlinked folders.
     */
    static _createSymlinksForTopLevelProject(localPackage) {
        const localModuleFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.folderPath, 'node_modules');
        // Sanity check
        if (localPackage.parent) {
            throw new Error('The provided package is not a top-level project');
        }
        // The root-level folder is the project itself, so we simply delete its node_modules
        // to start clean
        // eslint-disable-next-line no-console
        console.log('Purging ' + localModuleFolder);
        _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.dangerouslyDeletePath(localModuleFolder);
        if (localPackage.children.length > 0) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(localModuleFolder);
            for (const child of localPackage.children) {
                BaseLinkManager._createSymlinksForDependencies(child);
            }
        }
    }
    /**
     * This is a helper function used by createSymlinksForTopLevelProject().
     * It will recursively creates symlinked folders corresponding to each of the
     * Package objects in the provided tree.
     */
    static _createSymlinksForDependencies(localPackage) {
        const localModuleFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.folderPath, 'node_modules');
        if (!localPackage.symlinkTargetFolderPath) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('localPackage.symlinkTargetFolderPath was not assigned');
        }
        // This is special case for when localPackage.name has the form '@scope/name',
        // in which case we need to create the '@scope' folder first.
        const parentFolderPath = path__WEBPACK_IMPORTED_MODULE_0__.dirname(localPackage.folderPath);
        if (parentFolderPath && parentFolderPath !== localPackage.folderPath) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(parentFolderPath)) {
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(parentFolderPath);
            }
        }
        if (localPackage.children.length === 0) {
            // If there are no children, then we can symlink the entire folder
            BaseLinkManager._createSymlink({
                linkTargetPath: localPackage.symlinkTargetFolderPath,
                newLinkPath: localPackage.folderPath,
                symlinkKind: SymlinkKind.Directory
            });
        }
        else {
            // If there are children, then we need to symlink each item in the folder individually
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(localPackage.folderPath);
            for (const filename of _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.readFolderItemNames(localPackage.symlinkTargetFolderPath)) {
                if (filename.toLowerCase() !== 'node_modules') {
                    // Create the symlink
                    let symlinkKind = SymlinkKind.File;
                    const linkSource = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.folderPath, filename);
                    let linkTarget = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.symlinkTargetFolderPath, filename);
                    const linkStats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.getLinkStatistics(linkTarget);
                    if (linkStats.isSymbolicLink()) {
                        const targetStats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.getStatistics(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.getRealPath(linkTarget));
                        if (targetStats.isDirectory()) {
                            // Neither a junction nor a directory-symlink can have a directory-symlink
                            // as its target; instead, we must obtain the real physical path.
                            // A junction can link to another junction.  Unfortunately, the node 'fs' API
                            // lacks the ability to distinguish between a junction and a directory-symlink
                            // (even though it has the ability to create them both), so the safest policy
                            // is to always make a junction and always to the real physical path.
                            linkTarget = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.getRealPath(linkTarget);
                            symlinkKind = SymlinkKind.Directory;
                        }
                    }
                    else if (linkStats.isDirectory()) {
                        symlinkKind = SymlinkKind.Directory;
                    }
                    BaseLinkManager._createSymlink({
                        linkTargetPath: linkTarget,
                        newLinkPath: linkSource,
                        symlinkKind
                    });
                }
            }
        }
        if (localPackage.children.length > 0) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(localModuleFolder);
            for (const child of localPackage.children) {
                BaseLinkManager._createSymlinksForDependencies(child);
            }
        }
    }
    /**
     * Creates node_modules symlinks for all Rush projects defined in the RushConfiguration.
     * @param force - Normally the operation will be skipped if the links are already up to date;
     *   if true, this option forces the links to be recreated.
     */
    async createSymlinksForProjectsAsync(force) {
        // eslint-disable-next-line no-console
        console.log('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.Colorize.bold('Linking local projects'));
        const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_5__.Stopwatch.start();
        await this._linkProjectsAsync();
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        await new _api_FlagFile__WEBPACK_IMPORTED_MODULE_6__.FlagFile(this._rushConfiguration.defaultSubspace.getSubspaceTempFolderPath(), _RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.lastLinkFlagFilename, {}).createAsync();
        stopwatch.stop();
        // eslint-disable-next-line no-console
        console.log('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.Colorize.green(`Linking finished successfully. (${stopwatch.toString()})`));
        // eslint-disable-next-line no-console
        console.log('\nNext you should probably run "rush build" or "rush rebuild"');
    }
}
//# sourceMappingURL=BaseLinkManager.js.map

/***/ })

};
;
//# sourceMappingURL=LinkManagerFactory.js.map