"use strict";
exports.id = "InstallManagerFactory";
exports.ids = ["InstallManagerFactory"];
exports.modules = {

/***/ 498549:
/*!*****************************************************!*\
  !*** ./lib-esnext/logic/ApprovedPackagesChecker.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApprovedPackagesChecker: () => (/* binding */ ApprovedPackagesChecker)
/* harmony export */ });
/* harmony import */ var _DependencySpecifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DependencySpecifier */ 687463);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class ApprovedPackagesChecker {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
        this._approvedPackagesPolicy = this._rushConfiguration.approvedPackagesPolicy;
        this._filesAreOutOfDate = false;
        if (this._approvedPackagesPolicy.enabled) {
            this._updateApprovedPackagesPolicy();
        }
    }
    /**
     * If true, the files on disk are out of date.
     */
    get approvedPackagesFilesAreOutOfDate() {
        return this._filesAreOutOfDate;
    }
    /**
     * Examines the current dependencies for the projects specified in RushConfiguration,
     * and then adds them to the 'browser-approved-packages.json' and
     * 'nonbrowser-approved-packages.json' config files.  If these files don't exist,
     * they will be created.
     *
     * If the "approvedPackagesPolicy" feature is not enabled, then no action is taken.
     */
    rewriteConfigFiles() {
        const approvedPackagesPolicy = this._rushConfiguration.approvedPackagesPolicy;
        if (approvedPackagesPolicy.enabled) {
            approvedPackagesPolicy.browserApprovedPackages.saveToFile();
            approvedPackagesPolicy.nonbrowserApprovedPackages.saveToFile();
        }
    }
    _updateApprovedPackagesPolicy() {
        for (const rushProject of this._rushConfiguration.projects) {
            const packageJson = rushProject.packageJson;
            this._collectDependencies(packageJson.dependencies, this._approvedPackagesPolicy, rushProject);
            this._collectDependencies(packageJson.devDependencies, this._approvedPackagesPolicy, rushProject);
            this._collectDependencies(packageJson.peerDependencies, this._approvedPackagesPolicy, rushProject);
            this._collectDependencies(packageJson.optionalDependencies, this._approvedPackagesPolicy, rushProject);
        }
    }
    _collectDependencies(dependencies, approvedPackagesPolicy, rushProject) {
        if (dependencies) {
            for (const packageName of Object.keys(dependencies)) {
                let referencedPackageName = packageName;
                // Special handling for NPM package aliases such as this:
                //
                // "dependencies": {
                //   "alias-name": "npm:target-name@^1.2.3"
                // }
                const dependencySpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_0__.DependencySpecifier(packageName, dependencies[packageName]);
                if (dependencySpecifier.aliasTarget) {
                    // Use "target-name" instead of "alias-name"
                    referencedPackageName = dependencySpecifier.aliasTarget.packageName;
                }
                const scope = this._rushConfiguration.packageNameParser.getScope(referencedPackageName);
                // Make sure the scope isn't something like "@types" which should be ignored
                if (!approvedPackagesPolicy.ignoredNpmScopes.has(scope) && rushProject.reviewCategory) {
                    // Yes, add it to the list if it's not already there
                    let updated = false;
                    // By default we put everything in the browser file.  But if it already appears in the
                    // non-browser file, then use that instead.
                    if (approvedPackagesPolicy.nonbrowserApprovedPackages.getItemByName(referencedPackageName)) {
                        updated = approvedPackagesPolicy.nonbrowserApprovedPackages.addOrUpdatePackage(referencedPackageName, rushProject.reviewCategory);
                    }
                    else {
                        updated = approvedPackagesPolicy.browserApprovedPackages.addOrUpdatePackage(referencedPackageName, rushProject.reviewCategory);
                    }
                    this._filesAreOutOfDate = this._filesAreOutOfDate || updated;
                }
            }
        }
    }
}
//# sourceMappingURL=ApprovedPackagesChecker.js.map

/***/ }),

/***/ 438212:
/*!***************************************************!*\
  !*** ./lib-esnext/logic/InstallManagerFactory.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InstallManagerFactory: () => (/* binding */ InstallManagerFactory)
/* harmony export */ });
/* harmony import */ var _installManager_WorkspaceInstallManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./installManager/WorkspaceInstallManager */ 901896);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

class InstallManagerFactory {
    static async getInstallManagerAsync(rushConfiguration, rushGlobalFolder, purgeManager, options) {
        if (rushConfiguration.isPnpm &&
            rushConfiguration.pnpmOptions &&
            rushConfiguration.pnpmOptions.useWorkspaces) {
            return new _installManager_WorkspaceInstallManager__WEBPACK_IMPORTED_MODULE_0__.WorkspaceInstallManager(rushConfiguration, rushGlobalFolder, purgeManager, options);
        }
        const rushInstallManagerModule = await Promise.all(/*! import() | RushInstallManager */[__webpack_require__.e("lib-esnext_logic_LinkManagerFactory_js"), __webpack_require__.e("RushInstallManager")]).then(__webpack_require__.bind(__webpack_require__, /*! ./installManager/RushInstallManager */ 964771));
        return new rushInstallManagerModule.RushInstallManager(rushConfiguration, rushGlobalFolder, purgeManager, options);
    }
}
//# sourceMappingURL=InstallManagerFactory.js.map

/***/ }),

/***/ 277082:
/*!*********************************************************!*\
  !*** ./lib-esnext/logic/ProjectImpactGraphGenerator.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProjectImpactGraphGenerator: () => (/* binding */ ProjectImpactGraphGenerator)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 277275);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-yaml */ 607089);
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_yaml__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utilities/Stopwatch */ 74873);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RushConstants */ 195191);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/terminal */ 367587);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





/**
 * Default global excluded globs
 * Only used if the `<repository_root>/.mergequeueignore` does not exist
 */
const DEFAULT_GLOBAL_EXCLUDED_GLOBS = ['common/autoinstallers/**'];
async function tryReadFileLinesAsync(filePath) {
    let fileContents;
    try {
        fileContents = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readFileAsync(filePath);
    }
    catch (error) {
        if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.isNotExistError(error)) {
            throw error;
        }
    }
    if (fileContents) {
        return _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Text.convertToLf(fileContents).split('\n');
    }
}
class ProjectImpactGraphGenerator {
    /**
     * Get repositoryRoot and load projects within the rush.json
     */
    constructor(terminal, rushConfiguration) {
        this._terminal = terminal;
        this._rushConfiguration = rushConfiguration;
        const { rushJsonFolder } = rushConfiguration;
        this._repositoryRoot = rushJsonFolder;
        this._projectImpactGraphFilePath = `${rushJsonFolder}/${_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.projectImpactGraphFilename}`;
    }
    /**
     * Load global excluded globs
     */
    async _loadGlobalExcludedGlobsAsync() {
        const filePath = `${this._repositoryRoot}/${_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.mergeQueueIgnoreFileName}`;
        return await tryReadFileLinesAsync(filePath);
    }
    /**
     * Load project excluded globs
     * @param projectRootRelativePath - project root relative path
     */
    async _tryLoadProjectExcludedGlobsAsync(projectRootRelativePath) {
        const filePath = `${this._repositoryRoot}/${projectRootRelativePath}/${_RushConstants__WEBPACK_IMPORTED_MODULE_3__.RushConstants.mergeQueueIgnoreFileName}`;
        const globs = await tryReadFileLinesAsync(filePath);
        if (globs) {
            for (let i = 0; i < globs.length; i++) {
                globs[i] = `${projectRootRelativePath}/${globs[i]}`;
            }
            return globs;
        }
    }
    /**
     * Core Logic: generate project-impact-graph.yaml
     */
    async generateAsync() {
        const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_4__.Stopwatch.start();
        const [globalExcludedGlobs = DEFAULT_GLOBAL_EXCLUDED_GLOBS, projectEntries] = await Promise.all([
            this._loadGlobalExcludedGlobsAsync(),
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.Async.mapAsync(this._rushConfiguration.projects, async ({ packageName, consumingProjects, projectRelativeFolder }) => {
                const dependentList = [packageName];
                for (const consumingProject of consumingProjects) {
                    dependentList.push(consumingProject.packageName);
                }
                const projectImpactGraphProjectConfiguration = {
                    includedGlobs: [`${projectRelativeFolder}/**`],
                    dependentProjects: dependentList.sort()
                };
                const projectExcludedGlobs = await this._tryLoadProjectExcludedGlobsAsync(projectRelativeFolder);
                if (projectExcludedGlobs) {
                    projectImpactGraphProjectConfiguration.excludedGlobs = projectExcludedGlobs;
                }
                return [packageName, projectImpactGraphProjectConfiguration];
            }, { concurrency: 50 })
        ]);
        projectEntries.sort(([aName], [bName]) => aName.localeCompare(bName));
        const projects = Object.fromEntries(projectEntries);
        const content = { globalExcludedGlobs, projects };
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.writeFileAsync(this._projectImpactGraphFilePath, js_yaml__WEBPACK_IMPORTED_MODULE_1___default().safeDump(content));
        stopwatch.stop();
        this._terminal.writeLine();
        this._terminal.writeLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.Colorize.green(`Generate project impact graph successfully. (${stopwatch.toString()})`));
    }
    async validateAsync() {
        // TODO: More validation other than just existence
        return await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.existsAsync(this._projectImpactGraphFilePath);
    }
}
//# sourceMappingURL=ProjectImpactGraphGenerator.js.map

/***/ }),

/***/ 538033:
/*!*****************************************************!*\
  !*** ./lib-esnext/logic/base/BaseInstallManager.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseInstallManager: () => (/* binding */ BaseInstallManager),
/* harmony export */   pnpmIgnoreCompatibilityDbParameter: () => (/* binding */ pnpmIgnoreCompatibilityDbParameter)
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ 370857);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ 16928);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ 776982);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! semver */ 338064);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/node-core-library */ 277275);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fs */ 179896);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! fs/promises */ 191943);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @rushstack/terminal */ 367587);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var pnpm_sync_lib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! pnpm-sync-lib */ 567749);
/* harmony import */ var pnpm_sync_lib__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(pnpm_sync_lib__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _ApprovedPackagesChecker__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../ApprovedPackagesChecker */ 498549);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 778261);
/* harmony import */ var _Git__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../Git */ 53940);
/* harmony import */ var _api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../api/LastInstallFlag */ 844471);
/* harmony import */ var _api_Rush__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../api/Rush */ 490350);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../RushConstants */ 195191);
/* harmony import */ var _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../ShrinkwrapFileFactory */ 795791);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../utilities/Utilities */ 387714);
/* harmony import */ var _installManager_InstallHelpers__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../installManager/InstallHelpers */ 245559);
/* harmony import */ var _policy_PolicyValidator__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../policy/PolicyValidator */ 731283);
/* harmony import */ var _setup_SetupPackageRegistry__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../setup/SetupPackageRegistry */ 365756);
/* harmony import */ var _pnpm_PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../pnpm/PnpmfileConfiguration */ 621063);
/* harmony import */ var _utilities_npmrcUtilities__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../../utilities/npmrcUtilities */ 832286);
/* harmony import */ var _pnpm_SubspacePnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../pnpm/SubspacePnpmfileConfiguration */ 908327);
/* harmony import */ var _ProjectImpactGraphGenerator__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../ProjectImpactGraphGenerator */ 277082);
/* harmony import */ var _api_FlagFile__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../api/FlagFile */ 251748);
/* harmony import */ var _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../pnpm/PnpmShrinkwrapFile */ 522544);
/* harmony import */ var _utilities_PnpmSyncUtilities__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../utilities/PnpmSyncUtilities */ 279136);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



























/**
 * Pnpm don't support --ignore-compatibility-db, so use --config.ignoreCompatibilityDb for now.
 */
const pnpmIgnoreCompatibilityDbParameter = '--config.ignoreCompatibilityDb';
const pnpmCacheDirParameter = '--config.cacheDir';
const pnpmStateDirParameter = '--config.stateDir';
const gitLfsHooks = new Set(['post-checkout', 'post-commit', 'post-merge', 'pre-push']);
/**
 * This class implements common logic between "rush install" and "rush update".
 */
class BaseInstallManager {
    constructor(rushConfiguration, rushGlobalFolder, purgeManager, options) {
        this._npmSetupValidated = false;
        this._syncNpmrcAlreadyCalled = false;
        this._terminal = options.terminal;
        this.rushConfiguration = rushConfiguration;
        this.rushGlobalFolder = rushGlobalFolder;
        this.installRecycler = purgeManager.commonTempFolderRecycler;
        this.options = options;
        this._commonTempLinkFlag = new _api_FlagFile__WEBPACK_IMPORTED_MODULE_9__.FlagFile(options.subspace.getSubspaceTempFolderPath(), _RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.lastLinkFlagFilename, {});
        this.subspaceInstallFlags = new Map();
        if (rushConfiguration.subspacesFeatureEnabled) {
            for (const subspace of rushConfiguration.subspaces) {
                this.subspaceInstallFlags.set(subspace.subspaceName, (0,_api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_11__.getCommonTempFlag)(rushConfiguration, subspace));
            }
        }
    }
    async doInstallAsync() {
        const { allowShrinkwrapUpdates, selectedProjects, pnpmFilterArgumentValues, resolutionOnly, variant } = this.options;
        const isFilteredInstall = pnpmFilterArgumentValues.length > 0;
        const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;
        // Prevent filtered installs when workspaces is disabled
        if (isFilteredInstall && !useWorkspaces) {
            // eslint-disable-next-line no-console
            console.log();
            // eslint-disable-next-line no-console
            console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.red('Project filtering arguments can only be used when running in a workspace environment. Run the ' +
                'command again without specifying these arguments.'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
        }
        // Prevent update when using a filter, as modifications to the shrinkwrap shouldn't be saved
        if (allowShrinkwrapUpdates && isFilteredInstall) {
            // Allow partial update when there are subspace projects
            if (!this.rushConfiguration.subspacesFeatureEnabled) {
                // eslint-disable-next-line no-console
                console.log();
                // eslint-disable-next-line no-console
                console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.red('Project filtering arguments cannot be used when running "rush update". Run the command again ' +
                    'without specifying these arguments.'));
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
            }
        }
        const subspace = this.options.subspace;
        const projectImpactGraphGenerator = this.rushConfiguration
            .experimentsConfiguration.configuration.generateProjectImpactGraphDuringRushUpdate
            ? new _ProjectImpactGraphGenerator__WEBPACK_IMPORTED_MODULE_12__.ProjectImpactGraphGenerator(this._terminal, this.rushConfiguration)
            : undefined;
        const { shrinkwrapIsUpToDate, npmrcHash, projectImpactGraphIsUpToDate, variantIsUpToDate } = await this.prepareAsync(subspace, variant, projectImpactGraphGenerator);
        if (this.options.checkOnly) {
            return;
        }
        // eslint-disable-next-line no-console
        console.log('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.bold(`Checking installation in "${subspace.getSubspaceTempFolderPath()}"`));
        // This marker file indicates that the last "rush install" completed successfully.
        // Always perform a clean install if filter flags were provided. Additionally, if
        // "--purge" was specified, or if the last install was interrupted, then we will
        // need to perform a clean install.  Otherwise, we can do an incremental install.
        const commonTempInstallFlag = (0,_api_LastInstallFlag__WEBPACK_IMPORTED_MODULE_11__.getCommonTempFlag)(this.rushConfiguration, subspace, {
            npmrcHash: npmrcHash || '<NO NPMRC>'
        });
        if (isFilteredInstall && selectedProjects) {
            const selectedProjectNames = [];
            for (const { packageName } of selectedProjects) {
                selectedProjectNames.push(packageName);
            }
            selectedProjectNames.sort();
            // Get the projects involved in this filtered install
            commonTempInstallFlag.mergeFromObject({
                selectedProjectNames
            });
        }
        const optionsToIgnore = !this.rushConfiguration
            .experimentsConfiguration.configuration.cleanInstallAfterNpmrcChanges
            ? ['npmrcHash'] // If the "cleanInstallAfterNpmrcChanges" experiment is disabled, ignore the npmrcHash
            : undefined;
        const cleanInstall = !(await commonTempInstallFlag.checkValidAndReportStoreIssuesAsync({
            rushVerb: allowShrinkwrapUpdates ? 'update' : 'install',
            statePropertiesToIgnore: optionsToIgnore
        }));
        // Allow us to defer the file read until we need it
        const canSkipInstallAsync = async () => {
            // Based on timestamps, can we skip this install entirely?
            const outputStats = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.getStatisticsAsync(commonTempInstallFlag.path);
            return this.canSkipInstallAsync(outputStats.mtime, subspace, variant);
        };
        if (resolutionOnly ||
            cleanInstall ||
            !variantIsUpToDate ||
            !shrinkwrapIsUpToDate ||
            !(await canSkipInstallAsync()) ||
            !projectImpactGraphIsUpToDate) {
            // eslint-disable-next-line no-console
            console.log();
            await this.validateNpmSetupAsync();
            if (!this.rushConfiguration.rushConfigurationJson.suppressRushIsPublicVersionCheck) {
                let publishedRelease;
                try {
                    publishedRelease = await this._checkIfReleaseIsPublishedAsync();
                }
                catch (_a) {
                    // If the user is working in an environment that can't reach the registry,
                    // don't bother them with errors.
                }
                if (publishedRelease === false) {
                    // eslint-disable-next-line no-console
                    console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.yellow('Warning: This release of the Rush tool was unpublished; it may be unstable.'));
                }
            }
            if (!resolutionOnly) {
                // Delete the successful install file to indicate the install transaction has started
                await commonTempInstallFlag.clearAsync();
                // Since we're going to be tampering with common/node_modules, delete the "rush link" flag file if it exists;
                // this ensures that a full "rush link" is required next time
                await this._commonTempLinkFlag.clearAsync();
            }
            // Give plugins an opportunity to act before invoking the installation process
            if (this.options.beforeInstallAsync !== undefined) {
                await this.options.beforeInstallAsync(subspace);
            }
            await Promise.all([
                // Perform the actual install
                this.installAsync(cleanInstall, subspace),
                // If allowed, generate the project impact graph
                allowShrinkwrapUpdates ? projectImpactGraphGenerator === null || projectImpactGraphGenerator === void 0 ? void 0 : projectImpactGraphGenerator.generateAsync() : undefined
            ]);
            if (this.options.allowShrinkwrapUpdates && !shrinkwrapIsUpToDate) {
                const committedShrinkwrapFileName = subspace.getCommittedShrinkwrapFilePath(variant);
                const shrinkwrapFile = _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_13__.ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, committedShrinkwrapFileName);
                shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.validateShrinkwrapAfterUpdate(this.rushConfiguration, subspace, this._terminal);
                // Copy (or delete) common\temp\pnpm-lock.yaml --> common\config\rush\pnpm-lock.yaml
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_14__.Utilities.syncFile(subspace.getTempShrinkwrapFilename(), committedShrinkwrapFileName);
            }
            else {
                // TODO: Validate whether the package manager updated it in a nontrivial way
            }
            // Always update the state file if running "rush update"
            if (this.options.allowShrinkwrapUpdates) {
                if (subspace.getRepoState().refreshState(this.rushConfiguration, subspace, variant)) {
                    // eslint-disable-next-line no-console
                    console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.yellow(`${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.repoStateFilename} has been modified and must be committed to source control.`));
                }
            }
        }
        else {
            // eslint-disable-next-line no-console
            console.log('Installation is already up-to-date.');
        }
        const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;
        // if usePnpmSyncForInjectedDependencies is true
        // the pnpm-sync will generate the pnpm-sync.json based on lockfile
        if (this.rushConfiguration.isPnpm && (experiments === null || experiments === void 0 ? void 0 : experiments.usePnpmSyncForInjectedDependencies)) {
            const pnpmLockfilePath = subspace.getTempShrinkwrapFilename();
            const dotPnpmFolder = `${subspace.getSubspaceTempFolderPath()}/node_modules/.pnpm`;
            // we have an edge case here
            // if a package.json has no dependencies, pnpm will still generate the pnpm-lock.yaml but not .pnpm folder
            // so we need to make sure pnpm-lock.yaml and .pnpm exists before calling the pnpmSync APIs
            if ((await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.existsAsync(pnpmLockfilePath)) && (await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.existsAsync(dotPnpmFolder))) {
                await (0,pnpm_sync_lib__WEBPACK_IMPORTED_MODULE_8__.pnpmSyncPrepareAsync)({
                    lockfilePath: pnpmLockfilePath,
                    dotPnpmFolder,
                    lockfileId: subspace.subspaceName,
                    ensureFolderAsync: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.ensureFolderAsync,
                    // eslint-disable-next-line @typescript-eslint/naming-convention
                    readPnpmLockfile: async (lockfilePath) => {
                        var _a, _b;
                        const wantedPnpmLockfile = _pnpm_PnpmShrinkwrapFile__WEBPACK_IMPORTED_MODULE_15__.PnpmShrinkwrapFile.loadFromFile(lockfilePath, { withCaching: true });
                        if (!wantedPnpmLockfile) {
                            return undefined;
                        }
                        else {
                            const lockfilePackages = Object.create(null);
                            for (const versionPath of wantedPnpmLockfile.packages.keys()) {
                                lockfilePackages[versionPath] = {
                                    dependencies: (_a = wantedPnpmLockfile.packages.get(versionPath)) === null || _a === void 0 ? void 0 : _a.dependencies,
                                    optionalDependencies: (_b = wantedPnpmLockfile.packages.get(versionPath)) === null || _b === void 0 ? void 0 : _b.optionalDependencies
                                };
                            }
                            const result = {
                                lockfileVersion: wantedPnpmLockfile.shrinkwrapFileMajorVersion,
                                importers: Object.fromEntries(wantedPnpmLockfile.importers.entries()),
                                packages: lockfilePackages
                            };
                            return result;
                        }
                    },
                    logMessageCallback: (logMessageOptions) => _utilities_PnpmSyncUtilities__WEBPACK_IMPORTED_MODULE_16__.PnpmSyncUtilities.processLogMessage(logMessageOptions, this._terminal)
                });
            }
            // clean up the out of date .pnpm-sync.json
            for (const rushProject of subspace.getProjects()) {
                const pnpmSyncJsonPath = `${rushProject.projectFolder}/node_modules/.pnpm-sync.json`;
                if (!(0,fs__WEBPACK_IMPORTED_MODULE_5__.existsSync)(pnpmSyncJsonPath)) {
                    continue;
                }
                let existingPnpmSyncJsonFile;
                try {
                    existingPnpmSyncJsonFile = JSON.parse((await (0,fs_promises__WEBPACK_IMPORTED_MODULE_6__.readFile)(pnpmSyncJsonPath)).toString());
                    if ((existingPnpmSyncJsonFile === null || existingPnpmSyncJsonFile === void 0 ? void 0 : existingPnpmSyncJsonFile.version) !== (0,pnpm_sync_lib__WEBPACK_IMPORTED_MODULE_8__.pnpmSyncGetJsonVersion)()) {
                        await (0,fs_promises__WEBPACK_IMPORTED_MODULE_6__.unlink)(pnpmSyncJsonPath);
                    }
                }
                catch (e) {
                    await (0,fs_promises__WEBPACK_IMPORTED_MODULE_6__.unlink)(pnpmSyncJsonPath);
                }
            }
        }
        // Perform any post-install work the install manager requires
        await this.postInstallAsync(subspace);
        if (!resolutionOnly) {
            // Create the marker file to indicate a successful install
            await commonTempInstallFlag.createAsync();
        }
        // Give plugins an opportunity to act after a successful install
        if (this.options.afterInstallAsync !== undefined) {
            await this.options.afterInstallAsync(subspace);
        }
        // eslint-disable-next-line no-console
        console.log('');
    }
    async canSkipInstallAsync(lastModifiedDate, subspace, variant) {
        // Based on timestamps, can we skip this install entirely?
        const potentiallyChangedFiles = [];
        // Consider the timestamp on the node_modules folder; if someone tampered with it
        // or deleted it entirely, then we can't skip this install
        potentiallyChangedFiles.push(path__WEBPACK_IMPORTED_MODULE_1__.join(subspace.getSubspaceTempFolderPath(), _RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.nodeModulesFolderName));
        // Additionally, if they pulled an updated shrinkwrap file from Git,
        // then we can't skip this install
        potentiallyChangedFiles.push(subspace.getCommittedShrinkwrapFilePath(variant));
        // Add common-versions.json file to the potentially changed files list.
        potentiallyChangedFiles.push(subspace.getCommonVersionsFilePath(variant));
        // Add pnpm-config.json file to the potentially changed files list.
        potentiallyChangedFiles.push(subspace.getPnpmConfigFilePath());
        if (this.rushConfiguration.isPnpm) {
            // If the repo is using pnpmfile.js, consider that also
            const pnpmFileFilePath = subspace.getPnpmfilePath(variant);
            const pnpmFileExists = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.existsAsync(pnpmFileFilePath);
            if (pnpmFileExists) {
                potentiallyChangedFiles.push(pnpmFileFilePath);
            }
        }
        return await _utilities_Utilities__WEBPACK_IMPORTED_MODULE_14__.Utilities.isFileTimestampCurrentAsync(lastModifiedDate, potentiallyChangedFiles);
    }
    async prepareAsync(subspace, variant, projectImpactGraphGenerator) {
        const terminal = this._terminal;
        const { allowShrinkwrapUpdates } = this.options;
        // Check the policies
        await _policy_PolicyValidator__WEBPACK_IMPORTED_MODULE_17__.validatePolicyAsync(this.rushConfiguration, subspace, variant, this.options);
        await this._installGitHooksAsync();
        const approvedPackagesChecker = new _ApprovedPackagesChecker__WEBPACK_IMPORTED_MODULE_18__.ApprovedPackagesChecker(this.rushConfiguration);
        if (approvedPackagesChecker.approvedPackagesFilesAreOutOfDate) {
            approvedPackagesChecker.rewriteConfigFiles();
            if (allowShrinkwrapUpdates) {
                terminal.writeLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.yellow('Approved package files have been updated. These updates should be committed to source control'));
            }
            else {
                throw new Error(`Approved packages files are out-of date. Run "rush update" to update them.`);
            }
        }
        // Ensure that the package manager is installed
        await _installManager_InstallHelpers__WEBPACK_IMPORTED_MODULE_19__.InstallHelpers.ensureLocalPackageManagerAsync(this.rushConfiguration, this.rushGlobalFolder, this.options.maxInstallAttempts);
        let shrinkwrapFile = undefined;
        // (If it's a full update, then we ignore the shrinkwrap from Git since it will be overwritten)
        if (!this.options.fullUpgrade) {
            const committedShrinkwrapFileName = subspace.getCommittedShrinkwrapFilePath(variant);
            try {
                shrinkwrapFile = _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_13__.ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, committedShrinkwrapFileName);
            }
            catch (ex) {
                terminal.writeLine();
                terminal.writeLine(`Unable to load the ${this.rushConfiguration.shrinkwrapFilePhrase}: ${ex.message}`);
                if (!allowShrinkwrapUpdates) {
                    terminal.writeLine();
                    terminal.writeLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.red('You need to run "rush update" to fix this problem'));
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
                }
                shrinkwrapFile = undefined;
            }
        }
        // Write a file indicating which variant is being installed.
        // This will be used by bulk scripts to determine the correct Shrinkwrap file to track.
        const currentVariantJsonFilePath = this.rushConfiguration.currentVariantJsonFilePath;
        const currentVariantJson = {
            variant: variant !== null && variant !== void 0 ? variant : null
        };
        // Determine if the variant is already current by updating current-variant.json.
        // If nothing is written, the variant has not changed.
        const variantIsUpToDate = !(await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.JsonFile.saveAsync(currentVariantJson, currentVariantJsonFilePath, {
            onlyIfChanged: true
        }));
        this.rushConfiguration._currentVariantJsonLoadingPromise = undefined;
        if (this.options.variant) {
            terminal.writeLine();
            terminal.writeLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.bold(`Using variant '${this.options.variant}' for installation.`));
        }
        else if (!variantIsUpToDate && !variant && this.rushConfiguration.variants.size > 0) {
            terminal.writeLine();
            terminal.writeLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.bold('Using the default variant for installation.'));
        }
        const extraNpmrcLines = [];
        if (this.rushConfiguration.subspacesFeatureEnabled) {
            // Look for a monorepo level .npmrc file
            const commonNpmrcPath = `${this.rushConfiguration.commonRushConfigFolder}/.npmrc`;
            let commonNpmrcFileLines;
            try {
                commonNpmrcFileLines = (await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFileAsync(commonNpmrcPath)).split('\n');
            }
            catch (e) {
                if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.isNotExistError(e)) {
                    throw e;
                }
            }
            if (commonNpmrcFileLines) {
                extraNpmrcLines.push(...commonNpmrcFileLines);
            }
            extraNpmrcLines.push(`global-pnpmfile=${subspace.getSubspaceTempFolderPath()}/${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.pnpmfileGlobalFilename}`);
        }
        // Also copy down the committed .npmrc file, if there is one
        // "common\config\rush\.npmrc" --> "common\temp\.npmrc"
        // Also ensure that we remove any old one that may be hanging around
        const npmrcText = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_14__.Utilities.syncNpmrc({
            sourceNpmrcFolder: subspace.getSubspaceConfigFolderPath(),
            targetNpmrcFolder: subspace.getSubspaceTempFolderPath(),
            linesToPrepend: extraNpmrcLines,
            createIfMissing: this.rushConfiguration.subspacesFeatureEnabled,
            supportEnvVarFallbackSyntax: this.rushConfiguration.isPnpm
        });
        this._syncNpmrcAlreadyCalled = true;
        const npmrcHash = npmrcText
            ? crypto__WEBPACK_IMPORTED_MODULE_2__.createHash('sha1').update(npmrcText).digest('hex')
            : undefined;
        if (this.rushConfiguration.isPnpm) {
            // Copy the committed patches folder if using pnpm
            const commonTempPnpmPatchesFolder = `${subspace.getSubspaceTempFolderPath()}/${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.pnpmPatchesFolderName}`;
            const rushPnpmPatchesFolder = subspace.getSubspacePnpmPatchesFolderPath();
            let rushPnpmPatches;
            try {
                rushPnpmPatches = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFolderItemsAsync(rushPnpmPatchesFolder);
            }
            catch (e) {
                if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.isNotExistError(e)) {
                    throw e;
                }
            }
            if (rushPnpmPatches) {
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.ensureFolderAsync(commonTempPnpmPatchesFolder);
                const existingPatches = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFolderItemsAsync(commonTempPnpmPatchesFolder);
                const copiedPatchNames = new Set();
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Async.forEachAsync(rushPnpmPatches, async (patch) => {
                    const name = patch.name;
                    const sourcePath = `${rushPnpmPatchesFolder}/${name}`;
                    if (patch.isFile()) {
                        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.copyFileAsync({
                            sourcePath,
                            destinationPath: `${commonTempPnpmPatchesFolder}/${name}`
                        });
                        copiedPatchNames.add(name);
                    }
                    else {
                        throw new Error(`Unexpected non-file item found in ${rushPnpmPatchesFolder}: ${sourcePath}`);
                    }
                }, { concurrency: 50 });
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Async.forEachAsync(existingPatches, async (patch) => {
                    const name = patch.name;
                    if (!copiedPatchNames.has(name)) {
                        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFileAsync(`${commonTempPnpmPatchesFolder}/${name}`);
                    }
                }, { concurrency: 50 });
            }
            else {
                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFolderAsync(commonTempPnpmPatchesFolder);
            }
        }
        // Shim support for pnpmfile in.
        // Additionally when in workspaces, the shim implements support for common versions.
        if (this.rushConfiguration.isPnpm) {
            await _pnpm_PnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_20__.PnpmfileConfiguration.writeCommonTempPnpmfileShimAsync(this.rushConfiguration, subspace.getSubspaceTempFolderPath(), subspace, variant);
            if (this.rushConfiguration.subspacesFeatureEnabled) {
                await _pnpm_SubspacePnpmfileConfiguration__WEBPACK_IMPORTED_MODULE_21__.SubspacePnpmfileConfiguration.writeCommonTempSubspaceGlobalPnpmfileAsync(this.rushConfiguration, subspace, variant);
            }
        }
        // eslint-disable-next-line prefer-const
        let [{ shrinkwrapIsUpToDate, shrinkwrapWarnings }, projectImpactGraphIsUpToDate = true] = await Promise.all([
            // Allow for package managers to do their own preparation and check that the shrinkwrap is up to date
            this.prepareCommonTempAsync(subspace, shrinkwrapFile),
            projectImpactGraphGenerator === null || projectImpactGraphGenerator === void 0 ? void 0 : projectImpactGraphGenerator.validateAsync()
        ]);
        shrinkwrapIsUpToDate = shrinkwrapIsUpToDate && !this.options.recheckShrinkwrap;
        this._syncTempShrinkwrap(subspace, variant, shrinkwrapFile);
        // Write out the reported warnings
        if (shrinkwrapWarnings.length > 0) {
            terminal.writeLine();
            terminal.writeLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.yellow(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.PrintUtilities.wrapWords(`The ${this.rushConfiguration.shrinkwrapFilePhrase} contains the following issues:`)));
            for (const shrinkwrapWarning of shrinkwrapWarnings) {
                terminal.writeLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.yellow('  ' + shrinkwrapWarning));
            }
            terminal.writeLine();
        }
        let hasErrors = false;
        // Force update if the shrinkwrap is out of date
        if (!shrinkwrapIsUpToDate && !allowShrinkwrapUpdates) {
            terminal.writeErrorLine();
            terminal.writeErrorLine(`The ${this.rushConfiguration.shrinkwrapFilePhrase} is out of date. You need to run "rush update".`);
            hasErrors = true;
        }
        if (!projectImpactGraphIsUpToDate && !allowShrinkwrapUpdates) {
            hasErrors = true;
            terminal.writeErrorLine();
            terminal.writeErrorLine(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.red(`The ${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.projectImpactGraphFilename} file is missing or out of date. You need to run "rush update".`));
        }
        if (hasErrors) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
        }
        return { shrinkwrapIsUpToDate, npmrcHash, projectImpactGraphIsUpToDate, variantIsUpToDate };
    }
    /**
     * Git hooks are only installed if the repo opts in by including files in /common/git-hooks
     */
    async _installGitHooksAsync() {
        const hookSource = path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushConfiguration.commonFolder, 'git-hooks');
        const git = new _Git__WEBPACK_IMPORTED_MODULE_22__.Git(this.rushConfiguration);
        const hookDestination = git.getHooksFolder();
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(hookSource) && hookDestination) {
            const allHookFilenames = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFolderItemNames(hookSource);
            // Ignore the ".sample" file(s) in this folder.
            const hookFilenames = allHookFilenames.filter((x) => !/\.sample$/.test(x));
            if (hookFilenames.length > 0) {
                // eslint-disable-next-line no-console
                console.log('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.bold('Found files in the "common/git-hooks" folder.'));
                if (!(await git.getIsHooksPathDefaultAsync())) {
                    const hooksPath = await git.getConfigHooksPathAsync();
                    const color = this.options.bypassPolicy ? _rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.yellow : _rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.red;
                    // eslint-disable-next-line no-console
                    console.error(color([
                        ' ',
                        `Rush cannot install the "common/git-hooks" scripts because your Git configuration `,
                        `specifies "core.hooksPath=${hooksPath}". You can remove the setting by running:`,
                        ' ',
                        '    git config --unset core.hooksPath',
                        ' '
                    ].join('\n')));
                    if (this.options.bypassPolicy) {
                        // If "--bypass-policy" is specified, skip installation of hooks because Rush doesn't
                        // own the hooks folder
                        return;
                    }
                    // eslint-disable-next-line no-console
                    console.error(color([
                        '(Or, to temporarily ignore this problem, invoke Rush with the ' +
                            `"${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.bypassPolicyFlagLongName}" option.)`,
                        ' '
                    ].join('\n')));
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
                }
                // Clear the currently installed git hooks and install fresh copies
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.ensureEmptyFolder(hookDestination);
                // Find the relative path from Git hooks directory to the directory storing the actual scripts.
                const hookRelativePath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Path.convertToSlashes(path__WEBPACK_IMPORTED_MODULE_1__.relative(hookDestination, hookSource));
                // Only copy files that look like Git hook names
                const filteredHookFilenames = hookFilenames.filter((x) => /^[a-z\-]+/.test(x));
                for (const filename of filteredHookFilenames) {
                    const hookFilePath = `${hookSource}/${filename}`;
                    // Make sure the actual script in the hookSource directory has correct Linux compatible line endings
                    const originalHookFileContent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.readFile(hookFilePath);
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.writeFile(hookFilePath, originalHookFileContent, {
                        convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.NewlineKind.Lf
                    });
                    // Make sure the actual script in the hookSource directory has required permission bits
                    const originalPosixModeBits = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.getPosixModeBits(hookFilePath);
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.changePosixModeBits(hookFilePath, 
                    // eslint-disable-next-line no-bitwise
                    originalPosixModeBits | _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.PosixModeBits.UserRead | _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.PosixModeBits.UserExecute);
                    const gitLfsHookHandling = gitLfsHooks.has(filename)
                        ? `
# Inspired by https://github.com/git-lfs/git-lfs/issues/2865#issuecomment-365742940
if command -v git-lfs &> /dev/null; then
  git lfs ${filename} "$@"
fi
`
                        : '';
                    const hookFileContent = `#!/bin/bash
set -e
SCRIPT_DIR="$( cd "$( dirname "\${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
SCRIPT_IMPLEMENTATION_PATH="$SCRIPT_DIR/${hookRelativePath}/${filename}"

if [[ -f "$SCRIPT_IMPLEMENTATION_PATH" ]]; then
  "$SCRIPT_IMPLEMENTATION_PATH" $@
else
  echo "The ${filename} Git hook no longer exists in your version of the repo. Run 'rush install' or 'rush update' to refresh your installed Git hooks." >&2
fi
${gitLfsHookHandling}
`;
                    // Create the hook file.  Important: For Bash scripts, the EOL must not be CRLF.
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.writeFile(path__WEBPACK_IMPORTED_MODULE_1__.join(hookDestination, filename), hookFileContent, {
                        convertLineEndings: _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.NewlineKind.Lf
                    });
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.changePosixModeBits(path__WEBPACK_IMPORTED_MODULE_1__.join(hookDestination, filename), 
                    // eslint-disable-next-line no-bitwise
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.PosixModeBits.UserRead | _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.PosixModeBits.UserExecute);
                }
                // eslint-disable-next-line no-console
                console.log('Successfully installed these Git hook scripts: ' + filteredHookFilenames.join(', ') + '\n');
            }
        }
    }
    /**
     * Used when invoking the NPM tool.  Appends the common configuration options
     * to the command-line.
     */
    pushConfigurationArgs(args, options, subspace) {
        const { offline, collectLogFile, pnpmFilterArgumentValues, onlyShrinkwrap, networkConcurrency, allowShrinkwrapUpdates, resolutionOnly } = options;
        if (offline && this.rushConfiguration.packageManager !== 'pnpm') {
            throw new Error('The "--offline" parameter is only supported when using the PNPM package manager.');
        }
        if (resolutionOnly && this.rushConfiguration.packageManager !== 'pnpm') {
            throw new Error('The "--resolution-only" parameter is only supported when using the PNPM package manager.');
        }
        if (this.rushConfiguration.packageManager === 'npm') {
            if (semver__WEBPACK_IMPORTED_MODULE_3__.lt(this.rushConfiguration.packageManagerToolVersion, '5.0.0')) {
                // NOTE:
                //
                // When using an npm version older than v5.0.0, we do NOT install optional dependencies for
                // Rush, because npm does not generate the shrinkwrap file consistently across platforms.
                //
                // Consider the "fsevents" package. This is a Mac specific package
                // which is an optional second-order dependency. Optional dependencies work by attempting to install
                // the package, but removes the package if the install failed.
                // This means that someone running generate on a Mac WILL have fsevents included in their shrinkwrap.
                // When someone using Windows attempts to install from the shrinkwrap, the install will fail.
                //
                // If someone generates the shrinkwrap using Windows, then fsevents will NOT be listed in the shrinkwrap.
                // When someone using Mac attempts to install from the shrinkwrap, they will NOT have the
                // optional dependency installed.
                //
                // This issue has been fixed as of npm v5.0.0: https://github.com/npm/npm/releases/tag/v5.0.0
                //
                // For more context, see https://github.com/microsoft/rushstack/issues/761#issuecomment-428689600
                args.push('--no-optional');
            }
            args.push('--cache', this.rushConfiguration.npmCacheFolder);
            args.push('--tmp', this.rushConfiguration.npmTmpFolder);
            if (collectLogFile) {
                args.push('--verbose');
            }
        }
        else if (this.rushConfiguration.isPnpm) {
            // Only explicitly define the store path if `pnpmStore` is using the default, or has been set to
            // 'local'.  If `pnpmStore` = 'global', then allow PNPM to use the system's default
            // path.  In all cases, this will be overridden by RUSH_PNPM_STORE_PATH
            if (this.rushConfiguration.pnpmOptions.pnpmStore === 'local' ||
                _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_23__.EnvironmentConfiguration.pnpmStorePathOverride) {
                args.push('--store', this.rushConfiguration.pnpmOptions.pnpmStorePath);
                if (semver__WEBPACK_IMPORTED_MODULE_3__.gte(this.rushConfiguration.packageManagerToolVersion, '6.10.0')) {
                    args.push(`${pnpmCacheDirParameter}=${this.rushConfiguration.pnpmOptions.pnpmStorePath}`);
                    args.push(`${pnpmStateDirParameter}=${this.rushConfiguration.pnpmOptions.pnpmStorePath}`);
                }
            }
            const { pnpmVerifyStoreIntegrity } = _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_23__.EnvironmentConfiguration;
            if (pnpmVerifyStoreIntegrity !== undefined) {
                args.push(`--verify-store-integrity`, `${pnpmVerifyStoreIntegrity}`);
            }
            const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;
            if (experiments.usePnpmFrozenLockfileForRushInstall && !allowShrinkwrapUpdates) {
                args.push('--frozen-lockfile');
                if (pnpmFilterArgumentValues.length > 0 &&
                    Number.parseInt(this.rushConfiguration.packageManagerToolVersion, 10) >= 8 // PNPM Major version 8+
                ) {
                    // On pnpm@8, disable the "dedupe-peer-dependents" feature when doing a filtered CI install so that filters take effect.
                    args.push('--config.dedupe-peer-dependents=false');
                }
            }
            else if (experiments.usePnpmPreferFrozenLockfileForRushUpdate) {
                // In workspaces, we want to avoid unnecessary lockfile churn
                args.push('--prefer-frozen-lockfile');
            }
            else {
                // Ensure that Rush's tarball dependencies get synchronized properly with the pnpm-lock.yaml file.
                // See this GitHub issue: https://github.com/pnpm/pnpm/issues/1342
                args.push('--no-prefer-frozen-lockfile');
            }
            if (onlyShrinkwrap) {
                args.push(`--lockfile-only`);
            }
            if (collectLogFile) {
                args.push('--reporter', 'ndjson');
            }
            if (networkConcurrency) {
                args.push('--network-concurrency', networkConcurrency.toString());
            }
            if (offline) {
                args.push('--offline');
            }
            if (this.rushConfiguration.pnpmOptions.strictPeerDependencies === false) {
                args.push('--no-strict-peer-dependencies');
            }
            else {
                args.push('--strict-peer-dependencies');
            }
            if (resolutionOnly) {
                args.push('--resolution-only');
            }
            /*
              If user set auto-install-peers in pnpm-config.json only, use the value in pnpm-config.json
              If user set auto-install-peers in pnpm-config.json and .npmrc, use the value in pnpm-config.json
              If user set auto-install-peers in .npmrc only, do nothing, let pnpm handle it
              If user does not set auto-install-peers in both pnpm-config.json and .npmrc, rush will default it to "false"
            */
            const isAutoInstallPeersInNpmrc = (0,_utilities_npmrcUtilities__WEBPACK_IMPORTED_MODULE_24__.isVariableSetInNpmrcFile)(subspace.getSubspaceConfigFolderPath(), 'auto-install-peers', this.rushConfiguration.isPnpm);
            let autoInstallPeers = this.rushConfiguration.pnpmOptions.autoInstallPeers;
            if (autoInstallPeers !== undefined) {
                if (isAutoInstallPeersInNpmrc) {
                    this._terminal.writeWarningLine(`Warning: PNPM's auto-install-peers is specified in both .npmrc and pnpm-config.json. ` +
                        `The value in pnpm-config.json will take precedence.`);
                }
            }
            else if (!isAutoInstallPeersInNpmrc) {
                // if auto-install-peers isn't specified in either .npmrc or pnpm-config.json,
                // then rush will default it to "false"
                autoInstallPeers = false;
            }
            if (autoInstallPeers !== undefined) {
                args.push(`--config.auto-install-peers=${autoInstallPeers}`);
            }
            /*
              If user set resolution-mode in pnpm-config.json only, use the value in pnpm-config.json
              If user set resolution-mode in pnpm-config.json and .npmrc, use the value in pnpm-config.json
              If user set resolution-mode in .npmrc only, do nothing, let pnpm handle it
              If user does not set resolution-mode in pnpm-config.json and .npmrc, rush will default it to "highest"
            */
            const isResolutionModeInNpmrc = (0,_utilities_npmrcUtilities__WEBPACK_IMPORTED_MODULE_24__.isVariableSetInNpmrcFile)(subspace.getSubspaceConfigFolderPath(), 'resolution-mode', this.rushConfiguration.isPnpm);
            let resolutionMode = this.rushConfiguration.pnpmOptions.resolutionMode;
            if (resolutionMode) {
                if (isResolutionModeInNpmrc) {
                    this._terminal.writeWarningLine(`Warning: PNPM's resolution-mode is specified in both .npmrc and pnpm-config.json. ` +
                        `The value in pnpm-config.json will take precedence.`);
                }
            }
            else if (!isResolutionModeInNpmrc) {
                // if resolution-mode isn't specified in either .npmrc or pnpm-config.json,
                // then rush will default it to "highest"
                resolutionMode = 'highest';
            }
            if (resolutionMode) {
                args.push(`--config.resolutionMode=${resolutionMode}`);
            }
            if (semver__WEBPACK_IMPORTED_MODULE_3__.satisfies(this.rushConfiguration.packageManagerToolVersion, '6.32.12 - 6.33.x || 7.0.1 - 7.8.x')) {
                this._terminal.writeWarningLine(`Warning: Your ${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.rushJsonFilename} specifies a pnpmVersion with a known issue ` +
                    'that may cause unintended version selections.' +
                    " It's recommended to upgrade to PNPM >=6.34.0 or >=7.9.0. " +
                    'For details see: https://rushjs.io/link/pnpm-issue-5132');
            }
            if (semver__WEBPACK_IMPORTED_MODULE_3__.gte(this.rushConfiguration.packageManagerToolVersion, '7.9.0') ||
                semver__WEBPACK_IMPORTED_MODULE_3__.satisfies(this.rushConfiguration.packageManagerToolVersion, '^6.34.0')) {
                args.push(pnpmIgnoreCompatibilityDbParameter);
            }
        }
        else if (this.rushConfiguration.packageManager === 'yarn') {
            args.push('--link-folder', 'yarn-link');
            args.push('--cache-folder', this.rushConfiguration.yarnCacheFolder);
            // Without this option, Yarn will sometimes stop and ask for user input on STDIN
            // (e.g. "Which command would you like to run?").
            args.push('--non-interactive');
            if (networkConcurrency) {
                args.push('--network-concurrency', networkConcurrency.toString());
            }
            if (this.rushConfiguration.yarnOptions.ignoreEngines) {
                args.push('--ignore-engines');
            }
            if (collectLogFile) {
                args.push('--verbose');
            }
        }
    }
    async _checkIfReleaseIsPublishedAsync() {
        const lastCheckFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this.rushGlobalFolder.nodeSpecificPath, 'rush-' + _api_Rush__WEBPACK_IMPORTED_MODULE_25__.Rush.version, 'last-check.flag');
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.exists(lastCheckFile)) {
            let cachedResult = undefined;
            try {
                // NOTE: mtimeMs is not supported yet in Node.js 6.x
                const nowMs = new Date().getTime();
                const ageMs = nowMs - _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.getStatistics(lastCheckFile).mtime.getTime();
                const HOUR = 60 * 60 * 1000;
                // Is the cache too old?
                if (ageMs < 24 * HOUR) {
                    // No, read the cached result
                    cachedResult = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.JsonFile.load(lastCheckFile);
                }
            }
            catch (e) {
                // Unable to parse file
            }
            if (cachedResult === 'error') {
                throw new Error('Unable to contact server');
            }
            if (cachedResult === true || cachedResult === false) {
                return cachedResult;
            }
        }
        // Before we start the network operation, record a failed state.  If the process exits for some reason,
        // this will record the error.  It will also update the timestamp to prevent other Rush instances
        // from attempting to update the file.
        await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.JsonFile.saveAsync('error', lastCheckFile, { ensureFolderExists: true });
        try {
            // For this check we use the official registry, not the private registry
            const publishedRelease = await this._queryIfReleaseIsPublishedAsync('https://registry.npmjs.org:443');
            // Cache the result
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.JsonFile.saveAsync(publishedRelease, lastCheckFile, { ensureFolderExists: true });
            return publishedRelease;
        }
        catch (error) {
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.JsonFile.saveAsync('error', lastCheckFile, { ensureFolderExists: true });
            throw error;
        }
    }
    // Helper for checkIfReleaseIsPublished()
    async _queryIfReleaseIsPublishedAsync(registryUrl) {
        let queryUrl = registryUrl;
        if (queryUrl[-1] !== '/') {
            queryUrl += '/';
        }
        // Note that the "@" symbol does not normally get URL-encoded
        queryUrl += _RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.rushPackageName.replace('/', '%2F');
        const { WebClient } = await __webpack_require__.e(/*! import() */ "lib-esnext_utilities_WebClient_js").then(__webpack_require__.bind(__webpack_require__, /*! ../../utilities/WebClient */ 182127));
        const webClient = new WebClient();
        webClient.userAgent = `pnpm/? npm/? node/${process.version} ${os__WEBPACK_IMPORTED_MODULE_0__.platform()} ${os__WEBPACK_IMPORTED_MODULE_0__.arch()}`;
        webClient.accept = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';
        const response = await webClient.fetchAsync(queryUrl);
        if (!response.ok) {
            throw new Error('Failed to query');
        }
        const data = await response.getJsonAsync();
        let url;
        try {
            if (!data.versions[_api_Rush__WEBPACK_IMPORTED_MODULE_25__.Rush.version]) {
                // Version was not published
                return false;
            }
            url = data.versions[_api_Rush__WEBPACK_IMPORTED_MODULE_25__.Rush.version].dist.tarball;
            if (!url) {
                throw new Error(`URL not found`);
            }
        }
        catch (e) {
            throw new Error('Error parsing response');
        }
        // Make sure the tarball wasn't deleted from the CDN
        webClient.accept = '*/*';
        const response2 = await webClient.fetchAsync(url);
        if (!response2.ok) {
            if (response2.status === 404) {
                return false;
            }
            else {
                throw new Error('Failed to fetch');
            }
        }
        return true;
    }
    _syncTempShrinkwrap(subspace, variant, shrinkwrapFile) {
        const committedShrinkwrapFileName = subspace.getCommittedShrinkwrapFilePath(variant);
        if (shrinkwrapFile) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_14__.Utilities.syncFile(committedShrinkwrapFileName, subspace.getTempShrinkwrapFilename());
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_14__.Utilities.syncFile(committedShrinkwrapFileName, subspace.getTempShrinkwrapPreinstallFilename());
        }
        else {
            // Otherwise delete the temporary file
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFile(subspace.getTempShrinkwrapFilename());
            if (this.rushConfiguration.isPnpm) {
                // Workaround for https://github.com/pnpm/pnpm/issues/1890
                //
                // When "rush update --full" is run, Rush deletes "common/temp/pnpm-lock.yaml"
                // so that a new lockfile will be generated. However "pnpm install" by design will try to recover
                // "pnpm-lock.yaml" from "common/temp/node_modules/.pnpm/lock.yaml", which may prevent a full upgrade.
                // Deleting both files ensures that a new lockfile will always be generated.
                const pnpmPackageManager = this.rushConfiguration
                    .packageManagerWrapper;
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.FileSystem.deleteFile(path__WEBPACK_IMPORTED_MODULE_1__.join(subspace.getSubspaceTempFolderPath(), pnpmPackageManager.internalShrinkwrapRelativePath));
            }
        }
    }
    async validateNpmSetupAsync() {
        if (this._npmSetupValidated) {
            return;
        }
        if (!this.options.bypassPolicy) {
            const setupPackageRegistry = new _setup_SetupPackageRegistry__WEBPACK_IMPORTED_MODULE_26__.SetupPackageRegistry({
                rushConfiguration: this.rushConfiguration,
                isDebug: this.options.debug,
                syncNpmrcAlreadyCalled: this._syncNpmrcAlreadyCalled
            });
            const valid = await setupPackageRegistry.checkOnlyAsync();
            if (!valid) {
                // eslint-disable-next-line no-console
                console.error();
                // eslint-disable-next-line no-console
                console.error(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.red('ERROR: NPM credentials are missing or expired'));
                // eslint-disable-next-line no-console
                console.error();
                // eslint-disable-next-line no-console
                console.error(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_7__.Colorize.bold('==> Please run "rush setup" to update your NPM token. ' +
                    `(Or append "${_RushConstants__WEBPACK_IMPORTED_MODULE_10__.RushConstants.bypassPolicyFlagLongName}" to proceed anyway.)`));
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.AlreadyReportedError();
            }
        }
        this._npmSetupValidated = true;
    }
}
//# sourceMappingURL=BaseInstallManager.js.map

/***/ }),

/***/ 94024:
/*!**************************************************!*\
  !*** ./lib-esnext/logic/base/BaseLinkManager.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseLinkManager: () => (/* binding */ BaseLinkManager),
/* harmony export */   SymlinkKind: () => (/* binding */ SymlinkKind)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 16928);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 277275);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rushstack/terminal */ 367587);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utilities/Utilities */ 387714);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utilities/Stopwatch */ 74873);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 778261);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../RushConstants */ 195191);
/* harmony import */ var _api_FlagFile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../api/FlagFile */ 251748);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.








var SymlinkKind;
(function (SymlinkKind) {
    SymlinkKind[SymlinkKind["File"] = 0] = "File";
    SymlinkKind[SymlinkKind["Directory"] = 1] = "Directory";
})(SymlinkKind || (SymlinkKind = {}));
class BaseLinkManager {
    constructor(rushConfiguration) {
        this._rushConfiguration = rushConfiguration;
    }
    static _createSymlink(options) {
        const newLinkFolder = path__WEBPACK_IMPORTED_MODULE_0__.dirname(options.newLinkPath);
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.ensureFolder(newLinkFolder);
        let targetPath;
        if (_api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_3__.EnvironmentConfiguration.absoluteSymlinks) {
            targetPath = options.linkTargetPath;
        }
        else {
            // Link to the relative path, to avoid going outside containers such as a Docker image
            targetPath = path__WEBPACK_IMPORTED_MODULE_0__.relative(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.getRealPath(newLinkFolder), options.linkTargetPath);
        }
        if (process.platform === 'win32') {
            if (options.symlinkKind === SymlinkKind.Directory) {
                // For directories, we use a Windows "junction".  On Unix, this produces a regular symlink.
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.createSymbolicLinkJunction({
                    linkTargetPath: targetPath,
                    newLinkPath: options.newLinkPath
                });
            }
            else {
                // For files, we use a Windows "hard link", because creating a symbolic link requires
                // administrator permission.
                // NOTE: We cannot use the relative path for hard links
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.createHardLink({
                    linkTargetPath: options.linkTargetPath,
                    newLinkPath: options.newLinkPath
                });
            }
        }
        else {
            // However hard links seem to cause build failures on Mac, so for all other operating systems
            // we use symbolic links for this case.
            if (options.symlinkKind === SymlinkKind.Directory) {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.createSymbolicLinkFolder({
                    linkTargetPath: targetPath,
                    newLinkPath: options.newLinkPath
                });
            }
            else {
                _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.createSymbolicLinkFile({
                    linkTargetPath: targetPath,
                    newLinkPath: options.newLinkPath
                });
            }
        }
    }
    /**
     * For a Package object that represents a top-level Rush project folder
     * (i.e. with source code that we will be building), this clears out its
     * node_modules folder and then recursively creates all the symlinked folders.
     */
    static _createSymlinksForTopLevelProject(localPackage) {
        const localModuleFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.folderPath, 'node_modules');
        // Sanity check
        if (localPackage.parent) {
            throw new Error('The provided package is not a top-level project');
        }
        // The root-level folder is the project itself, so we simply delete its node_modules
        // to start clean
        // eslint-disable-next-line no-console
        console.log('Purging ' + localModuleFolder);
        _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.dangerouslyDeletePath(localModuleFolder);
        if (localPackage.children.length > 0) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(localModuleFolder);
            for (const child of localPackage.children) {
                BaseLinkManager._createSymlinksForDependencies(child);
            }
        }
    }
    /**
     * This is a helper function used by createSymlinksForTopLevelProject().
     * It will recursively creates symlinked folders corresponding to each of the
     * Package objects in the provided tree.
     */
    static _createSymlinksForDependencies(localPackage) {
        const localModuleFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.folderPath, 'node_modules');
        if (!localPackage.symlinkTargetFolderPath) {
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.InternalError('localPackage.symlinkTargetFolderPath was not assigned');
        }
        // This is special case for when localPackage.name has the form '@scope/name',
        // in which case we need to create the '@scope' folder first.
        const parentFolderPath = path__WEBPACK_IMPORTED_MODULE_0__.dirname(localPackage.folderPath);
        if (parentFolderPath && parentFolderPath !== localPackage.folderPath) {
            if (!_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.exists(parentFolderPath)) {
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(parentFolderPath);
            }
        }
        if (localPackage.children.length === 0) {
            // If there are no children, then we can symlink the entire folder
            BaseLinkManager._createSymlink({
                linkTargetPath: localPackage.symlinkTargetFolderPath,
                newLinkPath: localPackage.folderPath,
                symlinkKind: SymlinkKind.Directory
            });
        }
        else {
            // If there are children, then we need to symlink each item in the folder individually
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(localPackage.folderPath);
            for (const filename of _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.readFolderItemNames(localPackage.symlinkTargetFolderPath)) {
                if (filename.toLowerCase() !== 'node_modules') {
                    // Create the symlink
                    let symlinkKind = SymlinkKind.File;
                    const linkSource = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.folderPath, filename);
                    let linkTarget = path__WEBPACK_IMPORTED_MODULE_0__.join(localPackage.symlinkTargetFolderPath, filename);
                    const linkStats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.getLinkStatistics(linkTarget);
                    if (linkStats.isSymbolicLink()) {
                        const targetStats = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.getStatistics(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.getRealPath(linkTarget));
                        if (targetStats.isDirectory()) {
                            // Neither a junction nor a directory-symlink can have a directory-symlink
                            // as its target; instead, we must obtain the real physical path.
                            // A junction can link to another junction.  Unfortunately, the node 'fs' API
                            // lacks the ability to distinguish between a junction and a directory-symlink
                            // (even though it has the ability to create them both), so the safest policy
                            // is to always make a junction and always to the real physical path.
                            linkTarget = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.FileSystem.getRealPath(linkTarget);
                            symlinkKind = SymlinkKind.Directory;
                        }
                    }
                    else if (linkStats.isDirectory()) {
                        symlinkKind = SymlinkKind.Directory;
                    }
                    BaseLinkManager._createSymlink({
                        linkTargetPath: linkTarget,
                        newLinkPath: linkSource,
                        symlinkKind
                    });
                }
            }
        }
        if (localPackage.children.length > 0) {
            _utilities_Utilities__WEBPACK_IMPORTED_MODULE_4__.Utilities.createFolderWithRetry(localModuleFolder);
            for (const child of localPackage.children) {
                BaseLinkManager._createSymlinksForDependencies(child);
            }
        }
    }
    /**
     * Creates node_modules symlinks for all Rush projects defined in the RushConfiguration.
     * @param force - Normally the operation will be skipped if the links are already up to date;
     *   if true, this option forces the links to be recreated.
     */
    async createSymlinksForProjectsAsync(force) {
        // eslint-disable-next-line no-console
        console.log('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.Colorize.bold('Linking local projects'));
        const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_5__.Stopwatch.start();
        await this._linkProjectsAsync();
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        await new _api_FlagFile__WEBPACK_IMPORTED_MODULE_6__.FlagFile(this._rushConfiguration.defaultSubspace.getSubspaceTempFolderPath(), _RushConstants__WEBPACK_IMPORTED_MODULE_7__.RushConstants.lastLinkFlagFilename, {}).createAsync();
        stopwatch.stop();
        // eslint-disable-next-line no-console
        console.log('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_2__.Colorize.green(`Linking finished successfully. (${stopwatch.toString()})`));
        // eslint-disable-next-line no-console
        console.log('\nNext you should probably run "rush build" or "rush rebuild"');
    }
}
//# sourceMappingURL=BaseLinkManager.js.map

/***/ }),

/***/ 229196:
/*!****************************************************!*\
  !*** ./lib-esnext/logic/base/BaseWorkspaceFile.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseWorkspaceFile: () => (/* binding */ BaseWorkspaceFile)
/* harmony export */ });
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rushstack/node-core-library */ 277275);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

/**
 * This class is a parser for pnpm's pnpm-workspace.yaml file format.
 */
class BaseWorkspaceFile {
    constructor() {
        this._alreadyWarnedSpecs = new Set();
    }
    /**
     * Serializes and saves the workspace file to specified location
     */
    save(filePath, options) {
        // Do we need to read the previous file contents?
        let oldBuffer = undefined;
        if (options.onlyIfChanged && _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.exists(filePath)) {
            try {
                oldBuffer = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.readFileToBuffer(filePath);
            }
            catch (error) {
                // Ignore this error, and try writing a new file.  If that fails, then we should report that
                // error instead.
            }
        }
        const newYaml = this.serialize();
        const newBuffer = Buffer.from(newYaml); // utf8 encoding happens here
        if (options.onlyIfChanged) {
            // Has the file changed?
            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {
                // Nothing has changed, so don't touch the file
                return;
            }
        }
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_0__.FileSystem.writeFile(filePath, newBuffer.toString(), {
            ensureFolderExists: options.ensureFolderExists
        });
    }
}
//# sourceMappingURL=BaseWorkspaceFile.js.map

/***/ }),

/***/ 901896:
/*!********************************************************************!*\
  !*** ./lib-esnext/logic/installManager/WorkspaceInstallManager.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkspaceInstallManager: () => (/* binding */ WorkspaceInstallManager)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 16928);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! semver */ 338064);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! js-yaml */ 607089);
/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(js_yaml__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @rushstack/node-core-library */ 277275);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! crypto */ 776982);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _base_BaseInstallManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/BaseInstallManager */ 538033);
/* harmony import */ var _DependencySpecifier__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../DependencySpecifier */ 687463);
/* harmony import */ var _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../api/PackageJsonEditor */ 124921);
/* harmony import */ var _pnpm_PnpmWorkspaceFile__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../pnpm/PnpmWorkspaceFile */ 761172);
/* harmony import */ var _RushConstants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../RushConstants */ 195191);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utilities/Utilities */ 387714);
/* harmony import */ var _InstallHelpers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./InstallHelpers */ 245559);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 778261);
/* harmony import */ var _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../ShrinkwrapFileFactory */ 795791);
/* harmony import */ var _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../base/BaseProjectShrinkwrapFile */ 165809);
/* harmony import */ var _api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../api/CustomTipsConfiguration */ 640123);
/* harmony import */ var _utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utilities/objectUtilities */ 227095);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @rushstack/terminal */ 367587);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _base_BaseLinkManager__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../base/BaseLinkManager */ 94024);
/* harmony import */ var _api_FlagFile__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../api/FlagFile */ 251748);
/* harmony import */ var _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../utilities/Stopwatch */ 74873);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





















/**
 * This class implements common logic between "rush install" and "rush update".
 */
class WorkspaceInstallManager extends _base_BaseInstallManager__WEBPACK_IMPORTED_MODULE_6__.BaseInstallManager {
    /**
     * @override
     */
    async doInstallAsync() {
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        if (this.options.noLink) {
            // eslint-disable-next-line no-console
            console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.red('The "--no-link" option was provided but is not supported when using workspaces. Run the command again ' +
                'without specifying this argument.'));
            throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
        }
        await super.doInstallAsync();
    }
    /**
     * Regenerates the common/temp/package.json and related workspace files.
     * If shrinkwrapFile is provided, this function also validates whether it contains
     * everything we need to install and returns true if so; in all other cases,
     * the return value is false.
     *
     * @override
     */
    async prepareCommonTempAsync(subspace, shrinkwrapFile) {
        var _a;
        // Block use of the RUSH_TEMP_FOLDER environment variable
        if (_api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_7__.EnvironmentConfiguration.rushTempFolderOverride !== undefined) {
            throw new Error('The RUSH_TEMP_FOLDER environment variable is not compatible with workspace installs. If attempting ' +
                'to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.');
        }
        const { fullUpgrade, allowShrinkwrapUpdates, variant } = this.options;
        // eslint-disable-next-line no-console
        console.log('\n' + _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.bold('Updating workspace files in ' + subspace.getSubspaceTempFolderPath()));
        const shrinkwrapWarnings = [];
        // We will start with the assumption that it's valid, and then set it to false if
        // any of the checks fail
        let shrinkwrapIsUpToDate = true;
        if (!shrinkwrapFile) {
            shrinkwrapIsUpToDate = false;
        }
        else {
            if (!shrinkwrapFile.isWorkspaceCompatible && !fullUpgrade) {
                // eslint-disable-next-line no-console
                console.log();
                // eslint-disable-next-line no-console
                console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.red('The shrinkwrap file has not been updated to support workspaces. Run "rush update --full" to update ' +
                    'the shrinkwrap file.'));
                throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
            }
            // If there are orphaned projects, we need to update
            const orphanedProjects = shrinkwrapFile.findOrphanedProjects(this.rushConfiguration, subspace);
            if (orphanedProjects.length > 0) {
                for (const orphanedProject of orphanedProjects) {
                    shrinkwrapWarnings.push(`Your ${this.rushConfiguration.shrinkwrapFilePhrase} references "${orphanedProject}" ` +
                        `which was not found in ${_RushConstants__WEBPACK_IMPORTED_MODULE_8__.RushConstants.rushJsonFilename}`);
                }
                shrinkwrapIsUpToDate = false;
            }
        }
        // If preferred versions have been updated, or if the repo-state.json is invalid,
        // we can't be certain of the state of the shrinkwrap
        const repoState = subspace.getRepoState();
        if (!repoState.isValid) {
            shrinkwrapWarnings.push(`The ${_RushConstants__WEBPACK_IMPORTED_MODULE_8__.RushConstants.repoStateFilename} file is invalid. There may be a merge conflict marker in the file.`);
            shrinkwrapIsUpToDate = false;
        }
        else {
            const commonVersions = subspace.getCommonVersions(variant);
            if (repoState.preferredVersionsHash !== commonVersions.getPreferredVersionsHash()) {
                shrinkwrapWarnings.push(`Preferred versions from ${_RushConstants__WEBPACK_IMPORTED_MODULE_8__.RushConstants.commonVersionsFilename} have been modified.`);
                shrinkwrapIsUpToDate = false;
            }
            const stopwatch = _utilities_Stopwatch__WEBPACK_IMPORTED_MODULE_9__.Stopwatch.start();
            const packageJsonInjectedDependenciesHash = subspace.getPackageJsonInjectedDependenciesHash(variant);
            stopwatch.stop();
            this._terminal.writeDebugLine(`Total amount of time spent to hash related package.json files in the injected installation case: ${stopwatch.toString()}`);
            if (packageJsonInjectedDependenciesHash) {
                // if packageJsonInjectedDependenciesHash exists
                // make sure it matches the value in repoState
                if (packageJsonInjectedDependenciesHash !== repoState.packageJsonInjectedDependenciesHash) {
                    shrinkwrapWarnings.push(`Some injected dependencies' package.json might have been modified.`);
                    shrinkwrapIsUpToDate = false;
                }
            }
            else {
                // if packageJsonInjectedDependenciesHash not exists
                // there is a situation that the subspace previously has injected dependencies but removed
                // so we can check if the repoState up to date
                if (repoState.packageJsonInjectedDependenciesHash !== undefined) {
                    shrinkwrapWarnings.push(`It was detected that ${repoState.filePath} contains packageJsonInjectedDependenciesHash` +
                        ' but the injected dependencies feature is not enabled. You can manually remove this field in repo-state.json.' +
                        ' Or run rush update command to update the repo-state.json file.');
                }
            }
        }
        // To generate the workspace file, we will add each project to the file as we loop through and validate
        const workspaceFile = new _pnpm_PnpmWorkspaceFile__WEBPACK_IMPORTED_MODULE_10__.PnpmWorkspaceFile(path__WEBPACK_IMPORTED_MODULE_0__.join(subspace.getSubspaceTempFolderPath(), 'pnpm-workspace.yaml'));
        // For pnpm package manager, we need to handle dependenciesMeta changes in package.json. See more: https://pnpm.io/package_json#dependenciesmeta
        // If dependenciesMeta settings is different between package.json and pnpm-lock.yaml, then shrinkwrapIsUpToDate return false.
        // Build a object for dependenciesMeta settings in projects' package.json
        // key is the package path, value is the dependenciesMeta info for that package
        const expectedDependenciesMetaByProjectRelativePath = {};
        const commonTempFolder = subspace.getSubspaceTempFolderPath();
        const rushJsonFolder = this.rushConfiguration.rushJsonFolder;
        // get the relative path from common temp folder to repo root folder
        const relativeFromTempFolderToRootFolder = path__WEBPACK_IMPORTED_MODULE_0__.relative(commonTempFolder, rushJsonFolder);
        // Loop through the projects and add them to the workspace file. While we're at it, also validate that
        // referenced workspace projects are valid, and check if the shrinkwrap file is already up-to-date.
        for (const rushProject of this.rushConfiguration.projects) {
            if (!subspace.contains(rushProject)) {
                // skip processing any project that isn't in this subspace
                continue;
            }
            const packageJson = rushProject.packageJsonEditor;
            workspaceFile.addPackage(rushProject.projectFolder);
            for (const { name, version, dependencyType } of [
                ...packageJson.dependencyList,
                ...packageJson.devDependencyList
            ]) {
                // Allow the package manager to handle peer dependency resolution, since this is simply a constraint
                // enforced by the package manager. Additionally, peer dependencies are simply a version constraint
                // and do not need to be converted to workspaces protocol.
                if (dependencyType === _api_PackageJsonEditor__WEBPACK_IMPORTED_MODULE_11__.DependencyType.Peer) {
                    continue;
                }
                const dependencySpecifier = new _DependencySpecifier__WEBPACK_IMPORTED_MODULE_12__.DependencySpecifier(name, version);
                // Is there a locally built Rush project that could satisfy this dependency?
                let referencedLocalProject = this.rushConfiguration.getProjectByName(name);
                // If we enable exemptDecoupledDependenciesBetweenSubspaces, it will only check dependencies within the subspace.
                if (this.rushConfiguration.experimentsConfiguration.configuration
                    .exemptDecoupledDependenciesBetweenSubspaces) {
                    if (referencedLocalProject && !subspace.contains(referencedLocalProject)) {
                        referencedLocalProject = undefined;
                    }
                }
                // Validate that local projects are referenced with workspace notation. If not, and it is not a
                // cyclic dependency, then it needs to be updated to specify `workspace:*` explicitly. Currently only
                // supporting versions and version ranges for specifying a local project.
                if ((dependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_12__.DependencySpecifierType.Version ||
                    dependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_12__.DependencySpecifierType.Range) &&
                    referencedLocalProject &&
                    !rushProject.decoupledLocalDependencies.has(name)) {
                    // Make sure that this version is intended to target a local package. If not, then we will fail since it
                    // is not explicitly specified as a cyclic dependency.
                    if (!semver__WEBPACK_IMPORTED_MODULE_1__.satisfies(referencedLocalProject.packageJsonEditor.version, dependencySpecifier.versionSpecifier)) {
                        // eslint-disable-next-line no-console
                        console.log();
                        // eslint-disable-next-line no-console
                        console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.red(`"${rushProject.packageName}" depends on package "${name}" (${version}) which belongs to ` +
                            'the workspace but cannot be fulfilled with the specified version range. Either ' +
                            'specify a valid version range, or add the package to "decoupledLocalDependencies" in rush.json.'));
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
                    }
                    if (!allowShrinkwrapUpdates) {
                        // eslint-disable-next-line no-console
                        console.log();
                        // eslint-disable-next-line no-console
                        console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.red(`"${rushProject.packageName}" depends on package "${name}" (${version}) which exists within ` +
                            'the workspace. Run "rush update" to update workspace references for this package. ' +
                            `If package "${name}" is intentionally expected to be installed from an external package feed, ` +
                            `list package "${name}" in the "decoupledLocalDependencies" field in the ` +
                            `"${rushProject.packageName}" entry in rush.json to suppress this error.`));
                        throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
                    }
                    if (fullUpgrade) {
                        // We will update to `workspace` notation. If the version specified is a range, then use the provided range.
                        // Otherwise, use `workspace:*` to ensure we're always using the workspace package.
                        const workspaceRange = !!semver__WEBPACK_IMPORTED_MODULE_1__.validRange(dependencySpecifier.versionSpecifier) &&
                            !semver__WEBPACK_IMPORTED_MODULE_1__.valid(dependencySpecifier.versionSpecifier)
                            ? dependencySpecifier.versionSpecifier
                            : '*';
                        packageJson.addOrUpdateDependency(name, `workspace:${workspaceRange}`, dependencyType);
                        shrinkwrapIsUpToDate = false;
                        continue;
                    }
                }
                else if (dependencySpecifier.specifierType === _DependencySpecifier__WEBPACK_IMPORTED_MODULE_12__.DependencySpecifierType.Workspace &&
                    rushProject.decoupledLocalDependencies.has(name)) {
                    // If the dependency is a local project that is decoupled, then we need to ensure that it is not specified
                    // as a workspace project. If it is, then we need to update the package.json to remove the workspace notation.
                    this._terminal.writeWarningLine(`"${rushProject.packageName}" depends on package ${name}@${version}, but also lists it in ` +
                        `its "decoupledLocalDependencies" array. Either update the host project's package.json to use ` +
                        `a version from an external feed instead of "workspace:" notation, or remove the dependency from the ` +
                        `host project's "decoupledLocalDependencies" array in rush.json.`);
                    throw new _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.AlreadyReportedError();
                }
                else if (!rushProject.decoupledLocalDependencies.has(name)) {
                    // Already specified as a local project. Allow the package manager to validate this
                    continue;
                }
            }
            // Save the package.json if we modified the version references and warn that the package.json was modified
            if (packageJson.saveIfModified()) {
                // eslint-disable-next-line no-console
                console.log(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.yellow(`"${rushProject.packageName}" depends on one or more workspace packages which did not use "workspace:" ` +
                    'notation. The package.json has been modified and must be committed to source control.'));
            }
            // Now validate that the shrinkwrap file matches what is in the package.json
            if (await (shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.isWorkspaceProjectModifiedAsync(rushProject, subspace, variant))) {
                shrinkwrapWarnings.push(`Dependencies of project "${rushProject.packageName}" do not match the current shrinkwrap.`);
                shrinkwrapIsUpToDate = false;
            }
            const dependencyMetaList = packageJson.dependencyMetaList;
            if (dependencyMetaList.length !== 0) {
                const dependenciesMeta = {};
                for (const dependencyMeta of dependencyMetaList) {
                    dependenciesMeta[dependencyMeta.name] = {
                        injected: dependencyMeta.injected
                    };
                }
                // get the relative path from common temp folder to package folder, to align with the value in pnpm-lock.yaml
                const relativePathFromTempFolderToPackageFolder = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Path.convertToSlashes(`${relativeFromTempFolderToRootFolder}/${rushProject.projectRelativeFolder}`);
                expectedDependenciesMetaByProjectRelativePath[relativePathFromTempFolderToPackageFolder] =
                    dependenciesMeta;
            }
        }
        // Build a object for dependenciesMeta settings in pnpm-lock.yaml
        // key is the package path, value is the dependenciesMeta info for that package
        const lockfileDependenciesMetaByProjectRelativePath = {};
        if ((shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.importers) !== undefined) {
            for (const [key, value] of shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.importers) {
                const projectRelativePath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Path.convertToSlashes(key);
                // we only need to verify packages that exist in package.json and pnpm-lock.yaml
                // PNPM won't actively remove deleted packages in importers, unless it has to
                // so it is possible that a deleted package still showing in pnpm-lock.yaml
                if (expectedDependenciesMetaByProjectRelativePath[projectRelativePath] === undefined) {
                    continue;
                }
                if (value.dependenciesMeta !== undefined) {
                    lockfileDependenciesMetaByProjectRelativePath[projectRelativePath] = value.dependenciesMeta;
                }
            }
        }
        // Now, we compare these two objects to see if they are equal or not
        const dependenciesMetaAreEqual = (0,_utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_13__.objectsAreDeepEqual)(expectedDependenciesMetaByProjectRelativePath, lockfileDependenciesMetaByProjectRelativePath);
        if (!dependenciesMetaAreEqual) {
            shrinkwrapWarnings.push("The dependenciesMeta settings in one or more package.json don't match the current shrinkwrap.");
            shrinkwrapIsUpToDate = false;
        }
        // Check if overrides and globalOverrides are the same
        const pnpmOptions = subspace.getPnpmOptions() || this.rushConfiguration.pnpmOptions;
        const overridesAreEqual = (0,_utilities_objectUtilities__WEBPACK_IMPORTED_MODULE_13__.objectsAreDeepEqual)((_a = pnpmOptions.globalOverrides) !== null && _a !== void 0 ? _a : {}, (shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.overrides) ? Object.fromEntries(shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.overrides) : {});
        if (!overridesAreEqual) {
            shrinkwrapWarnings.push("The overrides settings doesn't match the current shrinkwrap.");
            shrinkwrapIsUpToDate = false;
        }
        // Check if packageExtensionsChecksum matches globalPackageExtension's hash
        const packageExtensionsChecksum = this._getPackageExtensionChecksum(pnpmOptions.globalPackageExtensions);
        const packageExtensionsChecksumAreEqual = packageExtensionsChecksum === (shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.packageExtensionsChecksum);
        if (!packageExtensionsChecksumAreEqual) {
            shrinkwrapWarnings.push("The package extension hash doesn't match the current shrinkwrap.");
            shrinkwrapIsUpToDate = false;
        }
        // Write the common package.json
        _InstallHelpers__WEBPACK_IMPORTED_MODULE_14__.InstallHelpers.generateCommonPackageJson(this.rushConfiguration, subspace, undefined, this._terminal);
        // Save the generated workspace file. Don't update the file timestamp unless the content has changed,
        // since "rush install" will consider this timestamp
        workspaceFile.save(workspaceFile.workspaceFilename, { onlyIfChanged: true });
        return { shrinkwrapIsUpToDate, shrinkwrapWarnings };
    }
    _getPackageExtensionChecksum(packageExtensions) {
        // https://github.com/pnpm/pnpm/blob/ba9409ffcef0c36dc1b167d770a023c87444822d/pkg-manager/core/src/install/index.ts#L331
        const packageExtensionsChecksum = Object.keys(packageExtensions !== null && packageExtensions !== void 0 ? packageExtensions : {}).length === 0
            ? undefined
            : createObjectChecksum(packageExtensions);
        return packageExtensionsChecksum;
    }
    async canSkipInstallAsync(lastModifiedDate, subspace, variant) {
        if (!(await super.canSkipInstallAsync(lastModifiedDate, subspace, variant))) {
            return false;
        }
        const potentiallyChangedFiles = [];
        if (this.rushConfiguration.isPnpm) {
            // Add workspace file. This file is only modified when workspace packages change.
            const pnpmWorkspaceFilename = path__WEBPACK_IMPORTED_MODULE_0__.join(subspace.getSubspaceTempFolderPath(), 'pnpm-workspace.yaml');
            if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.exists(pnpmWorkspaceFilename)) {
                potentiallyChangedFiles.push(pnpmWorkspaceFilename);
            }
        }
        // Also consider timestamps for all the project node_modules folders, as well as the package.json
        // files
        // Example: [ "C:\MyRepo\projects\projectA\node_modules", "C:\MyRepo\projects\projectA\package.json" ]
        potentiallyChangedFiles.push(...subspace.getProjects().map((project) => {
            return path__WEBPACK_IMPORTED_MODULE_0__.join(project.projectFolder, _RushConstants__WEBPACK_IMPORTED_MODULE_8__.RushConstants.nodeModulesFolderName);
        }), ...subspace.getProjects().map((project) => {
            return path__WEBPACK_IMPORTED_MODULE_0__.join(project.projectFolder, _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileConstants.PackageJson);
        }));
        // NOTE: If any of the potentiallyChangedFiles does not exist, then isFileTimestampCurrent()
        // returns false.
        return _utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__.Utilities.isFileTimestampCurrentAsync(lastModifiedDate, potentiallyChangedFiles);
    }
    /**
     * Runs "pnpm install" in the common folder.
     */
    async installAsync(cleanInstall, subspace) {
        // Example: "C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm"
        const packageManagerFilename = this.rushConfiguration.packageManagerToolFilename;
        const packageManagerEnv = _InstallHelpers__WEBPACK_IMPORTED_MODULE_14__.InstallHelpers.getPackageManagerEnvironment(this.rushConfiguration, this.options);
        if (_rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.ConsoleTerminalProvider.supportsColor) {
            packageManagerEnv.FORCE_COLOR = '1';
        }
        const commonNodeModulesFolder = path__WEBPACK_IMPORTED_MODULE_0__.join(subspace.getSubspaceTempFolderPath(), _RushConstants__WEBPACK_IMPORTED_MODULE_8__.RushConstants.nodeModulesFolderName);
        // Is there an existing "node_modules" folder to consider?
        if (_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.exists(commonNodeModulesFolder)) {
            // Should we delete the entire "node_modules" folder?
            if (cleanInstall) {
                // YES: Delete "node_modules"
                // Explain to the user why we are hosing their node_modules folder
                // eslint-disable-next-line no-console
                console.log('Deleting files from ' + commonNodeModulesFolder);
                this.installRecycler.moveFolder(commonNodeModulesFolder);
                _utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__.Utilities.createFolderWithRetry(commonNodeModulesFolder);
            }
        }
        const doInstallInternalAsync = async (options) => {
            // Run "npm install" in the common folder
            // To ensure that the output is always colored, set the option "--color=always", even when it's piped.
            // Without this argument, certain text that should be colored (such as red) will appear white.
            const installArgs = ['install'];
            this.pushConfigurationArgs(installArgs, options, subspace);
            // eslint-disable-next-line no-console
            console.log('\n' +
                _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.bold(`Running "${this.rushConfiguration.packageManager} install" in` +
                    ` ${subspace.getSubspaceTempFolderPath()}`) +
                '\n');
            // If any diagnostic options were specified, then show the full command-line
            if (this.options.debug ||
                this.options.collectLogFile ||
                this.options.networkConcurrency ||
                this.options.onlyShrinkwrap) {
                // eslint-disable-next-line no-console
                console.log('\n' +
                    _rushstack_terminal__WEBPACK_IMPORTED_MODULE_5__.Colorize.green('Invoking package manager: ') +
                    _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.getRealPath(packageManagerFilename) +
                    ' ' +
                    installArgs.join(' ') +
                    '\n');
            }
            // Store the tip IDs that should be printed.
            // They will be printed all at once *after* the install
            const tipIDsToBePrinted = new Set();
            const pnpmTips = [];
            for (const [customTipId, customTip] of Object.entries(_api_CustomTipsConfiguration__WEBPACK_IMPORTED_MODULE_16__.PNPM_CUSTOM_TIPS)) {
                if (this.rushConfiguration.customTipsConfiguration.providedCustomTipsByTipId.has(customTipId)) {
                    pnpmTips.push(customTip);
                }
            }
            const onPnpmStdoutChunk = pnpmTips.length > 0
                ? (chunk) => {
                    // Iterate over the supported custom tip metadata and try to match the chunk.
                    for (const { isMatch, tipId } of pnpmTips) {
                        if (isMatch === null || isMatch === void 0 ? void 0 : isMatch(chunk)) {
                            tipIDsToBePrinted.add(tipId);
                        }
                    }
                }
                : undefined;
            try {
                await _utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__.Utilities.executeCommandWithRetryAsync({
                    command: packageManagerFilename,
                    args: installArgs,
                    workingDirectory: subspace.getSubspaceTempFolderPath(),
                    environment: packageManagerEnv,
                    suppressOutput: false,
                    onStdoutStreamChunk: onPnpmStdoutChunk
                }, this.options.maxInstallAttempts, () => {
                    if (this.rushConfiguration.isPnpm) {
                        this._terminal.writeWarningLine(`Deleting the "node_modules" folder`);
                        this.installRecycler.moveFolder(commonNodeModulesFolder);
                        // Leave the pnpm-store as is for the retry. This ensures that packages that have already
                        // been downloaded need not be downloaded again, thereby potentially increasing the chances
                        // of a subsequent successful install.
                        _utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__.Utilities.createFolderWithRetry(commonNodeModulesFolder);
                    }
                });
            }
            finally {
                // The try-finally is to avoid the tips NOT being printed if the install fails.
                // NOT catching the error because we want to keep the other behaviors (i.e., the error will be caught and handle in upper layers).
                if (tipIDsToBePrinted.size > 0) {
                    this._terminal.writeLine();
                    for (const tipID of tipIDsToBePrinted) {
                        this.rushConfiguration.customTipsConfiguration._showTip(this._terminal, tipID);
                    }
                }
            }
        };
        const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;
        if (this.options.allowShrinkwrapUpdates &&
            experiments.usePnpmLockfileOnlyThenFrozenLockfileForRushUpdate) {
            await doInstallInternalAsync(Object.assign(Object.assign({}, this.options), { onlyShrinkwrap: true }));
            await doInstallInternalAsync(Object.assign(Object.assign({}, this.options), { allowShrinkwrapUpdates: false }));
        }
        else {
            await doInstallInternalAsync(this.options);
        }
        // If all attempts fail we just terminate. No special handling needed.
        // Ensure that node_modules folders exist after install, since the timestamps on these folders are used
        // to determine if the install can be skipped
        const projectNodeModulesFolders = [
            path__WEBPACK_IMPORTED_MODULE_0__.join(subspace.getSubspaceTempFolderPath(), _RushConstants__WEBPACK_IMPORTED_MODULE_8__.RushConstants.nodeModulesFolderName),
            ...this.rushConfiguration.projects.map((project) => {
                return path__WEBPACK_IMPORTED_MODULE_0__.join(project.projectFolder, _RushConstants__WEBPACK_IMPORTED_MODULE_8__.RushConstants.nodeModulesFolderName);
            })
        ];
        for (const nodeModulesFolder of projectNodeModulesFolders) {
            _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.ensureFolder(nodeModulesFolder);
        }
        // eslint-disable-next-line no-console
        console.log('');
    }
    async postInstallAsync(subspace) {
        var _a, _b;
        // Grab the temp shrinkwrap, as this was the most recently completed install. It may also be
        // more up-to-date than the checked-in shrinkwrap since filtered installs are not written back.
        // Note that if there are no projects, or if we're in PNPM workspace mode and there are no
        // projects with dependencies, a lockfile won't be generated.
        const tempShrinkwrapFile = _ShrinkwrapFileFactory__WEBPACK_IMPORTED_MODULE_17__.ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, subspace.getTempShrinkwrapFilename());
        if (tempShrinkwrapFile) {
            // Write or delete all project shrinkwraps related to the install
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Async.forEachAsync(subspace.getProjects(), async (project) => {
                var _a;
                await ((_a = tempShrinkwrapFile.getProjectShrinkwrap(project)) === null || _a === void 0 ? void 0 : _a.updateProjectShrinkwrapAsync());
            }, { concurrency: 10 });
        }
        else if (this.rushConfiguration.isPnpm && ((_a = this.rushConfiguration.pnpmOptions) === null || _a === void 0 ? void 0 : _a.useWorkspaces)) {
            // If we're in PNPM workspace mode and PNPM didn't create a shrinkwrap file,
            // there are no dependencies. Generate empty shrinkwrap files for all projects.
            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Async.forEachAsync(subspace.getProjects(), async (project) => {
                await _base_BaseProjectShrinkwrapFile__WEBPACK_IMPORTED_MODULE_18__.BaseProjectShrinkwrapFile.saveEmptyProjectShrinkwrapFileAsync(project);
            }, { concurrency: 10 });
        }
        else {
            // This is an unexpected case
            throw new Error('A shrinkwrap file does not exist after after successful installation. This probably indicates a ' +
                'bug in the package manager.');
        }
        // If the splitWorkspaceCompatibility is enabled for subspaces, create symlinks to mimic the behaviour
        // of having the node_modules folder created directly in the project folder. This requires symlinking two categories:
        // 1) Symlink any packages that are declared to be publicly hoisted, such as by using public-hoist-pattern in .npmrc.
        //    This creates a symlink from <project_folder>/node_modules/<dependency> -> temp/<subspace_name>/node_modules/<dependency>
        // 2) Symlink any workspace packages that are declared in the temp folder, as some packages may expect these packages to exist
        //    in the node_modules folder.
        //    This creates a symlink from temp/<subspace_name>/node_modules/<workspace_dependency_name> -> <workspace_dependency_folder>
        if (this.rushConfiguration.subspacesFeatureEnabled &&
            ((_b = this.rushConfiguration.subspacesConfiguration) === null || _b === void 0 ? void 0 : _b.splitWorkspaceCompatibility)) {
            const tempNodeModulesPath = `${subspace.getSubspaceTempFolderPath()}/node_modules`;
            const modulesFilePath = `${tempNodeModulesPath}/${_RushConstants__WEBPACK_IMPORTED_MODULE_8__.RushConstants.pnpmModulesFilename}`;
            if (subspace.subspaceName.startsWith('split_') &&
                subspace.getProjects().length === 1 &&
                (await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.existsAsync(modulesFilePath))) {
                // Find the .modules.yaml file in the subspace temp/node_modules folder
                const modulesContent = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.readFileAsync(modulesFilePath);
                const yamlContent = js_yaml__WEBPACK_IMPORTED_MODULE_2___default().load(modulesContent, { filename: modulesFilePath });
                const { hoistedDependencies } = yamlContent;
                const subspaceProject = subspace.getProjects()[0];
                const projectNodeModulesPath = `${subspaceProject.projectFolder}/node_modules`;
                for (const value of Object.values(hoistedDependencies)) {
                    for (const [filePath, type] of Object.entries(value)) {
                        if (type === 'public') {
                            if (_utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__.Utilities.existsOrIsSymlink(`${projectNodeModulesPath}/${filePath}`)) {
                                await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.deleteFolderAsync(`${projectNodeModulesPath}/${filePath}`);
                            }
                            // If we don't already have a symlink for this package, create one
                            const parentDir = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__.Utilities.trimAfterLastSlash(`${projectNodeModulesPath}/${filePath}`);
                            await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.ensureFolderAsync(parentDir);
                            _base_BaseLinkManager__WEBPACK_IMPORTED_MODULE_19__.BaseLinkManager._createSymlink({
                                linkTargetPath: `${tempNodeModulesPath}/${filePath}`,
                                newLinkPath: `${projectNodeModulesPath}/${filePath}`,
                                symlinkKind: _base_BaseLinkManager__WEBPACK_IMPORTED_MODULE_19__.SymlinkKind.Directory
                            });
                        }
                    }
                }
            }
            // Look for any workspace linked packages anywhere in this subspace, symlink them from the temp node_modules folder.
            const subspaceDependencyProjects = new Set();
            for (const subspaceProject of subspace.getProjects()) {
                for (const dependencyProject of subspaceProject.dependencyProjects) {
                    subspaceDependencyProjects.add(dependencyProject);
                }
            }
            for (const dependencyProject of subspaceDependencyProjects) {
                const symlinkToCreate = `${tempNodeModulesPath}/${dependencyProject.packageName}`;
                if (!_utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__.Utilities.existsOrIsSymlink(symlinkToCreate)) {
                    const parentFolder = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_15__.Utilities.trimAfterLastSlash(symlinkToCreate);
                    await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.FileSystem.ensureFolderAsync(parentFolder);
                    _base_BaseLinkManager__WEBPACK_IMPORTED_MODULE_19__.BaseLinkManager._createSymlink({
                        linkTargetPath: dependencyProject.projectFolder,
                        newLinkPath: symlinkToCreate,
                        symlinkKind: _base_BaseLinkManager__WEBPACK_IMPORTED_MODULE_19__.SymlinkKind.Directory
                    });
                }
            }
        }
        // TODO: Remove when "rush link" and "rush unlink" are deprecated
        await new _api_FlagFile__WEBPACK_IMPORTED_MODULE_20__.FlagFile(subspace.getSubspaceTempFolderPath(), _RushConstants__WEBPACK_IMPORTED_MODULE_8__.RushConstants.lastLinkFlagFilename, {}).createAsync();
    }
    /**
     * Used when invoking the NPM tool.  Appends the common configuration options
     * to the command-line.
     */
    pushConfigurationArgs(args, options, subspace) {
        super.pushConfigurationArgs(args, options, subspace);
        // Add workspace-specific args
        if (this.rushConfiguration.isPnpm) {
            args.push('--recursive');
            args.push('--link-workspace-packages', 'false');
            if (process.stdout.isTTY) {
                // If we're on a TTY console and something else didn't set a `--reporter` parameter,
                // explicitly set the default reporter. This fixes an issue where, when the pnpm
                // output is being monitored to match custom tips, pnpm will detect a non-TTY
                // stdout stream and use the `append-only` reporter.
                //
                // See docs here: https://pnpm.io/cli/install#--reportername
                let includesReporterArg = false;
                for (const arg of args) {
                    if (arg.startsWith('--reporter')) {
                        includesReporterArg = true;
                        break;
                    }
                }
                if (!includesReporterArg) {
                    args.push('--reporter', 'default');
                }
            }
            for (const arg of this.options.pnpmFilterArgumentValues) {
                args.push('--filter', arg);
            }
        }
    }
}
/**
 * Source: https://github.com/pnpm/pnpm/blob/ba9409ffcef0c36dc1b167d770a023c87444822d/pkg-manager/core/src/install/index.ts#L821-L824
 * @param obj
 * @returns
 */
function createObjectChecksum(obj) {
    const s = JSON.stringify(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_3__.Sort.sortKeys(obj));
    return (0,crypto__WEBPACK_IMPORTED_MODULE_4__.createHash)('md5').update(s).digest('hex');
}
//# sourceMappingURL=WorkspaceInstallManager.js.map

/***/ }),

/***/ 761172:
/*!****************************************************!*\
  !*** ./lib-esnext/logic/pnpm/PnpmWorkspaceFile.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PnpmWorkspaceFile: () => (/* binding */ PnpmWorkspaceFile)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 16928);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/node-core-library */ 277275);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _base_BaseWorkspaceFile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/BaseWorkspaceFile */ 229196);
/* harmony import */ var _PnpmYamlCommon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PnpmYamlCommon */ 178325);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.




const yamlModule = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Import.lazy('js-yaml', require);
const globEscape = __webpack_require__(/*! glob-escape */ 310434); // No @types/glob-escape package exists
class PnpmWorkspaceFile extends _base_BaseWorkspaceFile__WEBPACK_IMPORTED_MODULE_2__.BaseWorkspaceFile {
    /**
     * The PNPM workspace file is used to specify the location of workspaces relative to the root
     * of your PNPM install.
     */
    constructor(workspaceYamlFilename) {
        super();
        this.workspaceFilename = workspaceYamlFilename;
        // Ignore any existing file since this file is generated and we need to handle deleting packages
        // If we need to support manual customization, that should be an additional parameter for "base file"
        this._workspacePackages = new Set();
    }
    /** @override */
    addPackage(packagePath) {
        // Ensure the path is relative to the pnpm-workspace.yaml file
        if (path__WEBPACK_IMPORTED_MODULE_0__.isAbsolute(packagePath)) {
            packagePath = path__WEBPACK_IMPORTED_MODULE_0__.relative(path__WEBPACK_IMPORTED_MODULE_0__.dirname(this.workspaceFilename), packagePath);
        }
        // Glob can't handle Windows paths
        const globPath = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Path.convertToSlashes(packagePath);
        this._workspacePackages.add(globEscape(globPath));
    }
    /** @override */
    serialize() {
        // Ensure stable sort order when serializing
        _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_1__.Sort.sortSet(this._workspacePackages);
        const workspaceYaml = {
            packages: Array.from(this._workspacePackages)
        };
        return yamlModule.safeDump(workspaceYaml, _PnpmYamlCommon__WEBPACK_IMPORTED_MODULE_3__.PNPM_SHRINKWRAP_YAML_FORMAT);
    }
}
//# sourceMappingURL=PnpmWorkspaceFile.js.map

/***/ })

};
;
//# sourceMappingURL=InstallManagerFactory.js.map