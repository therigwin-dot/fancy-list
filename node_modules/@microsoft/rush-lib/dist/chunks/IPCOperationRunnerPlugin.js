"use strict";
exports.id = "IPCOperationRunnerPlugin";
exports.ids = ["IPCOperationRunnerPlugin"];
exports.modules = {

/***/ 311790:
/*!***********************************************************!*\
  !*** ./lib-esnext/logic/operations/IPCOperationRunner.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IPCOperationRunner: () => (/* binding */ IPCOperationRunner)
/* harmony export */ });
/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:events */ 478474);
/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rushstack/terminal */ 367587);
/* harmony import */ var _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../api/EnvironmentConfiguration */ 778261);
/* harmony import */ var _utilities_Utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utilities/Utilities */ 387714);
/* harmony import */ var _OperationError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./OperationError */ 681570);
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./OperationStatus */ 251124);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.






function isAfterExecuteEventMessage(message) {
    return typeof message === 'object' && message.event === 'after-execute';
}
function isRequestRunEventMessage(message) {
    return typeof message === 'object' && message.event === 'requestRun';
}
function isSyncEventMessage(message) {
    return typeof message === 'object' && message.event === 'sync';
}
/**
 * Runner that hosts a long-lived process to which it communicates via IPC.
 */
class IPCOperationRunner {
    constructor(options) {
        this.cacheable = false;
        this.reportTiming = true;
        this.silent = false;
        this.name = options.name;
        this.warningsAreAllowed =
            _api_EnvironmentConfiguration__WEBPACK_IMPORTED_MODULE_2__.EnvironmentConfiguration.allowWarningsInSuccessfulBuild ||
                options.phase.allowWarningsOnSuccess ||
                false;
        this._rushProject = options.project;
        this._commandToRun = options.commandToRun;
        this._commandForHash = options.commandForHash;
        this._persist = options.persist;
        this._requestRun = options.requestRun;
    }
    async executeAsync(context) {
        return await context.runWithTerminalAsync(async (terminal, terminalProvider) => {
            var _a, _b;
            let isConnected = false;
            if (!this._ipcProcess || typeof this._ipcProcess.exitCode === 'number') {
                // Run the operation
                terminal.writeLine('Invoking: ' + this._commandToRun);
                const { rushConfiguration, projectFolder } = this._rushProject;
                const { environment: initialEnvironment } = context;
                this._ipcProcess = _utilities_Utilities__WEBPACK_IMPORTED_MODULE_3__.Utilities.executeLifecycleCommandAsync(this._commandToRun, {
                    rushConfiguration,
                    workingDirectory: projectFolder,
                    initCwd: rushConfiguration.commonTempFolder,
                    handleOutput: true,
                    environmentPathOptions: {
                        includeProjectBin: true
                    },
                    ipc: true,
                    connectSubprocessTerminator: true,
                    initialEnvironment
                });
                let resolveReadyPromise;
                this._processReadyPromise = new Promise((resolve) => {
                    resolveReadyPromise = resolve;
                });
                this._ipcProcess.on('message', (message) => {
                    if (isRequestRunEventMessage(message)) {
                        this._requestRun(message.requestor);
                    }
                    else if (isSyncEventMessage(message)) {
                        resolveReadyPromise();
                    }
                });
            }
            else {
                terminal.writeLine(`Connecting to existing IPC process...`);
            }
            const subProcess = this._ipcProcess;
            let hasWarningOrError = false;
            function onStdout(data) {
                const text = data.toString();
                terminalProvider.write(text, _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.TerminalProviderSeverity.log);
            }
            function onStderr(data) {
                const text = data.toString();
                terminalProvider.write(text, _rushstack_terminal__WEBPACK_IMPORTED_MODULE_1__.TerminalProviderSeverity.error);
                hasWarningOrError = true;
            }
            // Hook into events, in order to get live streaming of the log
            (_a = subProcess.stdout) === null || _a === void 0 ? void 0 : _a.on('data', onStdout);
            (_b = subProcess.stderr) === null || _b === void 0 ? void 0 : _b.on('data', onStderr);
            const status = await new Promise((resolve, reject) => {
                function finishHandler(message) {
                    var _a, _b;
                    if (isAfterExecuteEventMessage(message)) {
                        terminal.writeLine('Received finish notification');
                        (_a = subProcess.stdout) === null || _a === void 0 ? void 0 : _a.off('data', onStdout);
                        (_b = subProcess.stderr) === null || _b === void 0 ? void 0 : _b.off('data', onStderr);
                        subProcess.off('message', finishHandler);
                        subProcess.off('error', reject);
                        subProcess.off('exit', onExit);
                        terminal.writeLine('Disconnected from IPC process');
                        // These types are currently distinct but have the same underlying values
                        resolve(message.status);
                    }
                }
                function onExit(exitCode, signal) {
                    try {
                        if (signal) {
                            context.error = new _OperationError__WEBPACK_IMPORTED_MODULE_4__.OperationError('error', `Terminated by signal: ${signal}`);
                            resolve(_OperationStatus__WEBPACK_IMPORTED_MODULE_5__.OperationStatus.Failure);
                        }
                        else if (exitCode !== 0) {
                            // Do NOT reject here immediately, give a chance for other logic to suppress the error
                            context.error = new _OperationError__WEBPACK_IMPORTED_MODULE_4__.OperationError('error', `Returned error code: ${exitCode}`);
                            resolve(_OperationStatus__WEBPACK_IMPORTED_MODULE_5__.OperationStatus.Failure);
                        }
                        else if (hasWarningOrError) {
                            resolve(_OperationStatus__WEBPACK_IMPORTED_MODULE_5__.OperationStatus.SuccessWithWarning);
                        }
                        else {
                            resolve(_OperationStatus__WEBPACK_IMPORTED_MODULE_5__.OperationStatus.Success);
                        }
                    }
                    catch (error) {
                        reject(error);
                    }
                }
                subProcess.on('message', finishHandler);
                subProcess.on('error', reject);
                subProcess.on('exit', onExit);
                this._processReadyPromise.then(() => {
                    isConnected = true;
                    terminal.writeLine('Child supports IPC protocol. Sending "run" command...');
                    const runCommand = {
                        command: 'run'
                    };
                    subProcess.send(runCommand);
                }, reject);
            });
            if (isConnected && !this._persist) {
                await this.shutdownAsync();
            }
            // @rushstack/operation-graph does not currently have a concept of "Success with Warning"
            // To match existing ShellOperationRunner behavior we treat any stderr as a warning.
            return status === _OperationStatus__WEBPACK_IMPORTED_MODULE_5__.OperationStatus.Success && hasWarningOrError
                ? _OperationStatus__WEBPACK_IMPORTED_MODULE_5__.OperationStatus.SuccessWithWarning
                : status;
        }, {
            createLogFile: true
        });
    }
    getConfigHash() {
        return this._commandForHash;
    }
    async shutdownAsync() {
        const { _ipcProcess: subProcess } = this;
        if (!subProcess) {
            return;
        }
        if (subProcess.connected) {
            const exitCommand = {
                command: 'exit'
            };
            subProcess.send(exitCommand);
            await (0,node_events__WEBPACK_IMPORTED_MODULE_0__.once)(subProcess, 'exit');
        }
    }
}
//# sourceMappingURL=IPCOperationRunner.js.map

/***/ }),

/***/ 70485:
/*!*****************************************************************!*\
  !*** ./lib-esnext/logic/operations/IPCOperationRunnerPlugin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IPCOperationRunnerPlugin: () => (/* binding */ IPCOperationRunnerPlugin)
/* harmony export */ });
/* harmony import */ var _IPCOperationRunner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./IPCOperationRunner */ 311790);
/* harmony import */ var _OperationStatus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperationStatus */ 251124);
/* harmony import */ var _ShellOperationRunnerPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShellOperationRunnerPlugin */ 462089);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



const PLUGIN_NAME = 'IPCOperationRunnerPlugin';
/**
 * Plugin that implements compatible phases via IPC to a long-lived watch process.
 */
class IPCOperationRunnerPlugin {
    apply(hooks) {
        // Workaround until the operation graph persists for the lifetime of the watch process
        const runnerCache = new Map();
        const operationStatesByRunner = new WeakMap();
        let currentContext;
        hooks.createOperations.tapPromise({
            name: PLUGIN_NAME,
            before: _ShellOperationRunnerPlugin__WEBPACK_IMPORTED_MODULE_0__.PLUGIN_NAME
        }, async (operations, context) => {
            var _a, _b;
            const { isWatch, isInitial } = context;
            if (!isWatch) {
                return operations;
            }
            currentContext = context;
            const getCustomParameterValuesForPhase = (0,_ShellOperationRunnerPlugin__WEBPACK_IMPORTED_MODULE_0__.getCustomParameterValuesByPhase)();
            for (const operation of operations) {
                const { associatedPhase: phase, associatedProject: project, runner } = operation;
                if (runner || !phase || !project) {
                    continue;
                }
                const { scripts } = project.packageJson;
                if (!scripts) {
                    continue;
                }
                const { name: phaseName } = phase;
                const rawScript = (_a = (!isInitial ? scripts[`${phaseName}:incremental:ipc`] : undefined)) !== null && _a !== void 0 ? _a : scripts[`${phaseName}:ipc`];
                if (!rawScript) {
                    continue;
                }
                // This is the command that will be used to identify the cache entry for this operation, to allow
                // for this operation (or downstream operations) to be restored from the build cache.
                const commandForHash = (_b = phase.shellCommand) !== null && _b !== void 0 ? _b : scripts === null || scripts === void 0 ? void 0 : scripts[phaseName];
                const customParameterValues = getCustomParameterValuesForPhase(phase);
                const commandToRun = (0,_ShellOperationRunnerPlugin__WEBPACK_IMPORTED_MODULE_0__.formatCommand)(rawScript, customParameterValues);
                const operationName = (0,_ShellOperationRunnerPlugin__WEBPACK_IMPORTED_MODULE_0__.getDisplayName)(phase, project);
                let maybeIpcOperationRunner = runnerCache.get(operationName);
                if (!maybeIpcOperationRunner) {
                    const ipcOperationRunner = (maybeIpcOperationRunner = new _IPCOperationRunner__WEBPACK_IMPORTED_MODULE_1__.IPCOperationRunner({
                        phase,
                        project,
                        name: operationName,
                        commandToRun,
                        commandForHash,
                        persist: true,
                        requestRun: (requestor) => {
                            var _a;
                            const operationState = operationStatesByRunner.get(ipcOperationRunner);
                            if (!operationState) {
                                return;
                            }
                            const status = operationState.status;
                            if (status === _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Waiting ||
                                status === _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Ready ||
                                status === _OperationStatus__WEBPACK_IMPORTED_MODULE_2__.OperationStatus.Queued) {
                                // Already pending. No-op.
                                return;
                            }
                            (_a = currentContext === null || currentContext === void 0 ? void 0 : currentContext.invalidateOperation) === null || _a === void 0 ? void 0 : _a.call(currentContext, operation, requestor || 'IPC');
                        }
                    }));
                    runnerCache.set(operationName, ipcOperationRunner);
                }
                operation.runner = maybeIpcOperationRunner;
            }
            return operations;
        });
        hooks.beforeExecuteOperations.tap(PLUGIN_NAME, (records, context) => {
            currentContext = context;
            for (const [{ runner }, result] of records) {
                if (runner instanceof _IPCOperationRunner__WEBPACK_IMPORTED_MODULE_1__.IPCOperationRunner) {
                    operationStatesByRunner.set(runner, result);
                }
            }
        });
        hooks.shutdownAsync.tapPromise(PLUGIN_NAME, async () => {
            await Promise.all(Array.from(runnerCache.values(), (runner) => runner.shutdownAsync()));
        });
    }
}
//# sourceMappingURL=IPCOperationRunnerPlugin.js.map

/***/ })

};
;
//# sourceMappingURL=IPCOperationRunnerPlugin.js.map