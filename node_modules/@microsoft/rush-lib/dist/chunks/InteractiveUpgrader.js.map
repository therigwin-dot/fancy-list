{"version":3,"file":"chunks/InteractiveUpgrader.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACiC;AACc;AACwB;AAC3B;AAC6B;AAClE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,mFAAkB;AACjC;AACA;AACA;AACA,uBAAuB,+DAAM;AAC7B,kBAAkB,iFAAgB;AAClC,SAAS;AACT,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAQ;AACtC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC,mCAAmC,gDAAQ;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACgC;AACC;AAC0B;AAC3D;AACA,WAAW,yDAAQ,WAAW,yDAAQ,MAAM,yDAAQ;AACpD;AACA;AACA,WAAW,yDAAQ,WAAW,yDAAQ,MAAM,yDAAQ;AACpD;AACA;AACA,WAAW,yDAAQ,WAAW,yDAAQ,MAAM,yDAAQ;AACpD;AACA;AACA,WAAW,yDAAQ,WAAW,yDAAQ,MAAM,yDAAQ;AACpD;AACO;AACP;AACA;AACA,kBAAkB;AAClB,KAAK;AACL;AACA,kBAAkB,gCAAgC,EAAE,yDAAQ,mCAAmC;AAC/F,kBAAkB;AAClB,KAAK;AACL;AACA,kBAAkB,oCAAoC,EAAE,yDAAQ,0CAA0C;AAC1G,kBAAkB;AAClB,KAAK;AACL;AACA,kBAAkB,qCAAqC,EAAE,yDAAQ,8CAA8C;AAC/G;AACA,kBAAkB;AAClB,KAAK;AACL;AACA,kBAAkB,kCAAkC,EAAE,yDAAQ,uDAAuD;AACrH,kBAAkB;AAClB,KAAK;AACL;AACA,kBAAkB,oCAAoC,EAAE,yDAAQ,+CAA+C;AAC/G,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAQ;AACzB,qCAAqC,yDAAQ;AAC7C,uCAAuC,yDAAQ;AAC/C,oCAAoC,yDAAQ,MAAM,yDAAQ;AAC1D;AACA;AACA;AACA;AACA,QAAQ,yDAAQ;AAChB;AACA;AACA;AACA;AACA,cAAc,eAAe,GAAG,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAkB,CAAC,2DAAU;AAC5C;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yBAAyB,kDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gCAAgC,0EAA0E;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAe;AAC1C;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AClKA;AACA;AAC+C;AACI;AACH;AACK;AACvB;AACkB;AACzC,+BAA+B,kEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,OAAO;AAC3E;AACA;AACA;AACA;AACA,8BAA8B,qEAAS;AACvC;AACA;AACA;AACA;AACA,uBAAuB,gEAAO;AAC9B;AACA,oEAAoE,mDAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAS;AAC3B;AACA;AACA;AACA,kBAAkB,yDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAQ;AAC/B;AACA;AACA;AACA,uBAAuB,yDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ,OAAO,yDAAQ,mCAAmC,EAAE,yDAAQ,mBAAmB;AACnH;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAQ,MAAM,wDAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/InteractiveUpgrader.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/InteractiveUpgradeUI.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/prompts/SearchListPrompt.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport npmCheck from 'npm-check';\nimport { Colorize } from '@rushstack/terminal';\nimport { upgradeInteractive } from '../utilities/InteractiveUpgradeUI';\nimport Prompt from 'inquirer/lib/ui/prompt';\nimport { SearchListPrompt } from '../utilities/prompts/SearchListPrompt';\nexport class InteractiveUpgrader {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    async upgradeAsync() {\n        const rushProject = await this._getUserSelectedProjectForUpgradeAsync();\n        const dependenciesState = await this._getPackageDependenciesStatusAsync(rushProject);\n        const depsToUpgrade = await this._getUserSelectedDependenciesToUpgradeAsync(dependenciesState);\n        return { projects: [rushProject], depsToUpgrade };\n    }\n    async _getUserSelectedDependenciesToUpgradeAsync(packages) {\n        return upgradeInteractive(packages);\n    }\n    async _getUserSelectedProjectForUpgradeAsync() {\n        const projects = this._rushConfiguration.projects;\n        const ui = new Prompt({\n            list: SearchListPrompt\n        });\n        const { selectProject } = await ui.run([\n            {\n                name: 'selectProject',\n                message: 'Select a project you would like to upgrade',\n                type: 'list',\n                choices: projects.map((project) => {\n                    return {\n                        name: Colorize.green(project.packageName),\n                        value: project\n                    };\n                }),\n                pageSize: 12\n            }\n        ]);\n        return selectProject;\n    }\n    async _getPackageDependenciesStatusAsync(rushProject) {\n        const { projectFolder } = rushProject;\n        const currentState = await npmCheck({\n            cwd: projectFolder,\n            skipUnused: true\n        });\n        return currentState.get('packages');\n    }\n}\n//# sourceMappingURL=InteractiveUpgrader.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n// UI Code, Table creation, and choice layout leveraged from npm-check\n// https://github.com/dylang/npm-check/blob/master/lib/out/interactive-update.js\n// Extended to use one type of text table\nimport inquirer from 'inquirer';\nimport CliTable from 'cli-table';\nimport { AnsiEscape, Colorize } from '@rushstack/terminal';\nfunction greenUnderlineBold(text) {\n    return Colorize.underline(Colorize.bold(Colorize.green(text)));\n}\nfunction yellowUnderlineBold(text) {\n    return Colorize.underline(Colorize.bold(Colorize.yellow(text)));\n}\nfunction redUnderlineBold(text) {\n    return Colorize.underline(Colorize.bold(Colorize.red(text)));\n}\nfunction magentaUnderlineBold(text) {\n    return Colorize.underline(Colorize.bold(Colorize.magenta(text)));\n}\nexport const UI_GROUPS = [\n    {\n        title: greenUnderlineBold('Update package.json to match version installed.'),\n        filter: { mismatch: true, bump: undefined }\n    },\n    {\n        title: `${greenUnderlineBold('Missing.')} ${Colorize.green('You probably want these.')}`,\n        filter: { notInstalled: true, bump: undefined }\n    },\n    {\n        title: `${greenUnderlineBold('Patch Update')} ${Colorize.green('Backwards-compatible bug fixes.')}`,\n        filter: { bump: 'patch' }\n    },\n    {\n        title: `${yellowUnderlineBold('Minor Update')} ${Colorize.yellow('New backwards-compatible features.')}`,\n        bgColor: 'yellow',\n        filter: { bump: 'minor' }\n    },\n    {\n        title: `${redUnderlineBold('Major Update')} ${Colorize.red('Potentially breaking API changes. Use caution.')}`,\n        filter: { bump: 'major' }\n    },\n    {\n        title: `${magentaUnderlineBold('Non-Semver')} ${Colorize.magenta('Versions less than 1.0.0, caution.')}`,\n        filter: { bump: 'nonSemver' }\n    }\n];\nfunction label(dep) {\n    const bumpInstalled = dep.bump ? dep.installed : '';\n    const installed = dep.mismatch ? dep.packageJson : bumpInstalled;\n    const name = Colorize.yellow(dep.moduleName);\n    const type = dep.devDependency ? Colorize.green(' devDep') : '';\n    const missing = dep.notInstalled ? Colorize.red(' missing') : '';\n    const homepage = dep.homepage ? Colorize.blue(Colorize.underline(dep.homepage)) : '';\n    return [\n        name + type + missing,\n        installed,\n        installed && '>',\n        Colorize.bold(dep.latest || ''),\n        dep.latest ? homepage : dep.regError || dep.pkgError\n    ];\n}\nfunction short(dep) {\n    return `${dep.moduleName}@${dep.latest}`;\n}\nfunction getChoice(dep) {\n    if (!dep.mismatch && !dep.bump && !dep.notInstalled) {\n        return false;\n    }\n    return {\n        value: dep,\n        name: label(dep),\n        short: short(dep)\n    };\n}\nfunction unselectable(options) {\n    return new inquirer.Separator(AnsiEscape.removeCodes(options ? options.title : ''));\n}\nfunction createChoices(packages, options) {\n    const { filter } = options;\n    const filteredChoices = packages.filter((pkg) => {\n        if ('mismatch' in filter && pkg.mismatch !== filter.mismatch) {\n            return false;\n        }\n        else if ('bump' in filter && pkg.bump !== filter.bump) {\n            return false;\n        }\n        else if ('notInstalled' in filter && pkg.notInstalled !== filter.notInstalled) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    });\n    const choices = filteredChoices\n        .map(getChoice)\n        .filter(Boolean);\n    const cliTable = new CliTable({\n        chars: {\n            top: '',\n            'top-mid': '',\n            'top-left': '',\n            'top-right': '',\n            bottom: '',\n            'bottom-mid': '',\n            'bottom-left': '',\n            'bottom-right': '',\n            left: '',\n            'left-mid': '',\n            mid: '',\n            'mid-mid': '',\n            right: '',\n            'right-mid': '',\n            middle: ' '\n        },\n        colWidths: [50, 10, 3, 10, 100]\n    });\n    for (const choice of choices) {\n        if (typeof choice === 'object' && 'name' in choice) {\n            cliTable.push(choice.name);\n        }\n    }\n    const choicesAsATable = cliTable.toString().split('\\n');\n    for (let i = 0; i < choices.length; i++) {\n        const choice = choices[i];\n        if (typeof choice === 'object' && 'name' in choice) {\n            choice.name = choicesAsATable[i];\n        }\n    }\n    if (choices.length > 0) {\n        choices.unshift(unselectable(options));\n        choices.unshift(unselectable());\n        return choices;\n    }\n}\nexport const upgradeInteractive = async (pkgs) => {\n    const choicesGrouped = UI_GROUPS.map((group) => createChoices(pkgs, group)).filter(Boolean);\n    const choices = [];\n    for (const choiceGroup of choicesGrouped) {\n        if (choiceGroup) {\n            choices.push(...choiceGroup);\n        }\n    }\n    if (!choices.length) {\n        // eslint-disable-next-line no-console\n        console.log('All dependencies are up to date!');\n        return { packages: [] };\n    }\n    choices.push(unselectable());\n    choices.push(unselectable({ title: 'Space to select. Enter to start upgrading. Control-C to cancel.' }));\n    const promptQuestions = [\n        {\n            name: 'packages',\n            message: 'Choose which packages to upgrade',\n            type: 'checkbox',\n            choices: choices.concat(unselectable()),\n            pageSize: process.stdout.rows - 2\n        }\n    ];\n    const answers = (await inquirer.prompt(promptQuestions));\n    return answers;\n};\n//# sourceMappingURL=InteractiveUpgradeUI.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Colorize } from '@rushstack/terminal';\nimport BasePrompt from 'inquirer/lib/prompts/base';\nimport observe from 'inquirer/lib/utils/events';\nimport Paginator from 'inquirer/lib/utils/paginator';\nimport figures from 'figures';\nimport { map, takeUntil } from 'rxjs/operators';\nexport class SearchListPrompt extends BasePrompt {\n    constructor(question, readline, answers) {\n        super(question, readline, answers);\n        this._selected = 0;\n        this._query = '';\n        this._firstRender = true;\n        if (!this.opt.choices) {\n            this.throwParamError('choices');\n        }\n        const isDefaultANumber = typeof this.opt.default === 'number';\n        if (isDefaultANumber && this.opt.default >= 0 && this.opt.default < this.opt.choices.realLength) {\n            this._selected = this.opt.default;\n        }\n        else if (!isDefaultANumber && this.opt.default !== null) {\n            const index = this.opt.choices.realChoices.findIndex(({ value }) => value === this.opt.default);\n            this._selected = Math.max(index, 0);\n        }\n        // Make sure no default is set (so it won't be printed)\n        this.opt.default = null;\n        this._paginator = new Paginator(this.screen);\n    }\n    _run(callback) {\n        this.done = callback;\n        // eslint-disable-next-line @typescript-eslint/typedef\n        const events = observe(this.rl);\n        // eslint-disable-next-line @typescript-eslint/typedef\n        const validation = this.handleSubmitEvents(events.line.pipe(map(this._getCurrentValue.bind(this))));\n        //eslint-disable-next-line no-void\n        void validation.success.forEach(this._onSubmit.bind(this));\n        //eslint-disable-next-line no-void\n        void validation.error.forEach(this._onError.bind(this));\n        // eslint-disable-next-line no-void\n        void events.numberKey\n            .pipe(takeUntil(events.line))\n            .forEach(this._onNumberKey.bind(this));\n        // eslint-disable-next-line no-void\n        void events.keypress\n            .pipe(takeUntil(validation.success))\n            .forEach(this._onKeyPress.bind(this));\n        this.render();\n        return this;\n    }\n    _onUpKey() {\n        return this._adjustSelected(-1);\n    }\n    _onDownKey() {\n        return this._adjustSelected(1);\n    }\n    _onNumberKey(input) {\n        if (input <= this.opt.choices.realLength) {\n            this._selected = input - 1;\n        }\n        this.render();\n    }\n    /**\n     * When user press `enter` key\n     */\n    _onSubmit(state) {\n        this.status = 'answered';\n        // Rerender prompt (and clean subline error)\n        this.render();\n        this.screen.done();\n        this.done(state.value);\n    }\n    _onError(state) {\n        this.render(state.isValid || undefined);\n    }\n    _onKeyPress(event) {\n        var _a, _b;\n        if (event.key.ctrl) {\n            switch (event.key.name) {\n                case 'backspace':\n                    return this._setQuery('');\n            }\n        }\n        else {\n            switch (event.key.name) {\n                // Go to beginning of list\n                case 'home':\n                    return this._adjustSelected(-Infinity);\n                // Got to end of list\n                case 'end':\n                    return this._adjustSelected(Infinity);\n                // Paginate up\n                case 'pageup':\n                    return this._adjustSelected(-((_a = this.opt.pageSize) !== null && _a !== void 0 ? _a : 1));\n                // Paginate down\n                case 'pagedown':\n                    return this._adjustSelected((_b = this.opt.pageSize) !== null && _b !== void 0 ? _b : 1);\n                case 'backspace':\n                    return this._setQuery(this._query.slice(0, -1));\n                case 'up':\n                    return this._onUpKey();\n                case 'down':\n                    return this._onDownKey();\n                default:\n                    if (event.key.sequence && event.key.sequence.length === 1) {\n                        this._setQuery(this._query + event.key.sequence);\n                    }\n            }\n        }\n    }\n    _setQuery(query) {\n        this._query = query;\n        const filter = query.toUpperCase();\n        const { choices } = this.opt.choices;\n        for (const choice of choices) {\n            if (choice.type !== 'separator') {\n                choice.disabled = !choice.short.toUpperCase().includes(filter);\n            }\n        }\n        // Select the first valid option\n        this._adjustSelected(0);\n    }\n    // Provide the delta in deplayed choices and change the selected\n    // index accordingly by the delta in real choices\n    _adjustSelected(delta) {\n        const { choices } = this.opt.choices;\n        const pointer = this._selected;\n        let lastValidIndex = pointer;\n        // if delta is less than 0, we are moving up in list w/ selected index\n        if (delta < 0) {\n            for (let i = pointer - 1; i >= 0; i--) {\n                const choice = choices[i];\n                if (isValidChoice(choice)) {\n                    ++delta;\n                    lastValidIndex = i;\n                    // if delta is 0, we have found the next valid choice that has an index less than the selected index\n                    if (delta === 0) {\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            // if delta is greater than 0, we are moving down in list w/ selected index\n            // Also, if delta is exactly 0, the request is to adjust to the first\n            // displayed choice that has an index >= the current selected choice.\n            ++delta;\n            for (let i = pointer, len = choices.length; i < len; i++) {\n                const choice = choices[i];\n                if (isValidChoice(choice)) {\n                    --delta;\n                    lastValidIndex = i;\n                    // if delta is 0, we have found the next valid choice that has an index greater than the selected index\n                    if (delta === 0) {\n                        break;\n                    }\n                }\n            }\n        }\n        this._selected = lastValidIndex;\n        this.render();\n    }\n    _getCurrentValue() {\n        return this.opt.choices.getChoice(this._selected).value;\n    }\n    render(error) {\n        // Render the question\n        let message = this.getQuestion();\n        let bottomContent = '';\n        if (this._firstRender) {\n            message += Colorize.dim(' (Use arrow keys)');\n        }\n        // Render choices or answer depending on the state\n        if (this.status === 'answered') {\n            message += Colorize.cyan(this.opt.choices.getChoice(this._selected).short);\n        }\n        else {\n            const choicesStr = listRender(this.opt.choices, this._selected);\n            const indexPosition = this.opt.choices.indexOf(this.opt.choices.getChoice(this._selected));\n            let realIndexPosition = 0;\n            const { choices } = this.opt.choices;\n            for (let i = 0; i < indexPosition; i++) {\n                const value = choices[i];\n                // Add line if it's a separator\n                if (value.type === 'separator') {\n                    realIndexPosition++;\n                    continue;\n                }\n                // Do not render choices which disabled property\n                // these represent choices that are filtered out\n                if (value.disabled) {\n                    continue;\n                }\n                const line = value.name;\n                // Non-strings take up one line\n                if (typeof line !== 'string') {\n                    realIndexPosition++;\n                    continue;\n                }\n                // Calculate lines taken up by string\n                // eslint-disable-next-line no-bitwise\n                realIndexPosition += ((line.length / process.stdout.columns) | 0) + 1;\n            }\n            message += `\\n${Colorize.white(Colorize.bold('Start typing to filter:'))} ${Colorize.cyan(this._query)}`;\n            // @ts-expect-error Types are wrong\n            message += '\\n' + this._paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);\n        }\n        if (error) {\n            bottomContent = Colorize.red('>> ') + error;\n        }\n        this.screen.render(message, bottomContent);\n    }\n}\nfunction listRender(choices, pointer) {\n    let output = '';\n    choices.forEach((choice, i) => {\n        if (choice.type === 'separator') {\n            output += ' ' + choice + '\\n';\n            return;\n        }\n        if (!choice.disabled) {\n            const line = choice.name;\n            if (i === pointer) {\n                output += Colorize.cyan(figures.pointer + line);\n            }\n            else {\n                output += ' ' + line;\n            }\n        }\n        if (i < choices.length - 1) {\n            output += '\\n';\n        }\n    });\n    return output.replace(/\\n$/, '');\n}\nfunction isValidChoice(choice) {\n    return !choice.disabled;\n}\n//# sourceMappingURL=SearchListPrompt.js.map"],"names":[],"sourceRoot":""}