{"version":3,"file":"chunks/ProjectWatcher.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACyB;AACA;AACY;AACP;AAC6B;AAC2B;AACvC;AACnB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,gBAAgB,2IAA2I;AAC3J;AACA;AACA;AACA;AACA,4BAA4B,qCAAG;AAC/B,yBAAyB,8DAAI,kBAAkB,yEAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8DAAI;AAC7B;AACA;AACA;AACA;AACA,wCAAwC,wCAAW,kBAAkB,wCAAW;AAChF;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA,6BAA6B,8DAAI;AACjC;AACA,aAAa;AACb;AACA;AACA,iCAAiC,8DAAI,4CAA4C,eAAe;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe,GAAG,YAAY,KAAK,eAAe;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,oEAAoE;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qCAAQ;AACxC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,8DAAI;AAClE,8DAA8D,KAAK,GAAG,eAAe;AACrF;AACA;AACA,6CAA6C,oEAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,+BAA+B,4CAAI;AACnC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC,kBAAkB,OAAO;AAC/E;AACA;AACA;AACA,YAAY,8CAAiB;AAC7B,YAAY,gDAAmB;AAC/B,YAAY,qDAAwB;AACpC;AACA;AACA,iCAAiC,yDAAQ,MAAM,yDAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/ProjectWatcher.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as readline from 'readline';\nimport { once } from 'events';\nimport { getRepoRoot } from '@rushstack/package-deps-hash';\nimport { AlreadyReportedError, Path, FileSystem } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { Git } from './Git';\n/**\n * This class is for incrementally watching a set of projects in the repository for changes.\n *\n * We are manually using fs.watch() instead of `chokidar` because all we want from the file system watcher is a boolean\n * signal indicating that \"at least 1 file in a watched project changed\". We then defer to getInputsSnapshotAsync (which\n * is responsible for change detection in all incremental builds) to determine what actually chanaged.\n *\n * Calling `waitForChange()` will return a promise that resolves when the package-deps of one or\n * more projects differ from the value the previous time it was invoked. The first time will always resolve with the full selection.\n */\nexport class ProjectWatcher {\n    constructor(options) {\n        this._forceChangedProjects = new Map();\n        this.isPaused = false;\n        const { getInputsSnapshotAsync: snapshotProvider, debounceMs = 1000, rushConfiguration, projectsToWatch, terminal, initialSnapshot: initialState } = options;\n        this._debounceMs = debounceMs;\n        this._rushConfiguration = rushConfiguration;\n        this._projectsToWatch = projectsToWatch;\n        this._terminal = terminal;\n        const gitPath = new Git(rushConfiguration).getGitPathOrThrow();\n        this._repoRoot = Path.convertToSlashes(getRepoRoot(rushConfiguration.rushJsonFolder, gitPath));\n        this._initialSnapshot = initialState;\n        this._previousSnapshot = initialState;\n        this._renderedStatusLines = 0;\n        this._getPromptLines = undefined;\n        this._getInputsSnapshotAsync = snapshotProvider;\n    }\n    pause() {\n        this.isPaused = true;\n        this._setStatus('Project watcher paused.');\n    }\n    resume() {\n        this.isPaused = false;\n        this._setStatus('Project watcher resuming...');\n        if (this._resolveIfChanged) {\n            this._resolveIfChanged().catch(() => {\n                // Suppress unhandled promise rejection error\n            });\n        }\n    }\n    invalidateProject(project, reason) {\n        if (this._forceChangedProjects.has(project)) {\n            return false;\n        }\n        this._forceChangedProjects.set(project, reason);\n        return true;\n    }\n    invalidateAll(reason) {\n        for (const project of this._projectsToWatch) {\n            this.invalidateProject(project, reason);\n        }\n    }\n    clearStatus() {\n        this._renderedStatusLines = 0;\n    }\n    setPromptGenerator(promptGenerator) {\n        this._getPromptLines = promptGenerator;\n    }\n    /**\n     * Waits for a change to the package-deps of one or more of the selected projects, since the previous invocation.\n     * Will return immediately the first time it is invoked, since no state has been recorded.\n     * If no change is currently present, watches the source tree of all selected projects for file changes.\n     * `waitForChange` is not allowed to be called multiple times concurrently.\n     */\n    async waitForChangeAsync(onWatchingFiles) {\n        const initialChangeResult = await this._computeChangedAsync();\n        // Ensure that the new state is recorded so that we don't loop infinitely\n        this._commitChanges(initialChangeResult.inputsSnapshot);\n        if (initialChangeResult.changedProjects.size) {\n            // We can't call `clear()` here due to the async tick in the end of _computeChanged\n            for (const project of initialChangeResult.changedProjects) {\n                this._forceChangedProjects.delete(project);\n            }\n            // TODO: _forceChangedProjects might be non-empty here, which will result in an immediate rerun after the next\n            // run finishes. This is suboptimal, but the latency of _computeChanged is probably high enough that in practice\n            // all invalidations will have been picked up already.\n            return initialChangeResult;\n        }\n        const previousState = initialChangeResult.inputsSnapshot;\n        const repoRoot = Path.convertToSlashes(this._rushConfiguration.rushJsonFolder);\n        // Map of path to whether config for the path\n        const pathsToWatch = new Map();\n        // Node 12 supports the \"recursive\" parameter to fs.watch only on win32 and OSX\n        // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_caveats\n        const useNativeRecursiveWatch = os.platform() === 'win32' || os.platform() === 'darwin';\n        if (useNativeRecursiveWatch) {\n            // Watch the root non-recursively\n            pathsToWatch.set(repoRoot, { recurse: false });\n            // Watch the rush config folder non-recursively\n            pathsToWatch.set(Path.convertToSlashes(this._rushConfiguration.commonRushConfigFolder), {\n                recurse: false\n            });\n            for (const project of this._projectsToWatch) {\n                // Use recursive watch in individual project folders\n                pathsToWatch.set(Path.convertToSlashes(project.projectFolder), { recurse: true });\n            }\n        }\n        else {\n            for (const project of this._projectsToWatch) {\n                const projectState = previousState.getTrackedFileHashesForOperation(project);\n                const prefixLength = project.projectFolder.length - repoRoot.length - 1;\n                // Watch files in the root of the project, or\n                for (const pathToWatch of ProjectWatcher._enumeratePathsToWatch(projectState.keys(), prefixLength)) {\n                    pathsToWatch.set(`${this._repoRoot}/${pathToWatch}`, { recurse: true });\n                }\n            }\n        }\n        const watchers = new Map();\n        const watchedResult = await new Promise((resolve, reject) => {\n            let timeout;\n            let terminated = false;\n            const terminal = this._terminal;\n            const debounceMs = this._debounceMs;\n            this.clearStatus();\n            const resolveIfChanged = (this._resolveIfChanged = async () => {\n                timeout = undefined;\n                if (terminated) {\n                    return;\n                }\n                try {\n                    if (this.isPaused) {\n                        this._setStatus(`Project watcher paused.`);\n                        return;\n                    }\n                    this._setStatus(`Evaluating changes to tracked files...`);\n                    const result = await this._computeChangedAsync();\n                    this._setStatus(`Finished analyzing.`);\n                    // Need an async tick to allow for more file system events to be handled\n                    process.nextTick(() => {\n                        if (timeout) {\n                            // If another file has changed, wait for another pass.\n                            this._setStatus(`More file changes detected, aborting.`);\n                            return;\n                        }\n                        // Since there are multiple async ticks since the projects were enumerated in _computeChanged,\n                        // more could have been added in the interaval. Check and debounce.\n                        for (const project of this._forceChangedProjects.keys()) {\n                            if (!result.changedProjects.has(project)) {\n                                this._setStatus(`More invalidations occurred, aborting.`);\n                                timeout = setTimeout(resolveIfChanged, debounceMs);\n                                return;\n                            }\n                        }\n                        this._commitChanges(result.inputsSnapshot);\n                        const hasForcedChanges = this._forceChangedProjects.size > 0;\n                        if (hasForcedChanges) {\n                            this._setStatus(`Projects were invalidated: ${Array.from(new Set(this._forceChangedProjects.values())).join(', ')}`);\n                            this.clearStatus();\n                        }\n                        this._forceChangedProjects.clear();\n                        if (result.changedProjects.size) {\n                            terminated = true;\n                            terminal.writeLine();\n                            resolve(result);\n                        }\n                        else {\n                            this._setStatus(`No changes detected to tracked files.`);\n                        }\n                    });\n                }\n                catch (err) {\n                    // eslint-disable-next-line require-atomic-updates\n                    terminated = true;\n                    terminal.writeLine();\n                    reject(err);\n                }\n            });\n            for (const [pathToWatch, { recurse }] of pathsToWatch) {\n                addWatcher(pathToWatch, recurse);\n            }\n            if (onWatchingFiles) {\n                onWatchingFiles();\n            }\n            this._setStatus(`Waiting for changes...`);\n            function onError(err) {\n                if (terminated) {\n                    return;\n                }\n                terminated = true;\n                terminal.writeLine();\n                reject(err);\n            }\n            function addWatcher(watchedPath, recursive) {\n                if (watchers.has(watchedPath)) {\n                    return;\n                }\n                const listener = changeListener(watchedPath, recursive);\n                const watcher = fs.watch(watchedPath, {\n                    encoding: 'utf-8',\n                    recursive: recursive && useNativeRecursiveWatch\n                }, listener);\n                watchers.set(watchedPath, watcher);\n                watcher.on('error', (err) => {\n                    watchers.delete(watchedPath);\n                    onError(err);\n                });\n            }\n            function innerListener(root, recursive, event, fileName) {\n                try {\n                    if (terminated) {\n                        return;\n                    }\n                    if (fileName === '.git' || fileName === 'node_modules') {\n                        return;\n                    }\n                    // Handling for added directories\n                    if (recursive && !useNativeRecursiveWatch) {\n                        const decodedName = fileName ? fileName.toString() : '';\n                        const normalizedName = decodedName && Path.convertToSlashes(decodedName);\n                        const fullName = normalizedName && `${root}/${normalizedName}`;\n                        if (fullName && !watchers.has(fullName)) {\n                            try {\n                                const stat = FileSystem.getStatistics(fullName);\n                                if (stat.isDirectory()) {\n                                    addWatcher(fullName, true);\n                                }\n                            }\n                            catch (err) {\n                                const code = err.code;\n                                if (code !== 'ENOENT' && code !== 'ENOTDIR') {\n                                    throw err;\n                                }\n                            }\n                        }\n                    }\n                    // Use a timeout to debounce changes, e.g. bulk copying files into the directory while the watcher is running.\n                    if (timeout) {\n                        clearTimeout(timeout);\n                    }\n                    timeout = setTimeout(resolveIfChanged, debounceMs);\n                }\n                catch (err) {\n                    terminated = true;\n                    terminal.writeLine();\n                    reject(err);\n                }\n            }\n            function changeListener(root, recursive) {\n                return innerListener.bind(0, root, recursive);\n            }\n        }).finally(() => {\n            this._resolveIfChanged = undefined;\n        });\n        const closePromises = [];\n        for (const [watchedPath, watcher] of watchers) {\n            closePromises.push(once(watcher, 'close').then(() => {\n                watchers.delete(watchedPath);\n            }));\n            watcher.close();\n        }\n        await Promise.all(closePromises);\n        return watchedResult;\n    }\n    _setStatus(status) {\n        var _a, _b;\n        const statusLines = [\n            `[${this.isPaused ? 'PAUSED' : 'WATCHING'}] Watch Status: ${status}`,\n            ...((_b = (_a = this._getPromptLines) === null || _a === void 0 ? void 0 : _a.call(this, this.isPaused)) !== null && _b !== void 0 ? _b : [])\n        ];\n        if (this._renderedStatusLines > 0) {\n            readline.cursorTo(process.stdout, 0);\n            readline.moveCursor(process.stdout, 0, -this._renderedStatusLines);\n            readline.clearScreenDown(process.stdout);\n        }\n        this._renderedStatusLines = statusLines.length;\n        this._terminal.writeLine(Colorize.bold(Colorize.cyan(statusLines.join('\\n'))));\n    }\n    /**\n     * Determines which, if any, projects (within the selection) have new hashes for files that are not in .gitignore\n     */\n    async _computeChangedAsync() {\n        const currentSnapshot = await this._getInputsSnapshotAsync();\n        if (!currentSnapshot) {\n            throw new AlreadyReportedError();\n        }\n        const previousSnapshot = this._previousSnapshot;\n        if (!previousSnapshot) {\n            return {\n                changedProjects: this._projectsToWatch,\n                inputsSnapshot: currentSnapshot\n            };\n        }\n        const changedProjects = new Set();\n        for (const project of this._projectsToWatch) {\n            const previous = previousSnapshot.getTrackedFileHashesForOperation(project);\n            const current = currentSnapshot.getTrackedFileHashesForOperation(project);\n            if (ProjectWatcher._haveProjectDepsChanged(previous, current)) {\n                // May need to detect if the nature of the change will break the process, e.g. changes to package.json\n                changedProjects.add(project);\n            }\n        }\n        for (const project of this._forceChangedProjects.keys()) {\n            changedProjects.add(project);\n        }\n        return {\n            changedProjects,\n            inputsSnapshot: currentSnapshot\n        };\n    }\n    _commitChanges(state) {\n        this._previousSnapshot = state;\n        if (!this._initialSnapshot) {\n            this._initialSnapshot = state;\n        }\n    }\n    /**\n     * Tests for inequality of the passed Maps. Order invariant.\n     *\n     * @returns `true` if the maps are different, `false` otherwise\n     */\n    static _haveProjectDepsChanged(prev, next) {\n        if (!prev && !next) {\n            return false;\n        }\n        if (!prev || !next) {\n            return true;\n        }\n        if (prev.size !== next.size) {\n            return true;\n        }\n        for (const [key, value] of prev) {\n            if (next.get(key) !== value) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static *_enumeratePathsToWatch(paths, prefixLength) {\n        for (const path of paths) {\n            const rootSlashIndex = path.indexOf('/', prefixLength);\n            if (rootSlashIndex < 0) {\n                yield path;\n                return;\n            }\n            yield path.slice(0, rootSlashIndex);\n            let slashIndex = path.indexOf('/', rootSlashIndex + 1);\n            while (slashIndex >= 0) {\n                yield path.slice(0, slashIndex);\n                slashIndex = path.indexOf('/', slashIndex + 1);\n            }\n        }\n    }\n}\n//# sourceMappingURL=ProjectWatcher.js.map"],"names":[],"sourceRoot":""}