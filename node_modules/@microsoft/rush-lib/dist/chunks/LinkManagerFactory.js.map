{"version":3,"file":"chunks/LinkManagerFactory.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAC6B;AAC4C;AAC1B;AACO;AACA;AACwB;AAC7B;AACH;AACvC;AACP;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA,8BAA8B,yCAAY;AAC1C,QAAQ,oEAAU;AAClB;AACA,YAAY,mFAAwB;AACpC;AACA;AACA;AACA;AACA,yBAAyB,0CAAa,CAAC,oEAAU;AACjD;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAS;AACjB;AACA,YAAY,2DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA,iCAAiC,yCAAY;AAC7C;AACA,iBAAiB,oEAAU;AAC3B,gBAAgB,2DAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,2DAAS;AACrB,mCAAmC,oEAAU;AAC7C;AACA;AACA;AACA,uCAAuC,sCAAS;AAChD,qCAAqC,sCAAS;AAC9C,sCAAsC,oEAAU;AAChD;AACA,4CAA4C,oEAAU,eAAe,oEAAU;AAC/E;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,yCAAyC,oEAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,YAAY,2DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAQ;AACnC,0BAA0B,2DAAS;AACnC;AACA;AACA,kBAAkB,mDAAQ,sEAAsE,yDAAa,yBAAyB;AACtI;AACA;AACA,2BAA2B,yDAAQ,0CAA0C,qBAAqB;AAClG;AACA;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseLinkManager.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, InternalError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { Utilities } from '../../utilities/Utilities';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport { RushConstants } from '../RushConstants';\nimport { FlagFile } from '../../api/FlagFile';\nexport var SymlinkKind;\n(function (SymlinkKind) {\n    SymlinkKind[SymlinkKind[\"File\"] = 0] = \"File\";\n    SymlinkKind[SymlinkKind[\"Directory\"] = 1] = \"Directory\";\n})(SymlinkKind || (SymlinkKind = {}));\nexport class BaseLinkManager {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    static _createSymlink(options) {\n        const newLinkFolder = path.dirname(options.newLinkPath);\n        FileSystem.ensureFolder(newLinkFolder);\n        let targetPath;\n        if (EnvironmentConfiguration.absoluteSymlinks) {\n            targetPath = options.linkTargetPath;\n        }\n        else {\n            // Link to the relative path, to avoid going outside containers such as a Docker image\n            targetPath = path.relative(FileSystem.getRealPath(newLinkFolder), options.linkTargetPath);\n        }\n        if (process.platform === 'win32') {\n            if (options.symlinkKind === SymlinkKind.Directory) {\n                // For directories, we use a Windows \"junction\".  On Unix, this produces a regular symlink.\n                FileSystem.createSymbolicLinkJunction({\n                    linkTargetPath: targetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n            else {\n                // For files, we use a Windows \"hard link\", because creating a symbolic link requires\n                // administrator permission.\n                // NOTE: We cannot use the relative path for hard links\n                FileSystem.createHardLink({\n                    linkTargetPath: options.linkTargetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n        }\n        else {\n            // However hard links seem to cause build failures on Mac, so for all other operating systems\n            // we use symbolic links for this case.\n            if (options.symlinkKind === SymlinkKind.Directory) {\n                FileSystem.createSymbolicLinkFolder({\n                    linkTargetPath: targetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n            else {\n                FileSystem.createSymbolicLinkFile({\n                    linkTargetPath: targetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n        }\n    }\n    /**\n     * For a Package object that represents a top-level Rush project folder\n     * (i.e. with source code that we will be building), this clears out its\n     * node_modules folder and then recursively creates all the symlinked folders.\n     */\n    static _createSymlinksForTopLevelProject(localPackage) {\n        const localModuleFolder = path.join(localPackage.folderPath, 'node_modules');\n        // Sanity check\n        if (localPackage.parent) {\n            throw new Error('The provided package is not a top-level project');\n        }\n        // The root-level folder is the project itself, so we simply delete its node_modules\n        // to start clean\n        // eslint-disable-next-line no-console\n        console.log('Purging ' + localModuleFolder);\n        Utilities.dangerouslyDeletePath(localModuleFolder);\n        if (localPackage.children.length > 0) {\n            Utilities.createFolderWithRetry(localModuleFolder);\n            for (const child of localPackage.children) {\n                BaseLinkManager._createSymlinksForDependencies(child);\n            }\n        }\n    }\n    /**\n     * This is a helper function used by createSymlinksForTopLevelProject().\n     * It will recursively creates symlinked folders corresponding to each of the\n     * Package objects in the provided tree.\n     */\n    static _createSymlinksForDependencies(localPackage) {\n        const localModuleFolder = path.join(localPackage.folderPath, 'node_modules');\n        if (!localPackage.symlinkTargetFolderPath) {\n            throw new InternalError('localPackage.symlinkTargetFolderPath was not assigned');\n        }\n        // This is special case for when localPackage.name has the form '@scope/name',\n        // in which case we need to create the '@scope' folder first.\n        const parentFolderPath = path.dirname(localPackage.folderPath);\n        if (parentFolderPath && parentFolderPath !== localPackage.folderPath) {\n            if (!FileSystem.exists(parentFolderPath)) {\n                Utilities.createFolderWithRetry(parentFolderPath);\n            }\n        }\n        if (localPackage.children.length === 0) {\n            // If there are no children, then we can symlink the entire folder\n            BaseLinkManager._createSymlink({\n                linkTargetPath: localPackage.symlinkTargetFolderPath,\n                newLinkPath: localPackage.folderPath,\n                symlinkKind: SymlinkKind.Directory\n            });\n        }\n        else {\n            // If there are children, then we need to symlink each item in the folder individually\n            Utilities.createFolderWithRetry(localPackage.folderPath);\n            for (const filename of FileSystem.readFolderItemNames(localPackage.symlinkTargetFolderPath)) {\n                if (filename.toLowerCase() !== 'node_modules') {\n                    // Create the symlink\n                    let symlinkKind = SymlinkKind.File;\n                    const linkSource = path.join(localPackage.folderPath, filename);\n                    let linkTarget = path.join(localPackage.symlinkTargetFolderPath, filename);\n                    const linkStats = FileSystem.getLinkStatistics(linkTarget);\n                    if (linkStats.isSymbolicLink()) {\n                        const targetStats = FileSystem.getStatistics(FileSystem.getRealPath(linkTarget));\n                        if (targetStats.isDirectory()) {\n                            // Neither a junction nor a directory-symlink can have a directory-symlink\n                            // as its target; instead, we must obtain the real physical path.\n                            // A junction can link to another junction.  Unfortunately, the node 'fs' API\n                            // lacks the ability to distinguish between a junction and a directory-symlink\n                            // (even though it has the ability to create them both), so the safest policy\n                            // is to always make a junction and always to the real physical path.\n                            linkTarget = FileSystem.getRealPath(linkTarget);\n                            symlinkKind = SymlinkKind.Directory;\n                        }\n                    }\n                    else if (linkStats.isDirectory()) {\n                        symlinkKind = SymlinkKind.Directory;\n                    }\n                    BaseLinkManager._createSymlink({\n                        linkTargetPath: linkTarget,\n                        newLinkPath: linkSource,\n                        symlinkKind\n                    });\n                }\n            }\n        }\n        if (localPackage.children.length > 0) {\n            Utilities.createFolderWithRetry(localModuleFolder);\n            for (const child of localPackage.children) {\n                BaseLinkManager._createSymlinksForDependencies(child);\n            }\n        }\n    }\n    /**\n     * Creates node_modules symlinks for all Rush projects defined in the RushConfiguration.\n     * @param force - Normally the operation will be skipped if the links are already up to date;\n     *   if true, this option forces the links to be recreated.\n     */\n    async createSymlinksForProjectsAsync(force) {\n        // eslint-disable-next-line no-console\n        console.log('\\n' + Colorize.bold('Linking local projects'));\n        const stopwatch = Stopwatch.start();\n        await this._linkProjectsAsync();\n        // TODO: Remove when \"rush link\" and \"rush unlink\" are deprecated\n        await new FlagFile(this._rushConfiguration.defaultSubspace.getSubspaceTempFolderPath(), RushConstants.lastLinkFlagFilename, {}).createAsync();\n        stopwatch.stop();\n        // eslint-disable-next-line no-console\n        console.log('\\n' + Colorize.green(`Linking finished successfully. (${stopwatch.toString()})`));\n        // eslint-disable-next-line no-console\n        console.log('\\nNext you should probably run \"rush build\" or \"rush rebuild\"');\n    }\n}\n//# sourceMappingURL=BaseLinkManager.js.map"],"names":[],"sourceRoot":""}