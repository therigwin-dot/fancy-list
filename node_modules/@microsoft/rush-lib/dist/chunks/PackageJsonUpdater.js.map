{"version":3,"file":"chunks/PackageJsonUpdater.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACiC;AACiD;AAClB;AACgB;AAClC;AACK;AACO;AACoC;AAC9C;AACiB;AACT;AACxD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qCAAqC,wEAAuB;AAC5D,6BAA6B,yDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kFAAkF;AAClG,gBAAgB,qBAAqB,QAAQ,wHAEd;AAC/B;AACA,gBAAgB,iGAAiG;AACjH;AACA;AACA;AACA,qBAAqB,gFAAgF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAQ,yDAAyD,yDAAQ;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW,GAAG,QAAQ;AACjE;AACA,kFAAkF,oBAAoB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uGAA4B;AAC1E;AACA;AACA;AACA,gCAAgC,kEAAc;AAC9C;AACA;AACA;AACA;AACA,gCAAgC,kEAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yFAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yDAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD,qBAAqB,UAAU;AAC/B;AACA,yCAAyC,yDAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAQ;AACzC;AACA,iCAAiC,uDAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B,gBAAgB,qBAAqB,QAAQ,wHAEd;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0FAA0F;AAC1G;AACA;AACA,gBAAgB,iGAAiG;AACjH;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA;AACA,qCAAqC,yDAAQ,wCAAwC,YAAY,IAAI,yDAAQ;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY,GAAG,QAAQ;AAClE;AACA,kFAAkF,oBAAoB;AACtG;AACA;AACA;AACA;AACA;AACA,6BAA6B,uGAA4B;AACzD;AACA,gDAAgD,kEAAc,wBAAwB,kEAAc;AACpG;AACA;AACA;AACA;AACA;AACA,uCAAuC,yFAAqB;AAC5D;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA,6BAA6B,uGAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B,gBAAgB,6CAA6C;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,kEAAc;AAClF;AACA;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAQ,iDAAiD,YAAY;AACtG;AACA,oEAAoE,yDAAQ,mBAAmB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yDAAQ;AACjD,oBAAoB,yDAAQ;AAC5B,oBAAoB,yDAAQ,iBAAiB,YAAY;AACzD;AACA;AACA;AACA,yCAAyC,yDAAQ;AACjD,oBAAoB,yDAAQ;AAC5B,oBAAoB,yDAAQ,iBAAiB,YAAY,kDAAkD,yDAAa,wBAAwB;AAChJ;AACA;AACA;AACA;AACA;AACA,mEAAmE,yDAAQ,kCAAkC,SAAS,YAAY;AAClI;AACA;AACA;AACA;AACA,mEAAmE,yDAAQ,kCAAkC,SAAS,YAAY;AAClI,qEAAqE,yDAAa,wBAAwB;AAC1G;AACA;AACA;AACA,cAAc,0EAAc,iFAAiF,yDAAa;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAQ;AAC7C;AACA;AACA;AACA,oBAAoB,6CAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,YAAY;AAChF,+DAA+D,YAAY;AAC3E,4BAA4B,QAAQ,0EAA0E,YAAY;AAC1H,0EAA0E,YAAY;AACtF;AACA;AACA;AACA;AACA,mFAAmF,YAAY;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yDAAQ,eAAe,oBAAoB;AACpF;AACA,wBAAwB,6CAAgB;AACxC;AACA,mFAAmF,YAAY,IAAI,yDAAQ,eAAe;AAC1H;AACA;AACA;AACA;AACA,oEAAoE,YAAY;AAChF,mDAAmD,YAAY;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yDAAQ;AACrD;AACA;AACA,yFAAyF,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA,yCAAyC,2DAAS;AAClD;AACA;AACA,8DAA8D,yDAAQ,uBAAuB;AAC7F;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAW;AAChC;AACA;AACA;AACA;AACA,qBAAqB,kEAAW;AAChC;AACA;AACA;AACA,qBAAqB,kEAAW;AAChC;AACA;AACA;AACA,qBAAqB,kEAAW;AAChC;AACA;AACA;AACA,8DAA8D,WAAW;AACzE;AACA;AACA;AACA;AACA,iCAAiC,yDAAQ,4BAA4B,kBAAkB,SAAS,YAAY,GAAG,sBAAsB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+BAA+B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAa,kBAAkB,mCAAmC,yBAAyB;AACjH;AACA;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB;AAChE,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAW;AAClC;AACA,uBAAuB,kEAAW;AAClC;AACA,kFAAkF,QAAQ;AAC1F,uBAAuB,kEAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/PackageJsonUpdater.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { ConsoleTerminalProvider, Terminal, Colorize } from '@rushstack/terminal';\nimport { InstallManagerFactory } from './InstallManagerFactory';\nimport { VersionMismatchFinder } from './versionMismatch/VersionMismatchFinder';\nimport { PurgeManager } from './PurgeManager';\nimport { Utilities } from '../utilities/Utilities';\nimport { DependencyType } from '../api/PackageJsonEditor';\nimport { VersionMismatchFinderProject } from './versionMismatch/VersionMismatchFinderProject';\nimport { RushConstants } from './RushConstants';\nimport { InstallHelpers } from './installManager/InstallHelpers';\nimport { SemVerStyle } from './PackageJsonUpdaterTypes';\n/**\n * A helper class for managing the dependencies of various package.json files.\n * @internal\n */\nexport class PackageJsonUpdater {\n    constructor(rushConfiguration, rushGlobalFolder) {\n        this._rushConfiguration = rushConfiguration;\n        this._rushGlobalFolder = rushGlobalFolder;\n        this._terminalProvider = new ConsoleTerminalProvider();\n        this._terminal = new Terminal(this._terminalProvider);\n    }\n    /**\n     * Upgrade dependencies to a particular project, or across specified projects. This is the core business logic for\n     * \"rush upgrade-interactive\".\n     */\n    async doRushUpgradeAsync(options) {\n        const { projects, packagesToAdd, updateOtherPackages, skipUpdate, debugInstall, variant } = options;\n        const { DependencyAnalyzer } = await import(\n        /* webpackChunkName: 'DependencyAnalyzer' */\n        './DependencyAnalyzer');\n        const dependencyAnalyzer = DependencyAnalyzer.forRushConfiguration(this._rushConfiguration);\n        const { allVersionsByPackageName, implicitlyPreferredVersionByPackageName, commonVersionsConfiguration } = dependencyAnalyzer.getAnalysis(undefined, variant, false);\n        const dependenciesToUpdate = {};\n        const devDependenciesToUpdate = {};\n        const peerDependenciesToUpdate = {};\n        for (const { moduleName, latest: latestVersion, packageJson, devDependency, peerDependency } of packagesToAdd) {\n            const inferredRangeStyle = this._cheaplyDetectSemVerRangeStyle(packageJson);\n            const implicitlyPreferredVersion = implicitlyPreferredVersionByPackageName.get(moduleName);\n            const explicitlyPreferredVersion = commonVersionsConfiguration.preferredVersions.get(moduleName);\n            const version = await this._getNormalizedVersionSpecAsync(projects, moduleName, latestVersion, implicitlyPreferredVersion, explicitlyPreferredVersion, inferredRangeStyle, commonVersionsConfiguration.ensureConsistentVersions);\n            if (devDependency) {\n                devDependenciesToUpdate[moduleName] = version;\n            }\n            else if (peerDependency) {\n                peerDependenciesToUpdate[moduleName] = version;\n            }\n            else {\n                dependenciesToUpdate[moduleName] = version;\n            }\n            this._terminal.writeLine(Colorize.green(`Updating projects to use `) + moduleName + '@' + Colorize.cyan(version));\n            this._terminal.writeLine();\n            const existingSpecifiedVersions = allVersionsByPackageName.get(moduleName);\n            if (existingSpecifiedVersions &&\n                !existingSpecifiedVersions.has(version) &&\n                commonVersionsConfiguration.ensureConsistentVersions &&\n                !updateOtherPackages) {\n                // There are existing versions, and the version we're going to use is not one of them, and this repo\n                // requires consistent versions, and we aren't going to update other packages, so we can't proceed.\n                const existingVersionList = Array.from(existingSpecifiedVersions).join(', ');\n                throw new Error(`Adding '${moduleName}@${version}' ` +\n                    `causes mismatched dependencies. Use the \"--make-consistent\" flag to update other packages to use ` +\n                    `this version, or try specify one of the existing versions (${existingVersionList}).`);\n            }\n        }\n        const allPackageUpdates = new Map();\n        const allDependenciesToUpdate = [\n            ...Object.entries(dependenciesToUpdate),\n            ...Object.entries(devDependenciesToUpdate),\n            ...Object.entries(peerDependenciesToUpdate)\n        ];\n        for (const project of projects) {\n            const mismatchFinderProject = new VersionMismatchFinderProject(project);\n            const currentProjectDepUpdate = {\n                project: mismatchFinderProject,\n                dependenciesToAddOrUpdateOrRemove: dependenciesToUpdate,\n                dependencyType: DependencyType.Regular\n            };\n            const currentProjectDevDepUpdate = {\n                project: mismatchFinderProject,\n                dependenciesToAddOrUpdateOrRemove: devDependenciesToUpdate,\n                dependencyType: DependencyType.Dev\n            };\n            allPackageUpdates.set(mismatchFinderProject.filePath, mismatchFinderProject);\n            this.updateProject(currentProjectDepUpdate);\n            this.updateProject(currentProjectDevDepUpdate);\n        }\n        if (updateOtherPackages) {\n            const mismatchFinder = VersionMismatchFinder.getMismatches(this._rushConfiguration, options);\n            for (const update of this._getUpdates(mismatchFinder, allDependenciesToUpdate)) {\n                this.updateProject(update);\n                allPackageUpdates.set(update.project.filePath, update.project);\n            }\n        }\n        for (const [filePath, project] of allPackageUpdates) {\n            if (project.saveIfModified()) {\n                this._terminal.writeLine(Colorize.green('Wrote ') + filePath);\n            }\n        }\n        if (!skipUpdate) {\n            if (this._rushConfiguration.subspacesFeatureEnabled) {\n                const subspaceSet = this._rushConfiguration.getSubspacesForProjects(options.projects);\n                for (const subspace of subspaceSet) {\n                    await this._doUpdateAsync(debugInstall, subspace, variant);\n                }\n            }\n            else {\n                await this._doUpdateAsync(debugInstall, this._rushConfiguration.defaultSubspace, variant);\n            }\n        }\n    }\n    async doRushUpdateAsync(options) {\n        let allPackageUpdates = [];\n        if (options.actionName === 'add') {\n            allPackageUpdates = await this._doRushAddAsync(options);\n        }\n        else if (options.actionName === 'remove') {\n            allPackageUpdates = await this._doRushRemoveAsync(options);\n        }\n        else {\n            throw new Error('only accept \"rush add\" or \"rush remove\"');\n        }\n        const { skipUpdate, debugInstall, variant } = options;\n        for (const { project } of allPackageUpdates) {\n            if (project.saveIfModified()) {\n                this._terminal.writeLine(Colorize.green('Wrote'), project.filePath);\n            }\n        }\n        if (!skipUpdate) {\n            if (this._rushConfiguration.subspacesFeatureEnabled) {\n                const subspaceSet = this._rushConfiguration.getSubspacesForProjects(options.projects);\n                for (const subspace of subspaceSet) {\n                    await this._doUpdateAsync(debugInstall, subspace, variant);\n                }\n            }\n            else {\n                await this._doUpdateAsync(debugInstall, this._rushConfiguration.defaultSubspace, variant);\n            }\n        }\n    }\n    async _doUpdateAsync(debugInstall, subspace, variant) {\n        this._terminal.writeLine();\n        this._terminal.writeLine(Colorize.green('Running \"rush update\"'));\n        this._terminal.writeLine();\n        const purgeManager = new PurgeManager(this._rushConfiguration, this._rushGlobalFolder);\n        const installManagerOptions = {\n            debug: debugInstall,\n            allowShrinkwrapUpdates: true,\n            bypassPolicy: false,\n            noLink: false,\n            fullUpgrade: false,\n            recheckShrinkwrap: false,\n            networkConcurrency: undefined,\n            offline: false,\n            collectLogFile: false,\n            variant,\n            maxInstallAttempts: RushConstants.defaultMaxInstallAttempts,\n            pnpmFilterArgumentValues: [],\n            selectedProjects: new Set(this._rushConfiguration.projects),\n            checkOnly: false,\n            subspace: subspace,\n            terminal: this._terminal\n        };\n        const installManager = await InstallManagerFactory.getInstallManagerAsync(this._rushConfiguration, this._rushGlobalFolder, purgeManager, installManagerOptions);\n        try {\n            await installManager.doInstallAsync();\n        }\n        finally {\n            await purgeManager.startDeleteAllAsync();\n        }\n    }\n    /**\n     * Adds a dependency to a particular project. The core business logic for \"rush add\".\n     */\n    async _doRushAddAsync(options) {\n        const { projects } = options;\n        const { DependencyAnalyzer } = await import(\n        /* webpackChunkName: 'DependencyAnalyzer' */\n        './DependencyAnalyzer');\n        const dependencyAnalyzer = DependencyAnalyzer.forRushConfiguration(this._rushConfiguration);\n        const allPackageUpdates = [];\n        const subspaceSet = this._rushConfiguration.getSubspacesForProjects(projects);\n        for (const subspace of subspaceSet) {\n            // Projects for this subspace\n            allPackageUpdates.push(...(await this._updateProjectsAsync(subspace, dependencyAnalyzer, options)));\n        }\n        return allPackageUpdates;\n    }\n    async _updateProjectsAsync(subspace, dependencyAnalyzer, options) {\n        const { projects, packagesToUpdate, devDependency, peerDependency, updateOtherPackages, variant } = options;\n        // Get projects for this subspace\n        const subspaceProjects = projects.filter((project) => project.subspace === subspace);\n        const { allVersionsByPackageName, implicitlyPreferredVersionByPackageName, commonVersionsConfiguration } = dependencyAnalyzer.getAnalysis(subspace, variant, options.actionName === 'add');\n        this._terminal.writeLine();\n        const dependenciesToAddOrUpdate = {};\n        for (const { packageName, version: initialVersion, rangeStyle } of packagesToUpdate) {\n            const implicitlyPreferredVersion = implicitlyPreferredVersionByPackageName.get(packageName);\n            const explicitlyPreferredVersion = commonVersionsConfiguration.preferredVersions.get(packageName);\n            const version = await this._getNormalizedVersionSpecAsync(subspaceProjects, packageName, initialVersion, implicitlyPreferredVersion, explicitlyPreferredVersion, rangeStyle, commonVersionsConfiguration.ensureConsistentVersions);\n            dependenciesToAddOrUpdate[packageName] = version;\n            this._terminal.writeLine(Colorize.green('Updating projects to use '), `${packageName}@`, Colorize.cyan(version));\n            this._terminal.writeLine();\n            const existingSpecifiedVersions = allVersionsByPackageName.get(packageName);\n            if (existingSpecifiedVersions &&\n                !existingSpecifiedVersions.has(version) &&\n                commonVersionsConfiguration.ensureConsistentVersions &&\n                !updateOtherPackages) {\n                // There are existing versions, and the version we're going to use is not one of them, and this repo\n                // requires consistent versions, and we aren't going to update other packages, so we can't proceed.\n                const existingVersionList = Array.from(existingSpecifiedVersions).join(', ');\n                throw new Error(`Adding '${packageName}@${version}' ` +\n                    `causes mismatched dependencies. Use the \"--make-consistent\" flag to update other packages to use ` +\n                    `this version, or try specify one of the existing versions (${existingVersionList}).`);\n            }\n        }\n        const allPackageUpdates = [];\n        for (const project of subspaceProjects) {\n            const currentProjectUpdate = {\n                project: new VersionMismatchFinderProject(project),\n                dependenciesToAddOrUpdateOrRemove: dependenciesToAddOrUpdate,\n                dependencyType: devDependency ? DependencyType.Dev : peerDependency ? DependencyType.Peer : undefined\n            };\n            this.updateProject(currentProjectUpdate);\n            let otherPackageUpdates = [];\n            // we need to do a mismatch check\n            if (updateOtherPackages) {\n                const mismatchFinder = VersionMismatchFinder.getMismatches(this._rushConfiguration, {\n                    subspace,\n                    variant\n                });\n                otherPackageUpdates = this._getUpdates(mismatchFinder, Object.entries(dependenciesToAddOrUpdate));\n            }\n            this.updateProjects(otherPackageUpdates);\n            allPackageUpdates.push(currentProjectUpdate, ...otherPackageUpdates);\n        }\n        return allPackageUpdates;\n    }\n    _getUpdates(mismatchFinder, dependenciesToUpdate) {\n        const result = [];\n        const { mismatches } = mismatchFinder;\n        for (const [packageName, version] of dependenciesToUpdate) {\n            const projectsByVersion = mismatches.get(packageName);\n            if (projectsByVersion) {\n                for (const consumers of projectsByVersion.values()) {\n                    for (const consumer of consumers) {\n                        result.push({\n                            project: consumer,\n                            dependenciesToAddOrUpdateOrRemove: {\n                                [packageName]: version\n                            }\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Remove a dependency from a particular project. The core business logic for \"rush remove\".\n     */\n    async _doRushRemoveAsync(options) {\n        const { projects, packagesToUpdate } = options;\n        this._terminal.writeLine();\n        const dependenciesToRemove = {};\n        const allPackageUpdates = [];\n        for (const project of projects) {\n            for (const { packageName } of packagesToUpdate) {\n                dependenciesToRemove[packageName] = '';\n            }\n            const currentProjectUpdate = {\n                project: new VersionMismatchFinderProject(project),\n                dependenciesToAddOrUpdateOrRemove: dependenciesToRemove\n            };\n            this.removePackageFromProject(currentProjectUpdate);\n            allPackageUpdates.push(currentProjectUpdate);\n        }\n        return allPackageUpdates;\n    }\n    /**\n     * Updates several projects' package.json files\n     */\n    updateProjects(projectUpdates) {\n        for (const update of projectUpdates) {\n            this.updateProject(update);\n        }\n    }\n    /**\n     * Updates a single project's package.json file\n     */\n    updateProject(options) {\n        let { dependencyType } = options;\n        const { project, dependenciesToAddOrUpdateOrRemove } = options;\n        for (const [packageName, newVersion] of Object.entries(dependenciesToAddOrUpdateOrRemove)) {\n            const oldDependency = project.tryGetDependency(packageName);\n            const oldDevDependency = project.tryGetDevDependency(packageName);\n            const oldDependencyType = oldDevDependency\n                ? oldDevDependency.dependencyType\n                : oldDependency\n                    ? oldDependency.dependencyType\n                    : undefined;\n            dependencyType = dependencyType || oldDependencyType || DependencyType.Regular;\n            project.addOrUpdateDependency(packageName, newVersion, dependencyType);\n        }\n    }\n    removePackageFromProject(options) {\n        const { project, dependenciesToAddOrUpdateOrRemove } = options;\n        for (const packageName of Object.keys(dependenciesToAddOrUpdateOrRemove)) {\n            const packageJsonDependencies = [\n                project.tryGetDependency(packageName),\n                project.tryGetDevDependency(packageName)\n            ];\n            for (const packageJsonDependency of packageJsonDependencies) {\n                if (!packageJsonDependency) {\n                    continue;\n                }\n                project.removeDependency(packageName, packageJsonDependency.dependencyType);\n            }\n        }\n    }\n    /**\n     * Selects an appropriate version number for a particular package, given an optional initial SemVer spec.\n     * If ensureConsistentVersions, tries to pick a version that will be consistent.\n     * Otherwise, will choose the latest semver matching the initialSpec and append the proper range style.\n     * @param projects - the projects which will have their package.json's updated\n     * @param packageName - the name of the package to be used\n     * @param initialSpec - a semver pattern that should be used to find the latest version matching the spec\n     * @param implicitlyPreferredVersion - the implicitly preferred (aka common/primary) version of the package in use\n     * @param rangeStyle - if this version is selected by querying registry, then this range specifier is prepended to\n     *   the selected version.\n     */\n    async _getNormalizedVersionSpecAsync(projects, packageName, initialSpec, implicitlyPreferredVersion, explicitlyPreferredVersion, rangeStyle, ensureConsistentVersions) {\n        this._terminal.writeLine(Colorize.gray(`Determining new version for dependency: ${packageName}`));\n        if (initialSpec) {\n            this._terminal.writeLine(`Specified version selector: ${Colorize.cyan(initialSpec)}`);\n        }\n        else {\n            this._terminal.writeLine(`No version selector was specified, so the version will be determined automatically.`);\n        }\n        this._terminal.writeLine();\n        // if ensureConsistentVersions => reuse the pinned version\n        // else, query the registry and use the latest that satisfies semver spec\n        if (initialSpec) {\n            if (initialSpec === implicitlyPreferredVersion) {\n                this._terminal.writeLine(Colorize.green('Assigning \"') +\n                    Colorize.cyan(initialSpec) +\n                    Colorize.green(`\" for \"${packageName}\" because it matches what other projects are using in this repo.`));\n                return initialSpec;\n            }\n            if (initialSpec === explicitlyPreferredVersion) {\n                this._terminal.writeLine(Colorize.green('Assigning \"') +\n                    Colorize.cyan(initialSpec) +\n                    Colorize.green(`\" for \"${packageName}\" because it is the preferred version listed in ${RushConstants.commonVersionsFilename}.`));\n                return initialSpec;\n            }\n        }\n        if (ensureConsistentVersions && !initialSpec) {\n            if (implicitlyPreferredVersion) {\n                this._terminal.writeLine(`Assigning the version \"${Colorize.cyan(implicitlyPreferredVersion)}\" for \"${packageName}\" ` +\n                    'because it is already used by other projects in this repo.');\n                return implicitlyPreferredVersion;\n            }\n            if (explicitlyPreferredVersion) {\n                this._terminal.writeLine(`Assigning the version \"${Colorize.cyan(explicitlyPreferredVersion)}\" for \"${packageName}\" ` +\n                    `because it is the preferred version listed in ${RushConstants.commonVersionsFilename}.`);\n                return explicitlyPreferredVersion;\n            }\n        }\n        await InstallHelpers.ensureLocalPackageManagerAsync(this._rushConfiguration, this._rushGlobalFolder, RushConstants.defaultMaxInstallAttempts);\n        const useWorkspaces = !!(this._rushConfiguration.pnpmOptions && this._rushConfiguration.pnpmOptions.useWorkspaces);\n        const workspacePrefix = 'workspace:';\n        // Trim 'workspace:' notation from the spec, since we're going to be tweaking the range\n        if (useWorkspaces && initialSpec && initialSpec.startsWith(workspacePrefix)) {\n            initialSpec = initialSpec.substring(workspacePrefix.length).trim();\n        }\n        // determine if the package is a project in the local repository and if the version exists\n        const localProject = this._tryGetLocalProject(packageName, projects);\n        let selectedVersion;\n        let selectedVersionPrefix = '';\n        if (initialSpec && initialSpec !== 'latest') {\n            this._terminal.writeLine(Colorize.gray('Finding versions that satisfy the selector: ') + initialSpec);\n            this._terminal.writeLine();\n            if (localProject !== undefined) {\n                const version = localProject.packageJson.version;\n                if (semver.satisfies(version, initialSpec)) {\n                    // For workspaces, assume that specifying the exact version means you always want to consume\n                    // the local project. Otherwise, use the exact local package version\n                    if (useWorkspaces) {\n                        selectedVersion = initialSpec === version ? '*' : initialSpec;\n                        selectedVersionPrefix = workspacePrefix;\n                    }\n                    else {\n                        selectedVersion = version;\n                    }\n                }\n                else {\n                    throw new Error(`The dependency being added (\"${packageName}\") is a project in the local Rush repository, ` +\n                        `but the version specifier provided (${initialSpec}) does not match the local project's version ` +\n                        `(${version}). Correct the version specifier, omit a version specifier, or include \"${packageName}\" as a ` +\n                        `cyclicDependencyProject if it is intended for \"${packageName}\" to come from an external feed and not ` +\n                        'from the local Rush repository.');\n                }\n            }\n            else {\n                this._terminal.writeLine(`Querying registry for all versions of \"${packageName}\"...`);\n                let commandArgs;\n                if (this._rushConfiguration.packageManager === 'yarn') {\n                    commandArgs = ['info', packageName, 'versions', '--json'];\n                }\n                else {\n                    commandArgs = ['view', packageName, 'versions', '--json'];\n                }\n                const allVersions = await Utilities.executeCommandAndCaptureOutputAsync(this._rushConfiguration.packageManagerToolFilename, commandArgs, this._rushConfiguration.commonTempFolder);\n                let versionList;\n                if (this._rushConfiguration.packageManager === 'yarn') {\n                    versionList = JSON.parse(allVersions).data;\n                }\n                else {\n                    versionList = JSON.parse(allVersions);\n                }\n                this._terminal.writeLine(Colorize.gray(`Found ${versionList.length} available versions.`));\n                for (const version of versionList) {\n                    if (semver.satisfies(version, initialSpec)) {\n                        selectedVersion = initialSpec;\n                        this._terminal.writeLine(`Found a version that satisfies ${initialSpec}: ${Colorize.cyan(version)}`);\n                        break;\n                    }\n                }\n                if (!selectedVersion) {\n                    throw new Error(`Unable to find a version of \"${packageName}\" that satisfies` +\n                        ` the version specifier \"${initialSpec}\"`);\n                }\n            }\n        }\n        else {\n            if (localProject !== undefined) {\n                // For workspaces, assume that no specified version range means you always want to consume\n                // the local project. Otherwise, use the exact local package version\n                if (useWorkspaces) {\n                    selectedVersion = '*';\n                    selectedVersionPrefix = workspacePrefix;\n                }\n                else {\n                    selectedVersion = localProject.packageJson.version;\n                }\n            }\n            else {\n                if (!this._rushConfiguration.ensureConsistentVersions) {\n                    this._terminal.writeLine(Colorize.gray(`The \"ensureConsistentVersions\" policy is NOT active, so we will assign the latest version.`));\n                    this._terminal.writeLine();\n                }\n                this._terminal.writeLine(`Querying NPM registry for latest version of \"${packageName}\"...`);\n                let commandArgs;\n                if (this._rushConfiguration.packageManager === 'yarn') {\n                    commandArgs = ['info', packageName, 'dist-tags.latest', '--silent'];\n                }\n                else {\n                    commandArgs = ['view', `${packageName}@latest`, 'version'];\n                }\n                selectedVersion = (await Utilities.executeCommandAndCaptureOutputAsync(this._rushConfiguration.packageManagerToolFilename, commandArgs, this._rushConfiguration.commonTempFolder)).trim();\n            }\n            this._terminal.writeLine();\n            this._terminal.writeLine(`Found latest version: ${Colorize.cyan(selectedVersion)}`);\n        }\n        this._terminal.writeLine();\n        let reasonForModification = '';\n        if (selectedVersion !== '*') {\n            switch (rangeStyle) {\n                case SemVerStyle.Caret: {\n                    selectedVersionPrefix += '^';\n                    reasonForModification = ' because the \"--caret\" flag was specified';\n                    break;\n                }\n                case SemVerStyle.Exact: {\n                    reasonForModification = ' because the \"--exact\" flag was specified';\n                    break;\n                }\n                case SemVerStyle.Tilde: {\n                    selectedVersionPrefix += '~';\n                    break;\n                }\n                case SemVerStyle.Passthrough: {\n                    break;\n                }\n                default: {\n                    throw new Error(`Unexpected SemVerStyle ${rangeStyle}.`);\n                }\n            }\n        }\n        const normalizedVersion = selectedVersionPrefix + selectedVersion;\n        this._terminal.writeLine(Colorize.gray(`Assigning version \"${normalizedVersion}\" for \"${packageName}\"${reasonForModification}.`));\n        return normalizedVersion;\n    }\n    _collectAllDownstreamDependencies(project) {\n        const allProjectDownstreamDependencies = new Set();\n        const collectDependencies = (rushProject) => {\n            for (const downstreamDependencyProject of rushProject.downstreamDependencyProjects) {\n                const foundProject = this._rushConfiguration.projectsByName.get(downstreamDependencyProject);\n                if (!foundProject) {\n                    continue;\n                }\n                if (foundProject.decoupledLocalDependencies.has(rushProject.packageName)) {\n                    continue;\n                }\n                if (!allProjectDownstreamDependencies.has(foundProject)) {\n                    allProjectDownstreamDependencies.add(foundProject);\n                    collectDependencies(foundProject);\n                }\n            }\n        };\n        collectDependencies(project);\n        return allProjectDownstreamDependencies;\n    }\n    /**\n     * Given a package name, this function returns a {@see RushConfigurationProject} if the package is a project\n     * in the local Rush repo and is not marked as cyclic for any of the projects.\n     *\n     * @remarks\n     * This function throws an error if adding the discovered local project as a dependency\n     * would create a dependency cycle, or if it would be added to multiple projects.\n     */\n    _tryGetLocalProject(packageName, projects) {\n        const foundProject = this._rushConfiguration.projectsByName.get(packageName);\n        if (foundProject === undefined) {\n            return undefined;\n        }\n        if (projects.length > 1) {\n            throw new Error(`\"rush add\" does not support adding a local project as a dependency to multiple projects at once.`);\n        }\n        const project = projects[0];\n        if (project.decoupledLocalDependencies.has(foundProject.packageName)) {\n            return undefined;\n        }\n        // Are we attempting to add this project to itself?\n        if (project === foundProject) {\n            throw new Error('Unable to add a project as a dependency of itself unless the dependency is listed as a cyclic dependency ' +\n                `in ${RushConstants.rushJsonFilename}. This command attempted to add \"${foundProject.packageName}\" ` +\n                `as a dependency of itself.`);\n        }\n        // Are we attempting to create a cycle?\n        const downstreamDependencies = this._collectAllDownstreamDependencies(project);\n        if (downstreamDependencies.has(foundProject)) {\n            throw new Error(`Adding \"${foundProject.packageName}\" as a direct or indirect dependency of ` +\n                `\"${project.packageName}\" would create a dependency cycle.`);\n        }\n        return foundProject;\n    }\n    _cheaplyDetectSemVerRangeStyle(version) {\n        // create a swtich statement to detect the first character of the version string and determine the range style\n        // TODO: This is a temporary solution until we have a better way to detect more complext range styles\n        // TODO: Should we handle/care about peerDependencies?\n        switch (version[0]) {\n            case '~':\n                return SemVerStyle.Tilde;\n            case '^':\n                return SemVerStyle.Caret;\n            default:\n                this._terminal.writeLine(`No SemVer range detected for version: ${version}. The exact version will be set in package.json.`);\n                return SemVerStyle.Exact;\n        }\n    }\n    _normalizeDepsToUpgrade(deps) {\n        return deps.map((dep) => {\n            return {\n                packageName: dep.moduleName,\n                version: dep.latest,\n                rangeStyle: this._cheaplyDetectSemVerRangeStyle(dep.packageJson)\n            };\n        });\n    }\n}\n//# sourceMappingURL=PackageJsonUpdater.js.map"],"names":[],"sourceRoot":""}