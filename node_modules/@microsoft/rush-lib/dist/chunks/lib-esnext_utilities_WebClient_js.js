"use strict";
exports.id = "lib-esnext_utilities_WebClient_js";
exports.ids = ["lib-esnext_utilities_WebClient_js"];
exports.modules = {

/***/ 182127:
/*!*******************************************!*\
  !*** ./lib-esnext/utilities/WebClient.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AUTHORIZATION_HEADER_NAME: () => (/* binding */ AUTHORIZATION_HEADER_NAME),
/* harmony export */   WebClient: () => (/* binding */ WebClient),
/* harmony export */   WebClientProxy: () => (/* binding */ WebClientProxy)
/* harmony export */ });
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ 370857);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! process */ 400932);
/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:http */ 937067);
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_http__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:https */ 344708);
/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(node_https__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @rushstack/node-core-library */ 277275);
/* harmony import */ var _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.





const createHttpsProxyAgent = _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.Import.lazy('https-proxy-agent', require);
/**
 * For use with {@link WebClient}.
 */
var WebClientProxy;
(function (WebClientProxy) {
    WebClientProxy[WebClientProxy["None"] = 0] = "None";
    WebClientProxy[WebClientProxy["Detect"] = 1] = "Detect";
    WebClientProxy[WebClientProxy["Fiddler"] = 2] = "Fiddler";
})(WebClientProxy || (WebClientProxy = {}));
const DEFLATE_ENCODING = 'deflate';
const GZIP_ENCODING = 'gzip';
const BROTLI_ENCODING = 'br';
const AUTHORIZATION_HEADER_NAME = 'Authorization';
const ACCEPT_HEADER_NAME = 'accept';
const USER_AGENT_HEADER_NAME = 'user-agent';
const CONTENT_ENCODING_HEADER_NAME = 'content-encoding';
const makeRequestAsync = async (url, options, redirected = false) => {
    const { body, redirect, noDecode } = options;
    return await new Promise((resolve, reject) => {
        const parsedUrl = typeof url === 'string' ? new URL(url) : url;
        const requestFunction = parsedUrl.protocol === 'https:' ? node_https__WEBPACK_IMPORTED_MODULE_3__.request : node_http__WEBPACK_IMPORTED_MODULE_2__.request;
        requestFunction(url, options, (response) => {
            const responseBuffers = [];
            response.on('data', (chunk) => {
                responseBuffers.push(Buffer.from(chunk));
            });
            response.on('end', () => {
                // Handle retries by calling the method recursively with the redirect URL
                const statusCode = response.statusCode;
                if (statusCode === 301 || statusCode === 302) {
                    switch (redirect) {
                        case 'follow': {
                            const redirectUrl = response.headers.location;
                            if (redirectUrl) {
                                makeRequestAsync(redirectUrl, options, true).then(resolve).catch(reject);
                            }
                            else {
                                reject(new Error(`Received status code ${response.statusCode} with no location header: ${url}`));
                            }
                            break;
                        }
                        case 'error':
                            reject(new Error(`Received status code ${response.statusCode}: ${url}`));
                            return;
                    }
                }
                const responseData = Buffer.concat(responseBuffers);
                const status = response.statusCode || 0;
                const statusText = response.statusMessage;
                const headers = response.headers;
                let bodyString;
                let bodyJson;
                let decodedBuffer;
                const result = {
                    ok: status >= 200 && status < 300,
                    status,
                    statusText,
                    redirected,
                    headers,
                    getTextAsync: async () => {
                        if (bodyString === undefined) {
                            const buffer = await result.getBufferAsync();
                            // eslint-disable-next-line require-atomic-updates
                            bodyString = buffer.toString();
                        }
                        return bodyString;
                    },
                    getJsonAsync: async () => {
                        if (bodyJson === undefined) {
                            const text = await result.getTextAsync();
                            // eslint-disable-next-line require-atomic-updates
                            bodyJson = JSON.parse(text);
                        }
                        return bodyJson;
                    },
                    getBufferAsync: async () => {
                        // Determine if the buffer is compressed and decode it if necessary
                        if (decodedBuffer === undefined) {
                            let encodings = headers[CONTENT_ENCODING_HEADER_NAME];
                            if (!noDecode && encodings !== undefined) {
                                const zlib = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! zlib */ 443106, 23));
                                if (!Array.isArray(encodings)) {
                                    encodings = encodings.split(',');
                                }
                                let buffer = responseData;
                                for (const encoding of encodings) {
                                    let decompressFn;
                                    switch (encoding.trim()) {
                                        case DEFLATE_ENCODING: {
                                            decompressFn = zlib.inflate.bind(zlib);
                                            break;
                                        }
                                        case GZIP_ENCODING: {
                                            decompressFn = zlib.gunzip.bind(zlib);
                                            break;
                                        }
                                        case BROTLI_ENCODING: {
                                            decompressFn = zlib.brotliDecompress.bind(zlib);
                                            break;
                                        }
                                        default: {
                                            throw new Error(`Unsupported content-encoding: ${encodings}`);
                                        }
                                    }
                                    buffer = await _rushstack_node_core_library__WEBPACK_IMPORTED_MODULE_4__.LegacyAdapters.convertCallbackToPromise(decompressFn, buffer);
                                }
                                // eslint-disable-next-line require-atomic-updates
                                decodedBuffer = buffer;
                            }
                            else {
                                decodedBuffer = responseData;
                            }
                        }
                        return decodedBuffer;
                    }
                };
                resolve(result);
            });
        })
            .on('error', (error) => {
            reject(error);
        })
            .end(body);
    });
};
/**
 * A helper for issuing HTTP requests.
 */
class WebClient {
    constructor() {
        this.standardHeaders = {};
        this.accept = '*/*';
        this.userAgent = `rush node/${process__WEBPACK_IMPORTED_MODULE_1__.version} ${os__WEBPACK_IMPORTED_MODULE_0__.platform()} ${os__WEBPACK_IMPORTED_MODULE_0__.arch()}`;
        this.proxy = WebClientProxy.Detect;
    }
    static mockRequestFn(fn) {
        WebClient._requestFn = fn;
    }
    static resetMockRequestFn() {
        WebClient._requestFn = makeRequestAsync;
    }
    static mergeHeaders(target, source) {
        for (const [name, value] of Object.entries(source)) {
            target[name] = value;
        }
    }
    addBasicAuthHeader(userName, password) {
        this.standardHeaders[AUTHORIZATION_HEADER_NAME] =
            'Basic ' + Buffer.from(userName + ':' + password).toString('base64');
    }
    async fetchAsync(url, options) {
        var _a;
        const { headers: optionsHeaders, timeoutMs = 15 * 1000, verb, redirect, body, noDecode } = (_a = options) !== null && _a !== void 0 ? _a : {};
        const headers = {};
        WebClient.mergeHeaders(headers, this.standardHeaders);
        if (optionsHeaders) {
            WebClient.mergeHeaders(headers, optionsHeaders);
        }
        if (this.userAgent) {
            headers[USER_AGENT_HEADER_NAME] = this.userAgent;
        }
        if (this.accept) {
            headers[ACCEPT_HEADER_NAME] = this.accept;
        }
        let proxyUrl = '';
        switch (this.proxy) {
            case WebClientProxy.Detect:
                if (process__WEBPACK_IMPORTED_MODULE_1__.env.HTTPS_PROXY) {
                    proxyUrl = process__WEBPACK_IMPORTED_MODULE_1__.env.HTTPS_PROXY;
                }
                else if (process__WEBPACK_IMPORTED_MODULE_1__.env.HTTP_PROXY) {
                    proxyUrl = process__WEBPACK_IMPORTED_MODULE_1__.env.HTTP_PROXY;
                }
                break;
            case WebClientProxy.Fiddler:
                // For debugging, disable cert validation
                // eslint-disable-next-line
                process__WEBPACK_IMPORTED_MODULE_1__.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                proxyUrl = 'http://localhost:8888/';
                break;
        }
        let agent = undefined;
        if (proxyUrl) {
            agent = createHttpsProxyAgent(proxyUrl);
        }
        const requestInit = {
            method: verb,
            headers,
            agent,
            timeout: timeoutMs,
            redirect,
            body,
            noDecode
        };
        return await WebClient._requestFn(url, requestInit);
    }
}
WebClient._requestFn = makeRequestAsync;
//# sourceMappingURL=WebClient.js.map

/***/ })

};
;
//# sourceMappingURL=lib-esnext_utilities_WebClient_js.js.map