{"version":3,"file":"chunks/ConsoleTimelinePlugin.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AAC+D;AACX;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,6DAAe;AACpB,KAAK,6DAAe;AACpB,KAAK,6DAAe;AACpB,KAAK,6DAAe;AACpB,KAAK,6DAAe;AACpB,KAAK,6DAAe;AACpB,KAAK,6DAAe;AACpB,KAAK,6DAAe;AACpB,KAAK,6DAAe;AACpB,KAAK,6DAAe;AACpB,KAAK,6DAAe;AACpB;AACA;AACA,IAAI,6DAAe;AACnB,IAAI,6DAAe;AACnB,IAAI,6DAAe;AACnB,IAAI,6DAAe;AACnB;AACA;AACA;AACA;AACA;AACA,KAAK,6DAAe,WAAW,yDAAQ;AACvC,KAAK,6DAAe,SAAS,yDAAQ;AACrC,KAAK,6DAAe,UAAU,yDAAQ;AACtC,KAAK,6DAAe,aAAa,yDAAQ;AACzC,KAAK,6DAAe,WAAW,yDAAQ;AACvC,KAAK,6DAAe,sBAAsB,yDAAQ;AAClD,KAAK,6DAAe,WAAW,yDAAQ;AACvC,KAAK,6DAAe,WAAW,yDAAQ;AACvC,KAAK,6DAAe,WAAW,yDAAQ;AACvC,KAAK,6DAAe,aAAa,yDAAQ;AACzC,KAAK,6DAAe,QAAQ,yDAAQ;AACpC;AACA;AACA;AACA;AACA;AACO,0BAA0B,wCAAwC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAmD;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAQ;AAC9B;AACA,YAAY,yDAAQ;AACpB,8BAA8B,yDAAQ,yCAAyC,EAAE,OAAO,EAAE,yDAAQ,6DAA6D;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C,uBAAuB,8BAA8B;AACrD,iCAAiC,SAAS;AAC1C,iCAAiC,+CAA+C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAQ,0CAA0C,EAAE,oBAAoB;AAC5G;AACA;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ConsoleTimelinePlugin.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Colorize, PrintUtilities } from '@rushstack/terminal';\nimport { OperationStatus } from './OperationStatus';\nconst PLUGIN_NAME = 'ConsoleTimelinePlugin';\n/* Sample output:\n==============================================================================================================================\n          @rushstack/tree-pattern (build) ###########-------------------------------------------------------------------- 3.3s\n          @rushstack/eslint-patch (build) ########----------------------------------------------------------------------- 2.2s\n           @rushstack/eslint-patch (test) -------%----------------------------------------------------------------------- 0.0s\n@rushstack/eslint-plugin-security (build) ----------########################--------------------------------------------- 6.8s\n@rushstack/eslint-plugin-packlets (build) ----------############################----------------------------------------- 8.1s\n         @rushstack/eslint-plugin (build) ----------##############################--------------------------------------- 8.7s\n           @rushstack/tree-pattern (test) ----------#####---------------------------------------------------------------- 1.2s\n @rushstack/eslint-plugin-security (test) ---------------------------------############---------------------------------- 3.3s\n @rushstack/eslint-plugin-packlets (test) -------------------------------------#####------------------------------------- 1.1s\n         @rushstack/eslint-config (build) ---------------------------------------%--------------------------------------- 0.0s\n          @rushstack/eslint-plugin (test) ---------------------------------------#############--------------------------- 3.8s\n          @rushstack/eslint-config (test) ---------------------------------------%--------------------------------------- 0.0s\n     @rushstack/node-core-library (build) ---------------------------------------################################-------- 9.5s\n      @rushstack/node-core-library (test) ----------------------------------------------------------------------######### 2.2s\n==============================================================================================================================\nLEGEND:                                                                                                      Total Work: 50.3s\n  [#] Success  [!] Failed/warnings  [%] Skipped/cached/no-op                                                 Wall Clock: 23.7s\n                                                                                                       Max Parallelism Used: 5\n                                                                                                     Avg Parallelism Used: 2.1\nBY PHASE:\n      _phase:build 38.6s\n       _phase:test 11.7s\n*/\n/**\n * Phased command plugin that emits a timeline to the console.\n */\nexport class ConsoleTimelinePlugin {\n    constructor(terminal) {\n        this._terminal = terminal;\n    }\n    apply(hooks) {\n        hooks.afterExecuteOperations.tap(PLUGIN_NAME, (result, context) => {\n            _printTimeline({\n                terminal: this._terminal,\n                result,\n                cobuildConfiguration: context.cobuildConfiguration\n            });\n        });\n    }\n}\n/**\n * Timeline - a wider column width for printing the timeline summary\n */\nconst TIMELINE_WIDTH = 109;\n/**\n * Timeline - symbols representing each operation status\n */\nconst TIMELINE_CHART_SYMBOLS = {\n    [OperationStatus.Waiting]: '?',\n    [OperationStatus.Ready]: '?',\n    [OperationStatus.Queued]: '?',\n    [OperationStatus.Executing]: '?',\n    [OperationStatus.Success]: '#',\n    [OperationStatus.SuccessWithWarning]: '!',\n    [OperationStatus.Failure]: '!',\n    [OperationStatus.Blocked]: '.',\n    [OperationStatus.Skipped]: '%',\n    [OperationStatus.FromCache]: '%',\n    [OperationStatus.NoOp]: '%'\n};\nconst COBUILD_REPORTABLE_STATUSES = new Set([\n    OperationStatus.Success,\n    OperationStatus.SuccessWithWarning,\n    OperationStatus.Failure,\n    OperationStatus.Blocked\n]);\n/**\n * Timeline - colorizer for each operation status\n */\nconst TIMELINE_CHART_COLORIZER = {\n    [OperationStatus.Waiting]: Colorize.yellow,\n    [OperationStatus.Ready]: Colorize.yellow,\n    [OperationStatus.Queued]: Colorize.yellow,\n    [OperationStatus.Executing]: Colorize.yellow,\n    [OperationStatus.Success]: Colorize.green,\n    [OperationStatus.SuccessWithWarning]: Colorize.yellow,\n    [OperationStatus.Failure]: Colorize.red,\n    [OperationStatus.Blocked]: Colorize.red,\n    [OperationStatus.Skipped]: Colorize.green,\n    [OperationStatus.FromCache]: Colorize.green,\n    [OperationStatus.NoOp]: Colorize.gray\n};\n/**\n * Print a more detailed timeline and analysis of CPU usage for the build.\n * @internal\n */\nexport function _printTimeline({ terminal, result, cobuildConfiguration }) {\n    //\n    // Gather the operation records we'll be displaying. Do some inline max()\n    // finding to reduce the number of times we need to loop through operations.\n    //\n    var _a;\n    const durationByPhase = new Map();\n    const data = [];\n    let longestNameLength = 0;\n    let longestDurationLength = 0;\n    let allStart = Infinity;\n    let allEnd = -Infinity;\n    let workDuration = 0;\n    for (const [operation, operationResult] of result.operationResults) {\n        if (operationResult.silent) {\n            continue;\n        }\n        const { stopwatch } = operationResult;\n        const { startTime, endTime } = stopwatch;\n        if (startTime && endTime) {\n            const nameLength = ((_a = operation.name) === null || _a === void 0 ? void 0 : _a.length) || 0;\n            if (nameLength > longestNameLength) {\n                longestNameLength = nameLength;\n            }\n            const { duration } = stopwatch;\n            const durationString = duration.toFixed(1);\n            const durationLength = durationString.length;\n            if (durationLength > longestDurationLength) {\n                longestDurationLength = durationLength;\n            }\n            if (endTime > allEnd) {\n                allEnd = endTime;\n            }\n            if (startTime < allStart) {\n                allStart = startTime;\n            }\n            workDuration += duration;\n            const { associatedPhase } = operation;\n            if (associatedPhase) {\n                durationByPhase.set(associatedPhase, (durationByPhase.get(associatedPhase) || 0) + duration);\n            }\n            data.push({\n                startTime,\n                endTime,\n                durationString,\n                name: operation.name,\n                status: operationResult.status,\n                isExecuteByOtherCobuildRunner: !!operationResult.cobuildRunnerId &&\n                    operationResult.cobuildRunnerId !== (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildRunnerId)\n            });\n        }\n    }\n    data.sort((a, b) => a.startTime - b.startTime);\n    //\n    // Determine timing for all tasks (wall clock and execution times)\n    //\n    const allDuration = allEnd - allStart;\n    const allDurationSeconds = allDuration / 1000;\n    //\n    // Do some calculations to determine what size timeline chart we need.\n    //\n    const maxWidth = PrintUtilities.getConsoleWidth() || TIMELINE_WIDTH;\n    const chartWidth = maxWidth - longestNameLength - longestDurationLength - 4;\n    //\n    // Loop through all operations, assembling some statistics about operations and\n    // phases, if applicable.\n    //\n    const busyCpus = [];\n    function getOpenCPU(time) {\n        const len = busyCpus.length;\n        for (let i = 0; i < len; i++) {\n            if (busyCpus[i] <= time) {\n                return i;\n            }\n        }\n        return len;\n    }\n    // Start with a newline\n    terminal.writeLine('');\n    terminal.writeLine('='.repeat(maxWidth));\n    let hasCobuildSymbol = false;\n    function getChartSymbol(record) {\n        const { isExecuteByOtherCobuildRunner, status } = record;\n        if (isExecuteByOtherCobuildRunner && COBUILD_REPORTABLE_STATUSES.has(status)) {\n            hasCobuildSymbol = true;\n            return 'C';\n        }\n        return TIMELINE_CHART_SYMBOLS[status];\n    }\n    for (const record of data) {\n        const { startTime, endTime, durationString, name, status } = record;\n        // Track busy CPUs\n        const openCpu = getOpenCPU(startTime);\n        busyCpus[openCpu] = endTime;\n        // Build timeline chart\n        const startIdx = Math.floor(((startTime - allStart) * chartWidth) / allDuration);\n        const endIdx = Math.floor(((endTime - allStart) * chartWidth) / allDuration);\n        const length = endIdx - startIdx + 1;\n        const chart = Colorize.gray('-'.repeat(startIdx)) +\n            TIMELINE_CHART_COLORIZER[status](getChartSymbol(record).repeat(length)) +\n            Colorize.gray('-'.repeat(chartWidth - endIdx));\n        terminal.writeLine(`${Colorize.cyan(name.padStart(longestNameLength))} ${chart} ${Colorize.white(durationString.padStart(longestDurationLength) + 's')}`);\n    }\n    terminal.writeLine('='.repeat(maxWidth));\n    //\n    // Format legend and summary areas\n    //\n    const usedCpus = busyCpus.length;\n    const legend = [\n        'LEGEND:',\n        '  [#] Success  [!] Failed/warnings  [%] Skipped/cached/no-op',\n        '',\n        ''\n    ];\n    if (hasCobuildSymbol) {\n        legend[2] = '  [C] Cobuild';\n    }\n    const summary = [\n        `Total Work: ${workDuration.toFixed(1)}s`,\n        `Wall Clock: ${allDurationSeconds.toFixed(1)}s`,\n        `Max Parallelism Used: ${usedCpus}`,\n        `Avg Parallelism Used: ${(workDuration / allDurationSeconds).toFixed(1)}`\n    ];\n    terminal.writeLine(legend[0] + summary[0].padStart(maxWidth - legend[0].length));\n    terminal.writeLine(legend[1] + summary[1].padStart(maxWidth - legend[1].length));\n    terminal.writeLine(legend[2] + summary[2].padStart(maxWidth - legend[2].length));\n    terminal.writeLine(legend[3] + summary[3].padStart(maxWidth - legend[3].length));\n    //\n    // Include time-by-phase, if phases are enabled\n    //\n    if (durationByPhase.size > 0) {\n        terminal.writeLine('BY PHASE:');\n        let maxPhaseName = 16;\n        for (const phase of durationByPhase.keys()) {\n            const len = phase.name.length;\n            if (len > maxPhaseName) {\n                maxPhaseName = len;\n            }\n        }\n        for (const [phase, duration] of durationByPhase.entries()) {\n            terminal.writeLine(`  ${Colorize.cyan(phase.name.padStart(maxPhaseName))} ${duration.toFixed(1)}s`);\n        }\n    }\n    terminal.writeLine('');\n}\n//# sourceMappingURL=ConsoleTimelinePlugin.js.map"],"names":[],"sourceRoot":""}