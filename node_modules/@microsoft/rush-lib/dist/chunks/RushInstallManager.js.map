{"version":3,"file":"chunks/RushInstallManager.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACwF;AAC7D;AACE;AACmB;AAChD;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAU,cAAc,yCAAY;AAC5C;AACA;AACA,QAAQ,oEAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uEAAa,WAAW,uEAAa,aAAa,uEAAa;AAC9G;AACA;AACA;AACA;AACA;AACA,QAAQ,uCAAU,cAAc,uEAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS,6CAA6C,yDAAa,gCAAgC,gCAAgC;AAClJ;AACA;AACA;AACA,eAAe,sCAAS,6CAA6C,yDAAa;AAClF;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACyB;AACI;AACI;AACJ;AACuG;AACrE;AACC;AACf;AACK;AACA;AACO;AACyB;AACpC;AACO;AACE;AAC3D,mBAAmB,mBAAO,CAAC,yBAAa,GAAG;AAC3C;AACA;AACA;AACO,iCAAiC,wEAAkB;AAC1D;AACA;AACA,sCAAsC,iEAAiB;AACvD;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAS;AACnC,gBAAgB,uBAAuB;AACvC;AACA,mCAAmC,sCAAS,0CAA0C,yDAAa;AACnG;AACA,2BAA2B,yDAAQ;AACnC,QAAQ,4DAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAQ;AAChC;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sEAAmB;AACnE;AACA,mEAAmE,WAAW,KAAK,QAAQ;AAC3F,wBAAwB,yDAAa;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6CAA6C,cAAc,gBAAgB;AAC/H,kDAAkD,yDAAa,kBAAkB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAI;AACZ;AACA;AACA;AACA;AACA;AACA,0EAA0E,yDAAa,4BAA4B,GAAG,oCAAoC;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mEAAc;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAI;AAChB;AACA,gDAAgD,sEAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,mEAAmE,YAAY,KAAK,eAAe,iBAAiB,wBAAwB;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sCAAS,oBAAoB,uEAAa;AACtF;AACA;AACA;AACA;AACA,oBAAoB,oEAAU,wBAAwB,oEAAU;AAChE;AACA,sCAAsC,oEAAU;AAChD,kDAAkD,kEAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAS;AAC7B;AACA;AACA;AACA,oBAAoB,oEAAU;AAC9B,oBAAoB,oEAAU;AAC9B;AACA,oBAAoB,kEAAQ;AAC5B;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA,gCAAgC,yDAAQ;AACxC;AACA,oBAAoB,oEAAU;AAC9B,oBAAoB,oEAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,wBAAwB;AACpI;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ,YAAY,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAS;AAC/C;AACA,sBAAsB,oEAAU;AAChC;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAc;AACtB;AACA;AACA,4DAA4D,qBAAqB;AACjF,iBAAiB;AACjB;AACA;AACA,8BAA8B,sEAAmB;AACjD,wCAAwC,0EAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa,mDAAmD,sBAAsB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,4CAAe,CAAC,gDAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,eAAe,4DAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAc;AAChD,wCAAwC,sCAAS,0CAA0C,yDAAa;AACxG;AACA,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uCAAuC;AACnF,+BAA+B,wCAAwC;AACvE;AACA;AACA,0BAA0B,4DAAS;AACnC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oDAAoD,sCAAS,0BAA0B,yDAAa;AACpG;AACA,4CAA4C,wBAAwB;AACpE;AACA,8DAA8D,8DAAI;AAClE,4BAA4B,gBAAgB,QAAQ,mHAAmB;AACvE;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,sCAAS;AACrD,gBAAgB,oEAAU;AAC1B;AACA;AACA,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAQ,kBAAkB,uCAAuC;AAC7E,oBAAoB,wCAAwC;AAC5D;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAQ;AACxB,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA,cAAc,4DAAS;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,yDAAQ;AACpC;AACA;AACA;AACA;AACA,gBAAgB,4DAAS;AACzB;AACA,SAAS;AACT;AACA;AACA,+BAA+B,yDAAQ;AACvC;AACA;AACA,kBAAkB,4DAAS;AAC3B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAkB;AAClD;AACA;AACA;AACA;AACA,+BAA+B,yDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sCAAS,0DAA0D,yDAAa;AACxH;AACA,kDAAkD,8DAAI;AACtD;AACA,gBAAgB,gBAAgB,QAAQ,mHAAmB;AAC3D;AACA;AACA;AACA;AACA,sCAAsC,kEAAQ;AAC9C;AACA;AACA,gBAAgB,kEAAQ,4CAA4C,qBAAqB;AACzF;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAQ,QAAQ,+DAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ,QAAQ,+DAAc,mBAAmB,6CAA6C,0BAA0B,wBAAwB;AACpK;AACA,6BAA6B;AAC7B;AACA;AACA,sBAAsB;AACtB;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/TempProjectHelper.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/installManager/RushInstallManager.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileConstants, FileSystem, PosixModeBits } from '@rushstack/node-core-library';\nimport * as tar from 'tar';\nimport * as path from 'path';\nimport { RushConstants } from './RushConstants';\n// The PosixModeBits are intended to be used with bitwise operations.\n/* eslint-disable no-bitwise */\nexport class TempProjectHelper {\n    constructor(rushConfiguration, subspace) {\n        this._rushConfiguration = rushConfiguration;\n        this._subspace = subspace;\n    }\n    /**\n     * Deletes the existing tarball and creates a tarball for the given rush project\n     */\n    createTempProjectTarball(rushProject) {\n        FileSystem.ensureFolder(path.resolve(this._subspace.getSubspaceTempFolderPath(), 'projects'));\n        const tarballFile = this.getTarballFilePath(rushProject);\n        const tempProjectFolder = this.getTempProjectFolder(rushProject);\n        FileSystem.deleteFile(tarballFile);\n        // NPM expects the root of the tarball to have a directory called 'package'\n        const npmPackageFolder = 'package';\n        const tarOptions = {\n            gzip: true,\n            file: tarballFile,\n            cwd: tempProjectFolder,\n            portable: true,\n            noMtime: true,\n            noPax: true,\n            sync: true,\n            prefix: npmPackageFolder,\n            filter: (tarPath, stat) => {\n                if (!this._rushConfiguration.experimentsConfiguration.configuration.noChmodFieldInTarHeaderNormalization) {\n                    stat.mode =\n                        (stat.mode & ~0x1ff) | PosixModeBits.AllRead | PosixModeBits.UserWrite | PosixModeBits.AllExecute;\n                }\n                return true;\n            }\n        };\n        // create the new tarball\n        tar.create(tarOptions, [FileConstants.PackageJson]);\n    }\n    /**\n     * Gets the path to the tarball\n     * Example: \"C:\\MyRepo\\common\\temp\\projects\\my-project-2.tgz\"\n     */\n    getTarballFilePath(project) {\n        return path.join(this._subspace.getSubspaceTempFolderPath(), RushConstants.rushTempProjectsFolderName, `${project.unscopedTempProjectName}.tgz`);\n    }\n    getTempProjectFolder(rushProject) {\n        const unscopedTempProjectName = rushProject.unscopedTempProjectName;\n        return path.join(this._subspace.getSubspaceTempFolderPath(), RushConstants.rushTempProjectsFolderName, unscopedTempProjectName);\n    }\n}\n//# sourceMappingURL=TempProjectHelper.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport * as ssri from 'ssri';\nimport { JsonFile, Text, FileSystem, FileConstants, Sort, InternalError, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Colorize, PrintUtilities } from '@rushstack/terminal';\nimport { BaseInstallManager } from '../base/BaseInstallManager';\nimport { RushConstants } from '../RushConstants';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { Utilities } from '../../utilities/Utilities';\nimport { DependencyType } from '../../api/PackageJsonEditor';\nimport { DependencySpecifier, DependencySpecifierType } from '../DependencySpecifier';\nimport { InstallHelpers } from './InstallHelpers';\nimport { TempProjectHelper } from '../TempProjectHelper';\nimport { LinkManagerFactory } from '../LinkManagerFactory';\nconst globEscape = require('glob-escape'); // No @types/glob-escape package exists\n/**\n * This class implements common logic between \"rush install\" and \"rush update\".\n */\nexport class RushInstallManager extends BaseInstallManager {\n    constructor(rushConfiguration, rushGlobalFolder, purgeManager, options) {\n        super(rushConfiguration, rushGlobalFolder, purgeManager, options);\n        this._tempProjectHelper = new TempProjectHelper(this.rushConfiguration, rushConfiguration.defaultSubspace);\n    }\n    /**\n     * Regenerates the common/package.json and all temp_modules projects.\n     * If shrinkwrapFile is provided, this function also validates whether it contains\n     * everything we need to install and returns true if so; in all other cases,\n     * the return value is false.\n     *\n     * @override\n     */\n    async prepareCommonTempAsync(subspace, shrinkwrapFile) {\n        const stopwatch = Stopwatch.start();\n        const { fullUpgrade, variant } = this.options;\n        // Example: \"C:\\MyRepo\\common\\temp\\projects\"\n        const tempProjectsFolder = path.join(this.rushConfiguration.commonTempFolder, RushConstants.rushTempProjectsFolderName);\n        // eslint-disable-next-line no-console\n        console.log('\\n' + Colorize.bold('Updating temp projects in ' + tempProjectsFolder));\n        Utilities.createFolderWithRetry(tempProjectsFolder);\n        const shrinkwrapWarnings = [];\n        // We will start with the assumption that it's valid, and then set it to false if\n        // any of the checks fail\n        let shrinkwrapIsUpToDate = true;\n        if (!shrinkwrapFile) {\n            shrinkwrapIsUpToDate = false;\n        }\n        else if (shrinkwrapFile.isWorkspaceCompatible && !fullUpgrade) {\n            // eslint-disable-next-line no-console\n            console.log();\n            // eslint-disable-next-line no-console\n            console.log(Colorize.red('The shrinkwrap file had previously been updated to support workspaces. Run \"rush update --full\" ' +\n                'to update the shrinkwrap file.'));\n            throw new AlreadyReportedError();\n        }\n        // dependency name --> version specifier\n        const allExplicitPreferredVersions = this.rushConfiguration.defaultSubspace\n            .getCommonVersions(variant)\n            .getAllPreferredVersions();\n        if (shrinkwrapFile) {\n            // Check any (explicitly) preferred dependencies first\n            allExplicitPreferredVersions.forEach((version, dependency) => {\n                const dependencySpecifier = new DependencySpecifier(dependency, version);\n                if (!shrinkwrapFile.hasCompatibleTopLevelDependency(dependencySpecifier)) {\n                    shrinkwrapWarnings.push(`Missing dependency \"${dependency}\" (${version}) required by the preferred versions from ` +\n                        RushConstants.commonVersionsFilename);\n                    shrinkwrapIsUpToDate = false;\n                }\n            });\n            if (this._findMissingTempProjects(shrinkwrapFile)) {\n                // If any Rush project's tarball is missing from the shrinkwrap file, then we need to update\n                // the shrinkwrap file.\n                shrinkwrapIsUpToDate = false;\n            }\n            // If there are orphaned projects, we need to update\n            const orphanedProjects = shrinkwrapFile.findOrphanedProjects(this.rushConfiguration, this.rushConfiguration.defaultSubspace);\n            if (orphanedProjects.length > 0) {\n                for (const orphanedProject of orphanedProjects) {\n                    shrinkwrapWarnings.push(`Your ${this.rushConfiguration.shrinkwrapFilePhrase} references \"${orphanedProject}\" ` +\n                        `which was not found in ${RushConstants.rushJsonFilename}`);\n                }\n                shrinkwrapIsUpToDate = false;\n            }\n        }\n        // dependency name --> version specifier\n        const commonDependencies = new Map([\n            ...allExplicitPreferredVersions,\n            ...this.rushConfiguration.getImplicitlyPreferredVersions(subspace, variant)\n        ]);\n        // To make the common/package.json file more readable, sort alphabetically\n        // according to rushProject.tempProjectName instead of packageName.\n        const sortedRushProjects = this.rushConfiguration.projects.slice(0);\n        Sort.sortBy(sortedRushProjects, (x) => x.tempProjectName);\n        for (const rushProject of sortedRushProjects) {\n            const packageJson = rushProject.packageJsonEditor;\n            // Example: \"C:\\MyRepo\\common\\temp\\projects\\my-project-2.tgz\"\n            const tarballFile = this._tempProjectHelper.getTarballFilePath(rushProject);\n            // Example: dependencies[\"@rush-temp/my-project-2\"] = \"file:./projects/my-project-2.tgz\"\n            commonDependencies.set(rushProject.tempProjectName, `file:./${RushConstants.rushTempProjectsFolderName}/${rushProject.unscopedTempProjectName}.tgz`);\n            const tempPackageJson = {\n                name: rushProject.tempProjectName,\n                version: '0.0.0',\n                private: true,\n                dependencies: {}\n            };\n            // Collect pairs of (packageName, packageVersion) to be added as dependencies of the @rush-temp package.json\n            const tempDependencies = new Map();\n            // These can be regular, optional, or peer dependencies (but NOT dev dependencies).\n            // (A given packageName will never appear more than once in this list.)\n            for (const dependency of packageJson.dependencyList) {\n                if (this.options.fullUpgrade && this._revertWorkspaceNotation(dependency)) {\n                    shrinkwrapIsUpToDate = false;\n                }\n                // If there are any optional dependencies, copy directly into the optionalDependencies field.\n                if (dependency.dependencyType === DependencyType.Optional) {\n                    if (!tempPackageJson.optionalDependencies) {\n                        tempPackageJson.optionalDependencies = {};\n                    }\n                    tempPackageJson.optionalDependencies[dependency.name] = dependency.version;\n                }\n                else {\n                    tempDependencies.set(dependency.name, dependency.version);\n                }\n            }\n            for (const dependency of packageJson.devDependencyList) {\n                if (this.options.fullUpgrade && this._revertWorkspaceNotation(dependency)) {\n                    shrinkwrapIsUpToDate = false;\n                }\n                // If there are devDependencies, we need to merge them with the regular dependencies.  If the same\n                // library appears in both places, then the dev dependency wins (because presumably it's saying what you\n                // want right now for development, not the range that you support for consumers).\n                tempDependencies.set(dependency.name, dependency.version);\n            }\n            Sort.sortMapKeys(tempDependencies);\n            for (const [packageName, packageVersion] of tempDependencies.entries()) {\n                const dependencySpecifier = new DependencySpecifier(packageName, packageVersion);\n                // Is there a locally built Rush project that could satisfy this dependency?\n                // If so, then we will symlink to the project folder rather than to common/temp/node_modules.\n                // In this case, we don't want \"npm install\" to process this package, but we do need\n                // to record this decision for linking later, so we add it to a special 'rushDependencies' field.\n                const localProject = this.rushConfiguration.getProjectByName(packageName);\n                if (localProject) {\n                    // Don't locally link if it's listed in the decoupledLocalDependencies\n                    if (!rushProject.decoupledLocalDependencies.has(packageName)) {\n                        // Also, don't locally link if the SemVer doesn't match\n                        const localProjectVersion = localProject.packageJsonEditor.version;\n                        if (semver.satisfies(localProjectVersion, packageVersion)) {\n                            // We will locally link this package, so instead add it to our special \"rushDependencies\"\n                            // field in the package.json file.\n                            if (!tempPackageJson.rushDependencies) {\n                                tempPackageJson.rushDependencies = {};\n                            }\n                            tempPackageJson.rushDependencies[packageName] = packageVersion;\n                            continue;\n                        }\n                    }\n                }\n                // We will NOT locally link this package; add it as a regular dependency.\n                tempPackageJson.dependencies[packageName] = packageVersion;\n                if (shrinkwrapFile &&\n                    !shrinkwrapFile.tryEnsureCompatibleDependency(dependencySpecifier, rushProject.tempProjectName)) {\n                    shrinkwrapWarnings.push(`Missing dependency \"${packageName}\" (${packageVersion}) required by \"${rushProject.packageName}\"`);\n                    shrinkwrapIsUpToDate = false;\n                }\n            }\n            if (this.rushConfiguration.packageManager === 'yarn') {\n                // This feature is only implemented by the Yarn package manager\n                if (packageJson.resolutionsList.length > 0) {\n                    tempPackageJson.resolutions = packageJson.saveToObject().resolutions;\n                }\n            }\n            // Example: \"C:\\MyRepo\\common\\temp\\projects\\my-project-2\"\n            const tempProjectFolder = this._tempProjectHelper.getTempProjectFolder(rushProject);\n            // Example: \"C:\\MyRepo\\common\\temp\\projects\\my-project-2\\package.json\"\n            const tempPackageJsonFilename = path.join(tempProjectFolder, FileConstants.PackageJson);\n            // we only want to overwrite the package if the existing tarball's package.json is different from tempPackageJson\n            let shouldOverwrite = true;\n            try {\n                // if the tarball and the temp file still exist, then compare the contents\n                if (FileSystem.exists(tarballFile) && FileSystem.exists(tempPackageJsonFilename)) {\n                    // compare the extracted package.json with the one we are about to write\n                    const oldBuffer = FileSystem.readFileToBuffer(tempPackageJsonFilename);\n                    const newBuffer = Buffer.from(JsonFile.stringify(tempPackageJson));\n                    if (Buffer.compare(oldBuffer, newBuffer) === 0) {\n                        shouldOverwrite = false;\n                    }\n                }\n            }\n            catch (error) {\n                // ignore the error, we will go ahead and create a new tarball\n            }\n            if (shouldOverwrite) {\n                try {\n                    // ensure the folder we are about to zip exists\n                    Utilities.createFolderWithRetry(tempProjectFolder);\n                    // remove the old tarball & old temp package json, this is for any cases where new tarball creation\n                    // fails, and the shouldOverwrite logic is messed up because the my-project-2\\package.json\n                    // exists and is updated, but the tarball is not accurate\n                    FileSystem.deleteFile(tarballFile);\n                    FileSystem.deleteFile(tempPackageJsonFilename);\n                    // write the expected package.json file into the zip staging folder\n                    JsonFile.save(tempPackageJson, tempPackageJsonFilename);\n                    // Delete the existing tarball and create a new one\n                    this._tempProjectHelper.createTempProjectTarball(rushProject);\n                    // eslint-disable-next-line no-console\n                    console.log(`Updating ${tarballFile}`);\n                }\n                catch (error) {\n                    // eslint-disable-next-line no-console\n                    console.log(Colorize.yellow(error));\n                    // delete everything in case of any error\n                    FileSystem.deleteFile(tarballFile);\n                    FileSystem.deleteFile(tempPackageJsonFilename);\n                }\n            }\n            // When using frozen shrinkwrap, we need to validate that the tarball integrities are up-to-date\n            // with the shrinkwrap file, since these will cause install to fail.\n            if (shrinkwrapFile &&\n                this.rushConfiguration.isPnpm &&\n                this.rushConfiguration.experimentsConfiguration.configuration.usePnpmFrozenLockfileForRushInstall) {\n                const pnpmShrinkwrapFile = shrinkwrapFile;\n                const tarballIntegrityValid = await this._validateRushProjectTarballIntegrityAsync(pnpmShrinkwrapFile, rushProject);\n                if (!tarballIntegrityValid) {\n                    shrinkwrapIsUpToDate = false;\n                    shrinkwrapWarnings.push(`Invalid or missing tarball integrity hash in shrinkwrap for \"${rushProject.packageName}\"`);\n                }\n            }\n            // Save the package.json if we modified the version references and warn that the package.json was modified\n            if (packageJson.saveIfModified()) {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.yellow(`\"${rushProject.packageName}\" depends on one or more local packages which used \"workspace:\" ` +\n                    'notation. The package.json has been modified and must be committed to source control.'));\n            }\n        }\n        // Remove the workspace file if it exists\n        if (this.rushConfiguration.isPnpm) {\n            const workspaceFilePath = path.join(this.rushConfiguration.commonTempFolder, 'pnpm-workspace.yaml');\n            try {\n                await FileSystem.deleteFileAsync(workspaceFilePath);\n            }\n            catch (e) {\n                if (!FileSystem.isNotExistError(e)) {\n                    throw e;\n                }\n            }\n        }\n        // Write the common package.json\n        InstallHelpers.generateCommonPackageJson(this.rushConfiguration, this.rushConfiguration.defaultSubspace, commonDependencies, this._terminal);\n        stopwatch.stop();\n        // eslint-disable-next-line no-console\n        console.log(`Finished creating temporary modules (${stopwatch.toString()})`);\n        return { shrinkwrapIsUpToDate, shrinkwrapWarnings };\n    }\n    _revertWorkspaceNotation(dependency) {\n        const specifier = new DependencySpecifier(dependency.name, dependency.version);\n        if (specifier.specifierType !== DependencySpecifierType.Workspace) {\n            return false;\n        }\n        // Replace workspace notation with the supplied version range\n        if (specifier.versionSpecifier === '*') {\n            // When converting to workspaces, exact package versions are replaced with a '*', so undo this\n            const localProject = this.rushConfiguration.getProjectByName(specifier.packageName);\n            if (!localProject) {\n                throw new InternalError(`Could not find local project with package name ${specifier.packageName}`);\n            }\n            dependency.setVersion(localProject.packageJson.version);\n        }\n        else {\n            dependency.setVersion(specifier.versionSpecifier);\n        }\n        return true;\n    }\n    async _validateRushProjectTarballIntegrityAsync(shrinkwrapFile, rushProject) {\n        if (shrinkwrapFile) {\n            const tempProjectDependencyKey = shrinkwrapFile.getTempProjectDependencyKey(rushProject.tempProjectName);\n            if (!tempProjectDependencyKey) {\n                return false;\n            }\n            const parentShrinkwrapEntry = shrinkwrapFile.getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey);\n            const newIntegrity = (await ssri.fromStream(fs.createReadStream(this._tempProjectHelper.getTarballFilePath(rushProject)))).toString();\n            if (!parentShrinkwrapEntry.resolution || parentShrinkwrapEntry.resolution.integrity !== newIntegrity) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Check whether or not the install is already valid, and therefore can be skipped.\n     *\n     * @override\n     */\n    async canSkipInstallAsync(lastModifiedDate, subspace, variant) {\n        if (!(await super.canSkipInstallAsync(lastModifiedDate, subspace, variant))) {\n            return false;\n        }\n        const potentiallyChangedFiles = [];\n        // Also consider timestamps for all the temp tarballs. (createTempModulesAndCheckShrinkwrap() will\n        // carefully preserve these timestamps unless something has changed.)\n        // Example: \"C:\\MyRepo\\common\\temp\\projects\\my-project-2.tgz\"\n        potentiallyChangedFiles.push(...this.rushConfiguration.projects.map((x) => {\n            return this._tempProjectHelper.getTarballFilePath(x);\n        }));\n        return Utilities.isFileTimestampCurrentAsync(lastModifiedDate, potentiallyChangedFiles);\n    }\n    /**\n     * Runs \"npm/pnpm/yarn install\" in the \"common/temp\" folder.\n     *\n     * @override\n     */\n    async installAsync(cleanInstall, subspace) {\n        // Since we are actually running npm/pnpm/yarn install, recreate all the temp project tarballs.\n        // This ensures that any existing tarballs with older header bits will be regenerated.\n        // It is safe to assume that temp project pacakge.jsons already exist.\n        for (const rushProject of this.rushConfiguration.projects) {\n            this._tempProjectHelper.createTempProjectTarball(rushProject);\n        }\n        // NOTE: The PNPM store is supposed to be transactionally safe, so we don't delete it automatically.\n        // The user must request that via the command line.\n        if (cleanInstall) {\n            if (this.rushConfiguration.packageManager === 'npm') {\n                // eslint-disable-next-line no-console\n                console.log(`Deleting the \"npm-cache\" folder`);\n                // This is faster and more thorough than \"npm cache clean\"\n                this.installRecycler.moveFolder(this.rushConfiguration.npmCacheFolder);\n                // eslint-disable-next-line no-console\n                console.log(`Deleting the \"npm-tmp\" folder`);\n                this.installRecycler.moveFolder(this.rushConfiguration.npmTmpFolder);\n            }\n        }\n        // Example: \"C:\\MyRepo\\common\\temp\\npm-local\\node_modules\\.bin\\npm\"\n        const packageManagerFilename = this.rushConfiguration.packageManagerToolFilename;\n        const packageManagerEnv = InstallHelpers.getPackageManagerEnvironment(this.rushConfiguration, this.options);\n        const commonNodeModulesFolder = path.join(this.rushConfiguration.commonTempFolder, RushConstants.nodeModulesFolderName);\n        // Is there an existing \"node_modules\" folder to consider?\n        if (FileSystem.exists(commonNodeModulesFolder)) {\n            // Should we delete the entire \"node_modules\" folder?\n            if (cleanInstall) {\n                // YES: Delete \"node_modules\"\n                // Explain to the user why we are hosing their node_modules folder\n                // eslint-disable-next-line no-console\n                console.log('Deleting files from ' + commonNodeModulesFolder);\n                this.installRecycler.moveFolder(commonNodeModulesFolder);\n                Utilities.createFolderWithRetry(commonNodeModulesFolder);\n            }\n            else {\n                // NO: Prepare to do an incremental install in the \"node_modules\" folder\n                // note: it is not necessary to run \"prune\" with pnpm\n                if (this.rushConfiguration.packageManager === 'npm') {\n                    // eslint-disable-next-line no-console\n                    console.log(`Running \"${this.rushConfiguration.packageManager} prune\"` +\n                        ` in ${this.rushConfiguration.commonTempFolder}`);\n                    const args = ['prune'];\n                    this.pushConfigurationArgs(args, this.options, subspace);\n                    await Utilities.executeCommandWithRetryAsync({\n                        command: packageManagerFilename,\n                        args: args,\n                        workingDirectory: this.rushConfiguration.commonTempFolder,\n                        environment: packageManagerEnv\n                    }, this.options.maxInstallAttempts);\n                    // Delete the (installed image of) the temp projects, since \"npm install\" does not\n                    // detect changes for \"file:./\" references.\n                    // We recognize the temp projects by their names, which always start with \"rush-\".\n                    // Example: \"C:\\MyRepo\\common\\temp\\node_modules\\@rush-temp\"\n                    const pathToDeleteWithoutStar = path.join(commonNodeModulesFolder, RushConstants.rushTempNpmScope);\n                    // eslint-disable-next-line no-console\n                    console.log(`Deleting ${pathToDeleteWithoutStar}\\\\*`);\n                    // Glob can't handle Windows paths\n                    const normalizedPathToDeleteWithoutStar = Text.replaceAll(pathToDeleteWithoutStar, '\\\\', '/');\n                    const { default: glob } = await import('fast-glob');\n                    const tempModulePaths = await glob(globEscape(normalizedPathToDeleteWithoutStar) + '/*');\n                    // Example: \"C:/MyRepo/common/temp/node_modules/@rush-temp/*\"\n                    for (const tempModulePath of tempModulePaths) {\n                        // We could potentially use AsyncRecycler here, but in practice these folders tend\n                        // to be very small\n                        Utilities.dangerouslyDeletePath(tempModulePath);\n                    }\n                }\n            }\n        }\n        if (this.rushConfiguration.packageManager === 'yarn') {\n            // Yarn does not correctly detect changes to a tarball, so we need to forcibly clear its cache\n            const yarnRushTempCacheFolder = path.join(this.rushConfiguration.yarnCacheFolder, 'v2', 'npm-@rush-temp');\n            if (FileSystem.exists(yarnRushTempCacheFolder)) {\n                // eslint-disable-next-line no-console\n                console.log('Deleting ' + yarnRushTempCacheFolder);\n                Utilities.dangerouslyDeletePath(yarnRushTempCacheFolder);\n            }\n        }\n        // Run \"npm install\" in the common folder\n        const installArgs = ['install'];\n        this.pushConfigurationArgs(installArgs, this.options, subspace);\n        // eslint-disable-next-line no-console\n        console.log('\\n' +\n            Colorize.bold(`Running \"${this.rushConfiguration.packageManager} install\" in` +\n                ` ${this.rushConfiguration.commonTempFolder}`) +\n            '\\n');\n        // If any diagnostic options were specified, then show the full command-line\n        if (this.options.debug || this.options.collectLogFile || this.options.networkConcurrency) {\n            // eslint-disable-next-line no-console\n            console.log('\\n' +\n                Colorize.green('Invoking package manager: ') +\n                FileSystem.getRealPath(packageManagerFilename) +\n                ' ' +\n                installArgs.join(' ') +\n                '\\n');\n        }\n        await Utilities.executeCommandWithRetryAsync({\n            command: packageManagerFilename,\n            args: installArgs,\n            workingDirectory: this.rushConfiguration.commonTempFolder,\n            environment: packageManagerEnv,\n            suppressOutput: false\n        }, this.options.maxInstallAttempts, () => {\n            if (this.rushConfiguration.isPnpm) {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.yellow(`Deleting the \"node_modules\" folder`));\n                this.installRecycler.moveFolder(commonNodeModulesFolder);\n                // Leave the pnpm-store as is for the retry. This ensures that packages that have already\n                // been downloaded need not be downloaded again, thereby potentially increasing the chances\n                // of a subsequent successful install.\n                Utilities.createFolderWithRetry(commonNodeModulesFolder);\n            }\n        });\n        if (this.rushConfiguration.packageManager === 'npm') {\n            // eslint-disable-next-line no-console\n            console.log('\\n' + Colorize.bold('Running \"npm shrinkwrap\"...'));\n            const npmArgs = ['shrinkwrap'];\n            this.pushConfigurationArgs(npmArgs, this.options, subspace);\n            await Utilities.executeCommandAsync({\n                command: this.rushConfiguration.packageManagerToolFilename,\n                args: npmArgs,\n                workingDirectory: this.rushConfiguration.commonTempFolder\n            });\n            // eslint-disable-next-line no-console\n            console.log('\"npm shrinkwrap\" completed\\n');\n            await this._fixupNpm5RegressionAsync();\n        }\n    }\n    async postInstallAsync(subspace) {\n        if (!this.options.noLink) {\n            const linkManager = LinkManagerFactory.getLinkManager(this.rushConfiguration);\n            await linkManager.createSymlinksForProjectsAsync(false);\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log('\\n' + Colorize.yellow('Since \"--no-link\" was specified, you will need to run \"rush link\" manually.'));\n        }\n    }\n    /**\n     * This is a workaround for a bug introduced in NPM 5 (and still unfixed as of NPM 5.5.1):\n     * https://github.com/npm/npm/issues/19006\n     *\n     * The regression is that \"npm install\" sets the package.json \"version\" field for the\n     * @rush-temp projects to a value like \"file:projects/example.tgz\", when it should be \"0.0.0\".\n     * This causes linking to fail later, when read-package-tree tries to parse the bad version.\n     * The error looks like this:\n     *\n     * ERROR: Failed to parse package.json for foo: Invalid version: \"file:projects/example.tgz\"\n     *\n     * Our workaround is to rewrite the package.json files for each of the @rush-temp projects\n     * in the node_modules folder, after \"npm install\" completes.\n     */\n    async _fixupNpm5RegressionAsync() {\n        const pathToDeleteWithoutStar = path.join(this.rushConfiguration.commonTempFolder, 'node_modules', RushConstants.rushTempNpmScope);\n        // Glob can't handle Windows paths\n        const normalizedPathToDeleteWithoutStar = Text.replaceAll(pathToDeleteWithoutStar, '\\\\', '/');\n        let anyChanges = false;\n        const { default: glob } = await import('fast-glob');\n        const packageJsonPaths = await glob(globEscape(normalizedPathToDeleteWithoutStar) + '/*/package.json');\n        // Example: \"C:/MyRepo/common/temp/node_modules/@rush-temp/*/package.json\"\n        for (const packageJsonPath of packageJsonPaths) {\n            // Example: \"C:/MyRepo/common/temp/node_modules/@rush-temp/example/package.json\"\n            const packageJsonObject = JsonFile.load(packageJsonPath);\n            // The temp projects always use \"0.0.0\" as their version\n            packageJsonObject.version = '0.0.0';\n            if (JsonFile.save(packageJsonObject, packageJsonPath, { onlyIfChanged: true })) {\n                anyChanges = true;\n            }\n        }\n        if (anyChanges) {\n            // eslint-disable-next-line no-console\n            console.log('\\n' + Colorize.yellow(PrintUtilities.wrapWords(`Applied workaround for NPM 5 bug`)) + '\\n');\n        }\n    }\n    /**\n     * Checks for temp projects that exist in the shrinkwrap file, but don't exist\n     * in rush.json.  This might occur, e.g. if a project was recently deleted or renamed.\n     *\n     * @returns true if orphans were found, or false if everything is okay\n     */\n    _findMissingTempProjects(shrinkwrapFile) {\n        const tempProjectNames = new Set(shrinkwrapFile.getTempProjectNames());\n        for (const rushProject of this.rushConfiguration.projects) {\n            if (!tempProjectNames.has(rushProject.tempProjectName)) {\n                // eslint-disable-next-line no-console\n                console.log('\\n' +\n                    Colorize.yellow(PrintUtilities.wrapWords(`Your ${this.rushConfiguration.shrinkwrapFilePhrase} is missing the project \"${rushProject.packageName}\".`)) +\n                    '\\n');\n                return true; // found one\n            }\n        }\n        return false; // none found\n    }\n}\n//# sourceMappingURL=RushInstallManager.js.map"],"names":[],"sourceRoot":""}