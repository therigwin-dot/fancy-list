{"version":3,"file":"chunks/IPCOperationRunnerPlugin.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACmC;AAC4B;AACe;AACxB;AACJ;AACE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mFAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D,wBAAwB,kCAAkC;AAC1D,mCAAmC,2DAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yEAAwB;AACrE;AACA;AACA;AACA,6CAA6C,yEAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2DAAc,mCAAmC,OAAO;AACxG,oCAAoC,6DAAe;AACnD;AACA;AACA;AACA,gDAAgD,2DAAc,kCAAkC,SAAS;AACzG,oCAAoC,6DAAe;AACnD;AACA;AACA,oCAAoC,6DAAe;AACnD;AACA;AACA,oCAAoC,6DAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAe;AAC7C,kBAAkB,6DAAe;AACjC;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAI;AACtB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrKA;AACA;AAC0D;AACN;AACmG;AACvJ;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAwB;AAC5C,SAAS;AACT;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA,qDAAqD,4FAA+B;AACpF;AACA,wBAAwB,6DAA6D;AACrF;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,iEAAiE,UAAU,6EAA6E,UAAU;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0EAAa;AAClD,sCAAsC,2EAAc;AACpD;AACA;AACA,8EAA8E,mEAAkB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6DAAe;AAC1D,2CAA2C,6DAAe;AAC1D,2CAA2C,6DAAe;AAC1D;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,QAAQ;AAClC,sCAAsC,mEAAkB;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/IPCOperationRunner.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/IPCOperationRunnerPlugin.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { once } from 'node:events';\nimport { TerminalProviderSeverity } from '@rushstack/terminal';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport { Utilities } from '../../utilities/Utilities';\nimport { OperationError } from './OperationError';\nimport { OperationStatus } from './OperationStatus';\nfunction isAfterExecuteEventMessage(message) {\n    return typeof message === 'object' && message.event === 'after-execute';\n}\nfunction isRequestRunEventMessage(message) {\n    return typeof message === 'object' && message.event === 'requestRun';\n}\nfunction isSyncEventMessage(message) {\n    return typeof message === 'object' && message.event === 'sync';\n}\n/**\n * Runner that hosts a long-lived process to which it communicates via IPC.\n */\nexport class IPCOperationRunner {\n    constructor(options) {\n        this.cacheable = false;\n        this.reportTiming = true;\n        this.silent = false;\n        this.name = options.name;\n        this.warningsAreAllowed =\n            EnvironmentConfiguration.allowWarningsInSuccessfulBuild ||\n                options.phase.allowWarningsOnSuccess ||\n                false;\n        this._rushProject = options.project;\n        this._commandToRun = options.commandToRun;\n        this._commandForHash = options.commandForHash;\n        this._persist = options.persist;\n        this._requestRun = options.requestRun;\n    }\n    async executeAsync(context) {\n        return await context.runWithTerminalAsync(async (terminal, terminalProvider) => {\n            var _a, _b;\n            let isConnected = false;\n            if (!this._ipcProcess || typeof this._ipcProcess.exitCode === 'number') {\n                // Run the operation\n                terminal.writeLine('Invoking: ' + this._commandToRun);\n                const { rushConfiguration, projectFolder } = this._rushProject;\n                const { environment: initialEnvironment } = context;\n                this._ipcProcess = Utilities.executeLifecycleCommandAsync(this._commandToRun, {\n                    rushConfiguration,\n                    workingDirectory: projectFolder,\n                    initCwd: rushConfiguration.commonTempFolder,\n                    handleOutput: true,\n                    environmentPathOptions: {\n                        includeProjectBin: true\n                    },\n                    ipc: true,\n                    connectSubprocessTerminator: true,\n                    initialEnvironment\n                });\n                let resolveReadyPromise;\n                this._processReadyPromise = new Promise((resolve) => {\n                    resolveReadyPromise = resolve;\n                });\n                this._ipcProcess.on('message', (message) => {\n                    if (isRequestRunEventMessage(message)) {\n                        this._requestRun(message.requestor);\n                    }\n                    else if (isSyncEventMessage(message)) {\n                        resolveReadyPromise();\n                    }\n                });\n            }\n            else {\n                terminal.writeLine(`Connecting to existing IPC process...`);\n            }\n            const subProcess = this._ipcProcess;\n            let hasWarningOrError = false;\n            function onStdout(data) {\n                const text = data.toString();\n                terminalProvider.write(text, TerminalProviderSeverity.log);\n            }\n            function onStderr(data) {\n                const text = data.toString();\n                terminalProvider.write(text, TerminalProviderSeverity.error);\n                hasWarningOrError = true;\n            }\n            // Hook into events, in order to get live streaming of the log\n            (_a = subProcess.stdout) === null || _a === void 0 ? void 0 : _a.on('data', onStdout);\n            (_b = subProcess.stderr) === null || _b === void 0 ? void 0 : _b.on('data', onStderr);\n            const status = await new Promise((resolve, reject) => {\n                function finishHandler(message) {\n                    var _a, _b;\n                    if (isAfterExecuteEventMessage(message)) {\n                        terminal.writeLine('Received finish notification');\n                        (_a = subProcess.stdout) === null || _a === void 0 ? void 0 : _a.off('data', onStdout);\n                        (_b = subProcess.stderr) === null || _b === void 0 ? void 0 : _b.off('data', onStderr);\n                        subProcess.off('message', finishHandler);\n                        subProcess.off('error', reject);\n                        subProcess.off('exit', onExit);\n                        terminal.writeLine('Disconnected from IPC process');\n                        // These types are currently distinct but have the same underlying values\n                        resolve(message.status);\n                    }\n                }\n                function onExit(exitCode, signal) {\n                    try {\n                        if (signal) {\n                            context.error = new OperationError('error', `Terminated by signal: ${signal}`);\n                            resolve(OperationStatus.Failure);\n                        }\n                        else if (exitCode !== 0) {\n                            // Do NOT reject here immediately, give a chance for other logic to suppress the error\n                            context.error = new OperationError('error', `Returned error code: ${exitCode}`);\n                            resolve(OperationStatus.Failure);\n                        }\n                        else if (hasWarningOrError) {\n                            resolve(OperationStatus.SuccessWithWarning);\n                        }\n                        else {\n                            resolve(OperationStatus.Success);\n                        }\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                }\n                subProcess.on('message', finishHandler);\n                subProcess.on('error', reject);\n                subProcess.on('exit', onExit);\n                this._processReadyPromise.then(() => {\n                    isConnected = true;\n                    terminal.writeLine('Child supports IPC protocol. Sending \"run\" command...');\n                    const runCommand = {\n                        command: 'run'\n                    };\n                    subProcess.send(runCommand);\n                }, reject);\n            });\n            if (isConnected && !this._persist) {\n                await this.shutdownAsync();\n            }\n            // @rushstack/operation-graph does not currently have a concept of \"Success with Warning\"\n            // To match existing ShellOperationRunner behavior we treat any stderr as a warning.\n            return status === OperationStatus.Success && hasWarningOrError\n                ? OperationStatus.SuccessWithWarning\n                : status;\n        }, {\n            createLogFile: true\n        });\n    }\n    getConfigHash() {\n        return this._commandForHash;\n    }\n    async shutdownAsync() {\n        const { _ipcProcess: subProcess } = this;\n        if (!subProcess) {\n            return;\n        }\n        if (subProcess.connected) {\n            const exitCommand = {\n                command: 'exit'\n            };\n            subProcess.send(exitCommand);\n            await once(subProcess, 'exit');\n        }\n    }\n}\n//# sourceMappingURL=IPCOperationRunner.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { IPCOperationRunner } from './IPCOperationRunner';\nimport { OperationStatus } from './OperationStatus';\nimport { PLUGIN_NAME as ShellOperationPluginName, formatCommand, getCustomParameterValuesByPhase, getDisplayName } from './ShellOperationRunnerPlugin';\nconst PLUGIN_NAME = 'IPCOperationRunnerPlugin';\n/**\n * Plugin that implements compatible phases via IPC to a long-lived watch process.\n */\nexport class IPCOperationRunnerPlugin {\n    apply(hooks) {\n        // Workaround until the operation graph persists for the lifetime of the watch process\n        const runnerCache = new Map();\n        const operationStatesByRunner = new WeakMap();\n        let currentContext;\n        hooks.createOperations.tapPromise({\n            name: PLUGIN_NAME,\n            before: ShellOperationPluginName\n        }, async (operations, context) => {\n            var _a, _b;\n            const { isWatch, isInitial } = context;\n            if (!isWatch) {\n                return operations;\n            }\n            currentContext = context;\n            const getCustomParameterValuesForPhase = getCustomParameterValuesByPhase();\n            for (const operation of operations) {\n                const { associatedPhase: phase, associatedProject: project, runner } = operation;\n                if (runner || !phase || !project) {\n                    continue;\n                }\n                const { scripts } = project.packageJson;\n                if (!scripts) {\n                    continue;\n                }\n                const { name: phaseName } = phase;\n                const rawScript = (_a = (!isInitial ? scripts[`${phaseName}:incremental:ipc`] : undefined)) !== null && _a !== void 0 ? _a : scripts[`${phaseName}:ipc`];\n                if (!rawScript) {\n                    continue;\n                }\n                // This is the command that will be used to identify the cache entry for this operation, to allow\n                // for this operation (or downstream operations) to be restored from the build cache.\n                const commandForHash = (_b = phase.shellCommand) !== null && _b !== void 0 ? _b : scripts === null || scripts === void 0 ? void 0 : scripts[phaseName];\n                const customParameterValues = getCustomParameterValuesForPhase(phase);\n                const commandToRun = formatCommand(rawScript, customParameterValues);\n                const operationName = getDisplayName(phase, project);\n                let maybeIpcOperationRunner = runnerCache.get(operationName);\n                if (!maybeIpcOperationRunner) {\n                    const ipcOperationRunner = (maybeIpcOperationRunner = new IPCOperationRunner({\n                        phase,\n                        project,\n                        name: operationName,\n                        commandToRun,\n                        commandForHash,\n                        persist: true,\n                        requestRun: (requestor) => {\n                            var _a;\n                            const operationState = operationStatesByRunner.get(ipcOperationRunner);\n                            if (!operationState) {\n                                return;\n                            }\n                            const status = operationState.status;\n                            if (status === OperationStatus.Waiting ||\n                                status === OperationStatus.Ready ||\n                                status === OperationStatus.Queued) {\n                                // Already pending. No-op.\n                                return;\n                            }\n                            (_a = currentContext === null || currentContext === void 0 ? void 0 : currentContext.invalidateOperation) === null || _a === void 0 ? void 0 : _a.call(currentContext, operation, requestor || 'IPC');\n                        }\n                    }));\n                    runnerCache.set(operationName, ipcOperationRunner);\n                }\n                operation.runner = maybeIpcOperationRunner;\n            }\n            return operations;\n        });\n        hooks.beforeExecuteOperations.tap(PLUGIN_NAME, (records, context) => {\n            currentContext = context;\n            for (const [{ runner }, result] of records) {\n                if (runner instanceof IPCOperationRunner) {\n                    operationStatesByRunner.set(runner, result);\n                }\n            }\n        });\n        hooks.shutdownAsync.tapPromise(PLUGIN_NAME, async () => {\n            await Promise.all(Array.from(runnerCache.values(), (runner) => runner.shutdownAsync()));\n        });\n    }\n}\n//# sourceMappingURL=IPCOperationRunnerPlugin.js.map"],"names":[],"sourceRoot":""}