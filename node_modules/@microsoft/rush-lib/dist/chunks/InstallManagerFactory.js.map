{"version":3,"file":"chunks/InstallManagerFactory.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AAC4D;AACrD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qEAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3EA;AACA;AACmF;AAC5E;AACP;AACA;AACA;AACA;AACA,uBAAuB,4FAAuB;AAC9C;AACA,+CAA+C,sQAED;AAC9C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACuE;AAC5C;AACwB;AACH;AACD;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oEAAU;AACvC;AACA;AACA,aAAa,oEAAU;AACvB;AACA;AACA;AACA;AACA,eAAe,8DAAI;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA,8CAA8C,eAAe,GAAG,yDAAa,4BAA4B;AACzG;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB,GAAG,yDAAa,0BAA0B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB,GAAG,wBAAwB,GAAG,yDAAa,0BAA0B;AACtH;AACA;AACA,4BAA4B,kBAAkB;AAC9C,8BAA8B,wBAAwB,GAAG,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAS;AACnC;AACA;AACA,YAAY,+DAAK,qDAAqD,uDAAuD;AAC7H;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,iBAAiB;AAClC;AACA;AACA;AACA,0BAA0B;AAC1B,cAAc,oEAAU,kDAAkD,uDAAa;AACvF;AACA;AACA,iCAAiC,yDAAQ,uDAAuD,qBAAqB;AACrH;AACA;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9FA;AACA;AACyB;AACI;AACI;AACA;AACkG;AACnG;AACe;AACgB;AACc;AACR;AACS;AACjD;AACiC;AACxB;AACW;AACgB;AACX;AACY;AACL;AACQ;AACC;AACI;AACY;AACT;AAC/B;AACkB;AACM;AACtE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAQ,+CAA+C,0DAAa,yBAAyB;AACpI;AACA;AACA;AACA,qEAAqE,wEAAiB;AACtF;AACA;AACA;AACA;AACA,gBAAgB,8FAA8F;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAQ;AAChC;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ;AACpC;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,kBAAkB,sFAA2B;AAC7C;AACA,gBAAgB,mFAAmF;AACnG;AACA;AACA;AACA;AACA,2BAA2B,yDAAQ,mCAAmC,qCAAqC;AAC3G;AACA;AACA;AACA;AACA,sCAAsC,wEAAiB;AACvD;AACA,SAAS;AACT;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC,oEAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAQ,iEAAiE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0EAAqB;AAC5D;AACA;AACA,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAQ,WAAW,0DAAa,oBAAoB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA,qCAAqC,qCAAqC;AAC1E;AACA;AACA;AACA,uBAAuB,oEAAU,0CAA0C,oEAAU;AACrF,sBAAsB,mEAAoB;AAC1C;AACA;AACA;AACA,uCAAuC,oEAAU;AACjD;AACA;AACA;AACA,mDAAmD,yEAAkB,8BAA8B,mBAAmB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,+DAA+D,4EAAiB;AAChF,iBAAiB;AACjB;AACA;AACA;AACA,4CAA4C,0BAA0B;AACtE,qBAAqB,8CAAU;AAC/B;AACA;AACA;AACA;AACA,iEAAiE,qDAAQ;AACzE,mJAAmJ,qEAAsB;AACzK,8BAA8B,mDAAM;AACpC;AACA;AACA;AACA,0BAA0B,mDAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,qCAAqC,sCAAS,uCAAuC,0DAAa;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oEAAU;AACnD;AACA;AACA;AACA;AACA,qBAAqB,4DAAS;AAC9B;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,cAAc,yEAAmC;AACjD;AACA,4CAA4C,8EAAuB;AACnE;AACA;AACA;AACA,mCAAmC,yDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2EAAc;AAC5B;AACA;AACA;AACA;AACA;AACA,iCAAiC,0EAAqB;AACtD;AACA;AACA;AACA,yDAAyD,4CAA4C,IAAI,WAAW;AACpH;AACA;AACA,uCAAuC,yDAAQ;AAC/C,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAAQ;AAClD;AACA,SAAS;AACT;AACA;AACA;AACA,+BAA+B,yDAAQ,wBAAwB,qBAAqB;AACpF;AACA;AACA;AACA,+BAA+B,yDAAQ;AACvC;AACA;AACA;AACA;AACA,uCAAuC,8CAA8C;AACrF;AACA;AACA,8CAA8C,oEAAU;AACxD;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,qCAAqC,GAAG,0DAAa,wBAAwB;AACjI;AACA;AACA;AACA;AACA,0BAA0B,4DAAS;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc,8CAAiB;AAC/B;AACA;AACA;AACA,mDAAmD,qCAAqC,GAAG,0DAAa,uBAAuB;AAC/H;AACA;AACA;AACA,wCAAwC,oEAAU;AAClD;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA;AACA;AACA,sBAAsB,oEAAU;AAChC,8CAA8C,oEAAU;AACxD;AACA,sBAAsB,+DAAK;AAC3B;AACA,0CAA0C,sBAAsB,GAAG,KAAK;AACxE;AACA,8BAA8B,oEAAU;AACxC;AACA,gDAAgD,4BAA4B,GAAG,KAAK;AACpF,yBAAyB;AACzB;AACA;AACA;AACA,6EAA6E,sBAAsB,IAAI,WAAW;AAClH;AACA,iBAAiB,IAAI,iBAAiB;AACtC,sBAAsB,+DAAK;AAC3B;AACA;AACA,8BAA8B,oEAAU,oBAAoB,4BAA4B,GAAG,KAAK;AAChG;AACA,iBAAiB,IAAI,iBAAiB;AACtC;AACA;AACA,sBAAsB,oEAAU;AAChC;AACA;AACA;AACA;AACA;AACA,kBAAkB,+EAAqB;AACvC;AACA,sBAAsB,+FAA6B;AACnD;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAQ,QAAQ,+DAAc,kBAAkB,6CAA6C;AAC5H;AACA,mCAAmC,yDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6CAA6C;AACxF;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAQ,YAAY,0DAAa,6BAA6B;AAClG;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAS;AACpC,wBAAwB,sCAAG;AAC3B;AACA,YAAY,oEAAU;AACtB,qCAAqC,oEAAU;AAC/C;AACA;AACA;AACA;AACA,mCAAmC,yDAAQ;AAC3C;AACA;AACA,8DAA8D,yDAAQ,UAAU,yDAAQ;AACxF;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAa,0BAA0B;AACvE;AACA;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA,yCAAyC,8DAAI,kBAAkB,0CAAa;AAC5E;AACA;AACA;AACA,4CAA4C,WAAW,GAAG,SAAS;AACnE;AACA,oDAAoD,oEAAU;AAC9D,oBAAoB,oEAAU;AAC9B,4CAA4C,qEAAW;AACvD,qBAAqB;AACrB;AACA,kDAAkD,oEAAU;AAC5D,oBAAoB,oEAAU;AAC9B;AACA,4CAA4C,uEAAa,YAAY,uEAAa;AAClF;AACA;AACA;AACA,oCAAoC;AACpC,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD,0CAA0C,iBAAiB,GAAG,SAAS;;AAEvE,2CAA2C;AAC3C;AACA;AACA,cAAc,UAAU;AACxB;AACA,EAAE;AACF;AACA;AACA,oBAAoB,oEAAU,WAAW,sCAAS;AAClD,4CAA4C,qEAAW;AACvD,qBAAqB;AACrB,oBAAoB,oEAAU,qBAAqB,sCAAS;AAC5D;AACA,oBAAoB,uEAAa,YAAY,uEAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gIAAgI;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oFAAwB;AACxC;AACA,oBAAoB,uCAAU;AAC9B,iCAAiC,sBAAsB,GAAG,iDAAiD;AAC3G,iCAAiC,sBAAsB,GAAG,iDAAiD;AAC3G;AACA;AACA,oBAAoB,2BAA2B,EAAE,oFAAwB;AACzE;AACA,yDAAyD,yBAAyB;AAClF;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oFAAwB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oFAAwB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA,gBAAgB,6CAAgB;AAChC,iEAAiE,0DAAa,mBAAmB;AACjG;AACA;AACA;AACA;AACA,gBAAgB,uCAAU;AAC1B,gBAAgB,6CAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sCAAS,mDAAmD,4CAAI;AAC9F,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA,sCAAsC,oEAAU;AAChD;AACA;AACA;AACA;AACA,mCAAmC,kEAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAQ,qCAAqC,0BAA0B;AACrF;AACA;AACA;AACA;AACA,kBAAkB,kEAAQ,8CAA8C,0BAA0B;AAClG;AACA;AACA;AACA,kBAAkB,kEAAQ,qCAAqC,0BAA0B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAa;AACjC,gBAAgB,YAAY,QAAQ,uKAAmC;AACvE;AACA,mDAAmD,iBAAiB,EAAE,wCAAW,IAAI,EAAE,oCAAO,GAAG;AACjG,iEAAiE,yBAAyB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4CAAI;AACnC;AACA;AACA;AACA,gCAAgC,4CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAS;AACrB,YAAY,4DAAS;AACrB;AACA;AACA;AACA,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAU,YAAY,sCAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAQ;AACtC;AACA;AACA;AACA,8BAA8B,yDAAQ;AACtC,mCAAmC,0DAAa,0BAA0B;AAC1E,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC70BA;AACA;AAC6B;AAC4C;AAC1B;AACO;AACA;AACwB;AAC7B;AACH;AACvC;AACP;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA,8BAA8B,yCAAY;AAC1C,QAAQ,oEAAU;AAClB;AACA,YAAY,mFAAwB;AACpC;AACA;AACA;AACA;AACA,yBAAyB,0CAAa,CAAC,oEAAU;AACjD;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAS;AACjB;AACA,YAAY,2DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA,iCAAiC,yCAAY;AAC7C;AACA,iBAAiB,oEAAU;AAC3B,gBAAgB,2DAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,2DAAS;AACrB,mCAAmC,oEAAU;AAC7C;AACA;AACA;AACA,uCAAuC,sCAAS;AAChD,qCAAqC,sCAAS;AAC9C,sCAAsC,oEAAU;AAChD;AACA,4CAA4C,oEAAU,eAAe,oEAAU;AAC/E;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,yCAAyC,oEAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,YAAY,2DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAQ;AACnC,0BAA0B,2DAAS;AACnC;AACA;AACA,kBAAkB,mDAAQ,sEAAsE,yDAAa,yBAAyB;AACtI;AACA;AACA,2BAA2B,yDAAQ,0CAA0C,qBAAqB;AAClG;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9KA;AACA;AAC0D;AAC1D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oEAAU;AAC/C;AACA,4BAA4B,oEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAU;AAClB;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AAC6B;AACI;AACN;AACuF;AAC9E;AAC4B;AACsB;AACzB;AACC;AACb;AACK;AACJ;AAC4B;AACb;AACa;AACT;AACC;AACE;AACD;AACzB;AACQ;AACtD;AACA;AACA;AACO,sCAAsC,wEAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAQ;AAChC;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mFAAwB;AACpC;AACA;AACA;AACA,gBAAgB,+CAA+C;AAC/D;AACA,2BAA2B,yDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ;AACpC;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,oDAAoD,6CAA6C,cAAc,gBAAgB;AAC/H,kDAAkD,yDAAa,kBAAkB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yDAAa,oBAAoB;AAC5E;AACA;AACA;AACA;AACA;AACA,mEAAmE,yDAAa,yBAAyB;AACzG;AACA;AACA,8BAA8B,2DAAS;AACvC;AACA;AACA,8IAA8I,qBAAqB;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,oBAAoB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAiB,CAAC,sCAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0CAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gCAAgC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mEAAc;AACrD;AACA;AACA,gDAAgD,sEAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,0EAAuB;AAClF,0DAA0D,0EAAuB;AACjF;AACA;AACA;AACA;AACA,yBAAyB,6CAAgB;AACzC;AACA;AACA;AACA,oCAAoC,yDAAQ,SAAS,wBAAwB,wBAAwB,KAAK,KAAK,QAAQ;AACvH;AACA;AACA,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA;AACA,oCAAoC,yDAAQ,SAAS,wBAAwB,wBAAwB,KAAK,KAAK,QAAQ;AACvH;AACA,2CAA2C,KAAK;AAChD,6CAA6C,KAAK;AAClD,gCAAgC,wBAAwB;AACxD,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA,iDAAiD,8CAAiB;AAClE,6BAA6B,yCAAY;AACzC;AACA;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA;AACA;AACA,+DAA+D,0EAAuB;AACtF;AACA;AACA;AACA,wDAAwD,wBAAwB,uBAAuB,KAAK,GAAG,QAAQ;AACvH;AACA;AACA;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ,YAAY,wBAAwB;AACxE;AACA;AACA;AACA;AACA,oEAAoE,wBAAwB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,8DAAI,qBAAqB,mCAAmC,GAAG,kCAAkC;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,8DAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gFAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gFAAmB,uEAAuE,gNAAgN;AAC5U;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAc;AACtB;AACA;AACA,8DAA8D,qBAAqB;AACnF,iBAAiB;AACjB;AACA;AACA;AACA,yIAAyI;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sCAAS;AACnD,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sCAAS,wBAAwB,yDAAa;AACjE,SAAS;AACT,mBAAmB,sCAAS,wBAAwB,uEAAa;AACjE,SAAS;AACT;AACA;AACA,eAAe,4DAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAc;AAChD,YAAY,wEAAuB;AACnC;AACA;AACA,wCAAwC,sCAAS,uCAAuC,yDAAa;AACrG;AACA,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAQ,kBAAkB,uCAAuC;AACjF,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ;AAC5B,oBAAoB,oEAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,2EAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAS;AACjC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA,uEAAuE,mBAAmB,sBAAsB;AAChH,uEAAuE,mBAAmB,+BAA+B;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAS,uCAAuC,yDAAa;AACzE;AACA,uBAAuB,sCAAS,wBAAwB,yDAAa;AACrE,aAAa;AACb;AACA;AACA,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0EAAqB;AACxD;AACA;AACA,kBAAkB,+DAAK;AACvB;AACA;AACA,aAAa,IAAI,iBAAiB;AAClC;AACA;AACA;AACA;AACA,kBAAkB,+DAAK;AACvB,sBAAsB,uFAAyB;AAC/C,aAAa,IAAI,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qCAAqC;AAChF,uCAAuC,oBAAoB,GAAG,yDAAa,qBAAqB;AAChG;AACA;AACA,uBAAuB,oEAAU;AACjC;AACA,6CAA6C,oEAAU;AACvD,oCAAoC,mDAAS,mBAAmB,2BAA2B;AAC3F,wBAAwB,sBAAsB;AAC9C;AACA,kDAAkD,8BAA8B;AAChF;AACA;AACA;AACA,gCAAgC,4DAAS,sBAAsB,uBAAuB,GAAG,SAAS;AAClG,sCAAsC,oEAAU,sBAAsB,uBAAuB,GAAG,SAAS;AACzG;AACA;AACA,8CAA8C,4DAAS,uBAAuB,uBAAuB,GAAG,SAAS;AACjH,kCAAkC,oEAAU;AAC5C,4BAA4B,mEAAe;AAC3C,mDAAmD,oBAAoB,GAAG,SAAS;AACnF,gDAAgD,uBAAuB,GAAG,SAAS;AACnF,6CAA6C,+DAAW;AACxD,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB,GAAG,8BAA8B;AAChG,qBAAqB,4DAAS;AAC9B,yCAAyC,4DAAS;AAClD,0BAA0B,oEAAU;AACpC,oBAAoB,mEAAe;AACnC;AACA;AACA,qCAAqC,+DAAW;AAChD,qBAAqB;AACrB;AACA;AACA;AACA;AACA,kBAAkB,oDAAQ,uCAAuC,yDAAa,yBAAyB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAI;AACjC,WAAW,kDAAU;AACrB;AACA;;;;;;;;;;;;;;;;;;;;ACtjBA;AACA;AAC6B;AACqC;AACJ;AACC;AAC/D,mBAAmB,gEAAM;AACzB,mBAAmB,mBAAO,CAAC,yBAAa,GAAG;AACpC,gCAAgC,sEAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAe;AAC3B,0BAA0B,0CAAa,CAAC,yCAAY;AACpD;AACA;AACA,yBAAyB,8DAAI;AAC7B;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAI;AACZ;AACA;AACA;AACA,kDAAkD,wEAA2B;AAC7E;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/logic/ApprovedPackagesChecker.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/InstallManagerFactory.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ProjectImpactGraphGenerator.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseInstallManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseLinkManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseWorkspaceFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/installManager/WorkspaceInstallManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmWorkspaceFile.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { DependencySpecifier } from './DependencySpecifier';\nexport class ApprovedPackagesChecker {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n        this._approvedPackagesPolicy = this._rushConfiguration.approvedPackagesPolicy;\n        this._filesAreOutOfDate = false;\n        if (this._approvedPackagesPolicy.enabled) {\n            this._updateApprovedPackagesPolicy();\n        }\n    }\n    /**\n     * If true, the files on disk are out of date.\n     */\n    get approvedPackagesFilesAreOutOfDate() {\n        return this._filesAreOutOfDate;\n    }\n    /**\n     * Examines the current dependencies for the projects specified in RushConfiguration,\n     * and then adds them to the 'browser-approved-packages.json' and\n     * 'nonbrowser-approved-packages.json' config files.  If these files don't exist,\n     * they will be created.\n     *\n     * If the \"approvedPackagesPolicy\" feature is not enabled, then no action is taken.\n     */\n    rewriteConfigFiles() {\n        const approvedPackagesPolicy = this._rushConfiguration.approvedPackagesPolicy;\n        if (approvedPackagesPolicy.enabled) {\n            approvedPackagesPolicy.browserApprovedPackages.saveToFile();\n            approvedPackagesPolicy.nonbrowserApprovedPackages.saveToFile();\n        }\n    }\n    _updateApprovedPackagesPolicy() {\n        for (const rushProject of this._rushConfiguration.projects) {\n            const packageJson = rushProject.packageJson;\n            this._collectDependencies(packageJson.dependencies, this._approvedPackagesPolicy, rushProject);\n            this._collectDependencies(packageJson.devDependencies, this._approvedPackagesPolicy, rushProject);\n            this._collectDependencies(packageJson.peerDependencies, this._approvedPackagesPolicy, rushProject);\n            this._collectDependencies(packageJson.optionalDependencies, this._approvedPackagesPolicy, rushProject);\n        }\n    }\n    _collectDependencies(dependencies, approvedPackagesPolicy, rushProject) {\n        if (dependencies) {\n            for (const packageName of Object.keys(dependencies)) {\n                let referencedPackageName = packageName;\n                // Special handling for NPM package aliases such as this:\n                //\n                // \"dependencies\": {\n                //   \"alias-name\": \"npm:target-name@^1.2.3\"\n                // }\n                const dependencySpecifier = new DependencySpecifier(packageName, dependencies[packageName]);\n                if (dependencySpecifier.aliasTarget) {\n                    // Use \"target-name\" instead of \"alias-name\"\n                    referencedPackageName = dependencySpecifier.aliasTarget.packageName;\n                }\n                const scope = this._rushConfiguration.packageNameParser.getScope(referencedPackageName);\n                // Make sure the scope isn't something like \"@types\" which should be ignored\n                if (!approvedPackagesPolicy.ignoredNpmScopes.has(scope) && rushProject.reviewCategory) {\n                    // Yes, add it to the list if it's not already there\n                    let updated = false;\n                    // By default we put everything in the browser file.  But if it already appears in the\n                    // non-browser file, then use that instead.\n                    if (approvedPackagesPolicy.nonbrowserApprovedPackages.getItemByName(referencedPackageName)) {\n                        updated = approvedPackagesPolicy.nonbrowserApprovedPackages.addOrUpdatePackage(referencedPackageName, rushProject.reviewCategory);\n                    }\n                    else {\n                        updated = approvedPackagesPolicy.browserApprovedPackages.addOrUpdatePackage(referencedPackageName, rushProject.reviewCategory);\n                    }\n                    this._filesAreOutOfDate = this._filesAreOutOfDate || updated;\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=ApprovedPackagesChecker.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { WorkspaceInstallManager } from './installManager/WorkspaceInstallManager';\nexport class InstallManagerFactory {\n    static async getInstallManagerAsync(rushConfiguration, rushGlobalFolder, purgeManager, options) {\n        if (rushConfiguration.isPnpm &&\n            rushConfiguration.pnpmOptions &&\n            rushConfiguration.pnpmOptions.useWorkspaces) {\n            return new WorkspaceInstallManager(rushConfiguration, rushGlobalFolder, purgeManager, options);\n        }\n        const rushInstallManagerModule = await import(\n        /* webpackChunkName: 'RushInstallManager' */\n        './installManager/RushInstallManager');\n        return new rushInstallManagerModule.RushInstallManager(rushConfiguration, rushGlobalFolder, purgeManager, options);\n    }\n}\n//# sourceMappingURL=InstallManagerFactory.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, Text, Async } from '@rushstack/node-core-library';\nimport yaml from 'js-yaml';\nimport { Stopwatch } from '../utilities/Stopwatch';\nimport { RushConstants } from './RushConstants';\nimport { Colorize } from '@rushstack/terminal';\n/**\n * Default global excluded globs\n * Only used if the `<repository_root>/.mergequeueignore` does not exist\n */\nconst DEFAULT_GLOBAL_EXCLUDED_GLOBS = ['common/autoinstallers/**'];\nasync function tryReadFileLinesAsync(filePath) {\n    let fileContents;\n    try {\n        fileContents = await FileSystem.readFileAsync(filePath);\n    }\n    catch (error) {\n        if (!FileSystem.isNotExistError(error)) {\n            throw error;\n        }\n    }\n    if (fileContents) {\n        return Text.convertToLf(fileContents).split('\\n');\n    }\n}\nexport class ProjectImpactGraphGenerator {\n    /**\n     * Get repositoryRoot and load projects within the rush.json\n     */\n    constructor(terminal, rushConfiguration) {\n        this._terminal = terminal;\n        this._rushConfiguration = rushConfiguration;\n        const { rushJsonFolder } = rushConfiguration;\n        this._repositoryRoot = rushJsonFolder;\n        this._projectImpactGraphFilePath = `${rushJsonFolder}/${RushConstants.projectImpactGraphFilename}`;\n    }\n    /**\n     * Load global excluded globs\n     */\n    async _loadGlobalExcludedGlobsAsync() {\n        const filePath = `${this._repositoryRoot}/${RushConstants.mergeQueueIgnoreFileName}`;\n        return await tryReadFileLinesAsync(filePath);\n    }\n    /**\n     * Load project excluded globs\n     * @param projectRootRelativePath - project root relative path\n     */\n    async _tryLoadProjectExcludedGlobsAsync(projectRootRelativePath) {\n        const filePath = `${this._repositoryRoot}/${projectRootRelativePath}/${RushConstants.mergeQueueIgnoreFileName}`;\n        const globs = await tryReadFileLinesAsync(filePath);\n        if (globs) {\n            for (let i = 0; i < globs.length; i++) {\n                globs[i] = `${projectRootRelativePath}/${globs[i]}`;\n            }\n            return globs;\n        }\n    }\n    /**\n     * Core Logic: generate project-impact-graph.yaml\n     */\n    async generateAsync() {\n        const stopwatch = Stopwatch.start();\n        const [globalExcludedGlobs = DEFAULT_GLOBAL_EXCLUDED_GLOBS, projectEntries] = await Promise.all([\n            this._loadGlobalExcludedGlobsAsync(),\n            Async.mapAsync(this._rushConfiguration.projects, async ({ packageName, consumingProjects, projectRelativeFolder }) => {\n                const dependentList = [packageName];\n                for (const consumingProject of consumingProjects) {\n                    dependentList.push(consumingProject.packageName);\n                }\n                const projectImpactGraphProjectConfiguration = {\n                    includedGlobs: [`${projectRelativeFolder}/**`],\n                    dependentProjects: dependentList.sort()\n                };\n                const projectExcludedGlobs = await this._tryLoadProjectExcludedGlobsAsync(projectRelativeFolder);\n                if (projectExcludedGlobs) {\n                    projectImpactGraphProjectConfiguration.excludedGlobs = projectExcludedGlobs;\n                }\n                return [packageName, projectImpactGraphProjectConfiguration];\n            }, { concurrency: 50 })\n        ]);\n        projectEntries.sort(([aName], [bName]) => aName.localeCompare(bName));\n        const projects = Object.fromEntries(projectEntries);\n        const content = { globalExcludedGlobs, projects };\n        await FileSystem.writeFileAsync(this._projectImpactGraphFilePath, yaml.safeDump(content));\n        stopwatch.stop();\n        this._terminal.writeLine();\n        this._terminal.writeLine(Colorize.green(`Generate project impact graph successfully. (${stopwatch.toString()})`));\n    }\n    async validateAsync() {\n        // TODO: More validation other than just existence\n        return await FileSystem.existsAsync(this._projectImpactGraphFilePath);\n    }\n}\n//# sourceMappingURL=ProjectImpactGraphGenerator.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport * as semver from 'semver';\nimport { FileSystem, JsonFile, PosixModeBits, NewlineKind, AlreadyReportedError, Path, Async } from '@rushstack/node-core-library';\nimport { existsSync } from 'fs';\nimport { readFile, unlink } from 'fs/promises';\nimport { PrintUtilities, Colorize } from '@rushstack/terminal';\nimport { pnpmSyncGetJsonVersion, pnpmSyncPrepareAsync } from 'pnpm-sync-lib';\nimport { ApprovedPackagesChecker } from '../ApprovedPackagesChecker';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport { Git } from '../Git';\nimport { getCommonTempFlag } from '../../api/LastInstallFlag';\nimport { Rush } from '../../api/Rush';\nimport { RushConstants } from '../RushConstants';\nimport { ShrinkwrapFileFactory } from '../ShrinkwrapFileFactory';\nimport { Utilities } from '../../utilities/Utilities';\nimport { InstallHelpers } from '../installManager/InstallHelpers';\nimport * as PolicyValidator from '../policy/PolicyValidator';\nimport { SetupPackageRegistry } from '../setup/SetupPackageRegistry';\nimport { PnpmfileConfiguration } from '../pnpm/PnpmfileConfiguration';\nimport { isVariableSetInNpmrcFile } from '../../utilities/npmrcUtilities';\nimport { SubspacePnpmfileConfiguration } from '../pnpm/SubspacePnpmfileConfiguration';\nimport { ProjectImpactGraphGenerator } from '../ProjectImpactGraphGenerator';\nimport { FlagFile } from '../../api/FlagFile';\nimport { PnpmShrinkwrapFile } from '../pnpm/PnpmShrinkwrapFile';\nimport { PnpmSyncUtilities } from '../../utilities/PnpmSyncUtilities';\n/**\n * Pnpm don't support --ignore-compatibility-db, so use --config.ignoreCompatibilityDb for now.\n */\nexport const pnpmIgnoreCompatibilityDbParameter = '--config.ignoreCompatibilityDb';\nconst pnpmCacheDirParameter = '--config.cacheDir';\nconst pnpmStateDirParameter = '--config.stateDir';\nconst gitLfsHooks = new Set(['post-checkout', 'post-commit', 'post-merge', 'pre-push']);\n/**\n * This class implements common logic between \"rush install\" and \"rush update\".\n */\nexport class BaseInstallManager {\n    constructor(rushConfiguration, rushGlobalFolder, purgeManager, options) {\n        this._npmSetupValidated = false;\n        this._syncNpmrcAlreadyCalled = false;\n        this._terminal = options.terminal;\n        this.rushConfiguration = rushConfiguration;\n        this.rushGlobalFolder = rushGlobalFolder;\n        this.installRecycler = purgeManager.commonTempFolderRecycler;\n        this.options = options;\n        this._commonTempLinkFlag = new FlagFile(options.subspace.getSubspaceTempFolderPath(), RushConstants.lastLinkFlagFilename, {});\n        this.subspaceInstallFlags = new Map();\n        if (rushConfiguration.subspacesFeatureEnabled) {\n            for (const subspace of rushConfiguration.subspaces) {\n                this.subspaceInstallFlags.set(subspace.subspaceName, getCommonTempFlag(rushConfiguration, subspace));\n            }\n        }\n    }\n    async doInstallAsync() {\n        const { allowShrinkwrapUpdates, selectedProjects, pnpmFilterArgumentValues, resolutionOnly, variant } = this.options;\n        const isFilteredInstall = pnpmFilterArgumentValues.length > 0;\n        const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;\n        // Prevent filtered installs when workspaces is disabled\n        if (isFilteredInstall && !useWorkspaces) {\n            // eslint-disable-next-line no-console\n            console.log();\n            // eslint-disable-next-line no-console\n            console.log(Colorize.red('Project filtering arguments can only be used when running in a workspace environment. Run the ' +\n                'command again without specifying these arguments.'));\n            throw new AlreadyReportedError();\n        }\n        // Prevent update when using a filter, as modifications to the shrinkwrap shouldn't be saved\n        if (allowShrinkwrapUpdates && isFilteredInstall) {\n            // Allow partial update when there are subspace projects\n            if (!this.rushConfiguration.subspacesFeatureEnabled) {\n                // eslint-disable-next-line no-console\n                console.log();\n                // eslint-disable-next-line no-console\n                console.log(Colorize.red('Project filtering arguments cannot be used when running \"rush update\". Run the command again ' +\n                    'without specifying these arguments.'));\n                throw new AlreadyReportedError();\n            }\n        }\n        const subspace = this.options.subspace;\n        const projectImpactGraphGenerator = this.rushConfiguration\n            .experimentsConfiguration.configuration.generateProjectImpactGraphDuringRushUpdate\n            ? new ProjectImpactGraphGenerator(this._terminal, this.rushConfiguration)\n            : undefined;\n        const { shrinkwrapIsUpToDate, npmrcHash, projectImpactGraphIsUpToDate, variantIsUpToDate } = await this.prepareAsync(subspace, variant, projectImpactGraphGenerator);\n        if (this.options.checkOnly) {\n            return;\n        }\n        // eslint-disable-next-line no-console\n        console.log('\\n' + Colorize.bold(`Checking installation in \"${subspace.getSubspaceTempFolderPath()}\"`));\n        // This marker file indicates that the last \"rush install\" completed successfully.\n        // Always perform a clean install if filter flags were provided. Additionally, if\n        // \"--purge\" was specified, or if the last install was interrupted, then we will\n        // need to perform a clean install.  Otherwise, we can do an incremental install.\n        const commonTempInstallFlag = getCommonTempFlag(this.rushConfiguration, subspace, {\n            npmrcHash: npmrcHash || '<NO NPMRC>'\n        });\n        if (isFilteredInstall && selectedProjects) {\n            const selectedProjectNames = [];\n            for (const { packageName } of selectedProjects) {\n                selectedProjectNames.push(packageName);\n            }\n            selectedProjectNames.sort();\n            // Get the projects involved in this filtered install\n            commonTempInstallFlag.mergeFromObject({\n                selectedProjectNames\n            });\n        }\n        const optionsToIgnore = !this.rushConfiguration\n            .experimentsConfiguration.configuration.cleanInstallAfterNpmrcChanges\n            ? ['npmrcHash'] // If the \"cleanInstallAfterNpmrcChanges\" experiment is disabled, ignore the npmrcHash\n            : undefined;\n        const cleanInstall = !(await commonTempInstallFlag.checkValidAndReportStoreIssuesAsync({\n            rushVerb: allowShrinkwrapUpdates ? 'update' : 'install',\n            statePropertiesToIgnore: optionsToIgnore\n        }));\n        // Allow us to defer the file read until we need it\n        const canSkipInstallAsync = async () => {\n            // Based on timestamps, can we skip this install entirely?\n            const outputStats = await FileSystem.getStatisticsAsync(commonTempInstallFlag.path);\n            return this.canSkipInstallAsync(outputStats.mtime, subspace, variant);\n        };\n        if (resolutionOnly ||\n            cleanInstall ||\n            !variantIsUpToDate ||\n            !shrinkwrapIsUpToDate ||\n            !(await canSkipInstallAsync()) ||\n            !projectImpactGraphIsUpToDate) {\n            // eslint-disable-next-line no-console\n            console.log();\n            await this.validateNpmSetupAsync();\n            if (!this.rushConfiguration.rushConfigurationJson.suppressRushIsPublicVersionCheck) {\n                let publishedRelease;\n                try {\n                    publishedRelease = await this._checkIfReleaseIsPublishedAsync();\n                }\n                catch (_a) {\n                    // If the user is working in an environment that can't reach the registry,\n                    // don't bother them with errors.\n                }\n                if (publishedRelease === false) {\n                    // eslint-disable-next-line no-console\n                    console.log(Colorize.yellow('Warning: This release of the Rush tool was unpublished; it may be unstable.'));\n                }\n            }\n            if (!resolutionOnly) {\n                // Delete the successful install file to indicate the install transaction has started\n                await commonTempInstallFlag.clearAsync();\n                // Since we're going to be tampering with common/node_modules, delete the \"rush link\" flag file if it exists;\n                // this ensures that a full \"rush link\" is required next time\n                await this._commonTempLinkFlag.clearAsync();\n            }\n            // Give plugins an opportunity to act before invoking the installation process\n            if (this.options.beforeInstallAsync !== undefined) {\n                await this.options.beforeInstallAsync(subspace);\n            }\n            await Promise.all([\n                // Perform the actual install\n                this.installAsync(cleanInstall, subspace),\n                // If allowed, generate the project impact graph\n                allowShrinkwrapUpdates ? projectImpactGraphGenerator === null || projectImpactGraphGenerator === void 0 ? void 0 : projectImpactGraphGenerator.generateAsync() : undefined\n            ]);\n            if (this.options.allowShrinkwrapUpdates && !shrinkwrapIsUpToDate) {\n                const committedShrinkwrapFileName = subspace.getCommittedShrinkwrapFilePath(variant);\n                const shrinkwrapFile = ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, committedShrinkwrapFileName);\n                shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.validateShrinkwrapAfterUpdate(this.rushConfiguration, subspace, this._terminal);\n                // Copy (or delete) common\\temp\\pnpm-lock.yaml --> common\\config\\rush\\pnpm-lock.yaml\n                Utilities.syncFile(subspace.getTempShrinkwrapFilename(), committedShrinkwrapFileName);\n            }\n            else {\n                // TODO: Validate whether the package manager updated it in a nontrivial way\n            }\n            // Always update the state file if running \"rush update\"\n            if (this.options.allowShrinkwrapUpdates) {\n                if (subspace.getRepoState().refreshState(this.rushConfiguration, subspace, variant)) {\n                    // eslint-disable-next-line no-console\n                    console.log(Colorize.yellow(`${RushConstants.repoStateFilename} has been modified and must be committed to source control.`));\n                }\n            }\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log('Installation is already up-to-date.');\n        }\n        const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;\n        // if usePnpmSyncForInjectedDependencies is true\n        // the pnpm-sync will generate the pnpm-sync.json based on lockfile\n        if (this.rushConfiguration.isPnpm && (experiments === null || experiments === void 0 ? void 0 : experiments.usePnpmSyncForInjectedDependencies)) {\n            const pnpmLockfilePath = subspace.getTempShrinkwrapFilename();\n            const dotPnpmFolder = `${subspace.getSubspaceTempFolderPath()}/node_modules/.pnpm`;\n            // we have an edge case here\n            // if a package.json has no dependencies, pnpm will still generate the pnpm-lock.yaml but not .pnpm folder\n            // so we need to make sure pnpm-lock.yaml and .pnpm exists before calling the pnpmSync APIs\n            if ((await FileSystem.existsAsync(pnpmLockfilePath)) && (await FileSystem.existsAsync(dotPnpmFolder))) {\n                await pnpmSyncPrepareAsync({\n                    lockfilePath: pnpmLockfilePath,\n                    dotPnpmFolder,\n                    lockfileId: subspace.subspaceName,\n                    ensureFolderAsync: FileSystem.ensureFolderAsync,\n                    // eslint-disable-next-line @typescript-eslint/naming-convention\n                    readPnpmLockfile: async (lockfilePath) => {\n                        var _a, _b;\n                        const wantedPnpmLockfile = PnpmShrinkwrapFile.loadFromFile(lockfilePath, { withCaching: true });\n                        if (!wantedPnpmLockfile) {\n                            return undefined;\n                        }\n                        else {\n                            const lockfilePackages = Object.create(null);\n                            for (const versionPath of wantedPnpmLockfile.packages.keys()) {\n                                lockfilePackages[versionPath] = {\n                                    dependencies: (_a = wantedPnpmLockfile.packages.get(versionPath)) === null || _a === void 0 ? void 0 : _a.dependencies,\n                                    optionalDependencies: (_b = wantedPnpmLockfile.packages.get(versionPath)) === null || _b === void 0 ? void 0 : _b.optionalDependencies\n                                };\n                            }\n                            const result = {\n                                lockfileVersion: wantedPnpmLockfile.shrinkwrapFileMajorVersion,\n                                importers: Object.fromEntries(wantedPnpmLockfile.importers.entries()),\n                                packages: lockfilePackages\n                            };\n                            return result;\n                        }\n                    },\n                    logMessageCallback: (logMessageOptions) => PnpmSyncUtilities.processLogMessage(logMessageOptions, this._terminal)\n                });\n            }\n            // clean up the out of date .pnpm-sync.json\n            for (const rushProject of subspace.getProjects()) {\n                const pnpmSyncJsonPath = `${rushProject.projectFolder}/node_modules/.pnpm-sync.json`;\n                if (!existsSync(pnpmSyncJsonPath)) {\n                    continue;\n                }\n                let existingPnpmSyncJsonFile;\n                try {\n                    existingPnpmSyncJsonFile = JSON.parse((await readFile(pnpmSyncJsonPath)).toString());\n                    if ((existingPnpmSyncJsonFile === null || existingPnpmSyncJsonFile === void 0 ? void 0 : existingPnpmSyncJsonFile.version) !== pnpmSyncGetJsonVersion()) {\n                        await unlink(pnpmSyncJsonPath);\n                    }\n                }\n                catch (e) {\n                    await unlink(pnpmSyncJsonPath);\n                }\n            }\n        }\n        // Perform any post-install work the install manager requires\n        await this.postInstallAsync(subspace);\n        if (!resolutionOnly) {\n            // Create the marker file to indicate a successful install\n            await commonTempInstallFlag.createAsync();\n        }\n        // Give plugins an opportunity to act after a successful install\n        if (this.options.afterInstallAsync !== undefined) {\n            await this.options.afterInstallAsync(subspace);\n        }\n        // eslint-disable-next-line no-console\n        console.log('');\n    }\n    async canSkipInstallAsync(lastModifiedDate, subspace, variant) {\n        // Based on timestamps, can we skip this install entirely?\n        const potentiallyChangedFiles = [];\n        // Consider the timestamp on the node_modules folder; if someone tampered with it\n        // or deleted it entirely, then we can't skip this install\n        potentiallyChangedFiles.push(path.join(subspace.getSubspaceTempFolderPath(), RushConstants.nodeModulesFolderName));\n        // Additionally, if they pulled an updated shrinkwrap file from Git,\n        // then we can't skip this install\n        potentiallyChangedFiles.push(subspace.getCommittedShrinkwrapFilePath(variant));\n        // Add common-versions.json file to the potentially changed files list.\n        potentiallyChangedFiles.push(subspace.getCommonVersionsFilePath(variant));\n        // Add pnpm-config.json file to the potentially changed files list.\n        potentiallyChangedFiles.push(subspace.getPnpmConfigFilePath());\n        if (this.rushConfiguration.isPnpm) {\n            // If the repo is using pnpmfile.js, consider that also\n            const pnpmFileFilePath = subspace.getPnpmfilePath(variant);\n            const pnpmFileExists = await FileSystem.existsAsync(pnpmFileFilePath);\n            if (pnpmFileExists) {\n                potentiallyChangedFiles.push(pnpmFileFilePath);\n            }\n        }\n        return await Utilities.isFileTimestampCurrentAsync(lastModifiedDate, potentiallyChangedFiles);\n    }\n    async prepareAsync(subspace, variant, projectImpactGraphGenerator) {\n        const terminal = this._terminal;\n        const { allowShrinkwrapUpdates } = this.options;\n        // Check the policies\n        await PolicyValidator.validatePolicyAsync(this.rushConfiguration, subspace, variant, this.options);\n        await this._installGitHooksAsync();\n        const approvedPackagesChecker = new ApprovedPackagesChecker(this.rushConfiguration);\n        if (approvedPackagesChecker.approvedPackagesFilesAreOutOfDate) {\n            approvedPackagesChecker.rewriteConfigFiles();\n            if (allowShrinkwrapUpdates) {\n                terminal.writeLine(Colorize.yellow('Approved package files have been updated. These updates should be committed to source control'));\n            }\n            else {\n                throw new Error(`Approved packages files are out-of date. Run \"rush update\" to update them.`);\n            }\n        }\n        // Ensure that the package manager is installed\n        await InstallHelpers.ensureLocalPackageManagerAsync(this.rushConfiguration, this.rushGlobalFolder, this.options.maxInstallAttempts);\n        let shrinkwrapFile = undefined;\n        // (If it's a full update, then we ignore the shrinkwrap from Git since it will be overwritten)\n        if (!this.options.fullUpgrade) {\n            const committedShrinkwrapFileName = subspace.getCommittedShrinkwrapFilePath(variant);\n            try {\n                shrinkwrapFile = ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, committedShrinkwrapFileName);\n            }\n            catch (ex) {\n                terminal.writeLine();\n                terminal.writeLine(`Unable to load the ${this.rushConfiguration.shrinkwrapFilePhrase}: ${ex.message}`);\n                if (!allowShrinkwrapUpdates) {\n                    terminal.writeLine();\n                    terminal.writeLine(Colorize.red('You need to run \"rush update\" to fix this problem'));\n                    throw new AlreadyReportedError();\n                }\n                shrinkwrapFile = undefined;\n            }\n        }\n        // Write a file indicating which variant is being installed.\n        // This will be used by bulk scripts to determine the correct Shrinkwrap file to track.\n        const currentVariantJsonFilePath = this.rushConfiguration.currentVariantJsonFilePath;\n        const currentVariantJson = {\n            variant: variant !== null && variant !== void 0 ? variant : null\n        };\n        // Determine if the variant is already current by updating current-variant.json.\n        // If nothing is written, the variant has not changed.\n        const variantIsUpToDate = !(await JsonFile.saveAsync(currentVariantJson, currentVariantJsonFilePath, {\n            onlyIfChanged: true\n        }));\n        this.rushConfiguration._currentVariantJsonLoadingPromise = undefined;\n        if (this.options.variant) {\n            terminal.writeLine();\n            terminal.writeLine(Colorize.bold(`Using variant '${this.options.variant}' for installation.`));\n        }\n        else if (!variantIsUpToDate && !variant && this.rushConfiguration.variants.size > 0) {\n            terminal.writeLine();\n            terminal.writeLine(Colorize.bold('Using the default variant for installation.'));\n        }\n        const extraNpmrcLines = [];\n        if (this.rushConfiguration.subspacesFeatureEnabled) {\n            // Look for a monorepo level .npmrc file\n            const commonNpmrcPath = `${this.rushConfiguration.commonRushConfigFolder}/.npmrc`;\n            let commonNpmrcFileLines;\n            try {\n                commonNpmrcFileLines = (await FileSystem.readFileAsync(commonNpmrcPath)).split('\\n');\n            }\n            catch (e) {\n                if (!FileSystem.isNotExistError(e)) {\n                    throw e;\n                }\n            }\n            if (commonNpmrcFileLines) {\n                extraNpmrcLines.push(...commonNpmrcFileLines);\n            }\n            extraNpmrcLines.push(`global-pnpmfile=${subspace.getSubspaceTempFolderPath()}/${RushConstants.pnpmfileGlobalFilename}`);\n        }\n        // Also copy down the committed .npmrc file, if there is one\n        // \"common\\config\\rush\\.npmrc\" --> \"common\\temp\\.npmrc\"\n        // Also ensure that we remove any old one that may be hanging around\n        const npmrcText = Utilities.syncNpmrc({\n            sourceNpmrcFolder: subspace.getSubspaceConfigFolderPath(),\n            targetNpmrcFolder: subspace.getSubspaceTempFolderPath(),\n            linesToPrepend: extraNpmrcLines,\n            createIfMissing: this.rushConfiguration.subspacesFeatureEnabled,\n            supportEnvVarFallbackSyntax: this.rushConfiguration.isPnpm\n        });\n        this._syncNpmrcAlreadyCalled = true;\n        const npmrcHash = npmrcText\n            ? crypto.createHash('sha1').update(npmrcText).digest('hex')\n            : undefined;\n        if (this.rushConfiguration.isPnpm) {\n            // Copy the committed patches folder if using pnpm\n            const commonTempPnpmPatchesFolder = `${subspace.getSubspaceTempFolderPath()}/${RushConstants.pnpmPatchesFolderName}`;\n            const rushPnpmPatchesFolder = subspace.getSubspacePnpmPatchesFolderPath();\n            let rushPnpmPatches;\n            try {\n                rushPnpmPatches = await FileSystem.readFolderItemsAsync(rushPnpmPatchesFolder);\n            }\n            catch (e) {\n                if (!FileSystem.isNotExistError(e)) {\n                    throw e;\n                }\n            }\n            if (rushPnpmPatches) {\n                await FileSystem.ensureFolderAsync(commonTempPnpmPatchesFolder);\n                const existingPatches = await FileSystem.readFolderItemsAsync(commonTempPnpmPatchesFolder);\n                const copiedPatchNames = new Set();\n                await Async.forEachAsync(rushPnpmPatches, async (patch) => {\n                    const name = patch.name;\n                    const sourcePath = `${rushPnpmPatchesFolder}/${name}`;\n                    if (patch.isFile()) {\n                        await FileSystem.copyFileAsync({\n                            sourcePath,\n                            destinationPath: `${commonTempPnpmPatchesFolder}/${name}`\n                        });\n                        copiedPatchNames.add(name);\n                    }\n                    else {\n                        throw new Error(`Unexpected non-file item found in ${rushPnpmPatchesFolder}: ${sourcePath}`);\n                    }\n                }, { concurrency: 50 });\n                await Async.forEachAsync(existingPatches, async (patch) => {\n                    const name = patch.name;\n                    if (!copiedPatchNames.has(name)) {\n                        await FileSystem.deleteFileAsync(`${commonTempPnpmPatchesFolder}/${name}`);\n                    }\n                }, { concurrency: 50 });\n            }\n            else {\n                await FileSystem.deleteFolderAsync(commonTempPnpmPatchesFolder);\n            }\n        }\n        // Shim support for pnpmfile in.\n        // Additionally when in workspaces, the shim implements support for common versions.\n        if (this.rushConfiguration.isPnpm) {\n            await PnpmfileConfiguration.writeCommonTempPnpmfileShimAsync(this.rushConfiguration, subspace.getSubspaceTempFolderPath(), subspace, variant);\n            if (this.rushConfiguration.subspacesFeatureEnabled) {\n                await SubspacePnpmfileConfiguration.writeCommonTempSubspaceGlobalPnpmfileAsync(this.rushConfiguration, subspace, variant);\n            }\n        }\n        // eslint-disable-next-line prefer-const\n        let [{ shrinkwrapIsUpToDate, shrinkwrapWarnings }, projectImpactGraphIsUpToDate = true] = await Promise.all([\n            // Allow for package managers to do their own preparation and check that the shrinkwrap is up to date\n            this.prepareCommonTempAsync(subspace, shrinkwrapFile),\n            projectImpactGraphGenerator === null || projectImpactGraphGenerator === void 0 ? void 0 : projectImpactGraphGenerator.validateAsync()\n        ]);\n        shrinkwrapIsUpToDate = shrinkwrapIsUpToDate && !this.options.recheckShrinkwrap;\n        this._syncTempShrinkwrap(subspace, variant, shrinkwrapFile);\n        // Write out the reported warnings\n        if (shrinkwrapWarnings.length > 0) {\n            terminal.writeLine();\n            terminal.writeLine(Colorize.yellow(PrintUtilities.wrapWords(`The ${this.rushConfiguration.shrinkwrapFilePhrase} contains the following issues:`)));\n            for (const shrinkwrapWarning of shrinkwrapWarnings) {\n                terminal.writeLine(Colorize.yellow('  ' + shrinkwrapWarning));\n            }\n            terminal.writeLine();\n        }\n        let hasErrors = false;\n        // Force update if the shrinkwrap is out of date\n        if (!shrinkwrapIsUpToDate && !allowShrinkwrapUpdates) {\n            terminal.writeErrorLine();\n            terminal.writeErrorLine(`The ${this.rushConfiguration.shrinkwrapFilePhrase} is out of date. You need to run \"rush update\".`);\n            hasErrors = true;\n        }\n        if (!projectImpactGraphIsUpToDate && !allowShrinkwrapUpdates) {\n            hasErrors = true;\n            terminal.writeErrorLine();\n            terminal.writeErrorLine(Colorize.red(`The ${RushConstants.projectImpactGraphFilename} file is missing or out of date. You need to run \"rush update\".`));\n        }\n        if (hasErrors) {\n            throw new AlreadyReportedError();\n        }\n        return { shrinkwrapIsUpToDate, npmrcHash, projectImpactGraphIsUpToDate, variantIsUpToDate };\n    }\n    /**\n     * Git hooks are only installed if the repo opts in by including files in /common/git-hooks\n     */\n    async _installGitHooksAsync() {\n        const hookSource = path.join(this.rushConfiguration.commonFolder, 'git-hooks');\n        const git = new Git(this.rushConfiguration);\n        const hookDestination = git.getHooksFolder();\n        if (FileSystem.exists(hookSource) && hookDestination) {\n            const allHookFilenames = FileSystem.readFolderItemNames(hookSource);\n            // Ignore the \".sample\" file(s) in this folder.\n            const hookFilenames = allHookFilenames.filter((x) => !/\\.sample$/.test(x));\n            if (hookFilenames.length > 0) {\n                // eslint-disable-next-line no-console\n                console.log('\\n' + Colorize.bold('Found files in the \"common/git-hooks\" folder.'));\n                if (!(await git.getIsHooksPathDefaultAsync())) {\n                    const hooksPath = await git.getConfigHooksPathAsync();\n                    const color = this.options.bypassPolicy ? Colorize.yellow : Colorize.red;\n                    // eslint-disable-next-line no-console\n                    console.error(color([\n                        ' ',\n                        `Rush cannot install the \"common/git-hooks\" scripts because your Git configuration `,\n                        `specifies \"core.hooksPath=${hooksPath}\". You can remove the setting by running:`,\n                        ' ',\n                        '    git config --unset core.hooksPath',\n                        ' '\n                    ].join('\\n')));\n                    if (this.options.bypassPolicy) {\n                        // If \"--bypass-policy\" is specified, skip installation of hooks because Rush doesn't\n                        // own the hooks folder\n                        return;\n                    }\n                    // eslint-disable-next-line no-console\n                    console.error(color([\n                        '(Or, to temporarily ignore this problem, invoke Rush with the ' +\n                            `\"${RushConstants.bypassPolicyFlagLongName}\" option.)`,\n                        ' '\n                    ].join('\\n')));\n                    throw new AlreadyReportedError();\n                }\n                // Clear the currently installed git hooks and install fresh copies\n                FileSystem.ensureEmptyFolder(hookDestination);\n                // Find the relative path from Git hooks directory to the directory storing the actual scripts.\n                const hookRelativePath = Path.convertToSlashes(path.relative(hookDestination, hookSource));\n                // Only copy files that look like Git hook names\n                const filteredHookFilenames = hookFilenames.filter((x) => /^[a-z\\-]+/.test(x));\n                for (const filename of filteredHookFilenames) {\n                    const hookFilePath = `${hookSource}/${filename}`;\n                    // Make sure the actual script in the hookSource directory has correct Linux compatible line endings\n                    const originalHookFileContent = FileSystem.readFile(hookFilePath);\n                    FileSystem.writeFile(hookFilePath, originalHookFileContent, {\n                        convertLineEndings: NewlineKind.Lf\n                    });\n                    // Make sure the actual script in the hookSource directory has required permission bits\n                    const originalPosixModeBits = FileSystem.getPosixModeBits(hookFilePath);\n                    FileSystem.changePosixModeBits(hookFilePath, \n                    // eslint-disable-next-line no-bitwise\n                    originalPosixModeBits | PosixModeBits.UserRead | PosixModeBits.UserExecute);\n                    const gitLfsHookHandling = gitLfsHooks.has(filename)\n                        ? `\n# Inspired by https://github.com/git-lfs/git-lfs/issues/2865#issuecomment-365742940\nif command -v git-lfs &> /dev/null; then\n  git lfs ${filename} \"$@\"\nfi\n`\n                        : '';\n                    const hookFileContent = `#!/bin/bash\nset -e\nSCRIPT_DIR=\"$( cd \"$( dirname \"\\${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\"\nSCRIPT_IMPLEMENTATION_PATH=\"$SCRIPT_DIR/${hookRelativePath}/${filename}\"\n\nif [[ -f \"$SCRIPT_IMPLEMENTATION_PATH\" ]]; then\n  \"$SCRIPT_IMPLEMENTATION_PATH\" $@\nelse\n  echo \"The ${filename} Git hook no longer exists in your version of the repo. Run 'rush install' or 'rush update' to refresh your installed Git hooks.\" >&2\nfi\n${gitLfsHookHandling}\n`;\n                    // Create the hook file.  Important: For Bash scripts, the EOL must not be CRLF.\n                    FileSystem.writeFile(path.join(hookDestination, filename), hookFileContent, {\n                        convertLineEndings: NewlineKind.Lf\n                    });\n                    FileSystem.changePosixModeBits(path.join(hookDestination, filename), \n                    // eslint-disable-next-line no-bitwise\n                    PosixModeBits.UserRead | PosixModeBits.UserExecute);\n                }\n                // eslint-disable-next-line no-console\n                console.log('Successfully installed these Git hook scripts: ' + filteredHookFilenames.join(', ') + '\\n');\n            }\n        }\n    }\n    /**\n     * Used when invoking the NPM tool.  Appends the common configuration options\n     * to the command-line.\n     */\n    pushConfigurationArgs(args, options, subspace) {\n        const { offline, collectLogFile, pnpmFilterArgumentValues, onlyShrinkwrap, networkConcurrency, allowShrinkwrapUpdates, resolutionOnly } = options;\n        if (offline && this.rushConfiguration.packageManager !== 'pnpm') {\n            throw new Error('The \"--offline\" parameter is only supported when using the PNPM package manager.');\n        }\n        if (resolutionOnly && this.rushConfiguration.packageManager !== 'pnpm') {\n            throw new Error('The \"--resolution-only\" parameter is only supported when using the PNPM package manager.');\n        }\n        if (this.rushConfiguration.packageManager === 'npm') {\n            if (semver.lt(this.rushConfiguration.packageManagerToolVersion, '5.0.0')) {\n                // NOTE:\n                //\n                // When using an npm version older than v5.0.0, we do NOT install optional dependencies for\n                // Rush, because npm does not generate the shrinkwrap file consistently across platforms.\n                //\n                // Consider the \"fsevents\" package. This is a Mac specific package\n                // which is an optional second-order dependency. Optional dependencies work by attempting to install\n                // the package, but removes the package if the install failed.\n                // This means that someone running generate on a Mac WILL have fsevents included in their shrinkwrap.\n                // When someone using Windows attempts to install from the shrinkwrap, the install will fail.\n                //\n                // If someone generates the shrinkwrap using Windows, then fsevents will NOT be listed in the shrinkwrap.\n                // When someone using Mac attempts to install from the shrinkwrap, they will NOT have the\n                // optional dependency installed.\n                //\n                // This issue has been fixed as of npm v5.0.0: https://github.com/npm/npm/releases/tag/v5.0.0\n                //\n                // For more context, see https://github.com/microsoft/rushstack/issues/761#issuecomment-428689600\n                args.push('--no-optional');\n            }\n            args.push('--cache', this.rushConfiguration.npmCacheFolder);\n            args.push('--tmp', this.rushConfiguration.npmTmpFolder);\n            if (collectLogFile) {\n                args.push('--verbose');\n            }\n        }\n        else if (this.rushConfiguration.isPnpm) {\n            // Only explicitly define the store path if `pnpmStore` is using the default, or has been set to\n            // 'local'.  If `pnpmStore` = 'global', then allow PNPM to use the system's default\n            // path.  In all cases, this will be overridden by RUSH_PNPM_STORE_PATH\n            if (this.rushConfiguration.pnpmOptions.pnpmStore === 'local' ||\n                EnvironmentConfiguration.pnpmStorePathOverride) {\n                args.push('--store', this.rushConfiguration.pnpmOptions.pnpmStorePath);\n                if (semver.gte(this.rushConfiguration.packageManagerToolVersion, '6.10.0')) {\n                    args.push(`${pnpmCacheDirParameter}=${this.rushConfiguration.pnpmOptions.pnpmStorePath}`);\n                    args.push(`${pnpmStateDirParameter}=${this.rushConfiguration.pnpmOptions.pnpmStorePath}`);\n                }\n            }\n            const { pnpmVerifyStoreIntegrity } = EnvironmentConfiguration;\n            if (pnpmVerifyStoreIntegrity !== undefined) {\n                args.push(`--verify-store-integrity`, `${pnpmVerifyStoreIntegrity}`);\n            }\n            const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;\n            if (experiments.usePnpmFrozenLockfileForRushInstall && !allowShrinkwrapUpdates) {\n                args.push('--frozen-lockfile');\n                if (pnpmFilterArgumentValues.length > 0 &&\n                    Number.parseInt(this.rushConfiguration.packageManagerToolVersion, 10) >= 8 // PNPM Major version 8+\n                ) {\n                    // On pnpm@8, disable the \"dedupe-peer-dependents\" feature when doing a filtered CI install so that filters take effect.\n                    args.push('--config.dedupe-peer-dependents=false');\n                }\n            }\n            else if (experiments.usePnpmPreferFrozenLockfileForRushUpdate) {\n                // In workspaces, we want to avoid unnecessary lockfile churn\n                args.push('--prefer-frozen-lockfile');\n            }\n            else {\n                // Ensure that Rush's tarball dependencies get synchronized properly with the pnpm-lock.yaml file.\n                // See this GitHub issue: https://github.com/pnpm/pnpm/issues/1342\n                args.push('--no-prefer-frozen-lockfile');\n            }\n            if (onlyShrinkwrap) {\n                args.push(`--lockfile-only`);\n            }\n            if (collectLogFile) {\n                args.push('--reporter', 'ndjson');\n            }\n            if (networkConcurrency) {\n                args.push('--network-concurrency', networkConcurrency.toString());\n            }\n            if (offline) {\n                args.push('--offline');\n            }\n            if (this.rushConfiguration.pnpmOptions.strictPeerDependencies === false) {\n                args.push('--no-strict-peer-dependencies');\n            }\n            else {\n                args.push('--strict-peer-dependencies');\n            }\n            if (resolutionOnly) {\n                args.push('--resolution-only');\n            }\n            /*\n              If user set auto-install-peers in pnpm-config.json only, use the value in pnpm-config.json\n              If user set auto-install-peers in pnpm-config.json and .npmrc, use the value in pnpm-config.json\n              If user set auto-install-peers in .npmrc only, do nothing, let pnpm handle it\n              If user does not set auto-install-peers in both pnpm-config.json and .npmrc, rush will default it to \"false\"\n            */\n            const isAutoInstallPeersInNpmrc = isVariableSetInNpmrcFile(subspace.getSubspaceConfigFolderPath(), 'auto-install-peers', this.rushConfiguration.isPnpm);\n            let autoInstallPeers = this.rushConfiguration.pnpmOptions.autoInstallPeers;\n            if (autoInstallPeers !== undefined) {\n                if (isAutoInstallPeersInNpmrc) {\n                    this._terminal.writeWarningLine(`Warning: PNPM's auto-install-peers is specified in both .npmrc and pnpm-config.json. ` +\n                        `The value in pnpm-config.json will take precedence.`);\n                }\n            }\n            else if (!isAutoInstallPeersInNpmrc) {\n                // if auto-install-peers isn't specified in either .npmrc or pnpm-config.json,\n                // then rush will default it to \"false\"\n                autoInstallPeers = false;\n            }\n            if (autoInstallPeers !== undefined) {\n                args.push(`--config.auto-install-peers=${autoInstallPeers}`);\n            }\n            /*\n              If user set resolution-mode in pnpm-config.json only, use the value in pnpm-config.json\n              If user set resolution-mode in pnpm-config.json and .npmrc, use the value in pnpm-config.json\n              If user set resolution-mode in .npmrc only, do nothing, let pnpm handle it\n              If user does not set resolution-mode in pnpm-config.json and .npmrc, rush will default it to \"highest\"\n            */\n            const isResolutionModeInNpmrc = isVariableSetInNpmrcFile(subspace.getSubspaceConfigFolderPath(), 'resolution-mode', this.rushConfiguration.isPnpm);\n            let resolutionMode = this.rushConfiguration.pnpmOptions.resolutionMode;\n            if (resolutionMode) {\n                if (isResolutionModeInNpmrc) {\n                    this._terminal.writeWarningLine(`Warning: PNPM's resolution-mode is specified in both .npmrc and pnpm-config.json. ` +\n                        `The value in pnpm-config.json will take precedence.`);\n                }\n            }\n            else if (!isResolutionModeInNpmrc) {\n                // if resolution-mode isn't specified in either .npmrc or pnpm-config.json,\n                // then rush will default it to \"highest\"\n                resolutionMode = 'highest';\n            }\n            if (resolutionMode) {\n                args.push(`--config.resolutionMode=${resolutionMode}`);\n            }\n            if (semver.satisfies(this.rushConfiguration.packageManagerToolVersion, '6.32.12 - 6.33.x || 7.0.1 - 7.8.x')) {\n                this._terminal.writeWarningLine(`Warning: Your ${RushConstants.rushJsonFilename} specifies a pnpmVersion with a known issue ` +\n                    'that may cause unintended version selections.' +\n                    \" It's recommended to upgrade to PNPM >=6.34.0 or >=7.9.0. \" +\n                    'For details see: https://rushjs.io/link/pnpm-issue-5132');\n            }\n            if (semver.gte(this.rushConfiguration.packageManagerToolVersion, '7.9.0') ||\n                semver.satisfies(this.rushConfiguration.packageManagerToolVersion, '^6.34.0')) {\n                args.push(pnpmIgnoreCompatibilityDbParameter);\n            }\n        }\n        else if (this.rushConfiguration.packageManager === 'yarn') {\n            args.push('--link-folder', 'yarn-link');\n            args.push('--cache-folder', this.rushConfiguration.yarnCacheFolder);\n            // Without this option, Yarn will sometimes stop and ask for user input on STDIN\n            // (e.g. \"Which command would you like to run?\").\n            args.push('--non-interactive');\n            if (networkConcurrency) {\n                args.push('--network-concurrency', networkConcurrency.toString());\n            }\n            if (this.rushConfiguration.yarnOptions.ignoreEngines) {\n                args.push('--ignore-engines');\n            }\n            if (collectLogFile) {\n                args.push('--verbose');\n            }\n        }\n    }\n    async _checkIfReleaseIsPublishedAsync() {\n        const lastCheckFile = path.join(this.rushGlobalFolder.nodeSpecificPath, 'rush-' + Rush.version, 'last-check.flag');\n        if (FileSystem.exists(lastCheckFile)) {\n            let cachedResult = undefined;\n            try {\n                // NOTE: mtimeMs is not supported yet in Node.js 6.x\n                const nowMs = new Date().getTime();\n                const ageMs = nowMs - FileSystem.getStatistics(lastCheckFile).mtime.getTime();\n                const HOUR = 60 * 60 * 1000;\n                // Is the cache too old?\n                if (ageMs < 24 * HOUR) {\n                    // No, read the cached result\n                    cachedResult = JsonFile.load(lastCheckFile);\n                }\n            }\n            catch (e) {\n                // Unable to parse file\n            }\n            if (cachedResult === 'error') {\n                throw new Error('Unable to contact server');\n            }\n            if (cachedResult === true || cachedResult === false) {\n                return cachedResult;\n            }\n        }\n        // Before we start the network operation, record a failed state.  If the process exits for some reason,\n        // this will record the error.  It will also update the timestamp to prevent other Rush instances\n        // from attempting to update the file.\n        await JsonFile.saveAsync('error', lastCheckFile, { ensureFolderExists: true });\n        try {\n            // For this check we use the official registry, not the private registry\n            const publishedRelease = await this._queryIfReleaseIsPublishedAsync('https://registry.npmjs.org:443');\n            // Cache the result\n            await JsonFile.saveAsync(publishedRelease, lastCheckFile, { ensureFolderExists: true });\n            return publishedRelease;\n        }\n        catch (error) {\n            await JsonFile.saveAsync('error', lastCheckFile, { ensureFolderExists: true });\n            throw error;\n        }\n    }\n    // Helper for checkIfReleaseIsPublished()\n    async _queryIfReleaseIsPublishedAsync(registryUrl) {\n        let queryUrl = registryUrl;\n        if (queryUrl[-1] !== '/') {\n            queryUrl += '/';\n        }\n        // Note that the \"@\" symbol does not normally get URL-encoded\n        queryUrl += RushConstants.rushPackageName.replace('/', '%2F');\n        const { WebClient } = await import('../../utilities/WebClient');\n        const webClient = new WebClient();\n        webClient.userAgent = `pnpm/? npm/? node/${process.version} ${os.platform()} ${os.arch()}`;\n        webClient.accept = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';\n        const response = await webClient.fetchAsync(queryUrl);\n        if (!response.ok) {\n            throw new Error('Failed to query');\n        }\n        const data = await response.getJsonAsync();\n        let url;\n        try {\n            if (!data.versions[Rush.version]) {\n                // Version was not published\n                return false;\n            }\n            url = data.versions[Rush.version].dist.tarball;\n            if (!url) {\n                throw new Error(`URL not found`);\n            }\n        }\n        catch (e) {\n            throw new Error('Error parsing response');\n        }\n        // Make sure the tarball wasn't deleted from the CDN\n        webClient.accept = '*/*';\n        const response2 = await webClient.fetchAsync(url);\n        if (!response2.ok) {\n            if (response2.status === 404) {\n                return false;\n            }\n            else {\n                throw new Error('Failed to fetch');\n            }\n        }\n        return true;\n    }\n    _syncTempShrinkwrap(subspace, variant, shrinkwrapFile) {\n        const committedShrinkwrapFileName = subspace.getCommittedShrinkwrapFilePath(variant);\n        if (shrinkwrapFile) {\n            Utilities.syncFile(committedShrinkwrapFileName, subspace.getTempShrinkwrapFilename());\n            Utilities.syncFile(committedShrinkwrapFileName, subspace.getTempShrinkwrapPreinstallFilename());\n        }\n        else {\n            // Otherwise delete the temporary file\n            FileSystem.deleteFile(subspace.getTempShrinkwrapFilename());\n            if (this.rushConfiguration.isPnpm) {\n                // Workaround for https://github.com/pnpm/pnpm/issues/1890\n                //\n                // When \"rush update --full\" is run, Rush deletes \"common/temp/pnpm-lock.yaml\"\n                // so that a new lockfile will be generated. However \"pnpm install\" by design will try to recover\n                // \"pnpm-lock.yaml\" from \"common/temp/node_modules/.pnpm/lock.yaml\", which may prevent a full upgrade.\n                // Deleting both files ensures that a new lockfile will always be generated.\n                const pnpmPackageManager = this.rushConfiguration\n                    .packageManagerWrapper;\n                FileSystem.deleteFile(path.join(subspace.getSubspaceTempFolderPath(), pnpmPackageManager.internalShrinkwrapRelativePath));\n            }\n        }\n    }\n    async validateNpmSetupAsync() {\n        if (this._npmSetupValidated) {\n            return;\n        }\n        if (!this.options.bypassPolicy) {\n            const setupPackageRegistry = new SetupPackageRegistry({\n                rushConfiguration: this.rushConfiguration,\n                isDebug: this.options.debug,\n                syncNpmrcAlreadyCalled: this._syncNpmrcAlreadyCalled\n            });\n            const valid = await setupPackageRegistry.checkOnlyAsync();\n            if (!valid) {\n                // eslint-disable-next-line no-console\n                console.error();\n                // eslint-disable-next-line no-console\n                console.error(Colorize.red('ERROR: NPM credentials are missing or expired'));\n                // eslint-disable-next-line no-console\n                console.error();\n                // eslint-disable-next-line no-console\n                console.error(Colorize.bold('==> Please run \"rush setup\" to update your NPM token. ' +\n                    `(Or append \"${RushConstants.bypassPolicyFlagLongName}\" to proceed anyway.)`));\n                throw new AlreadyReportedError();\n            }\n        }\n        this._npmSetupValidated = true;\n    }\n}\n//# sourceMappingURL=BaseInstallManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, InternalError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { Utilities } from '../../utilities/Utilities';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport { RushConstants } from '../RushConstants';\nimport { FlagFile } from '../../api/FlagFile';\nexport var SymlinkKind;\n(function (SymlinkKind) {\n    SymlinkKind[SymlinkKind[\"File\"] = 0] = \"File\";\n    SymlinkKind[SymlinkKind[\"Directory\"] = 1] = \"Directory\";\n})(SymlinkKind || (SymlinkKind = {}));\nexport class BaseLinkManager {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    static _createSymlink(options) {\n        const newLinkFolder = path.dirname(options.newLinkPath);\n        FileSystem.ensureFolder(newLinkFolder);\n        let targetPath;\n        if (EnvironmentConfiguration.absoluteSymlinks) {\n            targetPath = options.linkTargetPath;\n        }\n        else {\n            // Link to the relative path, to avoid going outside containers such as a Docker image\n            targetPath = path.relative(FileSystem.getRealPath(newLinkFolder), options.linkTargetPath);\n        }\n        if (process.platform === 'win32') {\n            if (options.symlinkKind === SymlinkKind.Directory) {\n                // For directories, we use a Windows \"junction\".  On Unix, this produces a regular symlink.\n                FileSystem.createSymbolicLinkJunction({\n                    linkTargetPath: targetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n            else {\n                // For files, we use a Windows \"hard link\", because creating a symbolic link requires\n                // administrator permission.\n                // NOTE: We cannot use the relative path for hard links\n                FileSystem.createHardLink({\n                    linkTargetPath: options.linkTargetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n        }\n        else {\n            // However hard links seem to cause build failures on Mac, so for all other operating systems\n            // we use symbolic links for this case.\n            if (options.symlinkKind === SymlinkKind.Directory) {\n                FileSystem.createSymbolicLinkFolder({\n                    linkTargetPath: targetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n            else {\n                FileSystem.createSymbolicLinkFile({\n                    linkTargetPath: targetPath,\n                    newLinkPath: options.newLinkPath\n                });\n            }\n        }\n    }\n    /**\n     * For a Package object that represents a top-level Rush project folder\n     * (i.e. with source code that we will be building), this clears out its\n     * node_modules folder and then recursively creates all the symlinked folders.\n     */\n    static _createSymlinksForTopLevelProject(localPackage) {\n        const localModuleFolder = path.join(localPackage.folderPath, 'node_modules');\n        // Sanity check\n        if (localPackage.parent) {\n            throw new Error('The provided package is not a top-level project');\n        }\n        // The root-level folder is the project itself, so we simply delete its node_modules\n        // to start clean\n        // eslint-disable-next-line no-console\n        console.log('Purging ' + localModuleFolder);\n        Utilities.dangerouslyDeletePath(localModuleFolder);\n        if (localPackage.children.length > 0) {\n            Utilities.createFolderWithRetry(localModuleFolder);\n            for (const child of localPackage.children) {\n                BaseLinkManager._createSymlinksForDependencies(child);\n            }\n        }\n    }\n    /**\n     * This is a helper function used by createSymlinksForTopLevelProject().\n     * It will recursively creates symlinked folders corresponding to each of the\n     * Package objects in the provided tree.\n     */\n    static _createSymlinksForDependencies(localPackage) {\n        const localModuleFolder = path.join(localPackage.folderPath, 'node_modules');\n        if (!localPackage.symlinkTargetFolderPath) {\n            throw new InternalError('localPackage.symlinkTargetFolderPath was not assigned');\n        }\n        // This is special case for when localPackage.name has the form '@scope/name',\n        // in which case we need to create the '@scope' folder first.\n        const parentFolderPath = path.dirname(localPackage.folderPath);\n        if (parentFolderPath && parentFolderPath !== localPackage.folderPath) {\n            if (!FileSystem.exists(parentFolderPath)) {\n                Utilities.createFolderWithRetry(parentFolderPath);\n            }\n        }\n        if (localPackage.children.length === 0) {\n            // If there are no children, then we can symlink the entire folder\n            BaseLinkManager._createSymlink({\n                linkTargetPath: localPackage.symlinkTargetFolderPath,\n                newLinkPath: localPackage.folderPath,\n                symlinkKind: SymlinkKind.Directory\n            });\n        }\n        else {\n            // If there are children, then we need to symlink each item in the folder individually\n            Utilities.createFolderWithRetry(localPackage.folderPath);\n            for (const filename of FileSystem.readFolderItemNames(localPackage.symlinkTargetFolderPath)) {\n                if (filename.toLowerCase() !== 'node_modules') {\n                    // Create the symlink\n                    let symlinkKind = SymlinkKind.File;\n                    const linkSource = path.join(localPackage.folderPath, filename);\n                    let linkTarget = path.join(localPackage.symlinkTargetFolderPath, filename);\n                    const linkStats = FileSystem.getLinkStatistics(linkTarget);\n                    if (linkStats.isSymbolicLink()) {\n                        const targetStats = FileSystem.getStatistics(FileSystem.getRealPath(linkTarget));\n                        if (targetStats.isDirectory()) {\n                            // Neither a junction nor a directory-symlink can have a directory-symlink\n                            // as its target; instead, we must obtain the real physical path.\n                            // A junction can link to another junction.  Unfortunately, the node 'fs' API\n                            // lacks the ability to distinguish between a junction and a directory-symlink\n                            // (even though it has the ability to create them both), so the safest policy\n                            // is to always make a junction and always to the real physical path.\n                            linkTarget = FileSystem.getRealPath(linkTarget);\n                            symlinkKind = SymlinkKind.Directory;\n                        }\n                    }\n                    else if (linkStats.isDirectory()) {\n                        symlinkKind = SymlinkKind.Directory;\n                    }\n                    BaseLinkManager._createSymlink({\n                        linkTargetPath: linkTarget,\n                        newLinkPath: linkSource,\n                        symlinkKind\n                    });\n                }\n            }\n        }\n        if (localPackage.children.length > 0) {\n            Utilities.createFolderWithRetry(localModuleFolder);\n            for (const child of localPackage.children) {\n                BaseLinkManager._createSymlinksForDependencies(child);\n            }\n        }\n    }\n    /**\n     * Creates node_modules symlinks for all Rush projects defined in the RushConfiguration.\n     * @param force - Normally the operation will be skipped if the links are already up to date;\n     *   if true, this option forces the links to be recreated.\n     */\n    async createSymlinksForProjectsAsync(force) {\n        // eslint-disable-next-line no-console\n        console.log('\\n' + Colorize.bold('Linking local projects'));\n        const stopwatch = Stopwatch.start();\n        await this._linkProjectsAsync();\n        // TODO: Remove when \"rush link\" and \"rush unlink\" are deprecated\n        await new FlagFile(this._rushConfiguration.defaultSubspace.getSubspaceTempFolderPath(), RushConstants.lastLinkFlagFilename, {}).createAsync();\n        stopwatch.stop();\n        // eslint-disable-next-line no-console\n        console.log('\\n' + Colorize.green(`Linking finished successfully. (${stopwatch.toString()})`));\n        // eslint-disable-next-line no-console\n        console.log('\\nNext you should probably run \"rush build\" or \"rush rebuild\"');\n    }\n}\n//# sourceMappingURL=BaseLinkManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem } from '@rushstack/node-core-library';\n/**\n * This class is a parser for pnpm's pnpm-workspace.yaml file format.\n */\nexport class BaseWorkspaceFile {\n    constructor() {\n        this._alreadyWarnedSpecs = new Set();\n    }\n    /**\n     * Serializes and saves the workspace file to specified location\n     */\n    save(filePath, options) {\n        // Do we need to read the previous file contents?\n        let oldBuffer = undefined;\n        if (options.onlyIfChanged && FileSystem.exists(filePath)) {\n            try {\n                oldBuffer = FileSystem.readFileToBuffer(filePath);\n            }\n            catch (error) {\n                // Ignore this error, and try writing a new file.  If that fails, then we should report that\n                // error instead.\n            }\n        }\n        const newYaml = this.serialize();\n        const newBuffer = Buffer.from(newYaml); // utf8 encoding happens here\n        if (options.onlyIfChanged) {\n            // Has the file changed?\n            if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {\n                // Nothing has changed, so don't touch the file\n                return;\n            }\n        }\n        FileSystem.writeFile(filePath, newBuffer.toString(), {\n            ensureFolderExists: options.ensureFolderExists\n        });\n    }\n}\n//# sourceMappingURL=BaseWorkspaceFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport yaml from 'js-yaml';\nimport { FileSystem, FileConstants, AlreadyReportedError, Async, Path, Sort } from '@rushstack/node-core-library';\nimport { createHash } from 'crypto';\nimport { BaseInstallManager } from '../base/BaseInstallManager';\nimport { DependencySpecifier, DependencySpecifierType } from '../DependencySpecifier';\nimport { DependencyType } from '../../api/PackageJsonEditor';\nimport { PnpmWorkspaceFile } from '../pnpm/PnpmWorkspaceFile';\nimport { RushConstants } from '../RushConstants';\nimport { Utilities } from '../../utilities/Utilities';\nimport { InstallHelpers } from './InstallHelpers';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport { ShrinkwrapFileFactory } from '../ShrinkwrapFileFactory';\nimport { BaseProjectShrinkwrapFile } from '../base/BaseProjectShrinkwrapFile';\nimport { PNPM_CUSTOM_TIPS } from '../../api/CustomTipsConfiguration';\nimport { objectsAreDeepEqual } from '../../utilities/objectUtilities';\nimport { Colorize, ConsoleTerminalProvider } from '@rushstack/terminal';\nimport { BaseLinkManager, SymlinkKind } from '../base/BaseLinkManager';\nimport { FlagFile } from '../../api/FlagFile';\nimport { Stopwatch } from '../../utilities/Stopwatch';\n/**\n * This class implements common logic between \"rush install\" and \"rush update\".\n */\nexport class WorkspaceInstallManager extends BaseInstallManager {\n    /**\n     * @override\n     */\n    async doInstallAsync() {\n        // TODO: Remove when \"rush link\" and \"rush unlink\" are deprecated\n        if (this.options.noLink) {\n            // eslint-disable-next-line no-console\n            console.log(Colorize.red('The \"--no-link\" option was provided but is not supported when using workspaces. Run the command again ' +\n                'without specifying this argument.'));\n            throw new AlreadyReportedError();\n        }\n        await super.doInstallAsync();\n    }\n    /**\n     * Regenerates the common/temp/package.json and related workspace files.\n     * If shrinkwrapFile is provided, this function also validates whether it contains\n     * everything we need to install and returns true if so; in all other cases,\n     * the return value is false.\n     *\n     * @override\n     */\n    async prepareCommonTempAsync(subspace, shrinkwrapFile) {\n        var _a;\n        // Block use of the RUSH_TEMP_FOLDER environment variable\n        if (EnvironmentConfiguration.rushTempFolderOverride !== undefined) {\n            throw new Error('The RUSH_TEMP_FOLDER environment variable is not compatible with workspace installs. If attempting ' +\n                'to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.');\n        }\n        const { fullUpgrade, allowShrinkwrapUpdates, variant } = this.options;\n        // eslint-disable-next-line no-console\n        console.log('\\n' + Colorize.bold('Updating workspace files in ' + subspace.getSubspaceTempFolderPath()));\n        const shrinkwrapWarnings = [];\n        // We will start with the assumption that it's valid, and then set it to false if\n        // any of the checks fail\n        let shrinkwrapIsUpToDate = true;\n        if (!shrinkwrapFile) {\n            shrinkwrapIsUpToDate = false;\n        }\n        else {\n            if (!shrinkwrapFile.isWorkspaceCompatible && !fullUpgrade) {\n                // eslint-disable-next-line no-console\n                console.log();\n                // eslint-disable-next-line no-console\n                console.log(Colorize.red('The shrinkwrap file has not been updated to support workspaces. Run \"rush update --full\" to update ' +\n                    'the shrinkwrap file.'));\n                throw new AlreadyReportedError();\n            }\n            // If there are orphaned projects, we need to update\n            const orphanedProjects = shrinkwrapFile.findOrphanedProjects(this.rushConfiguration, subspace);\n            if (orphanedProjects.length > 0) {\n                for (const orphanedProject of orphanedProjects) {\n                    shrinkwrapWarnings.push(`Your ${this.rushConfiguration.shrinkwrapFilePhrase} references \"${orphanedProject}\" ` +\n                        `which was not found in ${RushConstants.rushJsonFilename}`);\n                }\n                shrinkwrapIsUpToDate = false;\n            }\n        }\n        // If preferred versions have been updated, or if the repo-state.json is invalid,\n        // we can't be certain of the state of the shrinkwrap\n        const repoState = subspace.getRepoState();\n        if (!repoState.isValid) {\n            shrinkwrapWarnings.push(`The ${RushConstants.repoStateFilename} file is invalid. There may be a merge conflict marker in the file.`);\n            shrinkwrapIsUpToDate = false;\n        }\n        else {\n            const commonVersions = subspace.getCommonVersions(variant);\n            if (repoState.preferredVersionsHash !== commonVersions.getPreferredVersionsHash()) {\n                shrinkwrapWarnings.push(`Preferred versions from ${RushConstants.commonVersionsFilename} have been modified.`);\n                shrinkwrapIsUpToDate = false;\n            }\n            const stopwatch = Stopwatch.start();\n            const packageJsonInjectedDependenciesHash = subspace.getPackageJsonInjectedDependenciesHash(variant);\n            stopwatch.stop();\n            this._terminal.writeDebugLine(`Total amount of time spent to hash related package.json files in the injected installation case: ${stopwatch.toString()}`);\n            if (packageJsonInjectedDependenciesHash) {\n                // if packageJsonInjectedDependenciesHash exists\n                // make sure it matches the value in repoState\n                if (packageJsonInjectedDependenciesHash !== repoState.packageJsonInjectedDependenciesHash) {\n                    shrinkwrapWarnings.push(`Some injected dependencies' package.json might have been modified.`);\n                    shrinkwrapIsUpToDate = false;\n                }\n            }\n            else {\n                // if packageJsonInjectedDependenciesHash not exists\n                // there is a situation that the subspace previously has injected dependencies but removed\n                // so we can check if the repoState up to date\n                if (repoState.packageJsonInjectedDependenciesHash !== undefined) {\n                    shrinkwrapWarnings.push(`It was detected that ${repoState.filePath} contains packageJsonInjectedDependenciesHash` +\n                        ' but the injected dependencies feature is not enabled. You can manually remove this field in repo-state.json.' +\n                        ' Or run rush update command to update the repo-state.json file.');\n                }\n            }\n        }\n        // To generate the workspace file, we will add each project to the file as we loop through and validate\n        const workspaceFile = new PnpmWorkspaceFile(path.join(subspace.getSubspaceTempFolderPath(), 'pnpm-workspace.yaml'));\n        // For pnpm package manager, we need to handle dependenciesMeta changes in package.json. See more: https://pnpm.io/package_json#dependenciesmeta\n        // If dependenciesMeta settings is different between package.json and pnpm-lock.yaml, then shrinkwrapIsUpToDate return false.\n        // Build a object for dependenciesMeta settings in projects' package.json\n        // key is the package path, value is the dependenciesMeta info for that package\n        const expectedDependenciesMetaByProjectRelativePath = {};\n        const commonTempFolder = subspace.getSubspaceTempFolderPath();\n        const rushJsonFolder = this.rushConfiguration.rushJsonFolder;\n        // get the relative path from common temp folder to repo root folder\n        const relativeFromTempFolderToRootFolder = path.relative(commonTempFolder, rushJsonFolder);\n        // Loop through the projects and add them to the workspace file. While we're at it, also validate that\n        // referenced workspace projects are valid, and check if the shrinkwrap file is already up-to-date.\n        for (const rushProject of this.rushConfiguration.projects) {\n            if (!subspace.contains(rushProject)) {\n                // skip processing any project that isn't in this subspace\n                continue;\n            }\n            const packageJson = rushProject.packageJsonEditor;\n            workspaceFile.addPackage(rushProject.projectFolder);\n            for (const { name, version, dependencyType } of [\n                ...packageJson.dependencyList,\n                ...packageJson.devDependencyList\n            ]) {\n                // Allow the package manager to handle peer dependency resolution, since this is simply a constraint\n                // enforced by the package manager. Additionally, peer dependencies are simply a version constraint\n                // and do not need to be converted to workspaces protocol.\n                if (dependencyType === DependencyType.Peer) {\n                    continue;\n                }\n                const dependencySpecifier = new DependencySpecifier(name, version);\n                // Is there a locally built Rush project that could satisfy this dependency?\n                let referencedLocalProject = this.rushConfiguration.getProjectByName(name);\n                // If we enable exemptDecoupledDependenciesBetweenSubspaces, it will only check dependencies within the subspace.\n                if (this.rushConfiguration.experimentsConfiguration.configuration\n                    .exemptDecoupledDependenciesBetweenSubspaces) {\n                    if (referencedLocalProject && !subspace.contains(referencedLocalProject)) {\n                        referencedLocalProject = undefined;\n                    }\n                }\n                // Validate that local projects are referenced with workspace notation. If not, and it is not a\n                // cyclic dependency, then it needs to be updated to specify `workspace:*` explicitly. Currently only\n                // supporting versions and version ranges for specifying a local project.\n                if ((dependencySpecifier.specifierType === DependencySpecifierType.Version ||\n                    dependencySpecifier.specifierType === DependencySpecifierType.Range) &&\n                    referencedLocalProject &&\n                    !rushProject.decoupledLocalDependencies.has(name)) {\n                    // Make sure that this version is intended to target a local package. If not, then we will fail since it\n                    // is not explicitly specified as a cyclic dependency.\n                    if (!semver.satisfies(referencedLocalProject.packageJsonEditor.version, dependencySpecifier.versionSpecifier)) {\n                        // eslint-disable-next-line no-console\n                        console.log();\n                        // eslint-disable-next-line no-console\n                        console.log(Colorize.red(`\"${rushProject.packageName}\" depends on package \"${name}\" (${version}) which belongs to ` +\n                            'the workspace but cannot be fulfilled with the specified version range. Either ' +\n                            'specify a valid version range, or add the package to \"decoupledLocalDependencies\" in rush.json.'));\n                        throw new AlreadyReportedError();\n                    }\n                    if (!allowShrinkwrapUpdates) {\n                        // eslint-disable-next-line no-console\n                        console.log();\n                        // eslint-disable-next-line no-console\n                        console.log(Colorize.red(`\"${rushProject.packageName}\" depends on package \"${name}\" (${version}) which exists within ` +\n                            'the workspace. Run \"rush update\" to update workspace references for this package. ' +\n                            `If package \"${name}\" is intentionally expected to be installed from an external package feed, ` +\n                            `list package \"${name}\" in the \"decoupledLocalDependencies\" field in the ` +\n                            `\"${rushProject.packageName}\" entry in rush.json to suppress this error.`));\n                        throw new AlreadyReportedError();\n                    }\n                    if (fullUpgrade) {\n                        // We will update to `workspace` notation. If the version specified is a range, then use the provided range.\n                        // Otherwise, use `workspace:*` to ensure we're always using the workspace package.\n                        const workspaceRange = !!semver.validRange(dependencySpecifier.versionSpecifier) &&\n                            !semver.valid(dependencySpecifier.versionSpecifier)\n                            ? dependencySpecifier.versionSpecifier\n                            : '*';\n                        packageJson.addOrUpdateDependency(name, `workspace:${workspaceRange}`, dependencyType);\n                        shrinkwrapIsUpToDate = false;\n                        continue;\n                    }\n                }\n                else if (dependencySpecifier.specifierType === DependencySpecifierType.Workspace &&\n                    rushProject.decoupledLocalDependencies.has(name)) {\n                    // If the dependency is a local project that is decoupled, then we need to ensure that it is not specified\n                    // as a workspace project. If it is, then we need to update the package.json to remove the workspace notation.\n                    this._terminal.writeWarningLine(`\"${rushProject.packageName}\" depends on package ${name}@${version}, but also lists it in ` +\n                        `its \"decoupledLocalDependencies\" array. Either update the host project's package.json to use ` +\n                        `a version from an external feed instead of \"workspace:\" notation, or remove the dependency from the ` +\n                        `host project's \"decoupledLocalDependencies\" array in rush.json.`);\n                    throw new AlreadyReportedError();\n                }\n                else if (!rushProject.decoupledLocalDependencies.has(name)) {\n                    // Already specified as a local project. Allow the package manager to validate this\n                    continue;\n                }\n            }\n            // Save the package.json if we modified the version references and warn that the package.json was modified\n            if (packageJson.saveIfModified()) {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.yellow(`\"${rushProject.packageName}\" depends on one or more workspace packages which did not use \"workspace:\" ` +\n                    'notation. The package.json has been modified and must be committed to source control.'));\n            }\n            // Now validate that the shrinkwrap file matches what is in the package.json\n            if (await (shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.isWorkspaceProjectModifiedAsync(rushProject, subspace, variant))) {\n                shrinkwrapWarnings.push(`Dependencies of project \"${rushProject.packageName}\" do not match the current shrinkwrap.`);\n                shrinkwrapIsUpToDate = false;\n            }\n            const dependencyMetaList = packageJson.dependencyMetaList;\n            if (dependencyMetaList.length !== 0) {\n                const dependenciesMeta = {};\n                for (const dependencyMeta of dependencyMetaList) {\n                    dependenciesMeta[dependencyMeta.name] = {\n                        injected: dependencyMeta.injected\n                    };\n                }\n                // get the relative path from common temp folder to package folder, to align with the value in pnpm-lock.yaml\n                const relativePathFromTempFolderToPackageFolder = Path.convertToSlashes(`${relativeFromTempFolderToRootFolder}/${rushProject.projectRelativeFolder}`);\n                expectedDependenciesMetaByProjectRelativePath[relativePathFromTempFolderToPackageFolder] =\n                    dependenciesMeta;\n            }\n        }\n        // Build a object for dependenciesMeta settings in pnpm-lock.yaml\n        // key is the package path, value is the dependenciesMeta info for that package\n        const lockfileDependenciesMetaByProjectRelativePath = {};\n        if ((shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.importers) !== undefined) {\n            for (const [key, value] of shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.importers) {\n                const projectRelativePath = Path.convertToSlashes(key);\n                // we only need to verify packages that exist in package.json and pnpm-lock.yaml\n                // PNPM won't actively remove deleted packages in importers, unless it has to\n                // so it is possible that a deleted package still showing in pnpm-lock.yaml\n                if (expectedDependenciesMetaByProjectRelativePath[projectRelativePath] === undefined) {\n                    continue;\n                }\n                if (value.dependenciesMeta !== undefined) {\n                    lockfileDependenciesMetaByProjectRelativePath[projectRelativePath] = value.dependenciesMeta;\n                }\n            }\n        }\n        // Now, we compare these two objects to see if they are equal or not\n        const dependenciesMetaAreEqual = objectsAreDeepEqual(expectedDependenciesMetaByProjectRelativePath, lockfileDependenciesMetaByProjectRelativePath);\n        if (!dependenciesMetaAreEqual) {\n            shrinkwrapWarnings.push(\"The dependenciesMeta settings in one or more package.json don't match the current shrinkwrap.\");\n            shrinkwrapIsUpToDate = false;\n        }\n        // Check if overrides and globalOverrides are the same\n        const pnpmOptions = subspace.getPnpmOptions() || this.rushConfiguration.pnpmOptions;\n        const overridesAreEqual = objectsAreDeepEqual((_a = pnpmOptions.globalOverrides) !== null && _a !== void 0 ? _a : {}, (shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.overrides) ? Object.fromEntries(shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.overrides) : {});\n        if (!overridesAreEqual) {\n            shrinkwrapWarnings.push(\"The overrides settings doesn't match the current shrinkwrap.\");\n            shrinkwrapIsUpToDate = false;\n        }\n        // Check if packageExtensionsChecksum matches globalPackageExtension's hash\n        const packageExtensionsChecksum = this._getPackageExtensionChecksum(pnpmOptions.globalPackageExtensions);\n        const packageExtensionsChecksumAreEqual = packageExtensionsChecksum === (shrinkwrapFile === null || shrinkwrapFile === void 0 ? void 0 : shrinkwrapFile.packageExtensionsChecksum);\n        if (!packageExtensionsChecksumAreEqual) {\n            shrinkwrapWarnings.push(\"The package extension hash doesn't match the current shrinkwrap.\");\n            shrinkwrapIsUpToDate = false;\n        }\n        // Write the common package.json\n        InstallHelpers.generateCommonPackageJson(this.rushConfiguration, subspace, undefined, this._terminal);\n        // Save the generated workspace file. Don't update the file timestamp unless the content has changed,\n        // since \"rush install\" will consider this timestamp\n        workspaceFile.save(workspaceFile.workspaceFilename, { onlyIfChanged: true });\n        return { shrinkwrapIsUpToDate, shrinkwrapWarnings };\n    }\n    _getPackageExtensionChecksum(packageExtensions) {\n        // https://github.com/pnpm/pnpm/blob/ba9409ffcef0c36dc1b167d770a023c87444822d/pkg-manager/core/src/install/index.ts#L331\n        const packageExtensionsChecksum = Object.keys(packageExtensions !== null && packageExtensions !== void 0 ? packageExtensions : {}).length === 0\n            ? undefined\n            : createObjectChecksum(packageExtensions);\n        return packageExtensionsChecksum;\n    }\n    async canSkipInstallAsync(lastModifiedDate, subspace, variant) {\n        if (!(await super.canSkipInstallAsync(lastModifiedDate, subspace, variant))) {\n            return false;\n        }\n        const potentiallyChangedFiles = [];\n        if (this.rushConfiguration.isPnpm) {\n            // Add workspace file. This file is only modified when workspace packages change.\n            const pnpmWorkspaceFilename = path.join(subspace.getSubspaceTempFolderPath(), 'pnpm-workspace.yaml');\n            if (FileSystem.exists(pnpmWorkspaceFilename)) {\n                potentiallyChangedFiles.push(pnpmWorkspaceFilename);\n            }\n        }\n        // Also consider timestamps for all the project node_modules folders, as well as the package.json\n        // files\n        // Example: [ \"C:\\MyRepo\\projects\\projectA\\node_modules\", \"C:\\MyRepo\\projects\\projectA\\package.json\" ]\n        potentiallyChangedFiles.push(...subspace.getProjects().map((project) => {\n            return path.join(project.projectFolder, RushConstants.nodeModulesFolderName);\n        }), ...subspace.getProjects().map((project) => {\n            return path.join(project.projectFolder, FileConstants.PackageJson);\n        }));\n        // NOTE: If any of the potentiallyChangedFiles does not exist, then isFileTimestampCurrent()\n        // returns false.\n        return Utilities.isFileTimestampCurrentAsync(lastModifiedDate, potentiallyChangedFiles);\n    }\n    /**\n     * Runs \"pnpm install\" in the common folder.\n     */\n    async installAsync(cleanInstall, subspace) {\n        // Example: \"C:\\MyRepo\\common\\temp\\npm-local\\node_modules\\.bin\\npm\"\n        const packageManagerFilename = this.rushConfiguration.packageManagerToolFilename;\n        const packageManagerEnv = InstallHelpers.getPackageManagerEnvironment(this.rushConfiguration, this.options);\n        if (ConsoleTerminalProvider.supportsColor) {\n            packageManagerEnv.FORCE_COLOR = '1';\n        }\n        const commonNodeModulesFolder = path.join(subspace.getSubspaceTempFolderPath(), RushConstants.nodeModulesFolderName);\n        // Is there an existing \"node_modules\" folder to consider?\n        if (FileSystem.exists(commonNodeModulesFolder)) {\n            // Should we delete the entire \"node_modules\" folder?\n            if (cleanInstall) {\n                // YES: Delete \"node_modules\"\n                // Explain to the user why we are hosing their node_modules folder\n                // eslint-disable-next-line no-console\n                console.log('Deleting files from ' + commonNodeModulesFolder);\n                this.installRecycler.moveFolder(commonNodeModulesFolder);\n                Utilities.createFolderWithRetry(commonNodeModulesFolder);\n            }\n        }\n        const doInstallInternalAsync = async (options) => {\n            // Run \"npm install\" in the common folder\n            // To ensure that the output is always colored, set the option \"--color=always\", even when it's piped.\n            // Without this argument, certain text that should be colored (such as red) will appear white.\n            const installArgs = ['install'];\n            this.pushConfigurationArgs(installArgs, options, subspace);\n            // eslint-disable-next-line no-console\n            console.log('\\n' +\n                Colorize.bold(`Running \"${this.rushConfiguration.packageManager} install\" in` +\n                    ` ${subspace.getSubspaceTempFolderPath()}`) +\n                '\\n');\n            // If any diagnostic options were specified, then show the full command-line\n            if (this.options.debug ||\n                this.options.collectLogFile ||\n                this.options.networkConcurrency ||\n                this.options.onlyShrinkwrap) {\n                // eslint-disable-next-line no-console\n                console.log('\\n' +\n                    Colorize.green('Invoking package manager: ') +\n                    FileSystem.getRealPath(packageManagerFilename) +\n                    ' ' +\n                    installArgs.join(' ') +\n                    '\\n');\n            }\n            // Store the tip IDs that should be printed.\n            // They will be printed all at once *after* the install\n            const tipIDsToBePrinted = new Set();\n            const pnpmTips = [];\n            for (const [customTipId, customTip] of Object.entries(PNPM_CUSTOM_TIPS)) {\n                if (this.rushConfiguration.customTipsConfiguration.providedCustomTipsByTipId.has(customTipId)) {\n                    pnpmTips.push(customTip);\n                }\n            }\n            const onPnpmStdoutChunk = pnpmTips.length > 0\n                ? (chunk) => {\n                    // Iterate over the supported custom tip metadata and try to match the chunk.\n                    for (const { isMatch, tipId } of pnpmTips) {\n                        if (isMatch === null || isMatch === void 0 ? void 0 : isMatch(chunk)) {\n                            tipIDsToBePrinted.add(tipId);\n                        }\n                    }\n                }\n                : undefined;\n            try {\n                await Utilities.executeCommandWithRetryAsync({\n                    command: packageManagerFilename,\n                    args: installArgs,\n                    workingDirectory: subspace.getSubspaceTempFolderPath(),\n                    environment: packageManagerEnv,\n                    suppressOutput: false,\n                    onStdoutStreamChunk: onPnpmStdoutChunk\n                }, this.options.maxInstallAttempts, () => {\n                    if (this.rushConfiguration.isPnpm) {\n                        this._terminal.writeWarningLine(`Deleting the \"node_modules\" folder`);\n                        this.installRecycler.moveFolder(commonNodeModulesFolder);\n                        // Leave the pnpm-store as is for the retry. This ensures that packages that have already\n                        // been downloaded need not be downloaded again, thereby potentially increasing the chances\n                        // of a subsequent successful install.\n                        Utilities.createFolderWithRetry(commonNodeModulesFolder);\n                    }\n                });\n            }\n            finally {\n                // The try-finally is to avoid the tips NOT being printed if the install fails.\n                // NOT catching the error because we want to keep the other behaviors (i.e., the error will be caught and handle in upper layers).\n                if (tipIDsToBePrinted.size > 0) {\n                    this._terminal.writeLine();\n                    for (const tipID of tipIDsToBePrinted) {\n                        this.rushConfiguration.customTipsConfiguration._showTip(this._terminal, tipID);\n                    }\n                }\n            }\n        };\n        const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;\n        if (this.options.allowShrinkwrapUpdates &&\n            experiments.usePnpmLockfileOnlyThenFrozenLockfileForRushUpdate) {\n            await doInstallInternalAsync(Object.assign(Object.assign({}, this.options), { onlyShrinkwrap: true }));\n            await doInstallInternalAsync(Object.assign(Object.assign({}, this.options), { allowShrinkwrapUpdates: false }));\n        }\n        else {\n            await doInstallInternalAsync(this.options);\n        }\n        // If all attempts fail we just terminate. No special handling needed.\n        // Ensure that node_modules folders exist after install, since the timestamps on these folders are used\n        // to determine if the install can be skipped\n        const projectNodeModulesFolders = [\n            path.join(subspace.getSubspaceTempFolderPath(), RushConstants.nodeModulesFolderName),\n            ...this.rushConfiguration.projects.map((project) => {\n                return path.join(project.projectFolder, RushConstants.nodeModulesFolderName);\n            })\n        ];\n        for (const nodeModulesFolder of projectNodeModulesFolders) {\n            FileSystem.ensureFolder(nodeModulesFolder);\n        }\n        // eslint-disable-next-line no-console\n        console.log('');\n    }\n    async postInstallAsync(subspace) {\n        var _a, _b;\n        // Grab the temp shrinkwrap, as this was the most recently completed install. It may also be\n        // more up-to-date than the checked-in shrinkwrap since filtered installs are not written back.\n        // Note that if there are no projects, or if we're in PNPM workspace mode and there are no\n        // projects with dependencies, a lockfile won't be generated.\n        const tempShrinkwrapFile = ShrinkwrapFileFactory.getShrinkwrapFile(this.rushConfiguration.packageManager, subspace.getTempShrinkwrapFilename());\n        if (tempShrinkwrapFile) {\n            // Write or delete all project shrinkwraps related to the install\n            await Async.forEachAsync(subspace.getProjects(), async (project) => {\n                var _a;\n                await ((_a = tempShrinkwrapFile.getProjectShrinkwrap(project)) === null || _a === void 0 ? void 0 : _a.updateProjectShrinkwrapAsync());\n            }, { concurrency: 10 });\n        }\n        else if (this.rushConfiguration.isPnpm && ((_a = this.rushConfiguration.pnpmOptions) === null || _a === void 0 ? void 0 : _a.useWorkspaces)) {\n            // If we're in PNPM workspace mode and PNPM didn't create a shrinkwrap file,\n            // there are no dependencies. Generate empty shrinkwrap files for all projects.\n            await Async.forEachAsync(subspace.getProjects(), async (project) => {\n                await BaseProjectShrinkwrapFile.saveEmptyProjectShrinkwrapFileAsync(project);\n            }, { concurrency: 10 });\n        }\n        else {\n            // This is an unexpected case\n            throw new Error('A shrinkwrap file does not exist after after successful installation. This probably indicates a ' +\n                'bug in the package manager.');\n        }\n        // If the splitWorkspaceCompatibility is enabled for subspaces, create symlinks to mimic the behaviour\n        // of having the node_modules folder created directly in the project folder. This requires symlinking two categories:\n        // 1) Symlink any packages that are declared to be publicly hoisted, such as by using public-hoist-pattern in .npmrc.\n        //    This creates a symlink from <project_folder>/node_modules/<dependency> -> temp/<subspace_name>/node_modules/<dependency>\n        // 2) Symlink any workspace packages that are declared in the temp folder, as some packages may expect these packages to exist\n        //    in the node_modules folder.\n        //    This creates a symlink from temp/<subspace_name>/node_modules/<workspace_dependency_name> -> <workspace_dependency_folder>\n        if (this.rushConfiguration.subspacesFeatureEnabled &&\n            ((_b = this.rushConfiguration.subspacesConfiguration) === null || _b === void 0 ? void 0 : _b.splitWorkspaceCompatibility)) {\n            const tempNodeModulesPath = `${subspace.getSubspaceTempFolderPath()}/node_modules`;\n            const modulesFilePath = `${tempNodeModulesPath}/${RushConstants.pnpmModulesFilename}`;\n            if (subspace.subspaceName.startsWith('split_') &&\n                subspace.getProjects().length === 1 &&\n                (await FileSystem.existsAsync(modulesFilePath))) {\n                // Find the .modules.yaml file in the subspace temp/node_modules folder\n                const modulesContent = await FileSystem.readFileAsync(modulesFilePath);\n                const yamlContent = yaml.load(modulesContent, { filename: modulesFilePath });\n                const { hoistedDependencies } = yamlContent;\n                const subspaceProject = subspace.getProjects()[0];\n                const projectNodeModulesPath = `${subspaceProject.projectFolder}/node_modules`;\n                for (const value of Object.values(hoistedDependencies)) {\n                    for (const [filePath, type] of Object.entries(value)) {\n                        if (type === 'public') {\n                            if (Utilities.existsOrIsSymlink(`${projectNodeModulesPath}/${filePath}`)) {\n                                await FileSystem.deleteFolderAsync(`${projectNodeModulesPath}/${filePath}`);\n                            }\n                            // If we don't already have a symlink for this package, create one\n                            const parentDir = Utilities.trimAfterLastSlash(`${projectNodeModulesPath}/${filePath}`);\n                            await FileSystem.ensureFolderAsync(parentDir);\n                            BaseLinkManager._createSymlink({\n                                linkTargetPath: `${tempNodeModulesPath}/${filePath}`,\n                                newLinkPath: `${projectNodeModulesPath}/${filePath}`,\n                                symlinkKind: SymlinkKind.Directory\n                            });\n                        }\n                    }\n                }\n            }\n            // Look for any workspace linked packages anywhere in this subspace, symlink them from the temp node_modules folder.\n            const subspaceDependencyProjects = new Set();\n            for (const subspaceProject of subspace.getProjects()) {\n                for (const dependencyProject of subspaceProject.dependencyProjects) {\n                    subspaceDependencyProjects.add(dependencyProject);\n                }\n            }\n            for (const dependencyProject of subspaceDependencyProjects) {\n                const symlinkToCreate = `${tempNodeModulesPath}/${dependencyProject.packageName}`;\n                if (!Utilities.existsOrIsSymlink(symlinkToCreate)) {\n                    const parentFolder = Utilities.trimAfterLastSlash(symlinkToCreate);\n                    await FileSystem.ensureFolderAsync(parentFolder);\n                    BaseLinkManager._createSymlink({\n                        linkTargetPath: dependencyProject.projectFolder,\n                        newLinkPath: symlinkToCreate,\n                        symlinkKind: SymlinkKind.Directory\n                    });\n                }\n            }\n        }\n        // TODO: Remove when \"rush link\" and \"rush unlink\" are deprecated\n        await new FlagFile(subspace.getSubspaceTempFolderPath(), RushConstants.lastLinkFlagFilename, {}).createAsync();\n    }\n    /**\n     * Used when invoking the NPM tool.  Appends the common configuration options\n     * to the command-line.\n     */\n    pushConfigurationArgs(args, options, subspace) {\n        super.pushConfigurationArgs(args, options, subspace);\n        // Add workspace-specific args\n        if (this.rushConfiguration.isPnpm) {\n            args.push('--recursive');\n            args.push('--link-workspace-packages', 'false');\n            if (process.stdout.isTTY) {\n                // If we're on a TTY console and something else didn't set a `--reporter` parameter,\n                // explicitly set the default reporter. This fixes an issue where, when the pnpm\n                // output is being monitored to match custom tips, pnpm will detect a non-TTY\n                // stdout stream and use the `append-only` reporter.\n                //\n                // See docs here: https://pnpm.io/cli/install#--reportername\n                let includesReporterArg = false;\n                for (const arg of args) {\n                    if (arg.startsWith('--reporter')) {\n                        includesReporterArg = true;\n                        break;\n                    }\n                }\n                if (!includesReporterArg) {\n                    args.push('--reporter', 'default');\n                }\n            }\n            for (const arg of this.options.pnpmFilterArgumentValues) {\n                args.push('--filter', arg);\n            }\n        }\n    }\n}\n/**\n * Source: https://github.com/pnpm/pnpm/blob/ba9409ffcef0c36dc1b167d770a023c87444822d/pkg-manager/core/src/install/index.ts#L821-L824\n * @param obj\n * @returns\n */\nfunction createObjectChecksum(obj) {\n    const s = JSON.stringify(Sort.sortKeys(obj));\n    return createHash('md5').update(s).digest('hex');\n}\n//# sourceMappingURL=WorkspaceInstallManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { Sort, Import, Path } from '@rushstack/node-core-library';\nimport { BaseWorkspaceFile } from '../base/BaseWorkspaceFile';\nimport { PNPM_SHRINKWRAP_YAML_FORMAT } from './PnpmYamlCommon';\nconst yamlModule = Import.lazy('js-yaml', require);\nconst globEscape = require('glob-escape'); // No @types/glob-escape package exists\nexport class PnpmWorkspaceFile extends BaseWorkspaceFile {\n    /**\n     * The PNPM workspace file is used to specify the location of workspaces relative to the root\n     * of your PNPM install.\n     */\n    constructor(workspaceYamlFilename) {\n        super();\n        this.workspaceFilename = workspaceYamlFilename;\n        // Ignore any existing file since this file is generated and we need to handle deleting packages\n        // If we need to support manual customization, that should be an additional parameter for \"base file\"\n        this._workspacePackages = new Set();\n    }\n    /** @override */\n    addPackage(packagePath) {\n        // Ensure the path is relative to the pnpm-workspace.yaml file\n        if (path.isAbsolute(packagePath)) {\n            packagePath = path.relative(path.dirname(this.workspaceFilename), packagePath);\n        }\n        // Glob can't handle Windows paths\n        const globPath = Path.convertToSlashes(packagePath);\n        this._workspacePackages.add(globEscape(globPath));\n    }\n    /** @override */\n    serialize() {\n        // Ensure stable sort order when serializing\n        Sort.sortSet(this._workspacePackages);\n        const workspaceYaml = {\n            packages: Array.from(this._workspacePackages)\n        };\n        return yamlModule.safeDump(workspaceYaml, PNPM_SHRINKWRAP_YAML_FORMAT);\n    }\n}\n//# sourceMappingURL=PnpmWorkspaceFile.js.map"],"names":[],"sourceRoot":""}