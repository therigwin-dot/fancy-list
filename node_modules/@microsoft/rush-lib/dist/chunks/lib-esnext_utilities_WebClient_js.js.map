{"version":3,"file":"chunks/lib-esnext_utilities_WebClient_js.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACyB;AACU;AACgB;AACE;AACiB;AACtE,8BAA8B,gEAAM;AACpC;AACA,iBAAiB,gBAAgB;AACjC;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA,kEAAkE,+CAAY,GAAG,8CAAW;AAC5F;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,qBAAqB,2BAA2B,IAAI;AAC7H;AACA;AACA;AACA;AACA,qEAAqE,oBAAoB,IAAI,IAAI;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,mDAAmD,8GAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,UAAU;AACvG;AACA;AACA,mDAAmD,wEAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sCAAsC,4CAAe,EAAE,EAAE,wCAAW,IAAI,EAAE,oCAAO,GAAG;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iFAAiF;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAW;AAC/B,+BAA+B,wCAAW;AAC1C;AACA,yBAAyB,wCAAW;AACpC,+BAA+B,wCAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/utilities/WebClient.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as os from 'os';\nimport * as process from 'process';\nimport { request as httpRequest } from 'node:http';\nimport { request as httpsRequest } from 'node:https';\nimport { Import, LegacyAdapters } from '@rushstack/node-core-library';\nconst createHttpsProxyAgent = Import.lazy('https-proxy-agent', require);\n/**\n * For use with {@link WebClient}.\n */\nexport var WebClientProxy;\n(function (WebClientProxy) {\n    WebClientProxy[WebClientProxy[\"None\"] = 0] = \"None\";\n    WebClientProxy[WebClientProxy[\"Detect\"] = 1] = \"Detect\";\n    WebClientProxy[WebClientProxy[\"Fiddler\"] = 2] = \"Fiddler\";\n})(WebClientProxy || (WebClientProxy = {}));\nconst DEFLATE_ENCODING = 'deflate';\nconst GZIP_ENCODING = 'gzip';\nconst BROTLI_ENCODING = 'br';\nexport const AUTHORIZATION_HEADER_NAME = 'Authorization';\nconst ACCEPT_HEADER_NAME = 'accept';\nconst USER_AGENT_HEADER_NAME = 'user-agent';\nconst CONTENT_ENCODING_HEADER_NAME = 'content-encoding';\nconst makeRequestAsync = async (url, options, redirected = false) => {\n    const { body, redirect, noDecode } = options;\n    return await new Promise((resolve, reject) => {\n        const parsedUrl = typeof url === 'string' ? new URL(url) : url;\n        const requestFunction = parsedUrl.protocol === 'https:' ? httpsRequest : httpRequest;\n        requestFunction(url, options, (response) => {\n            const responseBuffers = [];\n            response.on('data', (chunk) => {\n                responseBuffers.push(Buffer.from(chunk));\n            });\n            response.on('end', () => {\n                // Handle retries by calling the method recursively with the redirect URL\n                const statusCode = response.statusCode;\n                if (statusCode === 301 || statusCode === 302) {\n                    switch (redirect) {\n                        case 'follow': {\n                            const redirectUrl = response.headers.location;\n                            if (redirectUrl) {\n                                makeRequestAsync(redirectUrl, options, true).then(resolve).catch(reject);\n                            }\n                            else {\n                                reject(new Error(`Received status code ${response.statusCode} with no location header: ${url}`));\n                            }\n                            break;\n                        }\n                        case 'error':\n                            reject(new Error(`Received status code ${response.statusCode}: ${url}`));\n                            return;\n                    }\n                }\n                const responseData = Buffer.concat(responseBuffers);\n                const status = response.statusCode || 0;\n                const statusText = response.statusMessage;\n                const headers = response.headers;\n                let bodyString;\n                let bodyJson;\n                let decodedBuffer;\n                const result = {\n                    ok: status >= 200 && status < 300,\n                    status,\n                    statusText,\n                    redirected,\n                    headers,\n                    getTextAsync: async () => {\n                        if (bodyString === undefined) {\n                            const buffer = await result.getBufferAsync();\n                            // eslint-disable-next-line require-atomic-updates\n                            bodyString = buffer.toString();\n                        }\n                        return bodyString;\n                    },\n                    getJsonAsync: async () => {\n                        if (bodyJson === undefined) {\n                            const text = await result.getTextAsync();\n                            // eslint-disable-next-line require-atomic-updates\n                            bodyJson = JSON.parse(text);\n                        }\n                        return bodyJson;\n                    },\n                    getBufferAsync: async () => {\n                        // Determine if the buffer is compressed and decode it if necessary\n                        if (decodedBuffer === undefined) {\n                            let encodings = headers[CONTENT_ENCODING_HEADER_NAME];\n                            if (!noDecode && encodings !== undefined) {\n                                const zlib = await import('zlib');\n                                if (!Array.isArray(encodings)) {\n                                    encodings = encodings.split(',');\n                                }\n                                let buffer = responseData;\n                                for (const encoding of encodings) {\n                                    let decompressFn;\n                                    switch (encoding.trim()) {\n                                        case DEFLATE_ENCODING: {\n                                            decompressFn = zlib.inflate.bind(zlib);\n                                            break;\n                                        }\n                                        case GZIP_ENCODING: {\n                                            decompressFn = zlib.gunzip.bind(zlib);\n                                            break;\n                                        }\n                                        case BROTLI_ENCODING: {\n                                            decompressFn = zlib.brotliDecompress.bind(zlib);\n                                            break;\n                                        }\n                                        default: {\n                                            throw new Error(`Unsupported content-encoding: ${encodings}`);\n                                        }\n                                    }\n                                    buffer = await LegacyAdapters.convertCallbackToPromise(decompressFn, buffer);\n                                }\n                                // eslint-disable-next-line require-atomic-updates\n                                decodedBuffer = buffer;\n                            }\n                            else {\n                                decodedBuffer = responseData;\n                            }\n                        }\n                        return decodedBuffer;\n                    }\n                };\n                resolve(result);\n            });\n        })\n            .on('error', (error) => {\n            reject(error);\n        })\n            .end(body);\n    });\n};\n/**\n * A helper for issuing HTTP requests.\n */\nexport class WebClient {\n    constructor() {\n        this.standardHeaders = {};\n        this.accept = '*/*';\n        this.userAgent = `rush node/${process.version} ${os.platform()} ${os.arch()}`;\n        this.proxy = WebClientProxy.Detect;\n    }\n    static mockRequestFn(fn) {\n        WebClient._requestFn = fn;\n    }\n    static resetMockRequestFn() {\n        WebClient._requestFn = makeRequestAsync;\n    }\n    static mergeHeaders(target, source) {\n        for (const [name, value] of Object.entries(source)) {\n            target[name] = value;\n        }\n    }\n    addBasicAuthHeader(userName, password) {\n        this.standardHeaders[AUTHORIZATION_HEADER_NAME] =\n            'Basic ' + Buffer.from(userName + ':' + password).toString('base64');\n    }\n    async fetchAsync(url, options) {\n        var _a;\n        const { headers: optionsHeaders, timeoutMs = 15 * 1000, verb, redirect, body, noDecode } = (_a = options) !== null && _a !== void 0 ? _a : {};\n        const headers = {};\n        WebClient.mergeHeaders(headers, this.standardHeaders);\n        if (optionsHeaders) {\n            WebClient.mergeHeaders(headers, optionsHeaders);\n        }\n        if (this.userAgent) {\n            headers[USER_AGENT_HEADER_NAME] = this.userAgent;\n        }\n        if (this.accept) {\n            headers[ACCEPT_HEADER_NAME] = this.accept;\n        }\n        let proxyUrl = '';\n        switch (this.proxy) {\n            case WebClientProxy.Detect:\n                if (process.env.HTTPS_PROXY) {\n                    proxyUrl = process.env.HTTPS_PROXY;\n                }\n                else if (process.env.HTTP_PROXY) {\n                    proxyUrl = process.env.HTTP_PROXY;\n                }\n                break;\n            case WebClientProxy.Fiddler:\n                // For debugging, disable cert validation\n                // eslint-disable-next-line\n                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';\n                proxyUrl = 'http://localhost:8888/';\n                break;\n        }\n        let agent = undefined;\n        if (proxyUrl) {\n            agent = createHttpsProxyAgent(proxyUrl);\n        }\n        const requestInit = {\n            method: verb,\n            headers,\n            agent,\n            timeout: timeoutMs,\n            redirect,\n            body,\n            noDecode\n        };\n        return await WebClient._requestFn(url, requestInit);\n    }\n}\nWebClient._requestFn = makeRequestAsync;\n//# sourceMappingURL=WebClient.js.map"],"names":[],"sourceRoot":""}