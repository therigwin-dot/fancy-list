{"version":3,"file":"commons.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAC6B;AAC+E;AACnD;AACS;AACX;AACvD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAU;AACvB;AACA;AACA;AACA;AACA;AACA,8CAA8C,0CAAa,qBAAqB;AAChF,0EAA0E,+DAAa,kBAAkB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kEAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iEAAc;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAQ;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,oEAAU;AAClB,gCAAgC,qEAAW;AAC3C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,aAAa;AAC9E,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA,4CAA4C,oEAAU,kBAAkB,mEAAU;AAClF;;;;;;;;;;;;;;;;;;ACtJA;AACA;AAC6B;AACmD;AACzB;AACvD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,+DAAa,kBAAkB;AAClH;AACA;AACA;AACA;AACA,4CAA4C,sCAAS,2CAA2C,+DAAa;AAC7G,2CAA2C,yFAA6B;AACxE;AACA;AACA,+CAA+C,sCAAS,2CAA2C,+DAAa;AAChH,8CAA8C,yFAA6B;AAC3E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AAC6B;AACyE;AACN;AACzC;AACS;AACM;AACN;AACJ;AAC5D;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,+FAA+F;AACjH;AACA,uCAAuC,+EAAwB;AAC/D;AACA,wCAAwC,+EAAwB;AAChE;AACA,sCAAsC,wGAA4B;AAClE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAU;AACvB;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yCAAY,2CAA2C,+DAAa;AACnF;AACA;AACA,qCAAqC,kEAAQ;AAC7C,4CAA4C,yEAAqB;AACjE;AACA;AACA,8BAA8B,wEAAY;AAC1C;AACA;AACA,+EAA+E,qCAAqC,KAAK,EAAE;AAC3H,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,6BAA6B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC,oEAAU,kBAAkB,6DAAU;AAC5E;;;;;;;;;;;;;;;;;;;AChGA;AACA;AAC6B;AAC2B;AACrB;AACnC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAQ;AAChB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO,GAAG,qBAAqB;AACrE,iBAAiB,qBAAqB;AACtC,yBAAyB,sCAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,OAAO,EAAE,OAAO,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa,GAAG,aAAa;AAChE;AACA,sBAAsB,cAAc,GAAG,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;;;;;;;;;;;;;;;ACdA;AACA;AAC0C;AAC1C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAU;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACgF;AAC5C;AACkC;AACf;AACC;AACxD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gBAAgB,6DAA6D;AAC7E,gCAAgC,+EAAwB;AACxD;AACA,+BAA+B,+EAAwB,oBAAoB,wCAAM;AACjF;AACA,kBAAkB,+EAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC,GAAG,+DAAa,iBAAiB;AAC5F;AACA;AACA;AACA;AACA,gCAAgC,kEAAQ;AACxC;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gCAAgC;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0DAA0D,sBAAsB,GAAG,qBAAqB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAU,kBAAkB,yDAAU;AACzE;;;;;;;;;;;;;;;;;;AC3FA;AACA;AACgF;AACzB;AACM;AAC7D;AACA,iBAAiB,+DAAa;AAC9B,UAAU,+DAAa;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAa;AAC9B,UAAU,+DAAa;AACvB;AACA;AACA;AACA,iFAAiF,+DAAa,kBAAkB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+DAAa,iBAAiB;AACjF;AACA;AACA,0CAA0C,+DAAa,qBAAqB,eAAe,WAAW;AACtG;AACA;AACA;AACA,0CAA0C,+DAAa,qBAAqB,eAAe,WAAW;AACtG;AACA,4CAA4C,+DAAa,iBAAiB;AAC1E;AACA;AACA;AACA;AACA,0CAA0C,+DAAa,qBAAqB,eAAe,WAAW;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAa,qBAAqB,kBAAkB,WAAW;AACjH,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAa,qBAAqB,kBAAkB,WAAW;AACjH,kEAAkE,eAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAa,qBAAqB,iBAAiB,aAAa;AAC1G;AACA;AACA;AACA;AACA,yBAAyB,+DAAa;AACtC;AACA;AACA;AACA,0EAA0E,cAAc,uJAAuJ;AAC/O;AACA;AACA;AACA,sDAAsD,+DAAa,qBAAqB;AACxF,wCAAwC,uBAAuB,wBAAwB,UAAU;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,+DAAa,qBAAqB;AAC5F,4CAA4C,uBAAuB,wBAAwB,UAAU;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAa;AACtC,0EAA0E,cAAc,iCAAiC;AACzH;AACA;AACA,yBAAyB,+DAAa;AACtC;AACA;AACA;AACA;AACA;AACA,+CAA+C,+DAAa;AAC5D,+CAA+C,+DAAa;AAC5D,0DAA0D,+DAAa;AACvE,2CAA2C,+DAAa,sBAAsB,qBAAqB,uBAAuB;AAC1H,iDAAiD,+DAAa,mBAAmB;AACjF,qCAAqC,+DAAa,iBAAiB,QAAQ,+DAAa,mBAAmB;AAC3G;AACA;AACA,2CAA2C,+DAAa,sBAAsB,qBAAqB,uBAAuB;AAC1H,iHAAiH,uBAAuB;AACxI;AACA,wDAAwD,+DAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+DAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+DAAa;AAChD;AACA;AACA,uDAAuD,+DAAa,kBAAkB;AACtF;AACA,qEAAqE,mCAAmC,aAAa,+DAAa,iTAAiT;AACnb;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gBAAgB,gLAAgL;AAC1Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAa,qBAAqB,mBAAmB,6BAA6B;AACpI,+DAA+D,iCAAiC;AAChG,mFAAmF,4BAA4B;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+DAAa,sBAAsB,uBAAuB,6BAA6B;AACtI,sEAAsE,sBAAsB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+DAAa,sBAAsB,uBAAuB,6BAA6B;AACtI,oEAAoE,oBAAoB;AACxF;AACA;AACA;AACA;AACA,uCAAuC,+DAAa,sBAAsB,uBAAuB,6BAA6B;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAa,qBAAqB;AACxE,8BAA8B,iBAAiB,gBAAgB,uEAAuE;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAQ;AACtC;AACA;AACA,iBAAiB,oEAAU;AAC3B;AACA;AACA;AACA;AACA,mEAAmE,wCAAwC;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAQ;AAC1C;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE;AACA;AACA;AACA;AACA,6BAA6B,+DAAa;AAC1C,6BAA6B,+DAAa;AAC1C;AACA,qCAAqC,+DAAa;AAClD;AACA;AACA;AACA,qCAAqC,+DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA,+DAA+D,yCAAyC;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA,yIAAyI;AACzI;AACA;AACA;AACA,uCAAuC,oEAAU,kBAAkB,8DAAU;AAC7E;;;;;;;;;;;;;;;;;;;;;;;;AC3aA;AACA;AAC4B;AACC;AACwF;AAC3D;AACD;AACF;AACS;AAChE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sCAAsC,wEAAc;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wEAAc;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+GAA+G,+DAAa,yBAAyB;AACrJ,mFAAmF,+DAAa,kBAAkB;AAClH;AACA;AACA;AACA;AACA,0FAA0F,+DAAa,mBAAmB;AAC1H,oDAAoD,+DAAa,yBAAyB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0CAAa,WAAW,KAAK,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB,iCAAiC,kEAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAI;AACZ;AACA,qCAAqC,uEAAa;AAClD,eAAe,wDAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAQ,0CAA0C,0BAA0B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAa;AACrB;AACA;AACA;AACA,QAAQ,mEAAkB;AAC1B;AACA;AACA;AACA;AACA,QAAQ,mEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA,qBAAqB,iEAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oEAAU,kBAAkB,iEAAU;AAChF;;;;;;;;;;;;;;;;;;;;;;;;;;AC3IA;AACA;AAC6B;AACmD;AACjB;AACH;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,4BAA4B,kEAAQ;AACpC;AACA;AACA,iBAAiB,oEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0CAAa,kBAAkB;AAC1E,sDAAsD,cAAc;AACpE;AACA;AACA,2CAA2C,0CAAa,kBAAkB;AAC1E,kEAAkE,cAAc;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gDAAgD;AAC/F;AACA,+BAA+B,4CAA4C;AAC3E;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAQ;AACrC;AACA;AACA;AACA,6BAA6B,yDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA,8CAA8C,+DAAc;AAC5D,0DAA0D,6BAA6B;AACvF;AACA;AACA;AACA;AACA,sCAAsC,oEAAU,kBAAkB,6DAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,QAAQ,mBAAmB;AAC3B,QAAQ,sBAAsB;AAC9B;AACA,0EAA0E;AAC1E;;;;;;;;;;;;;;;;;;;;;ACxRA;AACA;AACyB;AACI;AACqB;AAClD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAA6D;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wCAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+BAA+B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM,iCAAiC,KAAK;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2CAAc;AACnC,2EAA2E,qCAAQ;AACnF,2BAA2B,uCAAU;AACrC;AACA;AACA,oDAAoD,qCAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C,oCAAoC,sCAAS;AAC7C;AACA,kDAAkD,gEAAgB;AAClE,+BAA+B,sCAAS;AACxC;AACA,8BAA8B,OAAO,EAAE,qCAAQ,CAAC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChhBA;AACA;AACoD;AACpD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACgF;AACjC;AACa;AAC5D;AACA,iCAAiC,oEAAU,kBAAkB,6DAAU;AACvE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iCAAiC,kEAAQ;AACzC;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ,2BAA2B,eAAe;AAC9E,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrCA;AACA;AACoE;AACD;AACnE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW,GAAG,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAQ;AACrC;AACA,mBAAmB,+EAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAQ;AACtB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc,oEAAU;AACxB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AAC8D;AACP;AACS;AACjB;AACT;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,+CAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,+CAA+C,IAAI;AAC7G;AACA;AACA,6BAA6B,kEAAQ;AACrC;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,2EAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAI;AAClC;AACA;AACA,8BAA8B,8DAAI;AAClC;AACA;AACA;AACA;AACA;AACA,oGAAoG,UAAU;AAC9G,6CAA6C,uBAAuB;AACpE,6CAA6C,uBAAuB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAuB;AACnC;AACA;AACA,QAAQ,6DAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uEAAuE;AAC9E,yCAAyC,qOAAqO,qEAAsB,IAAI;AACxS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACzHA;AACA;AACiC;AACwD;AAChC;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAY,iBAAiB,8CAAiB;AAC3D,qEAAqE,WAAW;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA,oDAAoD,YAAY;AAChE;AACA;AACA,aAAa;AACb,kDAAkD;AAClD;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA,aAAa;AACb,8CAA8C;AAC9C;AACA,aAAa;AACb,6CAA6C;AAC7C;AACA,aAAa;AACb,yCAAyC;AACzC;AACA,aAAa;AACb,8CAA8C;AAC9C;AACA,aAAa;AACb,gFAAgF;AAChF,YAAY,8DAAI;AAChB,YAAY,8DAAI;AAChB;AACA;AACA,8CAA8C,SAAS,KAAK,UAAU;AACtE;AACA;AACA;AACA,+CAA+C,kEAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAQ;AACpB;AACA,4BAA4B,oEAAU;AACtC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qEAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1RA;AACA;AACiE;AAC1D;AACP;AACA;AACA;AACA;AACA,qCAAqC,2EAAiB,GAAG;AACzD;AACA;AACA;AACA;AACA,wCAAwC,2EAAiB;AACzD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AAC6B;AACmD;AAC3C;AACgC;AACR;AACF;AACsB;AACX;AACL;AACjE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,sBAAsB;AACnF;AACA;AACA;AACA;AACA;AACA,aAAa,6EAAqB;AAClC,YAAY,qEAAiB;AAC7B;AACA,aAAa,yFAA2B;AACxC;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAqB;AAChD;AACA;AACA,SAAS;AACT;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB,kEAAkE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAmB,yCAAyC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2EAAiB;AACzD;AACA,0BAA0B,uEAAa;AACvC;AACA,0CAA0C,yCAAY;AACtD,wCAAwC,2EAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAwB;AAC5C;AACA;AACA,+DAA+D,sBAAsB;AACrF;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvHA;AACA;AACsE;AACD;AACrE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,0CAA0C,6EAAqB,GAAG,qBAAqB;AACvF;AACA;AACA,yBAAyB,wCAAwC;AACjE;AACA,6BAA6B,iFAAiF;AAC9G;AACA,8BAA8B,gFAAwB;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AAC6B;AACI;AACoE;AAC5C;AACP;AACpB;AACwC;AACf;AACW;AACxB;AACgC;AACJ;AACnB;AACoB;AACE;AACA;AACH;AACZ;AACY;AACY;AACH;AACG;AAC7B;AACe;AACF;AAC5B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB,IAAI,+DAAa;AACjB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+EAAwB;AAChC;AACA,iBAAiB,8CAAiB;AAClC;AACA,mCAAmC,+DAAa,kBAAkB,KAAK,gDAAgD;AACvH;AACA,iBAAiB,6CAAgB;AACjC,iFAAiF,iBAAiB;AAClG,sFAAsF,+DAAa,mBAAmB;AACtH,4DAA4D,gDAAgD;AAC5G;AACA;AACA;AACA,oBAAoB,+EAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAY;AAC1C,4BAA4B,yCAAY,CAAC,sCAAS,sBAAsB,+DAAa;AACrF,sCAAsC,sCAAS;AAC/C;AACA,YAAY,+EAAwB;AACpC,gBAAgB,sCAAS,oBAAoB,+DAAa;AAC1D,mCAAmC,sCAAS;AAC5C,8BAA8B,yCAAY,CAAC,sCAAS;AACpD,4BAA4B,yCAAY,CAAC,sCAAS;AAClD,+BAA+B,yCAAY,CAAC,sCAAS;AACrD,6BAA6B,sCAAS,oBAAoB,+DAAa;AACvE,0CAA0C,sCAAS,wBAAwB,+DAAa;AACxF;AACA;AACA;AACA;AACA,sCAAsC,2EAAsB;AAC5D;AACA;AACA,sCAAsC,sCAAS,8BAA8B,+DAAa;AAC1F,4CAA4C,+EAAwB;AACpE,0CAA0C,sCAAS,8BAA8B,+DAAa;AAC9F,6CAA6C,+EAAwB;AACrE,8BAA8B,wFAAuB,uCAAuC;AAC5F,+BAA+B,2FAAwB,wCAAwC;AAC/F;AACA,+BAA+B,2FAAwB,4BAA4B,4BAA4B,GAAG,+DAAa,oBAAoB;AACnJ;AACA;AACA,0EAA0E,+DAAa,kBAAkB;AACzG;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B,mCAAmC,2FAAwB,2DAA2D;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+DAAa,mBAAmB;AACnE;AACA;AACA,mCAAmC,+DAAa,mBAAmB,oCAAoC,wBAAwB;AAC/H,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA,6CAA6C,iFAAiB;AAC9D;AACA;AACA;AACA,6CAA6C,mFAAkB;AAC/D;AACA;AACA;AACA,6CAA6C,mFAAkB;AAC/D;AACA;AACA,0CAA0C,yCAAY,CAAC,sCAAS,2BAA2B,oBAAoB,oCAAoC,oBAAoB;AACvK;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oEAAkB;AAChC,cAAc,oEAAkB;AAChC,0CAA0C,4EAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+DAAa,mBAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAU,uCAAuC;AAC/E,kDAAkD,sCAAS,8BAA8B,+DAAa;AACtG,8CAA8C,oFAA0B;AACxE,+CAA+C,sCAAS,8BAA8B,+DAAa;AACnG,2CAA2C,8EAAuB;AAClE;AACA;AACA,oBAAoB,cAAc;AAClC;AACA,4DAA4D,YAAY;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAa;AAC/C,+BAA+B,+DAAa;AAC5C;AACA;AACA;AACA;AACA;AACA,iCAAiC,gDAAQ;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0DAA0D,+DAAa;AACvE;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB,OAAO,+DAAa,mBAAmB;AACvH,wDAAwD,yBAAyB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gFAAwB;AACxD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qDAAqD,oBAAoB;AACzE,+BAA+B,+DAAa,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAa,kBAAkB,SAAS,yBAAyB;AAC3G,2HAA2H,oBAAoB;AAC/I;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yCAAY;AACnD;AACA;AACA,sCAAsC,kEAAQ;AAC9C;AACA,uCAAuC,gEAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0CAAa;AAC9C;AACA,mCAAmC,yCAAY;AAC/C;AACA,gBAAgB,sCAAS;AACzB,mCAAmC,kBAAkB,aAAa,oBAAoB;AACtF,wDAAwD,oCAAoC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAY,CAAC,wCAAI,cAAc,yCAAY;AAC3D,gBAAgB,yCAAY,CAAC,wCAAI,cAAc,yCAAY;AAC3D;AACA,oBAAoB,sCAAS,CAAC,wCAAI;AAClC,sDAAsD,kBAAkB;AACxE,4BAA4B,kCAAkC,2CAA2C,wCAAI,SAAS;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yCAAY;AACvC;AACA;AACA;AACA,qCAAqC,sCAAS,gBAAgB,+DAAa;AAC3E,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yCAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oEAAkB;AAC/C;AACA;AACA;AACA,iCAAiC,+DAAa,kBAAkB,GAAG,aAAa;AAChF;AACA;AACA,iCAAiC,+DAAa,kBAAkB,GAAG,aAAa,GAAG,QAAQ;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAU;AACvB;AACA,4CAA4C,uBAAuB;AACnE,YAAY,oEAAU;AACtB;AACA;AACA,+BAA+B,oEAAU;AACzC;AACA,yBAAyB,oEAAU,mBAAmB,sCAAS;AAC/D;AACA;AACA;AACA;AACA,kCAAkC,yCAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAa,oCAAoC,+DAAa;AAC/F;AACA,iEAAiE,uBAAuB,GAAG,SAAS;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE,wBAAwB,uBAAuB;AAC/C;AACA;AACA,uCAAuC,sCAAS,yBAAyB,+DAAa;AACtF,YAAY,oEAAU;AACtB,2FAA2F;AAC3F;AACA,6BAA6B,+DAAa,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAU;AACrC,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B,GAAG,6BAA6B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,+DAAa;AACjE;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0CAA0C;AAClE;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mBAAO,CAAC,yCAA6B;AAC9E;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAA+C;AACvE;AACA;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,mEAAY;AACtE;AACA,qCAAqC,0CAAa;AAClD,6CAA6C,mEAAY,mCAAmC,qCAAQ;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAY;AACzC;AACA;AACA,gBAAgB,8DAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAQ;AACjC;AACA;AACA,iBAAiB,oEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAU,kBAAkB,uDAAU;AACtE;;;;;;;;;;;;;;;;;;;;;;;;;ACx1BA;AACA;AAC6B;AACI;AACwC;AAClB;AACG;AACkC;AACZ;AAChF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAsE;AACtF,gBAAgB,oDAAoD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,yCAAyC;AACtG,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA,sEAAsE,yCAAyC;AAC/G,uCAAuC,sBAAsB;AAC7D;AACA,sCAAsC,sCAAS;AAC/C;AACA,oCAAoC,sCAAS,wBAAwB,uEAAa;AAClF;AACA,oCAAoC,oEAAU;AAC9C;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B,mEAAmE,aAAa,KAAK,oBAAoB;AACzG;AACA;AACA;AACA,mCAAmC,cAAc,cAAc,oBAAoB;AACnF;AACA;AACA;AACA,uCAAuC,sCAAS;AAChD,qCAAqC,sCAAS,wBAAwB,+DAAa,wBAAwB,+DAAa;AACxH;AACA;AACA;AACA;AACA;AACA,mFAAmF,+DAAa,kBAAkB;AAClH,2DAA2D,YAAY;AACvE;AACA;AACA,gDAAgD,YAAY;AAC5D,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB,iBAAiB,+DAAa,mBAAmB;AACnH,oCAAoC,sBAAsB;AAC1D;AACA,aAAa,yCAAY;AACzB,0CAA0C,yBAAyB;AACnE,iCAAiC,oBAAoB;AACrD;AACA,iCAAiC,yFAA6B;AAC9D;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uCAAuC,mEAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA,iCAAiC,sCAAS;AAC1C;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI,2BAA2B,YAAY;AAC3F,uDAAuD,+DAAa,kBAAkB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2EAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+EAAuB;AAC5D,qCAAqC,+EAAuB;AAC5D,wCAAwC,6CAAgB;AACxD;AACA;AACA;AACA,qCAAqC,+EAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wDAAwD;AACxD;AACA,QAAQ,uCAAU,6BAA6B,uCAAU;AACzD,sCAAsC,aAAa,YAAY,MAAM,cAAc,KAAK;AACxF;AACA;AACA,sCAAsC,aAAa,YAAY,MAAM,cAAc,KAAK;AACxF;AACA;AACA;AACA,sCAAsC,aAAa,YAAY,MAAM,cAAc,KAAK;AACxF;AACA,uBAAuB,uCAAU;AACjC;AACA,sCAAsC,aAAa,YAAY,MAAM,cAAc,KAAK,iDAAiD,WAAW;AACpJ;AACA;AACA;;;;;;;;;;;;;;;;;;AC5SA;AACA;AAC6B;AACsB;AACmB;AACtE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,yCAAyC,+EAAwB;AACjE;AACA;AACA;AACA;AACA,wBAAwB,sCAAS,CAAC,2DAAS;AAC3C;AACA;AACA;AACA;AACA,gCAAgC,sCAAS,oBAAoB,sBAAsB;AACnF;AACA;AACA;;;;;;;;;;;;;;;AC3BA;AACA;AAC8B;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAI,uBAAuB,OAAO,cAAc;AAC3E;AACA;AACA;AACA;AACA,+DAA+D,cAAc,+BAA+B,uCAAI,SAAS;AACzH;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzBA;AACA;AACgF;AACnB;AACtD;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB,iCAAiC,kEAAQ;AACzC;AACA;AACA;AACA,uCAAuC,oEAAU,kBAAkB,8DAAU;AAC7E;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACiF;AACO;AACrC;AACI;AACwB;AAClB;AACQ;AACrE,4CAA4C,iFAAwB;AACpE,uCAAuC,+DAAa,2BAA2B;AAC/E,sBAAsB,8DAAU;AAChC;AACA;AACA,6BAA6B,wEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,4EAA4E,oBAAoB,IAAI,0BAA0B,mBAAmB,IAAI;AACrQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,wEAAe;AAC5C;AACA;AACA,CAAC;AACD,gDAAgD,iFAAwB;AACxE;AACA,sBAAsB,8DAAkB;AACxC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uFAAuB;AACnE,gBAAgB,4CAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,oBAAoB;AAC5F,wCAAwC,wDAAwD;AAChG;AACA,wCAAwC,cAAc,kCAAkC,iBAAiB;AACzG;AACA;AACA,wEAAwE,oBAAoB;AAC5F,wCAAwC,wDAAwD;AAChG;AACA;AACA,4CAA4C,iBAAiB;AAC7D,wCAAwC,cAAc,MAAM,4CAA4C;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,UAAU;AAC1F;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,gDAAgD,8DAAI;AACpD,uFAAuF,gCAAgC,GAAG,iBAAiB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,4BAA4B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAA4D;AAC5E;AACA;AACA;AACA;AACA,+CAA+C,+DAAa,4BAA4B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAK;AACnB;AACA;AACA;AACA;AACA,SAAS,IAAI,iBAAiB;AAC9B;AACA;AACA;AACA,gCAAgC,6DAAS;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yDAAyD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc,mCAAmC,oBAAoB;AAC9H,2BAA2B,yDAAyD;AACpF;AACA;AACA;AACA;AACA,yDAAyD,kCAAkC;AAC3F,2CAA2C,0BAA0B;AACrE;AACA,kCAAkC,8DAAI,gEAAgE,8DAAI;AAC1G,8EAA8E,0BAA0B;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wJAAwJ,cAAc;AACtK;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACtTA;AACA;AACgF;AACnD;AACsB;AACI;AACY;AACnE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sCAAsC,4CAAe;AACrD;AACA;AACA;AACA;AACA;AACA,yCAAyC,sCAAS;AAClD;AACA;AACA,yCAAyC,kEAAQ;AACjD;AACA;AACA,iBAAiB,oEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAS;AACxC,yCAAyC,sCAAS,iBAAiB,+DAAa;AAChF;AACA;AACA;AACA,gCAAgC,oEAAU,kBAAkB,oEAAU;AACtE;;;;;;;;;;;;;;;ACxCA;AACA;AACwD;AACjD,4CAA4C,iEAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AAC6B;AACI;AACyB;AACY;AACf;AACqB;AACrB;AAC2B;AACU;AAC5F;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0FAAwB;AAClE;AACA;AACA;AACA,oBAAoB,oEAAU;AAC9B;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,+BAA+B,oBAAoB,kBAAkB;AAC7H;AACA;AACA,wBAAwB,oEAAU;AAClC,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA,yEAAyE,kBAAkB,aAAa,sBAAsB;AAC9H,wCAAwC;AACxC;AACA;AACA,kDAAkD,sBAAsB,YAAY,kBAAkB;AACtG;AACA,wBAAwB,oEAAU,WAAW,sBAAsB;AACnE,gFAAgF,sBAAsB,2CAA2C,yBAAyB;AAC1K;AACA,wBAAwB,oEAAU,WAAW,sBAAsB;AACnE,gFAAgF,sBAAsB,kDAAkD,yBAAyB;AACjL;AACA;AACA,qBAAqB,oEAAU;AAC/B,yEAAyE,kBAAkB;AAC3F;AACA;AACA,mDAAmD,yBAAyB,GAAG,+DAAa,6BAA6B;AACzH;AACA;AACA;AACA;AACA;AACA,mDAAmD,+BAA+B,GAAG,+DAAa,6BAA6B;AAC/H;AACA;AACA,qCAAqC,+EAAwB;AAC7D;AACA;AACA;AACA,4CAA4C,iBAAiB,GAAG,kBAAkB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB,GAAG,qCAAqC;AAC7G;AACA,+BAA+B,uCAAU;AACzC,wDAAwD,eAAe,GAAG,gBAAgB,aAAa,eAAe;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB,GAAG,+DAAa,wBAAwB,GAAG,QAAQ;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAoD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,+DAAa;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,+DAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qFAA2B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,+DAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAa;AAC5B;AACA;AACA,0BAA0B,+CAA+C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB,GAAG,2CAA2C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB,GAAG,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oGAA6B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wIAAwI;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB,8CAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtXA;AACA;AACgF;AACtB;AACH;AACvD;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAa;AACvC;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa;AACtD;AACA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAQ;AACpC;AACA;AACA,iBAAiB,oEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB,GAAG,+DAAa,yBAAyB;AACxG;AACA;AACA;AACA,qCAAqC,oEAAU,kBAAkB,2DAAU;AAC3E;;;;;;;;;;;;;;;;;AC7FA;AACA;AACsE;AACf;AACvD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,yBAAyB,+EAAwB;AACjD;AACO;AACP;AACA;AACA,wCAAwC,QAAQ,sBAAsB,+DAAa,kBAAkB;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACiC;AACmB;AAC2C;AACtC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAA4C;AACpD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,kEAAkE;AACnE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAI;AAClC;AACA;AACA;AACA,kFAAkF,+EAAsB;AACxG;AACA,wDAAwD,gFAAuB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gFAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+EAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,4BAA4B,0CAAa;AACzC;AACA;AACA,kBAAkB,8DAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0CAAa;AAChD;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB,aAAa,aAAa;AACvF,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0CAAa;AAC/C;AACA,+CAA+C,eAAe,KAAK,YAAY;AAC/E;AACA;AACA;AACA,+BAA+B,qEAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAa;AAC7C;AACA,uCAAuC,qEAAS;AAChD,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA,gDAAgD,iBAAiB,aAAa,aAAa;AAC3F,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0CAAa;AAC/C;AACA;AACA,yDAAyD,eAAe,KAAK,YAAY;AACzF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC/SA;AACA;AACgF;AAChC;AACiB;AAC1D;AACP;AACA;AACA;AACA,CAAC,0DAA0D;AACpD;AACP;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE,wBAAwB,2BAA2B;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,WAAW;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB,OAAO,iBAAiB,KAAK,WAAW;AAC9G;AACA;AACA;AACA;AACA,aAAa,oEAAU;AACvB;AACA;AACA,kCAAkC,kEAAQ;AAC1C;AACA,2BAA2B,yDAAa;AACxC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,kEAAQ,+CAA+C,0BAA0B;AAC7F;AACA;AACA;AACA,yCAAyC,oEAAU,kBAAkB,kEAAU;AAC/E;;;;;;;;;;;;;;;;AC1HA;AACA;AAC0D;AACR;AAClD;AACA;AACA;AACO,gCAAgC,2DAAc;AACrD;AACA;AACA,8BAA8B,+DAAa;AAC3C;AACA;AACA;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACiC;AACJ;AAC6B;AACR;AAClD;AACA;AACA;AACO,iCAAiC,2DAAc;AACtD;AACA;AACA,+BAA+B,+DAAa;AAC5C,kCAAkC,0CAAa;AAC/C;AACA;AACA,oCAAoC,+DAAa;AACjD;AACA;AACA,oCAAoC,+DAAa;AACjD;AACA;AACA;AACA,8CAA8C,sCAAS;AACvD;AACA;AACA;;;;;;;;;;;;;;;;AC1BA;AACA;AAC0D;AACR;AAClD;AACA;AACA;AACO,iCAAiC,2DAAc;AACtD;AACA;AACA,+BAA+B,+DAAa;AAC5C;AACA;AACA;;;;;;;;;;;;;;;;;ACbA;AACA;AAC+D;AACR;AAChD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAQ,KAAK,+DAAc;AACjD;AACA,sBAAsB,yDAAQ,QAAQ,+DAAc;AACpD;AACA;AACA;AACA,sBAAsB,+DAAc;AACpC,6BAA6B,+DAAa,gBAAgB;AAC1D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AAC6B;AACqD;AACO;AACS;AACrC;AACN;AACoB;AAC3B;AACM;AACF;AACE;AACJ;AAC0B;AACd;AACN;AACN;AACA;AACM;AACJ;AACE;AACJ;AACI;AACA;AAC0B;AACxB;AAC8B;AACR;AAC1B;AACoB;AACzB;AACY;AACQ;AACf;AACa;AACJ;AACW;AACN;AACb;AAC6B;AAC3E,oCAAoC,yEAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,qCAAqC,wEAAuB;AAC5D,6BAA6B,yDAAQ;AACrC,gEAAgE;AAChE;AACA,qCAAqC,qEAAiB;AACtD;AACA;AACA,aAAa;AACb;AACA,yCAAyC,qEAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA,QAAQ,2EAAmB;AAC3B;AACA;AACA;AACA,SAAS;AACT,oCAAoC,mEAAgB;AACpD,+BAA+B,qEAAW;AAC1C;AACA;AACA,SAAS;AACT,iCAAiC,yEAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qBAAqB,yCAAyC;AAC9D;AACA;AACA;AACA;AACA,mEAAmE,yBAAyB,KAAK,yBAAyB,IAAI,aAAa;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAiB;AAC7B;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAU;AACtC;AACA,qDAAqD,6DAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8EAAoB;AAC7D;AACA;AACA,sGAAsG;AACtG;AACA;AACA;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAS;AACxC,+BAA+B,gEAAY;AAC3C,+BAA+B,8DAAW;AAC1C,+BAA+B,gEAAY;AAC3C,+BAA+B,4DAAU;AACzC,+BAA+B,sFAAuB;AACtD,+BAA+B,wEAAgB;AAC/C,+BAA+B,4EAAkB;AACjD,+BAA+B,kEAAa;AAC5C,+BAA+B,4DAAU;AACzC,+BAA+B,4DAAU;AACzC,+BAA+B,kEAAa;AAC5C,+BAA+B,8DAAW;AAC1C,+BAA+B,gEAAY;AAC3C,+BAA+B,4DAAU;AACzC,+BAA+B,8DAAW;AAC1C,+BAA+B,gEAAY;AAC3C,+BAA+B,gEAAY;AAC3C,+BAA+B,4FAA0B;AACzD,+BAA+B,0FAAyB;AACxD,+BAA+B,gGAA4B;AAC3D,+BAA+B,wFAAwB;AACvD,+BAA+B,kEAAa;AAC5C,+BAA+B,8DAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sCAAS,gDAAgD,gEAAa;AAC9G;AACA,yCAAyC,oFAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gEAAa,sBAAsB,qBAAqB,aAAa;AACpG;AACA;AACA;AACA,iBAAiB,gEAAa;AAC9B;AACA;AACA;AACA,iBAAiB,gEAAa;AAC9B;AACA;AACA;AACA;AACA,mCAAmC,gEAAa,sBAAsB,qBAAqB,aAAa;AACxG,2DAA2D,oBAAoB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gEAAa;AAC1C,6BAA6B,gEAAa;AAC1C,+BAA+B,gEAAa,sBAAsB,qBAAqB,aAAa;AACpG,qCAAqC,gEAAa,mBAAmB;AACrE,yBAAyB,gEAAa,iBAAiB,QAAQ,gEAAa,mBAAmB;AAC/F;AACA;AACA,2BAA2B,kFAAkB,+BAA+B,2BAA2B,kFAAkF;AACzL;AACA;AACA;AACA;AACA,2BAA2B,kFAAkB,+BAA+B,yBAAyB,0UAA0U,gEAAa,0IAA0I;AACtkB;AACA;AACA,+BAA+B,8EAAoB;AACnD;AACA;AACA;AACA;AACA,4BAA4B,8DAAI,iBAAiB,+DAAc;AAC/D,+BAA+B,yDAAQ;AACvC;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChWA;AACA;AACwE;AACjE;AACP;AACA,QAAQ,iFAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AAC6B;AAC4F;AACvC;AACrB;AACM;AACd;AACE;AACI;AACN;AACc;AAChB;AACwB;AAC3E;AACA;AACA;AACA,2BAA2B,8EAAoB;AAC/C;AACA,uCAAuC,+DAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kCAAkC,qEAAiB;AACnD;AACA;AACA,SAAS;AACT,QAAQ,2EAAmB;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qEAAqE,+DAAa,mBAAmB;AACrG;AACA;AACA,qFAAqF,+DAAa;AAClG,6GAA6G,mBAAmB;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C,aAAa,oEAAU;AACvB;AACA,+CAA+C,kBAAkB;AACjE,qCAAqC,yDAAQ;AAC7C,sBAAsB,8EAAoB;AAC1C;AACA,aAAa,oEAAU;AACvB;AACA,4CAA4C,yDAAQ;AACpD,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,wEAAuB;AAClI;AACA;AACA,SAAS;AACT,6BAA6B,yDAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,2BAA2B;AACvF;AACA;AACA,6GAA6G,SAAS;AACtH,qCAAqC,yDAAQ;AAC7C,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+DAAc,0BAA0B,2BAA2B;AACjH,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAc,+BAA+B,YAAY;AAC3G,6CAA6C,yDAAQ;AACrD,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAc,+BAA+B,YAAY;AAC3G;AACA,6CAA6C,yDAAQ;AACrD,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,+DAAc,iCAAiC,YAAY;AAC/G;AACA;AACA;AACA;AACA;AACA,yCAAyC,gHAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+DAAc;AACpE,wEAAwE,+DAAa,mBAAmB;AACxG,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA,oDAAoD,sCAAS,iDAAiD,+DAAa;AAC3H;AACA,sDAAsD,+DAAc,sGAAsG,+DAAa,mBAAmB;AAC1M,4EAA4E,+DAAa,mBAAmB,UAAU,wBAAwB;AAC9I,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA,yCAAyC,gHAAgB;AACzD;AACA;AACA;AACA;AACA,sDAAsD,+DAAc;AACpE,wEAAwE,+DAAa,mBAAmB;AACxG,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAAc,+BAA+B,YAAY;AAC3G,6CAA6C,yDAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wEAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,6BAA6B;AAC1H;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW,QAAQ,2DAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,qBAAqB;AAC7E;AACA;AACA;AACA,qDAAqD,mBAAmB,GAAG,uEAAa,aAAa;AACrG,0CAA0C,kEAAQ;AAClD;AACA;AACA;AACA,qBAAqB,+EAAmB;AACxC,2DAA2D,mBAAmB,GAAG,+DAAa,uBAAuB;AACrH;AACA;AACA,wBAAwB,oEAAU;AAClC,wBAAwB,oEAAU;AAClC;AACA,+CAA+C,4BAA4B;AAC3E;AACA,6CAA6C,sBAAsB;AACnE,wBAAwB,oEAAU;AAClC;AACA;AACA,yBAAyB;AACzB;AACA;AACA,4BAA4B,oEAAU;AACtC;AACA,oDAAoD,sBAAsB;AAC1E,4BAA4B,oEAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,+DAAa,oBAAoB;AAC3G,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAQ;AACzC;AACA,qCAAqC,mEAAgB;AACrD,iCAAiC,6DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oFAAwB;AACzD,gCAAgC,+DAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,wLAET;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5ZA;AACA;AAC+C;AACQ;AACY;AAC5D;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAQ,sCAAsC,cAAc;AACxE,YAAY,yDAAQ,YAAY,+DAAa,gBAAgB;AAC7D,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ,sCAAsC,cAAc,mBAAmB,YAAY;AAC/G;AACA;AACA;AACA,iCAAiC,2EAAmB;AACpD;AACA,cAAc,2EAAmB;AACjC;AACA;AACA,kBAAkB,aAAa,GAAG,iBAAiB;AACnD;AACA;AACA,6BAA6B,yDAAQ;AACrC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AAC6B;AAC6D;AAC+B;AACvE;AACC;AACY;AAC5B;AAC0B;AACM;AACX;AACO;AACrB;AACiC;AACpB;AACY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sCAAsC,qEAAiB;AACvD;AACA,aAAa;AACb;AACA,sBAAsB,uEAAiB;AACvC;AACA,8CAA8C,mFAAwB;AACtE;AACA;AACA;AACA,mHAAmH,kDAAK;AACxH;AACA;AACA;AACA,kCAAkC,yDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mHAAmH,kDAAK;AACxH;AACA;AACA;AACA,kCAAkC,yDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAQ;AAClC;AACA;AACA;AACA;AACA,YAAY,iEAAiB,sBAAsB,2CAAI;AACvD;AACA;AACA,QAAQ,4EAAmB;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA,sCAAsC,2EAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAQ;AAChC,mBAAmB,gEAAa,kBAAkB;AAClD;AACA;AACA,sCAAsC,wEAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA,sEAAsE,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,4DAAS;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0CAA0C;AACvE;AACA,8BAA8B,yCAAY;AAC1C,yBAAyB,4DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qCAAqC,wEAAuB;AAC5D;AACA;AACA,SAAS;AACT,6BAA6B,yDAAQ;AACrC;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA,0BAA0B,oEAAU;AACpC,4BAA4B,mBAAmB,QAAQ,sIAEJ;AACnD,0BAA0B,gEAAiB;AAC3C;AACA,2CAA2C,oEAAU;AACrD,qDAAqD,+DAAK;AAC1D;AACA,mEAAmE,4EAAiB;AACpF,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qDAAqD,0BAA0B,gBAAgB,SAAS;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAQ,2BAA2B,qDAAqD;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,yDAAQ,wBAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+DAAc,sBAAsB,sEAAqB;AAC9F;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ,MAAM,8DAAI;AACtC;AACA,oBAAoB,8DAAI;AACxB;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ;AAC5B;AACA,8EAA8E,EAAE;AAChF;AACA;AACA;AACA;AACA,wBAAwB,yDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvRA;AACA;AACiC;AACiC;AACI;AACJ;AACM;AACjE,wBAAwB,2EAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,4DAA4D,4DAAiB;AAC7E;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB,SAAS,yBAAyB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA,sCAAsC,2EAAmB;AACzD,qBAAqB,8CAAiB,iCAAiC,yCAAY;AACnF,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB,SAAS,yBAAyB;AACvG,sDAAsD,gCAAgC,2BAA2B,QAAQ;AACzH;AACA,6BAA6B,uEAAW;AACxC;AACA;AACA;AACA,sBAAsB,uEAAW;AACjC;AACA,0BAA0B,uEAAW;AACrC,0BAA0B,uEAAW;AACrC;AACA,iCAAiC,kCAAkC;AACnE;AACA,8BAA8B,8DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClIA;AACA;AACwE;AACtB;AACM;AACjD,0BAA0B,2DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B,yDAAQ,KAAK,wEAAuB,GAAG,gCAAgC;AACpG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC,6DAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrCA;AACA;AACkD;AACQ;AAC1D;AACA;AACA;AACO,qCAAqC,2DAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D,qDAAqD,+DAAa,mBAAmB,aAAa,wBAAwB;AAC1H;AACA;AACA;AACA;AACA;AACA,yCAAyC,gPAC6C;AACtF;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxCA;AACA;AACkD;AACQ;AACnD,sCAAsC,2DAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC,+DAAa;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACoE;AACrB;AACG;AACL;AACW;AACF;AACoB;AACpB;AACoC;AAChC;AACgB;AACF;AACxE;AACA;AACA;AACO,gCAAgC,2DAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,+DAAa;AAC5C,gFAAgF,+DAAa,mBAAmB;AAChH,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,+DAAa;AACvC,SAAS;AACT;AACA;AACA,mFAAmF,+DAAa,kBAAkB;AAClH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4DAA4D,4DAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yDAAQ;AACjD,uCAAuC,kFAAsB,CAAC;AAC9D,0BAA0B,8EAAoB;AAC9C;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,8BAA8B,8DAAe;AAC7C;AACA;AACA;AACA,gBAAgB,+FAAqB;AACrC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,YAAY,+FAAqB;AACjC;AACA;AACA,aAAa;AACb;AACA,0BAA0B,2DAAS;AACnC,QAAQ,2DAAW;AACnB;AACA;AACA,0CAA0C,+EAAqB;AAC/D;AACA;AACA,kBAAkB,+EAAqB;AACvC;AACA,sCAAsC,mDAAK;AAC3C,iCAAiC,8DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA;AACA;AACA,6CAA6C,kCAAkC;AAC/E;AACA,kDAAkD,2LAEN;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAQ,mCAAmC,sBAAsB;AACjG;AACA;AACA;AACA,gCAAgC,6CAA6C;AAC7E,wFAAwF,4BAA4B;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,wFAAwF,4BAA4B,wCAAwC;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,4BAA4B,kDAAkD;AAClM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mDAAK;AAC/C;AACA;AACA;AACA;AACA,gBAAgB,yDAAQ;AACxB;AACA;AACA;AACA,2BAA2B,yDAAQ,eAAe,iBAAiB,0BAA0B,qBAAqB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4KAA4K;AACxO;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5OA;AACA;AAC6B;AACkC;AACP;AACT;AACmB;AACD;AACX;AACtD;AACA;AACA;AACA;AACO,uCAAuC,yEAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAQ;AAC7B;AACA,gCAAgC,yDAAQ;AACxC;AACA;AACA;AACA;AACA,aAAa,yEAAqB;AAClC;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB,oBAAoB,2CAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,0CAA0C,uEAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAS;AAC3B;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7GA;AACA;AAC6B;AACkB;AACiC;AACE;AACvB;AACH;AACN;AACA;AACI;AACgB;AACI;AACpC;AACoB;AACJ;AACtD;AACA;AACA;AACO,2BAA2B,2DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,+DAAa,kBAAkB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,2CAAG;AAC3B,6BAA6B,yDAAQ,KAAK,wEAAuB,GAAG,gCAAgC;AACpG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,wBAAwB,UAAU,0BAA0B;AACnF,mBAAmB,gBAAgB;AACnC,SAAS;AACT;AACA;AACA;AACA,gFAAgF,gBAAgB;AAChG,SAAS;AACT;AACA;AACA;AACA,kFAAkF,gBAAgB;AAClG,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE,oCAAoC;AAClE,2BAA2B,gCAAgC;AAC3D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kHAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,6DAAU,CAAC,6DAAU;AACrF,uCAAuC,4CAA4C,MAAM,2CAA2C;AACpI,uDAAuD,oCAAoC;AAC3F,wBAAwB,6DAAU,CAAC,6DAAU,OAAO,uBAAuB,4CAA4C;AACvH,sCAAsC,2CAA2C;AACjF;AACA;AACA;AACA;AACA,uBAAuB,qCAAqC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6DAAU,CAAC,6DAAU;AAC7D;AACA,+CAA+C,6DAAU,CAAC,6DAAU;AACpE;AACA,wCAAwC,kBAAkB,4CAA4C,YAAY;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE,mBAAmB,4CAA4C,MAAM,2CAA2C;AAChH;AACA;AACA;AACA,2CAA2C,2DAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,iBAAiB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gFAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAW;AACnB;AACA;AACA,yBAAyB,yEAAW;AACpC,sCAAsC,0CAAa;AACnD;AACA;AACA;AACA;AACA,wBAAwB,sCAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C,aAAa;AACb,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sBAAsB,6DAAU,CAAC,6DAAU;AAC3C;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAU,CAAC,6DAAU;AACtC;AACA;AACA,iBAAiB,6DAAU,CAAC,6DAAU;AACtC,iBAAiB,6DAAU,CAAC,6DAAU;AACtC,iBAAiB,6DAAU,CAAC,6DAAU;AACtC,iBAAiB,6DAAU,CAAC,6DAAU;AACtC;AACA;AACA;AACA;AACA;AACA,qDAAqD,4EAA2B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,4EAA2B;AACrF;AACA;AACA,2CAA2C,6DAAU,CAAC,6DAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDACM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,8EAA8E,MAAM;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+BAA+B,wDAAU;AACzC;AACA,2BAA2B,oEAAU;AACrC;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAU,+BAA+B,0BAA0B;AAC3E;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAS;AAC3B;AACA;AACA;AACA,aAAa;AACb,kBAAkB,4DAAS;AAC3B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wFAAwF,cAAc;AACtG;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxlBA;AACA;AAC+C;AACG;AACwC;AAClB;AACjE,0BAA0B,2DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4DAA4D,4DAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAe;AAC7C;AACA,4CAA4C,yDAAQ,oBAAoB,0BAA0B;AAClG,6BAA6B,iBAAiB,EAAE,iCAAiC,GAAG,0BAA0B;AAC9G;AACA,QAAQ,+FAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;ACzDA;AACA;AAC6B;AACqB;AAC6B;AACxE,2BAA2B,2DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,8BAA8B,QAAQ,kJAAwD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0CAAa,oBAAoB;AACxE;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE,6BAA6B,0CAAa,mBAAmB;AAC7D;AACA;AACA;AACA,cAAc,yCAAY;AAC1B,cAAc,sCAAS;AACvB;AACA,cAAc,yCAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA,oDAAoD,oFAAqB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,mBAAmB,QAAQ,sIAEJ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7JA;AACA;AAC6B;AACkE;AAChD;AACa;AACK;AACS;AACnE,yBAAyB,qEAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAQ;AAClC;AACA;AACA;AACA;AACA,+BAA+B,oEAAU;AACzC;AACA;AACA;AACA;AACA,6BAA6B,sCAAS;AACtC,0BAA0B,oEAAU;AACpC;AACA;AACA;AACA;AACA,8BAA8B,yDAAQ,sCAAsC,SAAS;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sEAAgB,CAAC;AACpD;AACA,+BAA+B,sCAAS;AACxC,iBAAiB,oEAAU;AAC3B;AACA,0BAA0B,uEAAa;AACvC;AACA,oCAAoC,sCAAS;AAC7C;AACA,kBAAkB,mFAAqB;AACvC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5HA;AACA;AACiF;AAClC;AACG;AACQ;AACnD,sCAAsC,2DAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kCAAkC,+DAAa;AAC/C;AACA;AACA;AACA,SAAS;AACT,YAAY,oEAAU;AACtB;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ;AAC5B,QAAQ,kEAAQ;AAChB;AACA,+BAA+B,qEAAW;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACuE;AACxB;AACG;AAC2C;AAC5B;AACP;AAC1D,gCAAgC,sEAAgB,CAAC;AAC1C,+BAA+B,2DAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC,kGAA2B;AAC5D,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ;AAC5B;AACA;AACA;AACA,sEAAsE,+DAAa,kBAAkB,KAAK,iBAAiB;AAC3H;AACA,gCAAgC,oEAAU;AAC1C;AACA,QAAQ,oEAAU;AAClB;AACA,gCAAgC,qEAAW;AAC3C,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACiE;AACf;AACwB;AACC;AACH;AACE;AACnE,iCAAiC,2DAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6BAA6B,yDAAQ,KAAK,wEAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mCAAmC;AACrF;AACA,YAAY,+EAAsB;AAClC;AACA;AACA,sCAAsC,oCAAoC,oBAAoB,gBAAgB;AAC9G,mCAAmC,sEAAgB,CAAC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oEAAU;AACxB,cAAc,+DAAK;AACnB,kCAAkC,gBAAgB,sBAAsB,iBAAiB;AACzF,uCAAuC,mBAAmB,GAAG,uCAAuC;AACpG,kBAAkB,mFAAqB;AACvC,SAAS,IAAI,iBAAiB;AAC9B;AACA,mCAAmC,kEAAQ;AAC3C;AACA,cAAc,kEAAQ;AACtB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjEA;AACA;AACwD;AACiB;AACpB;AAC9C,4BAA4B,iEAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wCAAwC,iFAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1EA;AACA;AACoE;AAC7D,yCAAyC,6EAAuB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACkD;AAC3C,yBAAyB,2DAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C,iQAEN;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACoD;AACoB;AACtB;AACoB;AACG;AAClE,yBAAyB,2DAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,wCAAwC,iFAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,6BAA6B,yDAAQ,KAAK,wEAAuB;AACjE;AACA,QAAQ,8DAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2EAA2B;AAClE,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB,QAAQ,mHAAmB;AAC/D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,2EAA2B;AACtE;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtLA;AACA;AAC6B;AACI;AACyB;AACX;AACS;AACd;AACsB;AACI;AACN;AACJ;AACR;AACE;AACkB;AACL;AACX;AAChB;AACoB;AACnD,4BAA4B,2DAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+FAA+F,+DAAa,mBAAmB;AAC/H;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8EAAmC,8FAA8F,qBAAqB;AACpK;AACA,yCAAyC,sCAAS;AAClD;AACA,uCAAuC,sCAAS;AAChD;AACA;AACA;AACA;AACA,YAAY,yEAAkB;AAC9B;AACA;AACA;AACA;AACA,wBAAwB,2CAAG;AAC3B,+BAA+B,yDAAU;AACzC;AACA;AACA;AACA;AACA,wCAAwC,oEAAe;AACvD;AACA;AACA;AACA,2BAA2B,yDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC,oBAAoB,oBAAoB;AAC1G;AACA;AACA;AACA,kCAAkC,gEAAa;AAC/C;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,2EAA8B;AACjI;AACA;AACA;AACA;AACA,8CAA8C,8DAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,8DAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,0BAA0B;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY,GAAG,eAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8DAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAgB;AAClC;AACA;AACA;AACA,oBAAoB,sEAAgB;AACpC;AACA;AACA,wCAAwC,gDAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAY;AAC1C;AACA,4CAA4C,0BAA0B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAgB;AACpC,cAAc,sEAAgB;AAC9B;AACA;AACA;AACA,gCAAgC,sCAAS;AACzC;AACA;AACA,kBAAkB,sCAAS;AAC3B,YAAY,oEAAU;AACtB;AACA,iCAAiC,sCAAS;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK,IAAI,4BAA4B;AAC3D;AACA;AACA,sBAAsB,KAAK,GAAG,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAS;AACjB;AACA,QAAQ,4DAAS;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,2BAA2B,SAAS,cAAc,yBAAyB;AAC3E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChcA;AACA;AAC+C;AACG;AACI;AACE;AACE;AACnD,0BAA0B,2DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,2DAAS;AACnC,kCAAkC,+DAAa;AAC/C,iCAAiC,6DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAQ,6EAA6E,qBAAqB;AACtH;AACA;AACA;;;;;;;;;;;;;;;;ACxCA;AACA;AACkE;AACM;AACjE,2BAA2B,2EAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,4DAA4D,4DAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA,6DAA6D,oBAAoB,mBAAmB,YAAY;AAChH;AACA;AACA,oCAAoC,aAAa;AACjD;AACA,8BAA8B,8DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC9DA;AACA;AAC6B;AACqB;AACH;AACW;AACE;AACrD,yBAAyB,qEAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC,yCAAY;AAChD,aAAa,oEAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB,QAAQ,mHAAmB;AAC3D,8CAA8C,cAAc,OAAO,QAAQ,OAAO,cAAc;AAChG;AACA;AACA,iCAAiC,oEAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,8DAA2B;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChNA;AACA;AAC8E;AAC5B;AAC3C,0BAA0B,2DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC,mFAAoB;AAC7D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzBA;AACA;AACkD;AACQ;AACnD,2BAA2B,2DAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kCAAkC,+DAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3BA;AACA;AACwD;AACiB;AACpB;AAC9C,2BAA2B,iEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4CAA4C,iFAAqB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3FA;AACA;AACoE;AAC7D,wCAAwC,6EAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACoE;AACI;AACtB;AAC0B;AAClB;AACnD,2CAA2C,2DAAc;AAChE;AACA;AACA,wBAAwB,+DAAa;AACrC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,yDAAQ,KAAK,wEAAuB;AACjE,8CAA8C,iFAAuB;AACrE;AACA;AACA,kDAAkD,2BAA2B;AAC7E,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA,gDAAgD,oCAAoC;AACpF,mBAAmB,oCAAoC;AACvD;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA,kDAAkD,oCAAoC;AACtF,mBAAmB,oCAAoC;AACvD,mBAAmB,2BAA2B;AAC9C,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/EA;AACA;AACkD;AACsB;AACjE,uCAAuC,2DAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,4DAA4D,4DAAiB;AAC7E;AACA;AACA,iBAAiB,oBAAoB,IAAI,qBAAqB;AAC9D,YAAY,gPAAqF;AACjG,YAAY,qLAAuF;AACnG;AACA;AACA;AACA,8BAA8B,8DAAe;AAC7C;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACiC;AACkC;AAChB;AACa;AAC0B;AACpB;AACpB;AACE;AACd;AACoB;AACnD;AACA;AACA,4BAA4B,2DAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,+DAAa;AAC5C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kBAAkB,8EAAmC;AACrD;AACA;AACA,aAAa;AACb;AACA,wBAAwB,2CAAG;AAC3B;AACA;AACA,2CAA2C,sKAEN;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA,kGAAkG,8DAAI,eAAe,wDAAQ;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,0CAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8DAAI,kBAAkB,wDAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+FAAqB;AACxD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAG;AAC3B,+BAA+B,yDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uEAAa;AACnD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9NA;AACA;AACyB;AACzB;AACA;AACA;AACA;AACO;AACP;AACA,oCAAoC,4BAA4B,oDAAuB,+CAA+C,+BAAE,oCAAoC,oCAAO;AACnL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACuF;AACxC;AACG;AACsD;AACV;AACJ;AACoB;AACxB;AAC5B;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,uCAAuC,mGAA0B;AACjE;AACA,uCAAuC,6GAA+B;AACtE,uCAAuC,+FAAwB;AAC/D,kDAAkD,mHAAkC;AACpF,4CAA4C,2FAAsB;AAClE;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO,GAAG,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ,aAAa,uBAAuB;AACxE;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA,0BAA0B,uDAAS;AACnC;AACA,QAAQ,uDAAS,uBAAuB,uDAAS,cAAc,uDAAS;AACxE;AACA,QAAQ,uDAAS;AACjB;AACA;AACA;AACA,QAAQ,uDAAS,oBAAoB,uDAAS,2BAA2B,uDAAS;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAS;AACtC;AACA;AACA;AACA,8BAA8B,uDAAS;AACvC;AACA;AACA;AACA,QAAQ,uDAAS;AACjB,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAoC;AACjE,mCAAmC,0CAA0C;AAC7E,yCAAyC,gDAAgD;AACzF,6BAA6B,oCAAoC;AACjE,2BAA2B,kCAAkC;AAC7D,iCAAiC,wCAAwC;AACzE,0CAA0C,0CAA0C;AACpF,wCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2EAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,+DAAa,kBAAkB;AACpJ,qDAAqD,eAAe;AACpE,kCAAkC,8EAAoB;AACtD;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,MAAM,eAAe,cAAc,MAAM,YAAY;AAC7H,4CAA4C,4EAA4E,oBAAoB,gBAAgB;AAC5J,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3VA;AACA;AAC2D;AACD;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,mEAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uCAAuC,+DAAa,sBAAsB,uBAAuB,mBAAmB,yCAAyC,wBAAwB;AACrL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACnGA;AACA;AAC6B;AACmE;AACjD;AACO;AACA;AACA;AACI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,+DAAgB;AACxD;AACA;AACA;AACA;AACA;AACA,YAAY,+DAAa;AACzB;AACA,0CAA0C,sCAAS;AACnD,iBAAiB,oEAAU;AAC3B,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA,oCAAoC,sCAAS;AAC7C,iBAAiB,oEAAU;AAC3B,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA,gCAAgC,kEAAQ;AACxC;AACA,uDAAuD,gBAAgB;AACvE,yEAAyE,wBAAwB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAa;AAC/C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sCAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAS;AACnC,yBAAyB,2DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,yDAAQ,yCAAyC,SAAS;AACzF,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAI,sCAAsC,MAAM;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,SAAS,IAAI,wCAAwC,qCAAqC,QAAQ;AAC1L;AACA,kGAAkG,aAAa;AAC/G;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrJA;AACA;AACmF;AAC1B;AACqB;AACxB;AACgB;AAChB;AACuC;AACnC;AACoB;AACF;AACH;AACY;AACU;AAClD;AAC6B;AACD;AACgC;AAC1C;AACO;AACqB;AACb;AACH;AACgB;AACO;AACpD;AAC2C;AACjB;AACtB;AACuC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,+DAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,+DAAa;AAC7G;AACA;AACA;AACA;AACA,yBAAyB,mFAAkB;AAC3C,6BAA6B,yDAAQ;AACrC;AACA;AACA,YAAY,0FAAqB;AACjC;AACA,YAAY,uGAA4B;AACxC;AACA,YAAY,oGAA0B;AACtC,YAAY,8FAAuB;AACnC,YAAY,gGAAwB;AACpC;AACA;AACA;AACA;AACA;AACA,qCAAqC,oFAAwB;AAC7D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,wCAAwC,kFAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,aAAa;AACb;AACA;AACA;AACA,mFAAmF,+DAAa,kBAAkB;AAClH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4IAA4I,gEAAgE;AAC5M,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gEAAgE,6DAAiB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA,kCAAkC,uEAAa,oCAAoC,UAAU;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB,QAAQ,kQAEW;AAC7D,kCAAkC,+DAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qCAAqC,oDAAQ,qEAAqE,+DAAa,yBAAyB;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4EAAgB;AAC9B;AACA;AACA,0BAA0B,4DAAS;AACnC;AACA;AACA,oBAAoB,wBAAwB,QAAQ,qMAEO;AAC3D;AACA;AACA;AACA;AACA;AACA,gBAAgB,+FAAuB;AACvC;AACA,aAAa;AACb;AACA;AACA,YAAY,+GAA+B;AAC3C,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kFAAuB;AACnE,yCAAyC,4EAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAQ;AAC3C;AACA;AACA;AACA;AACA,2BAA2B,8MAC0F;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iGAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,iFAAgB;AACpC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB,QAAQ,iMAAgD;AAClG;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA,wBAAwB,8BAA8B,QAAQ,yNAA4D;AAC1H;AACA;AACA,qCAAqC,wDAAS;AAC9C;AACA;AACA;AACA,wBAAwB,oFAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+GAA+G;AAC/H,gBAAgB,wBAAwB;AACxC,gBAAgB,mBAAmB;AACnC;AACA;AACA,uCAAuC,4DAAS;AAChD;AACA,6BAA6B,gFAAqB;AAClD;AACA;AACA,QAAQ,wDAAS;AACjB;AACA;AACA,oCAAoC,8BAA8B;AAClE;AACA,8EAA8E,qCAAqC,iCAAiC;AACpJ,sEAAsE,qCAAqC;AAC3G;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB,OAAO,8BAA8B;AAClF,4BAA4B,cAAc;AAC1C;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wHAAwH;AACxI;AACA;AACA,gBAAgB,oCAAoC;AACpD;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA,gBAAgB,iBAAiB,QAAQ,sKAEJ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,sBAAsB,EAAE,oDAAoD;AACtI;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,uEAAuE,gBAAgB,GAAG,OAAO;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAyC;AAC7D,oCAAoC,iEAAc;AAClD;AACA;AACA;AACA;AACA,sDAAsD,sBAAsB,SAAS,sCAAsC;AAC3H;AACA;AACA,0CAA0C,yDAAQ,YAAY;AAC9D;AACA;AACA,2EAA2E,qCAAqC;AAChH;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,8BAA8B;AACrG;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8EAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wEAAwE;AACxF,qCAAqC,mGAAyB;AAC9D,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA;AACA,wCAAwC,+EAAe;AACvD;AACA;AACA,oCAAoC,iBAAiB,GAAG,qBAAqB;AAC7E,kCAAkC,+EAAe;AACjD,mCAAmC,yDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8EAAoB;AACrD,2CAA2C,iBAAiB,GAAG,qBAAqB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yDAAQ,aAAa,iBAAiB,aAAa,qBAAqB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,8EAA8E;AACxJ;AACA,0KAA0K;AAC1K;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+EAAe;AAC5C;AACA;AACA,6BAA6B,+EAAe;AAC5C;AACA;AACA,6BAA6B,+EAAe;AAC5C;AACA;AACA,6BAA6B,+EAAe;AAC5C;AACA;AACA,6BAA6B,+EAAe;AAC5C;AACA;AACA,6BAA6B,+EAAe;AAC5C;AACA;AACA,6BAA6B,+EAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA,gCAAgC,+DAAa;AAC7C,gCAAgC,+DAAa;AAC7C;AACA;AACA;AACA,QAAQ,4DAAW;AACnB,sCAAsC,mDAAK;AAC3C;AACA;AACA,gCAAgC,+DAAa;AAC7C,gCAAgC,+DAAa;AAC7C;AACA;AACA;AACA,sCAAsC,mDAAK;AAC3C;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChrBA;AACA;AACA;AACA,yDAAyD,iCAAiC;AAC1F;AACA;AACA;AACyE;AACH;AACV;AAClB;AAC4B;AACuC;AAC/B;AACG;AACA;AACT;AACN;AAC6B;AACK;AAC9C;AACe;AACK;AACA;AACN;AACW;AAC2B;AAC1B;AAC8C;AACxE;AACD;AACD;AACG;AACoF;AAC7D;AAC5C;AACoC;AACI;AAC6C;AACjD;AACb;AACY;AACT;AACS;AACK;AAChB;AACwC;AACkB;AAC5D;AACxD;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AAC6B;AAC2E;AACzD;AACI;AACU;AACI;AACjB;AACS;AACY;AAC9D;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,6EAAqB;AACvG;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA,4BAA4B,qEAAW;AACvC;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA;AACA;AACA,aAAa,oEAAU;AACvB,iDAAiD,WAAW,6DAA6D,UAAU;AACnI;AACA,cAAc,0EAAc,iFAAiF,yDAAa;AAC1H;AACA,oCAAoC,0CAAa;AACjD,uEAAuE,oBAAoB;AAC3F,2BAA2B,kEAAQ;AACnC;AACA;AACA,wCAAwC,sCAAS,wBAAwB,yDAAa;AACtF,oCAAoC,sCAAS;AAC7C,gCAAgC,kEAAQ;AACxC,wCAAwC,iEAAe;AACvD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yCAAyC,sBAAsB,GAAG,yDAAa,uBAAuB;AACtG,gCAAgC,kBAAkB;AAClD,uFAAuF,oEAAU;AACjG;AACA,oBAAoB,oEAAU;AAC9B;AACA,oBAAoB,oEAAU;AAC9B;AACA;AACA,gBAAgB,2DAAS;AACzB;AACA;AACA;AACA,iBAAiB;AACjB,yFAAyF,sBAAsB;AAC/G,sBAAsB,2DAAS;AAC/B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0EAAc,iFAAiF,yDAAa;AAC1H,6CAA6C,sCAAS;AACtD,oBAAoB,oEAAU;AAC9B;AACA;AACA,mFAAmF,6BAA6B;AAChH;AACA,kBAAkB,oEAAU;AAC5B,8BAA8B,oEAAU,qCAAqC,oBAAoB,qEAAW,KAAK;AACjH;AACA,kBAAkB,oEAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oEAAU,iBAAiB,sCAAS;AAC1D;AACA;AACA;AACA,kCAAkC,qEAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAS;AACjB;AACA;AACA;AACA,SAAS;AACT,cAAc,2DAAS;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oDAAoD,yDAAQ;AAC5D,kBAAkB,2DAAS;AAC3B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,oEAAU;AAC9B;AACA;AACA,sCAAsC,oEAAU;AAChD,gCAAgC,qEAAW;AAC3C,SAAS;AACT;AACA,oDAAoD,yDAAQ;AAC5D,2DAA2D,wBAAwB;AACnF;AACA;AACA,oDAAoD,yDAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChLA;AACA;AACuF;AAC3B;AAC5D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAU,kBAAkB,6DAAU;AAC7D;AACA;AACA;AACA,8CAA8C,SAAS;AACvD,+BAA+B,kEAAQ;AACvC;AACA;AACA;AACA;AACA,2DAA2D,UAAU,uBAAuB,YAAY;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,YAAY;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD,kCAAkC,kEAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wDAAwD,SAAS;AACjE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB,QAAQ,mHAAmB;AAC/D,qDAAqD,wCAAwC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kBAAkB,+DAAK;AACvB,4CAA4C,kEAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAiD,EAAE,cAAc;AAChG,kBAAkB,+DAAK;AACvB;AACA,kCAAkC,SAAS;AAC3C;AACA,0BAA0B,oEAAU;AACpC;AACA,aAAa,IAAI,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3IA;AACA;AACsD;AACV;AACQ;AACM;AAC1D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6DAAe;AACtE;AACA;AACA,gCAAgC,qDAAW;AAC3C,iCAAiC,+DAAgB;AACjD,+BAA+B,+DAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,+DAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mEAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC5EA;AACA;AAC6B;AACI;AAC+C;AAC1B;AACD;AACK;AAC1D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAY;AAC7C,qCAAqC,yCAAY;AACjD,gBAAgB,oEAAU;AAC1B;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA;AACA;AACA,gBAAgB,oEAAU,WAAW,sCAAS;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6DAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sCAAsC,sCAAS;AAC/C;AACA,2BAA2B,IAAI,IAAI,qCAAqC;AACxE,yCAAyC,mBAAmB,GAAG,kBAAkB;AACjF;AACA;AACA,gBAAgB,kEAAQ;AACxB,gBAAgB,oEAAU,WAAW,sCAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAS;AAC3C;AACA;AACA,YAAY,oEAAU;AACtB,wBAAwB,kEAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA,8CAA8C,0BAA0B;AACxE;AACA;AACA;AACA;AACA,8BAA8B,cAAc,EAAE,IAAI;AAClD;AACA,+BAA+B,WAAW,EAAE,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,MAAM,EAAE,UAAU;AAChD;AACA,iCAAiC,gBAAgB,EAAE,IAAI;AACvD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8CAAiB;AAC/B,mIAAmI,6DAAU;AAC7I;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAU,kBAAkB,2DAAU;AACtE;;;;;;;;;;;;;;;;;;;;ACpMA;AACA;AAC0F;AACvC;AACkB;AACT;AACO;AACnE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,yEAAyE,mBAAmB;AAC5F;AACA;AACA,2IAA2I;AAC3I;AACA;AACA;AACA;AACA,mCAAmC,6EAAqB;AACxD,iCAAiC,mBAAmB,GAAG,eAAe;AACtE,2BAA2B,oEAAU,kBAAkB,6DAAU;AACjE;AACA;AACA,+BAA+B,kEAAQ;AACvC;AACA;AACA,iBAAiB,oEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAQ,qCAAqC,eAAe;AACzF;AACA;AACA;AACA;AACA;AACA,cAAc,2DAAS;AACvB;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA,aAAa,+EAAmB;AAChC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAQ;AAC1B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChIA;AACA;AACiC;AACyB;AACnD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAmE;AAC5F,uCAAuC,kEAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1HA;AACA;AAC4C;AACiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM,GAAG,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAqB;AAC5C;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa,4CAA4C,cAAc;AACjG;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrIA;AACA;AAC+C;AACI;AACT;AACS;AACwB;AACpE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kDAAK,SAAS;AACtE;AACA;AACA,8BAA8B,2DAAS;AACvC;AACA,+BAA+B,yDAAQ,oCAAoC,kDAAK,QAAQ;AACxF;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,gCAAgC,mFAAwB;AACxD,oBAAoB,2DAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,wBAAwB,yDAAQ,uBAAuB,OAAO,YAAY,MAAM;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,+BAA+B,yDAAQ,iCAAiC,qBAAqB;AAC7F;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChEA;AACA;AACoC;AACP;AACF;AACuB;AAC2C;AAC9C;AACwB;AACpB;AACO;AACiB;AACxB;AACH;AACzC;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mFAAwB,kBAAkB,oEAAU;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAmC;AACtD;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sCAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAgB;AAC3C;AACA;AACA;AACA;AACA,iCAAiC,yCAAY;AAC7C;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,aAAa;AAC/F;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB,QAAQ,mBAAmB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,iBAAiB;AAClC;AACA;AACA;AACA,gHAAgH,mBAAmB;AACnI;AACA,0BAA0B,mBAAmB,GAAG,gDAAgD;AAChG;AACA;AACA;AACA,0FAA0F,0BAA0B;AACpH,kFAAkF,kBAAkB;AACpG;AACA,4BAA4B,yDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAQ,sDAAsD,yDAAa,kBAAkB;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAc;AAC7B;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK,EAAE,QAAQ;AACnD;AACA;AACA,oCAAoC,KAAK,GAAG,QAAQ;AACpD;AACA;AACA,0BAA0B,sCAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe,EAAE,mBAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,iBAAiB;AACrF;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAU;AACtC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+CAA+C,iBAAiB;AAChE;AACA;AACA,0EAA0E,iBAAiB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAS;AAClC;AACA;AACA,YAAY,qFAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,IAAI;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,eAAe;AACtE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,kFAAkF,IAAI;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3RA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACiC;AACc;AACC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yCAAY;AACrC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAgB;AAC5B;AACA,0BAA0B,yDAAQ,iCAAiC,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAQ,oCAAoC,YAAY;AACzF,sGAAsG,yDAAa,kBAAkB;AACrI;AACA;AACA;AACA;AACA,iCAAiC,yDAAQ,oCAAoC,YAAY;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAQ,oCAAoC,YAAY;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAQ,oCAAoC,YAAY;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;;;;;;;;;;;;;;ACZA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AAC6B;AACD;AACiE;AACiB;AACnC;AACE;AACd;AACnC;AACkC;AAC9D;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,qCAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAwC;AACxD,gBAAgB,iGAAiG;AACjH;AACA,yBAAyB,yEAAW;AACpC;AACA;AACA;AACA;AACA;AACA,6BAA6B,4EAAc;AAC3C;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAK;AACvB;AACA;AACA;AACA;AACA,aAAa,IAAI,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8DAAI,kBAAkB,0CAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,wEAAkB;AAChE;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY,GAAG,2BAA2B;AAC/E;AACA,qBAAqB;AACrB,0CAA0C,wEAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,kCAAkC,yEAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D,iDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAK;AAC3B,sDAAsD,sFAAyB;AAC/E,gCAAgC,oEAAU;AAC1C;AACA;AACA;AACA,sEAAsE,0BAA0B;AAChG;AACA;AACA,8DAA8D,8DAAI,kBAAkB,0CAAa;AACjG;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,uCAAuC,8DAAI,kBAAkB,0CAAa;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA;AACA,wBAAwB,+EAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,4EAAc;AACzE,+BAA+B,uEAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,wGAAwG,oGAAoG;AAC5M;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,oGAAoG;AACpM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0CAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mFAAwB;AAC3E;AACA,kCAAkC,6CAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB,QAAQ,mHAAmB;AACvD,UAAU,+DAAK;AACf,gBAAgB,+DAA+D;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC,8DAAI,kBAAkB,0CAAa,gBAAgB,yCAAY;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oBAAoB,MAAM,8BAA8B;AACnH,iDAAiD,cAAc,sBAAsB,QAAQ,yBAAyB,qBAAqB;AAC3I,4BAA4B,yBAAyB,MAAM,mCAAmC;AAC9F;AACA;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;ACpSA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjCA;AACA;AACsD;AACH;AACnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAgB;AAC9B;AACA;AACA,cAAc,+DAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAgB;AAC9B;AACA;AACA,cAAc,+DAAgB;AAC9B;AACA;AACA;AACA,cAAc,+DAAgB;AAC9B;AACA;AACA;AACA,wBAAwB,+DAAgB;AACxC,cAAc,+DAAgB;AAC9B;AACA;AACA,gCAAgC,QAAQ,GAAG,eAAe;AAC1D;AACA;AACA,qBAAqB,aAAa,GAAG,eAAe,GAAG,eAAe;AACtE,qBAAqB,aAAa,GAAG,eAAe;AACpD;AACA;AACA;AACA;AACA,wBAAwB,+DAAgB;AACxC,iCAAiC,2DAAS,yGAAyG,+DAAgB;AACnK;AACA;AACA;AACA,cAAc,+DAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AAC6B;AACI;AACQ;AACyD;AAC7C;AACF;AACkC;AAC9B;AACvD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6BAA6B;AACxE;AACA;AACA;AACA,kCAAkC,kEAAQ;AAC1C;AACA,gCAAgC,qCAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wDAAwD,qBAAqB,aAAa,+BAA+B;AACzH;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6DAAU;AACnD,0BAA0B,uCAAU;AACpC,gDAAgD,6DAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2DAA2D,2DAAyB;AACpF,gCAAgC,UAAU;AAC1C;AACA;AACA,8CAA8C,EAAE,oCAAoC,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAa;AAC7C;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA,0BAA0B,8DAAI;AAC9B;AACA;AACA,2BAA2B,uCAAuC,IAAI,SAAS,EAAE,aAAa,EAAE,kBAAkB;AAClH;AACA,kBAAkB,2DAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+CAA+C,qEAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,yEAAuB;AACnF,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA,iBAAiB,6DAAU;AAC3B;AACA,iBAAiB,6DAAU;AAC3B;AACA,iBAAiB,6DAAU;AAC3B;AACA,iBAAiB,6DAAU;AAC3B;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA,YAAY,8CAAiB;AAC7B;AACA,yBAAyB,uCAAU;AACnC;AACA,qBAAqB,uCAAU;AAC/B,oBAAoB,YAAY,GAAG,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAQ,IAAI,SAAS,WAAW,SAAS;AACrE,qBAAqB,yCAAY;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qCAAqC,IAAI,6DAAU,qBAAqB;AACvG,uBAAuB,oBAAoB,KAAK,WAAW;AAC3D;AACA;AACA;AACA,+BAA+B,qCAAqC,eAAe,oBAAoB,KAAK,WAAW;AACvH;AACA,4BAA4B,sCAAS,wBAAwB,uEAAa;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAU,uBAAuB,IAAI,kBAAkB;AAC1F;AACA,SAAS;AACT;AACA,YAAY,kEAAQ,kCAAkC,0BAA0B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6DAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qEAAmB;AACxE;AACA;AACA,+DAA+D,yEAAuB;AACtF,+CAA+C,WAAW;AAC1D;AACA;AACA,kEAAkE,6DAAU;AAC5E;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,6DAAU;AACtF;AACA;AACA,sEAAsE,6DAAU;AAChF,6BAA6B,uCAAU;AACvC;AACA,sBAAsB,WAAW,GAAG,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wGAAwG;AAChI;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAI,kBAAkB,6DAAU;AAChE;AACA;AACA,2DAA2D,6BAA6B,KAAK,eAAe;AAC5G;AACA;AACA,8BAA8B,uEAAa,wBAAwB,4BAA4B;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAU;AAC5C,gDAAgD,yCAAyC;AACzF;AACA,sCAAsC,6DAAU;AAChD,iEAAiE,qCAAqC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAS;AACjC;AACA;AACA;AACA;AACA;AACA,uCAAuC,6DAAU;AACjD;AACA;AACA,sCAAsC,6DAAU;AAChD,6CAA6C,8CAAiB;AAC9D;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,2CAA2C,uCAAU;AACrD;AACA;AACA;AACA;AACA;AACA,gDAAgD,sCAAS;AACzD;AACA;AACA,2FAA2F,6DAAU;AACrG;AACA,sBAAsB,uCAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAS;AACrC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,sCAAsC,6DAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qEAAmB;AAC3D,iFAAiF,yEAAuB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6DAAU;AACpD,iCAAiC,6DAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAgB;AAC5C,8BAA8B,6DAAU;AACxC,8BAA8B,6DAAU;AACxC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yEAAuB;AAC/D,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB,EAAE,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qEAAmB;AAClE;AACA,yDAAyD,yEAAuB;AAChF;AACA;AACA;AACA,2CAA2C,qEAAmB;AAC9D;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAU;AACtC,iDAAiD,eAAe;AAChE,0DAA0D,yBAAyB;AACnF,4BAA4B,qBAAqB;AACjD,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7jBA;AACA;AAC6B;AACkB;AACY;AACX;AAChD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wCAAwC,sCAAS,2CAA2C,yDAAa;AACzG,4CAA4C,mEAAa;AACzD,0CAA0C,sCAAS,8BAA8B,yDAAa;AAC9F,2CAA2C,mEAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAa;AAC/C;AACA;AACA,kCAAkC,yCAAY;AAC9C;AACA;AACA;AACA,yBAAyB,0CAAa;AACtC;AACA,aAAa,4CAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAQ,8DAA8D,sCAAS;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtFA;AACA;AAC6F;AAC9B;AACJ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oEAAU;AACrC;AACA;AACA,iBAAiB,oEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,+CAA+C,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wEAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAW,IAAI,EAAE,kBAAkB;AACtD,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAQ,4BAA4B,mBAAmB,qEAAW,KAAK;AACtF;AACA;AACA,4BAA4B,oEAAU,kBAAkB,4DAAU;AAClE;;;;;;;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzRA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACtFA;AACA;AAC6B;AACI;AAC+C;AACjB;AACf;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAQ,KAAK,+DAAc;AACrD,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB,+BAA+B,yDAAa,mBAAmB;AAC/D;AACA,kCAAkC,gCAAgC;AAClE;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB,+BAA+B,yDAAa,mBAAmB;AAC/D;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAY,CAAC,oEAAU;AACxD;AACA;AACA,mCAAmC,oEAAU;AAC7C;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ,QAAQ,+DAAc;AAC1D;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ,QAAQ,+DAAc;AAC1D;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ,YAAY,OAAO;AACvD;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAS,SAAS,yDAAa;AACrE,gBAAgB,oEAAU;AAC1B;AACA,kCAAkC,oEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yCAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5HA;AACA;AAC4D;AACG;AACA;AACxD;AACP;AACA;AACA;AACA,uBAAuB,qEAAiB;AACxC;AACA,uBAAuB,wEAAkB;AACzC;AACA,uBAAuB,wEAAkB;AACzC;AACA,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAiB;AACxC;AACA,uBAAuB,wEAAkB;AACzC;AACA,uBAAuB,wEAAkB;AACzC;AACA,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACiE;AACuH;AACxI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8EAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8EAAwB,EAAE;AACnE;AACA,KAAK;AACL;AACA,oBAAoB,kFAA4B;AAChD;AACA;AACA;AACA,mCAAmC,yDAAa,mBAAmB;AACnE;AACA;AACA,yCAAyC,kFAA4B,EAAE;AACvE;AACA,KAAK;AACL;AACA,oBAAoB,mFAA6B;AACjD;AACA;AACA;AACA,mCAAmC,yDAAa,mBAAmB;AACnE;AACA;AACA;AACA;AACA,yCAAyC,mFAA6B,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA,oBAAoB,sFAAgC;AACpD;AACA;AACA;AACA,mCAAmC,yDAAa,mBAAmB;AACnE;AACA;AACA;AACA;AACA,yCAAyC,sFAAgC,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,cAAc,oEAAU;AACxB;AACA,cAAc,+DAAK;AACnB;AACA;AACA,SAAS,IAAI,iBAAiB;AAC9B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAK;AACnB;AACA,SAAS,IAAI,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAsC,GAAG,kBAAkB;AAC7F;AACA;AACA;AACA;AACA,kCAAkC,oEAAU;AAC5C;AACA;AACA,iBAAiB,oEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,YAAY,eAAe;AAC/E;AACA,sBAAsB,oEAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE,kCAAkC,uEAAiB,CAAC,GAAG,WAAW;AAClE,kCAAkC,oEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpKA;AACA;AACyB;AACI;AACuC;AACjC;AACnC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAS;AACpC;AACA;AACA;AACA;AACA;AACA,qBAAqB,oCAAO;AAC5B,mDAAmD,oBAAoB;AACvE,qCAAqC,oCAAO;AAC5C;AACA;AACA;AACA;AACA,kDAAkD,wCAAW;AAC7D,iDAAiD,uCAAU;AAC3D,aAAa,kKAAkK,2CAAI,UAAU;AAC7L;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAQ,+BAA+B,uDAAuD;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB,0BAA0B,oEAAU;AACpC;AACA;AACA;AACA,qCAAqC,sCAAS;AAC9C,kCAAkC,oEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,gCAAgC,mBAAmB;AACnD,oBAAoB,oEAAU;AAC9B;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA,eAAe,sCAAS;AACxB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACzGA;AACA;AAC6B;AACmD;AACjC;AACI;AAC0B;AAClC;AACK;AAChD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAQ;AAChC;AACA,sBAAsB,8EAAoB;AAC1C;AACA,kBAAkB,mDAAQ,sEAAsE,yDAAa,yBAAyB;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAS;AAC/C,gBAAgB,oEAAU;AAC1B;AACA,uCAAuC,kBAAkB;AACzD,gBAAgB,2DAAS;AACzB;AACA;AACA,8CAA8C,sFAAyB;AACvE,gBAAgB,oEAAU;AAC1B;AACA,wCAAwC,0BAA0B;AAClE,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACbA;AACA;AACoE;AACnB;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAQ,aAAa,+BAA+B,0BAA0B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B,GAAG,yDAAa,2BAA2B;AAC3F;AACA;AACA;AACA;AACA;AACA,cAAc,oEAAU,mDAAmD,yBAAyB;AACpG;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACiC;AACc;AACE;AACgB;AACC;AAClE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAkB,8BAA8B,yDAAa;AAC7E;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,yEAAuB;AACvE;AACA,uDAAuD,yEAAuB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,iBAAiB,yEAAuB;AACxC,iBAAiB,yEAAuB;AACxC,uBAAuB,6CAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAQ,mCAAmC,gCAAgC;AAC3G,wCAAwC,mCAAmC;AAC3E;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnJA;AACA;AACmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,UAAU;AAChG;AACA;AACA,mCAAmC,EAAE,sBAAsB,kBAAkB;AAC7E;AACA;AACA;AACA;AACA,2CAA2C,EAAE,sBAAsB,aAAa;AAChF;AACA;AACA,2CAA2C,EAAE,sBAAsB,yEAAyE;AAC5I;AACA;AACA,yEAAyE,eAAe,aAAa,UAAU;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA,2CAA2C,EAAE,sBAAsB,8BAA8B;AACjG;AACA;AACA;AACA,2CAA2C,EAAE,sBAAsB,mCAAmC;AACtG;AACA;AACA,yEAAyE,eAAe,aAAa,UAAU;AAC/G;AACA;AACA;AACA;AACA;AACA,sFAAsF,UAAU;AAChG;AACA,+BAA+B,8DAAgB;AAC/C;AACA;AACA;AACA,sFAAsF,UAAU;AAChG;AACA,+BAA+B,0DAAY;AAC3C;AACA;AACA,kEAAkE,UAAU;AAC5E;AACA;AACA,aAAa;AACb;AACA,0EAA0E,gBAAgB;AAC1F;AACA;AACA,iFAAiF,eAAe,GAAG;AACnG;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjHA;AACA;AAC6B;AAC6B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,gBAAgB,sCAAS;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oEAAU,mDAAmD,0BAA0B;AACrG,2DAA2D,mBAAmB;AAC9E;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AAC6B;AACI;AAC+C;AAClB;AACgB;AACvE;AACP;AACA,gBAAgB,2BAA2B,8EAA8E,sCAAsC;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mEAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA,gEAAgE,cAAc,mKAAmK;AACjP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA,8DAA8D,0CAA0C;AACxG,mFAAmF,oEAAU,sBAAsB,kBAAkB,GAAG,iBAAiB;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,kDAAkD;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+CAAkB;AACnD,+CAA+C,yBAAyB,GAAG,aAAa;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0BAA0B,+DAAK;AAC/B,sCAAsC,oEAAU;AAChD;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,8BAA8B,oEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,aAAa;AACjF,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA,mBAAmB,mFAAwB,uBAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oEAAU;AACnD;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa,GAAG,WAAW;AACxE;AACA,8DAA8D,kBAAkB;AAChF;AACA;AACA;AACA,sDAAsD,SAAS,GAAG,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB,GAAG,aAAa;AAClE;AACA,uCAAuC,oEAAU;AACjD;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS,yCAAyC,QAAQ,GAAG,KAAK;AACjF;AACA;AACA,gBAAgB,oCAAoC,aAAa,kCAAkC;AACnG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;AClRA;AACA;AAC6D;AAC7D;AACO;AACP;AACA,gBAAgB,wHAAwH;AACxI,gBAAgB,yDAAyD;AACzE,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/DA;AACA;AAC6D;AAC7D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACtGA;AACA;AAC6B;AACmD;AACjC;AACoB;AAClB;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa;AACtD;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA,aAAa,oEAAU;AACvB;AACA;AACA,2BAA2B,yDAAQ,sCAAsC,iBAAiB;AAC1F,mCAAmC,kEAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,2BAA2B;AACxH,+CAA+C,yDAAa,kBAAkB;AAC9E;AACA;AACA;AACA;AACA,0CAA0C,4BAA4B,2BAA2B,yDAAa,kBAAkB;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oEAAU,kBAAkB,iEAAU;AAChF;;;;;;;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACkC;AACO;AACb;AAC6B;AACgB;AACxB;AACjD,QAAQ,gBAAgB,EAAE,yDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD,uEAAuE;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,KAAK;AAC7E;AACA;AACA;AACA,8BAA8B,uEAAa,sCAAsC,KAAK,4BAA4B,oCAAoC;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,4CAA4C,sBAAsB;AACrG;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C,0CAA0C,mEAAY;AACtD;AACA,mDAAmD,eAAe,GAAG,WAAW;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAkD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,YAAY,mBAAmB,cAAc,gBAAgB,8BAA8B,iCAAiC,SAAS;AACtM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,uEAAuE,sBAAsB;AAC7F;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA,2BAA2B,uDAAU;AACrC;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC;AAClE;AACA;AACA;AACA;AACA,6CAA6C,cAAc,GAAG,OAAO,GAAG,gCAAgC;AACxG;AACA;AACA;AACA,yCAAyC,cAAc,EAAE,kCAAkC;AAC3F;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc,EAAE,SAAS,EAAE,cAAc,EAAE,SAAS;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA,sEAAsE,SAAS;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8DAAI,kBAAkB,+CAAa;AAC9C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACzNA;AACA;AAC6B;AACgE;AAC9C;AACa;AACN;AACE;AACP;AAChB;AAC1B;AACP;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sCAAS;AAC7B,8CAA8C,yDAAQ,iCAAiC,oDAAoD;AAC3I;AACA,2BAA2B,yCAAyC,GAAG,yDAAa,oBAAoB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sCAAS,uCAAuC,uEAAa;AACvG;AACA;AACA,QAAQ,kEAAQ,sDAAsD,qBAAqB;AAC3F;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oEAAU;AACvB;AACA,YAAY,oEAAU;AACtB;AACA;AACA;AACA,4CAA4C,eAAe,GAAG,sBAAsB;AACpF;AACA,yCAAyC,sCAAS;AAClD,yCAAyC,iEAAe;AACxD;AACA,SAAS;AACT,wEAAwE,yBAAyB;AACjG,2BAA2B,kEAAQ;AACnC,+DAA+D,yBAAyB;AACxF;AACA,8CAA8C,yDAAQ,oBAAoB,gBAAgB,UAAU,sBAAsB;AAC1H;AACA,kBAAkB,2DAAS;AAC3B;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,wEAAwE,gBAAgB,UAAU,sBAAsB;AACxH;AACA;AACA,uDAAuD,gBAAgB,UAAU,uBAAuB,KAAK,yBAAyB;AACtI;AACA;AACA;AACA,QAAQ,oEAAU;AAClB;AACA,8CAA8C,sCAAS,wCAAwC,eAAe;AAC9G,2DAA2D,8BAA8B;AACzF,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAU;AAClB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,OAAO;AACxF;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA,qDAAqD,gBAAgB;AACrE;AACA,kDAAkD,yDAAa,kBAAkB,IAAI,mCAAmC;AACxH;AACA;AACA;AACA,iGAAiG,yDAAa,kBAAkB;AAChI;AACA;AACA;AACA,oCAAoC,yDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA,gDAAgD,mCAAmC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClNA;AACA;AACwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC,gHAAsC;AACnF;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClBA;AACA;AACmF;AACnB;AACH;AACtD,gCAAgC,wEAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAU;AAChD;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B,kCAAkC;AAClC;AACA,8CAA8C,uBAAuB,QAAQ,cAAc;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;ACtFA;AACA;AACoD;AACH;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,sCAAsC;AACtD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6DAAe,8BAA8B,6DAAe;AAC1F;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAe;AACnD,kCAAkC,6DAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA,uCAAuC,uCAAuC;AAC9E;AACA,kCAAkC,6DAAe;AACjD,kCAAkC,6DAAe;AACjD,kCAAkC,6DAAe;AACjD,kCAAkC,6DAAe;AACjD,kCAAkC,6DAAe;AACjD,kCAAkC,6DAAe;AACjD,kCAAkC,6DAAe;AACjD;AACA;AACA;AACA,uCAAuC,6DAAe,6BAA6B,6DAAe;AAClG;AACA;AACA;AACA,uCAAuC,6DAAe;AACtD;AACA;AACA;AACA;AACA,uCAAuC,6DAAe;AACtD;AACA,sDAAsD,cAAc,0BAA0B,YAAY;AAC1G;AACA;AACA;AACA;AACA,gCAAgC,6DAAe;AAC/C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,yDAAa,kBAAkB;AACxG;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7KA;AACA;AACiC;AAC+C;AAClB;AACsB;AAClB;AACkB;AAChC;AACC;AACe;AACnB;AAC6C;AACzC;AACC;AACsB;AAC5E;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,gFAAgF;AAChG;AACA;AACA,oBAAoB,8EAA8E;AAClG;AACA;AACA;AACA;AACA,sBAAsB,6DAAW;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,wBAAwB,0EAA0E;AAClG;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yDAAa,4BAA4B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAgB;AAC1D;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAI;AAC5B;AACA,yBAAyB;AACzB;AACA,qCAAqC,8CAAiB;AACtD;AACA,oCAAoC,qDAAqD;AACzF;AACA;AACA,4CAA4C,yDAAa;AACzD;AACA,4CAA4C,yDAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6HAA6H;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,0HAA0H,oBAAoB;AAC9I;AACA;AACA,6HAA6H,oBAAoB;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB,EAAE,2EAAsB;AACtE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB,IAAI,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6DAAe;AAC9C;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,4CAA4C,6DAAe;AAC3D,yBAAyB;AACzB,+BAA+B,6DAAe;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,oFAAoF;AACxG,oBAAoB,sEAAsE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,6DAAe;AACvE;AACA;AACA,oBAAoB,2FAA2F;AAC/G;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD,4BAA4B,8BAA8B;AAC1D,4BAA4B,2DAA2D,EAAE,2EAAsB;AAC/G;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,8BAA8B,uEAAa;AAC3C;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA,mCAAmC,6DAAe;AAClD,0CAA0C,QAAQ,GAAG,UAAU;AAC/D;AACA,wCAAwC,6DAAe;AACvD,0CAA0C,QAAQ,GAAG,UAAU;AAC/D;AACA;AACA,6BAA6B,6DAAe;AAC5C,6BAA6B,6DAAe;AAC5C,6BAA6B,6DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,oDAAoD,6DAAe;AACnE,gCAAgC,6DAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,6DAAe;AACjF,wCAAwC,6DAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,qBAAqB,6DAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,sCAAsC,gBAAgB;AACzF;AACA;AACA;AACA,+BAA+B,8DAA8D;AAC7F;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4EAAiB;AACrE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iDAAiD,gGAAgG;AACjJ;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,uBAAuB,8CAAiB;AACxC;AACA;AACA,gDAAgD,sCAAsC;AACtF;AACA;AACA;AACA,kCAAkC,4EAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oCAAoC,oFAAoF;AACxH;AACA;AACA;AACA;AACA,8BAA8B,uEAAa;AAC3C;AACA,oDAAoD,8DAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2CAA2C,wGAAwG;AACnJ;AACA;AACA,6CAA6C,kFAAoB;AACjE,uBAAuB,yDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yCAAyC,uEAAsB;AAC/D;AACA,aAAa;AACb,kDAAkD,sEAAqB;AACvE;AACA,mCAAmC,qEAAW;AAC9C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kEAAiB;AAChE;AACA,aAAa;AACb,wCAAwC,wEAAgB;AACxD;AACA;AACA,wCAAwC,wEAAgB;AACxD;AACA,+CAA+C,0FAAwB;AACvE;AACA,SAAS;AACT,mBAAmB,yDAAQ;AAC3B;AACA,mDAAmD,0EAA0E;AAC7H;AACA;AACA;AACA;AACA,6BAA6B,2EAAsB;AACnD;AACA,sCAAsC,sBAAsB;AAC5D,SAAS;AACT,6DAA6D,mFAA8B;AAC3F;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA,6BAA6B,qBAAqB;AAClD,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9hBA;AACA;AAC6B;AACuC;AACL;AACX;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,2FAA2F;AAC3G;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,wBAAwB,YAAY;AACpC,wBAAwB,mDAAmD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,4DAA4D,sBAAsB;AAClF,wCAAwC,qDAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,sBAAsB;AAC1G;AACA,uCAAuC,yDAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mCAAmC,yDAAQ,MAAM,+DAAc;AAC/D;AACA;AACA,SAAS;AACT;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC,oBAAoB,0CAA0C;AAC9D;AACA;AACA,+CAA+C,oEAAU;AACzD;AACA;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA,wEAAwE,gBAAgB,IAAI,EAAE;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6DAAe;AAC1C;AACA;AACA;AACA,mCAAmC,qDAAS;AAC5C;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA,gBAAgB,oEAAU;AAC1B;AACA,SAAS;AACT;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAe,uBAAuB,6DAAe;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD,2BAA2B,6DAAe;AAC1C;AACA,gCAAgC,6DAAe;AAC/C,oCAAoC,6DAAe;AACnD;AACA;AACA;AACA,sBAAsB,kEAAQ;AAC9B;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;ACrKA;AACA;AACwB;AACkC;AAC1D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,kCAAkC,mDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB,oBAAoB,eAAe;AACnC,0DAA0D,cAAc;AACxE,iDAAiD,cAAc,EAAE,iBAAiB;AAClF;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAA0D;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW,KAAK,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACiI;AACrE;AAC2C;AAC3C;AACR;AACkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAQ,qBAAqB,yDAAQ;AACtE;AACA;AACA,4CAA4C,2BAA2B,KAAK,sBAAsB;AAClG,wCAAwC,yDAAQ,iCAAiC,yDAAQ;AACzF;AACA;AACA;AACA;AACA,mCAAmC,yDAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gTAAgT;AAChU;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,8DAAa;AACnE,4CAA4C,sEAAqB;AACjE;AACA,+BAA+B,qEAAW;AAC1C,2BAA2B,wEAAuB;AAClD,SAAS;AACT,mCAAmC,sEAAc;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+EAAwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,cAAc,wCAAwC,gBAAgB;AACxH;AACA;AACA;AACA;AACA;AACA,mCAAmC,qEAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iBAAiB,WAAW,OAAO;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK;AACzD;AACA;AACA;AACA,iEAAiE,mBAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6DAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAK;AACnB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,cAAc,6DAAe;AAC7B;AACA,kBAAkB,6DAAe;AACjC,kBAAkB,6DAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8EAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC,sBAAsB,kEAAiB;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA,iBAAiB,6DAAe;AAChC;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,yCAAyC,yDAAQ,SAAS,KAAK;AAC/D;AACA;AACA,iDAAiD,6DAAe;AAChE;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA,yDAAyD,mBAAmB,mBAAmB,KAAK;AACpG;AACA,+CAA+C,6DAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,6DAAe;AACrE;AACA,kCAAkC,uEAAa,sBAAsB,oBAAoB,6BAA6B,qBAAqB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAe;AAChC;AACA,mEAAmE,yDAAQ,WAAW,KAAK;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAe;AAChC;AACA,mEAAmE,yDAAQ,WAAW,KAAK;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAe;AAChC;AACA,mEAAmE,yDAAQ,UAAU,KAAK;AAC1F;AACA;AACA;AACA,iBAAiB,6DAAe;AAChC;AACA,mEAAmE,yDAAQ,WAAW,KAAK,8BAA8B,4BAA4B;AACrJ;AACA;AACA;AACA,iBAAiB,6DAAe;AAChC;AACA,mEAAmE,yDAAQ,YAAY,KAAK,+BAA+B,4BAA4B;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChSA;AACA;AACiC;AACsH;AAC7E;AACZ;AACS;AACjB;AACgB;AACc;AACU;AAC7C;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAS;AACtC,mCAAmC,gEAAe;AAClD;AACA;AACA,SAAS;AACT;AACA,gBAAgB,6CAA6C;AAC7D;AACA,sBAAsB,uEAAa,yBAAyB,uFAAuF,iBAAiB,oGAAoG;AACxQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+EAAwB;AAC9C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,yDAAyD,6DAAe,WAAW,6DAAe;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,gBAAgB,sDAAsD;AACtE,gBAAgB,oCAAoC;AACpD;AACA,cAAc,2EAAsB;AACpC;AACA,0CAA0C,qDAAqD,EAAE,cAAc;AAC/G,aAAa;AACb;AACA;AACA;AACA,oBAAoB,mFAA8B;AAClD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAiB;AACvC;AACA,iBAAiB;AACjB;AACA,4CAA4C,oEAAmB;AAC/D;AACA,6BAA6B,qEAAW;AACxC,aAAa;AACb,2CAA2C,kEAAiB;AAC5D;AACA;AACA,8BAA8B,uEAAsB,GAAG,kCAAkC;AACzF;AACA;AACA;AACA,aAAa;AACb,kDAAkD,sEAAqB;AACvE;AACA,mCAAmC,qEAAW;AAC9C;AACA,aAAa;AACb,yCAAyC,wEAAgB;AACzD,yCAAyC,yFAAwB;AACjE;AACA,aAAa;AACb,iCAAiC,yDAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6DAAe;AACzC,0BAA0B,6DAAe;AACzC;AACA;AACA;AACA;AACA;AACA,0BAA0B,6DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAA2C,kBAAkB;AACjF;AACA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAa,eAAe,EAAE,YAAY,GAAG,mCAAmC;AAC1G,aAAa;AACb,2BAA2B,8CAAiB;AAC5C;AACA;AACA,6BAA6B,yDAAa,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAa,eAAe,EAAE,eAAe;AAC9E;AACA,6BAA6B,yDAAa,eAAe,EAAE,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjTA;AACA;AACA,qBAAqB,SAAI,IAAI,SAAI;AACjC;AACA;AACA,2GAA2G,uFAAuF,cAAc;AAChN,uBAAuB,8BAA8B,gDAAgD,wDAAwD;AAC7J,6CAA6C,sCAAsC,UAAU,mBAAmB,IAAI;AACpH;AACyB;AACwC;AACiB;AACxB;AACT;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,0BAA0B,0BAA0B;AACpE,gBAAgB,gBAAgB;AAChC;AACA,sCAAsC,yDAAa,uBAAuB,GAAG,yDAAa,oBAAoB,aAAa,sBAAsB;AACjJ,6BAA6B,mEAAkB;AAC/C;AACA;AACA,SAAS;AACT;AACA,2BAA2B,cAAc,GAAG,mBAAmB;AAC/D,gCAAgC,cAAc,GAAG,mBAAmB;AACpE,iCAAiC,cAAc,GAAG,mBAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4FAA4F;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAK;AACnB;AACA,sBAAsB,oEAAU;AAChC;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA,4BAA4B,0CAA0C;AACtE;AACA;AACA,uCAAuC,oEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC,6BAA6B,kEAAiB;AAC9C,iDAAiD,yEAAwB;AACzE;AACA;AACA,iDAAiD,yEAAwB;AACzE;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAU;AAC5B;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB,oEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAmB;AAC3C;AACA,SAAS;AACT;AACA,mGAAmG,oFAAoF;AACvL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,aAAa,oEAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxJA;AACA;AAC6D;AACd;AACK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA,iBAAiB,6DAAe;AAChC,iBAAiB,6DAAe;AAChC,iBAAiB,6DAAe;AAChC,iBAAiB,6DAAe;AAChC,iBAAiB,6DAAe;AAChC,iBAAiB,6DAAe;AAChC,iBAAiB,6DAAe;AAChC;AACA;AACA;AACA,0BAA0B,uEAAa,iCAAiC,OAAO;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAe,8BAA8B,yDAAQ;AACzF,oCAAoC,6DAAe,2BAA2B,yDAAQ;AACtF,oCAAoC,6DAAe,gCAAgC,yDAAQ;AAC3F,oCAAoC,6DAAe,8BAA8B,yDAAQ;AACzF,mCAAmC,6DAAe,yCAAyC,yDAAQ;AACnG,oCAAoC,6DAAe,8BAA8B,yDAAQ;AACzF,mCAAmC,6DAAe,8BAA8B,yDAAQ;AACxF;AACA;AACA,aAAa,6DAAe;AAC5B;AACA;AACA,aAAa,6DAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6DAAe;AACtD;AACA;AACA,oCAAoC,eAAe,EAAE,YAAY,EAAE,KAAK;AACxE;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB,IAAI,eAAe;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAQ,cAAc,EAAE,8BAA8B,EAAE,yDAAQ,UAAU,6CAA6C,KAAK,EAAE,yDAAQ,cAAc,EAAE,yDAAQ,aAAa;AACzM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB,EAAE,uDAAuD;AACvG,2BAA2B,OAAO,IAAI,aAAa;AACnD;AACA;AACA;AACA;AACA,0BAA0B,yDAAQ,cAAc,EAAE,2BAA2B,EAAE,yDAAQ,UAAU,wCAAwC,GAAG;AAC5I;AACA;;;;;;;;;;;;;;;;ACrKA;AACA;AACmF;AACnF;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,gCAAgC;AAChD,mCAAmC,eAAe,GAAG,4BAA4B;AACjF,2BAA2B,cAAc,GAAG,sBAAsB;AAClE;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAQ,kCAAkC,uDAAuD;AAC/G;AACA;AACA;AACA;AACA,gCAAgC,kEAAQ;AACxC;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvCA;AACA;AACwC;AACxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,+IAA+I;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB,gBAAgB,gCAAgC;AACpF;AACA;AACA,4BAA4B,iDAAS;AACrC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB,EAAE,WAAW;AAChD;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACkG;AACkB;AAClD;AACjB;AACjD,2CAA2C,yDAAa,uBAAuB,GAAG,yDAAa,oBAAoB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ;AACA;AACO,gCAAgC,iEAAgB;AACvD;AACA;AACA;AACA,uBAAuB,oEAAU;AACjC;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,8BAA8B,aAAa;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,8BAA8B,aAAa;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,iEAAgB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oEAAU;AACpC;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,8BAA8B,aAAa;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA,2BAA2B,kEAAiB;AAC5C;AACA;AACA,uCAAuC,oEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,4CAA4C;AACxD,YAAY,gHAAgH;AAC5H;AACA,QAAQ,oEAAU;AAClB,+BAA+B,oEAAU;AACzC,QAAQ,oEAAU;AAClB,QAAQ,oEAAU;AAClB,QAAQ,oEAAU;AAClB;AACA,yBAAyB,sEAAqB;AAC9C;AACA;AACA,2BAA2B,qEAAW;AACtC,KAAK;AACL;AACA;AACA,6BAA6B,kEAAiB;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gCAAgC,uEAAkB;AAClD,+BAA+B,oBAAoB,GAAG,sBAAsB;AAC5E;AACA,yBAAyB,gBAAgB;AACzC,0BAA0B,gBAAgB;AAC1C,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B,cAAc,GAAG,yDAAa,oBAAoB;AAC5E,2BAA2B,cAAc,GAAG,gCAAgC;AAC5E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,WAAW,4BAA4B,0BAA0B;AAC7E,YAAY,0BAA0B;AACtC,YAAY,0EAA0E;AACtF,wBAAwB,WAAW,GAAG,QAAQ;AAC9C,yBAAyB,WAAW,GAAG,SAAS;AAChD,yBAAyB,YAAY,GAAG,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtMA;AACA;AACiD;AACW;AACpB;AACY;AAC2E;AACxH;AACP;AACA;AACA,mBAAmB,WAAW;AAC9B,mBAAmB,WAAW;AAC9B,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2CAA2C;AACvD,6CAA6C,4FAA+B;AAC5E;AACA,gBAAgB,oIAAoI;AACpJ;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iDAAS;AACnD;AACA;AACA;AACA,4BAA4B,qEAAmB;AAC/C,6BAA6B,2EAAc,kBAAkB;AAC7D,4BAA4B,6DAAe;AAC3C;AACA,iBAAiB;AACjB,0CAA0C,0BAA0B;AACpE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yKAAyK,yDAAa,uBAAuB,cAAc,2BAA2B,UAAU,4BAA4B;AAC5R;AACA;AACA;AACA;AACA,qFAAqF,4BAA4B,KAAK,2BAA2B;AACjJ;AACA;AACA;AACA;AACA;AACA,2CAA2C,2EAAc,kBAAkB;AAC3E;AACA;AACA;AACA,0CAA0C,aAAa;AACvD,kCAAkC,OAAO;AACzC;AACA,oBAAoB,UAAU;AAC9B;AACA,iDAAiD,0BAA0B;AAC3E,+BAA+B,2FAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,0CAA0C,WAAW;AACrD;AACA;AACA,gDAAgD,oBAAoB,uBAAuB,WAAW;AACtG;AACA,0IAA0I,4BAA4B,GAAG,4BAA4B;AACrM;AACA;AACA;AACA,2EAA2E,6BAA6B,MAAM,6BAA6B;AAC3I;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA,2CAA2C,iDAAS;AACpD;AACA;AACA,4DAA4D,6BAA6B,yEAAyE;AAClK,8CAA8C,0BAA0B,SAAS,MAAM;AACvF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2EAAc,kBAAkB,UAAU,MAAM,GAAG,OAAO;AACtG,wCAAwC,2FAA8B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxIA;AACA;AACoD;AACW;AACe;AACxB;AACJ;AACE;AACpD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,YAAY,mFAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D,oBAAoB,mCAAmC;AACvD,oBAAoB,kCAAkC;AACtD,+BAA+B,2DAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA,6CAA6C,yEAAwB;AACrE,aAAa;AACb;AACA;AACA,6CAA6C,yEAAwB;AACrE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gDAAgD,2DAAc,mCAAmC,OAAO;AACxG,oCAAoC,6DAAe;AACnD;AACA;AACA,gDAAgD,2DAAc,kCAAkC,SAAS;AACzG,oCAAoC,6DAAe;AACnD;AACA;AACA,oCAAoC,6DAAe;AACnD;AACA;AACA,oCAAoC,6DAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8DAAI;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChJA;AACA;AACiD;AACW;AAC4B;AACpC;AAC7C;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA,wBAAwB,qDAAqD;AAC7E;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA,4LAA4L,UAAU;AACtM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACO;AACP,YAAY,6DAA6D;AACzE;AACA,wCAAwC,oBAAoB,uBAAuB,WAAW;AAC9F;AACA;AACA,gBAAgB,2DAA2D;AAC3E;AACA;AACA;AACA;AACA,mBAAmB,uEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA,oBAAoB,6DAAe;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,+BAA+B,YAAY,EAAE,gCAAgC;AAC7E,8CAA8C,+EAAwB;AACtE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wDAAwD,yDAAa;AACrE,kBAAkB,qBAAqB,GAAG,uBAAuB;AACjE;AACA;AACA;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAA6C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpCA;AACA;AACqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC;AACA,gBAAgB,SAAS;AACzB,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAK;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACwD;AACkB;AACF;AACgC;AAC1B;AACf;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uCAAuC,gHAAsC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mFAAwB;AACpC,iCAAiC,mFAAwB;AACzD;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAQ,KAAK,wEAAuB;AACjE,0CAA0C,oFAA2B;AACrE,8BAA8B,6DAAU;AACxC,SAAS;AACT;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAQ,uCAAuC,0BAA0B;AACrF;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxFA;AACA;AACiC;AACsC;AACO;AAC7B;AACjD;AACA;AACA;AACO,wCAAwC,sFAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,6BAA6B;AACxG;AACA;AACA;AACA,sEAAsE;AACtE,8EAA8E;AAC9E;AACA;AACA;AACA,gCAAgC,yDAAa,kBAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK,GAAG,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa,8BAA8B,MAAM,eAAe,SAAS;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CACN;AAC3B;AACA;AACA,2BAA2B,KAAK,GAAG,QAAQ,GAAG,aAAa;AAC3D;AACA;AACA;AACA;AACA,2GAA2G;AAC3G;AACA;AACA;AACA,mHAAmH;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA,2CAA2C,yDAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAQ,mDAAmD,0BAA0B;AACnG;AACA;AACA;;;;;;;;;;;;;;;;;ACvKA;AACA;AACA,cAAc,SAAI,IAAI,SAAI;AAC1B;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqD;AACgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA,wHAAwH,QAAQ;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE,8EAAkB,+BAA+B,WAAW;AACvG;AACA,8BAA8B,OAAO,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2DAA2D,YAAY;AACvE;AACA,6GAA6G;AAC7G,sBAAsB,mEAAY;AAClC;AACA;AACA,yCAAyC,WAAW,0FAA0F,0BAA0B;AACxK;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5FA;AACA;AAC6B;AACI;AACL;AACiF;AAC9D;AACsC;AAC7B;AACQ;AACH;AACE;AACd;AAC+B;AAChB;AACQ;AACF;AACN;AACmB;AACnF,mBAAmB,gEAAM;AAClB;AACP;AACA;AACA;AACA,CAAC,gEAAgE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa,EAAE,qEAAiC;AAC5D;AACA;AACA;AACA;AACA,YAAY,yCAAY;AACxB,uBAAuB,qEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA;AACA;AACA,mBAAmB,qEAAmB,wBAAwB,KAAK,GAAG,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yCAAY;AACrB,qEAAqE,GAAG;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qEAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC;AACA;AACA;AACA,mBAAmB,qEAAmB,wBAAwB,kBAAkB,GAAG,kBAAkB;AACrG;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,wEAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF,8EAA8E;AAC9E,gFAAgF;AAChF,4EAA4E;AAC5E,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK,GAAG,QAAQ;AAC3E;AACA;AACA,yDAAyD,KAAK,GAAG,QAAQ;AACzE;AACA,eAAe,+DAA2B,0CAA0C,KAAK,GAAG,QAAQ;AACpG;AACA,kDAAkD,cAAc,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oEAAU;AACpD;AACA;AACA;AACA,oBAAoB,oEAAU;AAC9B,sCAAsC;AACtC;AACA,kDAAkD,uBAAuB,QAAQ,cAAc;AAC/F;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gGAAiC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAkD;AAClE;AACA,eAAe,wDAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,gEAAgE,sEAAW;AAC3E,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,qDAAqD,gFAAwB;AAC7E;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ,YAAY,0DAAa,oBAAoB;AACjF;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAQ;AACxC;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA,gCAAgC,yDAAQ;AACxC;AACA;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qFAA8C;AAC9F;AACA,kBAAkB,+BAA+B,GAAG,gCAAgC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wEAAiC;AACzD;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAmB;AAC9C;AACA;AACA,wBAAwB,4BAA4B,EAAE,wDAAoB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yCAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kFAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAI,kBAAkB,0CAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wDACN;AAC/B;AACA;AACA,yCAAyC,YAAY,GAAG,aAAa;AACrE;AACA,wBAAwB,sDAAsD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0EAAqB;AACrE;AACA;AACA;AACA;AACA;AACA,yCAAyC,sCAAS,uCAAuC,0DAAa;AACtG,sBAAsB,oEAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAQ,8BAA8B,0DAAa,qBAAqB,KAAK,qBAAqB;AACxI;AACA;AACA;AACA,sCAAsC,yDAAQ,oDAAoD,qBAAqB,aAAa,YAAY;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAQ,4DAA4D,qBAAqB,aAAa,YAAY;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAwD,EAAE,sEAAiB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,mEAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAc;AAC3C;AACA,6BAA6B,mEAAc;AAC3C,qEAAqE,mEAAc;AACnF;AACA;AACA;AACA,6BAA6B,mEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA,yBAAyB,mEAAc;AACvC;AACA;AACA;AACA,yBAAyB,mEAAc;AACvC;AACA;AACA;AACA,yBAAyB,mEAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6IAA6I;AAC7I,6HAA6H;AAC7H,mIAAmI;AACnI,qIAAqI;AACrI,yBAAyB,gCAAgC;AACzD;AACA;AACA;AACA;AACA,yBAAyB,mEAAc;AACvC;AACA;AACA;AACA;AACA,yBAAyB,mEAAc;AACvC;AACA,2CAA2C;AAC3C;AACA,yBAAyB,mEAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8DAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,KAAK;AACvG,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,8DAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDACN;AAC3B;AACA;AACA,+BAA+B,UAAU,GAAG,aAAa;AACzD;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK,GAAG,QAAQ;AAC/E;AACA;AACA;AACA;AACA,+DAA+D,KAAK,GAAG,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,kBAAkB;AACtG,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,yEAA2B;AACrF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACn8BA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AAC6B;AACI;AAC0D;AAChD;AAC6C;AACxF;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,gDAAc;AACtB;AACA;AACA;AACA;AACA,0FAA0F,iCAAiC;AAC3H;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,iCAAiC;AAC3H;AACA,6BAA6B,sCAAS;AACtC;AACA,cAAc,oEAAU;AACxB,2BAA2B,uEAAiB,CAAC,GAAG,0EAAoB,CAAC;AACrE;AACA,SAAS;AACT;AACA;AACA,cAAc,kEAAQ,iCAAiC,sCAAS;AAChE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAa;AACzB;AACA;AACA,oDAAoD,0CAAa;AACjE;AACA;AACA;AACA,mCAAmC,uEAAa;AAChD,yCAAyC,uEAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAM,iBAAiB,iDAAiD;AAChG;AACA;AACA;AACA,gCAAgC,oEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAc;AAClC;AACA;AACA;AACA,mBAAmB,gDAAc;AACjC;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,yBAAyB;AAC9F;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC3GA;AACA;AAC6B;AAC+C;AACoB;AAC/C;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,iCAAiC;AAC3H;AACA;AACA,2CAA2C,sCAAS,YAAY,yDAAa;AAC7E;AACA,cAAc,oEAAU;AACxB,2BAA2B,uEAAiB,CAAC,GAAG,kFAA4B,CAAC;AAC7E;AACA,SAAS;AACT;AACA;AACA,cAAc,kEAAQ,+CAA+C,sCAAS;AAC9E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAkD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAM,iBAAiB,iDAAiD;AAChG;AACA;AACA,iCAAiC,sCAAS;AAC1C,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzIA;AACA;AACuF;AACtC;AACjD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,cAAc,+DAAK;AACnB,gDAAgD,wCAAwC;AACxF,qCAAqC,oEAAU;AAC/C;AACA;AACA;AACA,SAAS,IAAI,gBAAgB;AAC7B;AACA;AACA,yGAAyG,MAAM;AAC/G;AACA;AACA,wDAAwD,yDAAa,0BAA0B;AAC/F;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACoE;AACrB;AACO;AACzB;AACoB;AAC1C;AACP,oBAAoB,qCAAG;AACvB;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,gBAAgB,yDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA,yBAAyB,8EAAoB;AAC7C;AACA;AACA,6CAA6C,yDAAa,0BAA0B;AACpF;AACA;AACA,wBAAwB,yDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAQ;AAC7B;AACA,gCAAgC,2DAAS;AACzC;AACA,4BAA4B,UAAU,GAAG,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,yDAAQ;AACtF;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAa,0BAA0B;AAC5E;AACA;AACA,gBAAgB,yDAAQ;AACxB,cAAc,8EAAoB;AAClC;AACO;AACP;AACA,QAAQ,yDAAQ;AAChB,QAAQ,yDAAQ,4CAA4C,uDAAuD;AACnH;AACA;AACA;;;;;;;;;;;;;;;;;ACvHA;AACA;AACmD;AACY;AACN;AAClD;AACP;AACA,cAAc,0DAA4B;AAC1C,cAAc,6DAA+B;AAC7C;AACA;AACA;AACA,YAAY,2DAA6B;AACzC;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACiE;AACjE;AACA;AACA;AACO;AACP;AACA;AACA,2BAA2B,yEAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,cAAc,oCAAoC;AACrJ;AACA;;;;;;;;;;;;;;;AClBA;AACA;AACiE;AAC1D;AACP;AACA;AACA;AACA;AACA,kCAAkC,4BAA4B;AAC9D,0CAA0C,yEAAqB;AAC/D,wCAAwC,8CAA8C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjBA;AACA;AACiF;AAChC;AAC1C;AACP;AACA;AACA;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA,yDAAyD,iBAAiB,eAAe,cAAc;AACvG,mBAAmB,yDAAa,kBAAkB;AAClD,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qEAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpCA;AACA;AACiD;AAC1C;AACP;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAa;AAChD,+BAA+B,yDAAa;AAC5C;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvBA;AACA;AACoE;AACnB;AAC1C;AACP;AACA;AACA;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA,gDAAgD,iBAAiB,eAAe,cAAc;AAC9F,mBAAmB,yDAAa,kBAAkB;AAClD,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrBA;AACA;AACoE;AAC7D;AACP;AACA;AACA;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA,2DAA2D,iBAAiB,eAAe,cAAc;AACzG,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxBA;AACA;AACgF;AACjB;AAC/D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB,iCAAiC,kEAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oEAAU,kBAAkB,6DAAU;AAC7E;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACqC;AACF;AACgD;AACpC;AAC/C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAY,CAAC,wCAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa;AACvC;AACA;AACA,qBAAqB,0CAAa;AAClC,sBAAsB,2CAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qDAAwB,GAAG,mBAAmB;AAChF,QAAQ,wDAA2B,CAAC,0CAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAgB;AAC5B,gCAAgC,wCAAW;AAC3C;AACA;AACA;AACA,8BAA8B,yDAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA,sBAAsB,yDAAQ;AAC9B;AACA,kBAAkB,8EAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChIA;AACA;AAC6B;AACiG;AAC5B;AAC5C;AACgB;AACtB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,6BAA6B,yDAAQ,KAAK,wEAAuB;AACjE;AACA,SAAS;AACT,6CAA6C,+EAAwB,CAAC,sCAAS;AAC/E,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,iCAAiC,+DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAS;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAU;AACjC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,UAAU;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAa;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4CAA4C,yDAAa;AACzD;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA,+CAA+C,yDAAQ;AACvD;AACA;AACA;AACA;AACA,oCAAoC,yDAAa;AACjD;AACA,SAAS;AACT;AACA;AACA;AACA,qCAAqC,yDAAQ;AAC7C;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA,mCAAmC,yDAAa;AAChD;AACA,SAAS;AACT;AACA;AACA;AACA,qCAAqC,yDAAQ;AAC7C;AACA,sBAAsB,8EAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY,QAAQ,uKAAmC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,mEAAmE,gBAAgB,IAAI,oBAAoB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAI;AAClC;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAS,CAAC,2DAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAQ;AACzC;AACA,YAAY,oEAAU;AACtB,iCAAiC,oEAAU,uBAAuB,oBAAoB,qEAAW,KAAK;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAI;AAC1B;AACA;AACA,kDAAkD;AAClD,wBAAwB,kBAAkB;AAC1C;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,uCAAuC,iBAAiB;AACxD;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClZA;AACA;AACqC;AACF;AACwB;AACb;AAC9C,gCAAgC,uDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAQ;AAClC,0BAA0B,yDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAiB;AACzB,QAAQ,+CAAkB;AAC1B,uBAAuB,yDAAQ,sBAAsB,yDAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAiB;AAC7B;AACA,gBAAgB,+CAAkB;AAClC;AACA,YAAY,gDAAmB;AAC/B;AACA;AACA;AACA,QAAQ,8CAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAkB;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC,qDAAwB,GAAG,OAAO,0CAAa,EAAE;AACnF;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAc;AACrC,qBAAqB,yDAAQ;AAC7B,qBAAqB,yDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7LA;AACA;AACoE;AACrB;AACc;AACiB;AACc;AAC5B;AAChE;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mGAAmG;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,wDAAwD;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAwD;AACxE;AACA;AACA;AACA;AACA,0BAA0B,qGAAmC;AAC7D;AACA;AACA,8BAA8B,uFAA4B;AAC1D;AACA;AACA;AACA;AACA,gBAAgB,6FAA6F;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAQ,cAAc,mCAAmC,4BAA4B,8FAA8F,0EAA0E,OAAO;AACpS,sFAAsF,qEAAW;AACjG;AACA;AACA;AACA;AACA;AACA,8BAA8B,8EAAoB;AAClD;AACA;AACA;AACA;AACA,oCAAoC,yDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAQ;AAChC;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,kEAAc;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvNA;AACA;AACiD;AACmC;AACR;AACrE,kDAAkD,qFAA2B;AACpF;AACA;AACA,qDAAqD,yDAAa,wBAAwB;AAC1F;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,+BAA+B,kEAAc;AAC7C,+BAA+B,yDAAa,yBAAyB,gBAAgB,kEAAc,SAAS;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAqB,0BAA0B,kEAAc,oEAAoE,kEAAc;AAClK;AACA;AACA;;;;;;;;;;;;;;ACnDA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACTA;AACA;AAC4E;AACrE,2CAA2C,qFAA2B;AAC7E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCA;AACA;AACwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uCAAuC,gHAAsC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACgE;AACiB;AAChC;AACiB;AAClE,uBAAuB,gEAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,wEAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAkB;AAClC,gBAAgB,yDAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAU;AAChD;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B,kCAAkC;AAClC;AACA,8CAA8C,mBAAmB,QAAQ,cAAc;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChKA;AACA;AACyI;AACzI;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAwB;AAC5D;AACA;AACA;AACA;AACA,2CAA2C,oDAAe;AAC1D;AACA;AACA;AACA;AACA,4CAA4C,6CAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,0CAA0C,oDAAe;AACzD;AACA;AACA;AACA,0CAA0C,wDAAmB;AAC7D;AACA;AACA;AACA;AACA,iDAAiD,sDAAiB;AAClE;AACA;AACA;AACA,yCAAyC,oDAAe;AACxD;AACA;AACA;AACA,iCAAiC,sDAAiB;AAClD;AACA;AACA;AACA;AACA;AACA,qCAAqC,6CAAQ;AAC7C;AACA;AACA;AACA;AACA,6BAA6B,6CAAQ;AACrC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AAC6B;AACsD;AACzB;AACA;AACJ;AACtD;AACA;AACA;AACO,wCAAwC,+DAAgB;AAC/D;AACA;AACA,iCAAiC,+DAAa;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B,sCAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA,6BAA6B,sCAAS,gBAAgB,+DAAa;AACnE;AACA,yBAAyB,kEAAQ;AACjC;AACA,QAAQ,oEAAU;AAClB;AACA;AACA,SAAS;AACT;AACA,QAAQ,oEAAU;AAClB;AACA,QAAQ,uEAAa,WAAW,uEAAa;AAC7C;AACA;AACA,+CAA+C,WAAW,gDAAgD,YAAY;AACtH;AACA;AACA;AACA,gDAAgD,sCAAS;AACzD,iBAAiB,oEAAU;AAC3B,kEAAkE,WAAW,UAAU,YAAY;AACnG,wBAAwB,yBAAyB;AACjD;AACA;AACA,YAAY,oEAAU;AACtB;AACA;AACA,aAAa;AACb;AACA,YAAY,oEAAU;AACtB;AACA,YAAY,uEAAa,WAAW,uEAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sCAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAQ;AACpC;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA,sEAAsE,iBAAiB,eAAe,iBAAiB,wBAAwB,oBAAoB;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS,kGAAkG,+DAAa;AACvI;AACA;AACA,eAAe,sCAAS,mHAAmH,+DAAa;AACxJ;AACA;AACA;;;;;;;;;;;;;;;ACvGA;AACA;AACsD;AACtD;AACA;AACA;AACA;AACO,kCAAkC,+DAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AAC+F;AAClE;AACiD;AACpB;AACtB;AACoC;AACjE;AACP,kBAAkB,kDAAkD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6CAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,mFAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAS;AACrB;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA,eAAe,sCAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,oCAAoC,mBAAmB,KAAK,EAAE;AACjG;AACA;AACA,sBAAsB,uEAAa,6BAA6B,mBAAmB;AACnF;AACA,oEAAoE,mBAAmB;AACvF;AACA;AACA,sBAAsB,uEAAa,yEAAyE,mBAAmB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAS;AACpC,aAAa,oEAAU;AACvB,sBAAsB,uEAAa,gCAAgC,WAAW,qBAAqB,gBAAgB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAQ;AACpC;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS,qDAAqD,gBAAgB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAS;AAC/C,eAAe,oEAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAU;AAC3B,oEAAoE,aAAa;AACjF;AACA,2CAA2C,kEAAQ;AACnD;AACA;AACA,mCAAmC,YAAY,0CAA0C,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAS,qBAAqB,+DAAa;AAC1D;AACA;AACA,+BAA+B,oEAAU,kBAAkB,sEAAU;AACrE;;;;;;;;;;;;;;AC9IA;AACA;AACO;AACP;AACA;AACA,kCAAkC,mBAAO,CAAC,yBAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACdA;AACA;AACiF;AACR;AACY;AAClD;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,2CAAI;AAC/C;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAM;AAC/C;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kFAAmB;AAC1C;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,uBAAuB,8FAAyB;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC,8BAA8B,8FAAyB;AACvD;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,WAAW;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa,oBAAoB,WAAW,KAAK,EAAE;AACzE;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzKA;AACA;AACsE;AACtE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,8BAA8B,oDAAe;AAC7C;AACA;AACA;AACA,6CAA6C,oDAAe;AAC5D;AACA;AACA;AACA,0CAA0C,4CAAO;AACjD,uBAAuB,oDAAe;AACtC,SAAS;AACT;AACA;AACA;AACA,uCAAuC,oDAAe;AACtD;AACA;AACA;AACA,oCAAoC,4CAAO;AAC3C,uBAAuB,oDAAe;AACtC,SAAS;AACT;AACA;AACA;AACA,iCAAiC,oDAAe;AAChD;AACA;AACA;AACA,gCAAgC,oDAAe;AAC/C;AACA;AACA;AACA,kCAAkC,sDAAiB;AACnD;AACA;AACA;;;;;;;;;;;;;;;;;;AChDA;AACA;AAC6D;AACnB;AACW;AACrD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,yBAAyB,8DAAkB;AAC3C;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,mBAAmB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,yBAAyB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjDA;AACA;AAC+C;AACxC;AACP;AACA;AACA;AACA;AACA,4BAA4B,yDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,+CAA+C,8BAA8B;AAC7E;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,mDAAmD,gCAAgC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AAC+C;AACtB;AACA;AACI;AACyC;AAC9B;AACxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8BAA8B,yCAAY;AAC1C;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAI;AAChB;AACA;AACA,aAAa,oEAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAS;AACjB,QAAQ,iDAAS,8GAA8G,EAAE;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yCAAY;AAC/C;AACA,6BAA6B,oEAAU;AACvC;AACA;AACA,qCAAqC,yCAAY;AACjD;AACA;AACA;AACA;AACA,oBAAoB,oEAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB,GAAG,8BAA8B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAW;AACvB;AACA;AACA;AACA;AACA,0CAA0C,8DAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sBAAsB;AACpE;AACA,wCAAwC,yEAAyE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oEAAU;AAClD;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sCAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB,GAAG,aAAa,GAAG,QAAQ;AAC5E;AACA,YAAY,0CAAa;AACzB;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oEAAU;AACnC;AACA,qCAAqC,WAAW,GAAG,WAAW;AAC9D;AACA;AACA;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA,QAAQ,oEAAU;AAClB;AACA;AACA;;;;;;;;;;;;;;;;ACzKA;AACA;AACkF;AAC3E;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yEAAwB;AACzC,iBAAiB,yEAAwB;AACzC;AACA;AACA;AACA,oDAAoD,kBAAkB,kEAAiB,SAAS;AAChG;AACA;AACA,iBAAiB,yEAAwB;AACzC;AACA;AACA;AACA,wDAAwD,kBAAkB,kEAAiB,SAAS;AACpG;AACA;AACA;AACA,iBAAiB,yEAAwB;AACzC,oDAAoD,kBAAkB,kEAAiB,SAAS;AAChG;AACA;AACA;AACA,iBAAiB,yEAAwB;AACzC,oDAAoD,kBAAkB,kEAAiB,SAAS;AAChG;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrDA;AACA;AACwC;AACP;AAC1B;AACP;AACA;AACA;AACA,sCAAsC,iDAAS;AAC/C;AACA;AACA,wBAAwB,yCAAY;AACpC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA,8CAA8C,iDAAS;AACvD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,mEAAmE,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACiE;AACjE;AACA;AACA;AACO,8BAA8B,2EAAiB;AACtD;AACA;AACA;AACO,4BAA4B,sBAAsB;AACzD;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACO,6BAA6B,sBAAsB,QAAQ,kBAAkB;AACpF;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACoE;AACrB;AACsB;AAC9D;AACP;AACA;AACA;AACA,oCAAoC,yDAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAoB;AACrC,6GAA6G,uCAAuC;AACpJ;AACA,iBAAiB,+DAAoB;AACrC;AACA,oDAAoD,mBAAmB;AACvE;AACA,+BAA+B,uCAAuC;AACtE;AACA;AACA;AACA,iBAAiB,+DAAoB;AACrC;AACA,+EAA+E,wBAAwB;AACvG,6CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA,iBAAiB,+DAAoB;AACrC;AACA;AACA,yGAAyG,wBAAwB;AACjI,yCAAyC,sBAAsB;AAC/D,wCAAwC,yBAAyB;AACjE,0BAA0B,8EAAoB;AAC9C;AACA;AACA;AACA;AACA,iBAAiB,yDAAc;AAC/B,wCAAwC,yDAAQ;AAChD,0BAA0B,8EAAoB;AAC9C,iBAAiB,yDAAc;AAC/B,0CAA0C,yDAAQ;AAClD;AACA,iBAAiB,yDAAc;AAC/B,iBAAiB,yDAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AAC+D;AAC6B;AACtB;AACf;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mCAAmC,GAAG,+DAAa,0BAA0B;AACxH,4CAA4C,yCAAyC,GAAG,+DAAa,0BAA0B;AAC/H;AACA;AACA,YAAY,oEAAU;AACtB,YAAY,oEAAU;AACtB;AACA;AACA;AACA,kBAAkB,kEAAQ,gDAAgD,oEAAU,kBAAkB,6DAAoB;AAC1H;AACA;AACA,kBAAkB,kEAAQ,sCAAsC,YAAY,oEAAU,mBAAmB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yDAAQ,8CAA8C,OAAO;AACtG;AACA;AACA,yCAAyC,yDAAQ;AACjD;AACA;AACA,0BAA0B,OAAO;AACjC,qCAAqC,yDAAQ,WAAW,MAAM;AAC9D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uDAAuD,2BAA2B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qBAAqB,oCAAoC,gBAAgB;AACpH,wBAAwB,oEAAU;AAClC;AACA;AACA;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB,4BAA4B,QAAQ;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,gBAAgB,4BAA4B,QAAQ;AACxH;AACA;AACA;AACA;AACA;AACA,sEAAsE,gBAAgB;AACtF,uBAAuB,qBAAqB,kBAAkB,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+DAAc;AAC/D;AACA;AACA;AACA,eAAe,+DAAc,mDAAmD,yDAAQ;AACxF;AACA,eAAe,+DAAc;AAC7B;AACA;AACA,8BAA8B,+DAAc,qDAAqD,yDAAQ;AACzG;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA,wFAAwF,cAAc;AACtG;AACA;AACA,cAAc,kEAAQ;AACtB;AACA;AACA,wBAAwB,oEAAU;AAClC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzSA;AACA;AACiE;AACU;AAC3E,gBAAgB,2EAAiB;AACjC;AACA;AACA,oDAAoD,WAAW;AAC/D,gBAAgB,mFAAwB;AACxC;AACA;;;;;;;;;;;;;;;;ACVA;AACA;AACwC;AACxC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACO;AACP,0BAA0B,iDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB,QAAQ,0BAA0B,EAAE,oBAAoB;AAClG;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpGA;AACA;AAC6B;AACT;AAC8D;AACtD;AAC+C;AACpE;AACP;AACA;AACA;AACA;AACA;AACA,kCAAkC,mFAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA,cAAc,oEAAU,mBAAmB,yCAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oEAAU,mBAAmB,yCAAY;AACvD,2BAA2B,oEAAU;AACrC;AACA,2BAA2B,sBAAsB;AACjD,yBAAyB,yBAAyB,EAAE,eAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oEAAU;AACvC;AACA,SAAS;AACT,+EAA+E,MAAM;AACrF,+EAA+E,MAAM;AACrF;AACA;AACA;AACA;AACA;AACA,oCAAoC,kDAAW;AAC/C,2FAA2F,YAAY;AACvG;AACA;AACA;AACA;AACA,YAAY,kDAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB;AAC7E,0BAA0B,oEAAU;AACpC;AACA;AACA;AACA;AACA,eAAe,oEAAU;AACzB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtIA;AACA;AAC+C;AACtB;AACI;AACY;AACN;AACyF;AAC/E;AAC8B;AACpB;AACvD;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yCAAY;AACvC,aAAa,oEAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO,iBAAiB,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oEAAU,qEAAqE,EAAE;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oEAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+DAAK;AACnB;AACA;AACA;AACA,uCAAuC,oEAAU;AACjD;AACA;AACA,wBAAwB,oEAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8HAA8H;AACrK,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA,gCAAgC,SAAS;AACzC;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,oDAAuB;AAClG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gDAAmB;AAC7F;AACA,YAAY,8EAAoB,8BAA8B,8EAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+GAA+G;AACjK,oBAAoB,yCAAY;AAChC,sCAAsC,oEAAU;AAChD;AACA;AACA;AACA;AACA,cAAc,oEAAU;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAQ,2BAA2B,sCAAS,YAAY,uEAAa;AACnF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB;AACA,oCAAoC,WAAW;AAC/C;AACA,kCAAkC,gBAAgB;AAClD,YAAY,oEAAU,YAAY,6BAA6B;AAC/D;AACA;AACA,gBAAgB,oEAAU;AAC1B;AACA;AACA,wCAAwC,gBAAgB;AACxD,gBAAgB,oEAAU;AAC1B;AACA;AACA;AACA;AACA,2CAA2C,+DAAa,mBAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qCAAqC,sPAAsP;AAClV,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8EAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,2CAAc;AACvH;AACA;AACA;AACA,oBAAoB,mFAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yCAAY;AACpC;AACA,sBAAsB,QAAQ,EAAE,2CAAc,CAAC,EAAE,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oIAAoI;AACpL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iCAAiC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAmB;AAChD;AACA,sCAAsC,6CAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qBAAqB,oEAAU;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA,4BAA4B,uBAAuB;AACnD;AACA,kCAAkC,OAAO;AACzC;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA,iEAAiE,OAAO,IAAI,OAAO;AACnF;AACA;AACA;AACA,sBAAsB,sDAAS;AAC/B;;;;;;;;;;;;;;;;;;;;AC3hBA;AACA;AACA;AACyB;AACI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8EAA8E;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0CAAa;AACrB,+BAA+B,4CAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,mBAAmB;AAC9G;AACA;AACO;AACP;AACA;AACA,gEAAgE,SAAS;AACzE,iCAAiC,KAAK,KAAK;AAC3C,yCAAyC;AACzC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA,yBAAyB,6BAA6B;AACtD,yBAAyB,6BAA6B;AACtD,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAkE,cAAc;AAClG,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2CAA2C;AACvD,gCAAgC,gBAAgB,IAAI;AACpD,0BAA0B,gBAAgB;AAC1C;AACA,IAAI,6CAAgB;AACpB;AACA;AACO;AACP,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK,4BAA4B;AACjC,4BAA4B,sCAAS;AACrC,4BAA4B,sCAAS;AACrC;AACA,YAAY,0CAAa;AACzB;AACA,iBAAiB,0CAAa;AAC9B,gBAAgB,yCAAY,sBAAsB,iBAAiB;AACnE;AACA,yDAAyD;AACzD;AACA,wBAAwB;AACxB;AACA,iBAAiB,0CAAa;AAC9B;AACA,oCAAoC,gBAAgB,IAAI;AACxD,YAAY,0CAAa;AACzB;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACO;AACP,+BAA+B,kBAAkB;AACjD;AACA,SAAS,0CAAa;AACtB;AACA;AACA,8CAA8C,8CAA8C;AAC5F,6CAA6C,YAAY;AACzD;AACA;AACA;;;;;;;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxKA;AACA;AACsF;AACvC;AACZ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wCAAwC,oEAAU;AAClD;AACA;AACA;AACA,wBAAwB,yDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAoB,yDAAQ,wBAAwB,gBAAgB;AACpE;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA,yBAAyB,oEAAU,6BAA6B,oBAAoB,qEAAW,KAAK;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa,wDAAwD,uBAAuB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAa,sDAAsD,uBAAuB;AACpH;AACA;AACA;AACA,0BAA0B,uEAAa,uDAAuD,uBAAuB;AACrH;AACA;AACA;AACA,0BAA0B,uEAAa,8DAA8D,uBAAuB;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAa;AAC3C,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oEAAU;AACpB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAa,sDAAsD,YAAY;AAC7F;AACA;AACA;AACA;AACA,mBAAmB,2CAAI;AACvB;AACA,sBAAsB,uEAAa,mDAAmD,aAAa;AACnG;AACA;AACA","sources":["webpack://@microsoft/rush-lib/./lib-esnext/api/ApprovedPackagesConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/ApprovedPackagesPolicy.js","webpack://@microsoft/rush-lib/./lib-esnext/api/BuildCacheConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/ChangeFile.js","webpack://@microsoft/rush-lib/./lib-esnext/api/ChangeManagement.js","webpack://@microsoft/rush-lib/./lib-esnext/api/ChangeManager.js","webpack://@microsoft/rush-lib/./lib-esnext/api/CobuildConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/CommandLineConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/CommonVersionsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/CustomTipsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/EnvironmentConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/EventHooks.js","webpack://@microsoft/rush-lib/./lib-esnext/api/ExperimentsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/FlagFile.js","webpack://@microsoft/rush-lib/./lib-esnext/api/LastInstallFlag.js","webpack://@microsoft/rush-lib/./lib-esnext/api/PackageJsonEditor.js","webpack://@microsoft/rush-lib/./lib-esnext/api/PackageNameParsers.js","webpack://@microsoft/rush-lib/./lib-esnext/api/Rush.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushCommandLine.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushConfigurationProject.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushGlobalFolder.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushInternals.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushPluginsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushProjectConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/RushUserConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/SaveCallbackPackageJsonEditor.js","webpack://@microsoft/rush-lib/./lib-esnext/api/Subspace.js","webpack://@microsoft/rush-lib/./lib-esnext/api/SubspacesConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/Variants.js","webpack://@microsoft/rush-lib/./lib-esnext/api/VersionPolicy.js","webpack://@microsoft/rush-lib/./lib-esnext/api/VersionPolicyConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/api/packageManager/NpmPackageManager.js","webpack://@microsoft/rush-lib/./lib-esnext/api/packageManager/PackageManager.js","webpack://@microsoft/rush-lib/./lib-esnext/api/packageManager/PnpmPackageManager.js","webpack://@microsoft/rush-lib/./lib-esnext/api/packageManager/YarnPackageManager.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/CommandLineMigrationAdvisor.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/RushCommandLineParser.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/RushPnpmCommandLine.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/RushPnpmCommandLineParser.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/RushStartupBanner.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/RushXCommandLine.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/AddAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/AlertAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/BaseAddAndRemoveAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/BaseAutoinstallerAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/BaseInstallAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/BaseRushAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/ChangeAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/CheckAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/DeployAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/InitAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/InitAutoinstallerAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/InitDeployAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/InitSubspaceAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/InstallAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/InstallAutoinstallerAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/LinkAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/ListAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/PublishAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/PurgeAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/RemoveAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/ScanAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/SetupAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/UnlinkAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/UpdateAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/UpdateAutoinstallerAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/UpdateCloudCredentialsAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/UpgradeInteractiveAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/actions/VersionAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/parsing/ParseParallelism.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/parsing/SelectionParameterSet.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/scriptActions/BaseScriptAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/scriptActions/GlobalScriptAction.js","webpack://@microsoft/rush-lib/./lib-esnext/cli/scriptActions/PhasedScriptAction.js","webpack://@microsoft/rush-lib/./lib-esnext/index.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/Autoinstaller.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ChangeFiles.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ChangeManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ChangelogGenerator.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/CredentialCache.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/DependencyAnalyzer.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/DependencySpecifier.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/EventHooksManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/Git.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/GitStatusParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/JsonSchemaUrls.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/NodeJsCompatibility.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/PackageJsonUpdaterTypes.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/PrereleaseToken.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ProjectChangeAnalyzer.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ProjectCommandSet.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/PublishGit.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/PublishUtilities.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/PurgeManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/RepoStateFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/RushConstants.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/Selection.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/SetupChecks.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/ShrinkwrapFileFactory.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/StandardScriptUpdater.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/Telemetry.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/UnlinkManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BasePackageManagerOptionsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseProjectShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/base/BaseShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/buildCache/CacheEntryId.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/buildCache/FileSystemBuildCacheProvider.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/buildCache/ProjectBuildCache.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/cobuild/CobuildLock.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/cobuild/DisjointSet.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/deploy/DeployScenarioConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/incremental/InputsSnapshot.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/installManager/InstallHelpers.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/npm/NpmOptionsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/npm/NpmShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/AsyncOperationQueue.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/CacheableOperationPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/LegacySkipPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/NodeDiagnosticDirPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/NullOperationRunner.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/Operation.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationError.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationExecutionManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationExecutionRecord.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationMetadataManager.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationResultSummarizerPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationStateFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/OperationStatus.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/PeriodicCallback.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/PhasedOperationPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ProjectLogWritable.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ShardedPhaseOperationPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ShellOperationRunner.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ShellOperationRunnerPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/ValidateOperationsPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/operations/WeightedOperationPlugin.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmOptionsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmProjectShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmShrinkWrapFileConverters.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmYamlCommon.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmfileConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/PnpmfileShim.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/pnpm/SubspacePnpmfileConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/policy/EnvironmentPolicy.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/policy/GitEmailPolicy.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/policy/PolicyValidator.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/policy/ShrinkwrapFilePolicy.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/selectors/GitChangedProjectSelectorParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/selectors/NamedProjectSelectorParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/selectors/SubspaceSelectorParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/selectors/TagProjectSelectorParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/selectors/VersionPolicyProjectSelectorParser.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/setup/ArtifactoryConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/setup/KeyboardLoop.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/setup/SetupPackageRegistry.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/setup/TerminalInput.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/versionMismatch/VersionMismatchFinder.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/versionMismatch/VersionMismatchFinderCommonVersions.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/versionMismatch/VersionMismatchFinderEntity.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/versionMismatch/VersionMismatchFinderProject.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/yarn/YarnOptionsConfiguration.js","webpack://@microsoft/rush-lib/./lib-esnext/logic/yarn/YarnShrinkwrapFile.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PhasedCommandHooks.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PluginLoader/AutoinstallerPluginLoader.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PluginLoader/BuiltInPluginLoader.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PluginLoader/PluginLoaderBase.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PluginLoader/RushSdk.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/PluginManager.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/RushLifeCycle.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/RushSession.js","webpack://@microsoft/rush-lib/./lib-esnext/pluginFramework/logging/Logger.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/AsyncRecycler.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/CollatedTerminalProvider.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/Npm.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/NullTerminalProvider.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/OverlappingPathAnalyzer.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/PathConstants.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/PnpmSyncUtilities.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/RushAlerts.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/SetRushLibPath.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/Stopwatch.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/TarExecutable.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/Utilities.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/npmrcUtilities.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/objectUtilities.js","webpack://@microsoft/rush-lib/./lib-esnext/utilities/templateUtilities.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { JsonFile, JsonSchema, FileSystem, NewlineKind, InternalError } from '@rushstack/node-core-library';\nimport { JsonSchemaUrls } from '../logic/JsonSchemaUrls';\nimport schemaJson from '../schemas/approved-packages.schema.json';\nimport { RushConstants } from '../logic/RushConstants';\n/**\n * An item returned by ApprovedPackagesConfiguration\n * @public\n */\nexport class ApprovedPackagesItem {\n    /**\n     * @internal\n     */\n    constructor(packageName) {\n        /**\n         * The project categories that are allowed to use this package.\n         */\n        this.allowedCategories = new Set();\n        this.packageName = packageName;\n    }\n}\n/**\n * This represents the JSON file specified via the \"approvedPackagesFile\" option in rush.json.\n * @public\n */\nexport class ApprovedPackagesConfiguration {\n    constructor(jsonFilename) {\n        this.items = [];\n        this._itemsByName = new Map();\n        this._jsonFilename = jsonFilename;\n        this.clear();\n    }\n    /**\n     * Clears all the settings, returning to an empty state.\n     */\n    clear() {\n        this._itemsByName.clear();\n        this._loadedJson = {\n            // Ensure this comes first in the key ordering\n            $schema: '',\n            packages: []\n        };\n    }\n    getItemByName(packageName) {\n        return this._itemsByName.get(packageName);\n    }\n    addOrUpdatePackage(packageName, reviewCategory) {\n        let changed = false;\n        let item = this._itemsByName.get(packageName);\n        if (!item) {\n            item = new ApprovedPackagesItem(packageName);\n            this._addItem(item);\n            changed = true;\n        }\n        if (reviewCategory && !item.allowedCategories.has(reviewCategory)) {\n            item.allowedCategories.add(reviewCategory);\n            changed = true;\n        }\n        return changed;\n    }\n    /**\n     * If the file exists, calls loadFromFile().\n     */\n    tryLoadFromFile(approvedPackagesPolicyEnabled) {\n        if (!FileSystem.exists(this._jsonFilename)) {\n            return false;\n        }\n        this.loadFromFile();\n        if (!approvedPackagesPolicyEnabled) {\n            // eslint-disable-next-line no-console\n            console.log(`Warning: Ignoring \"${path.basename(this._jsonFilename)}\" because the` +\n                ` \"approvedPackagesPolicy\" setting was not specified in ${RushConstants.rushJsonFilename}`);\n        }\n        return false;\n    }\n    /**\n     * Loads the configuration data from the filename that was passed to the constructor.\n     */\n    loadFromFile() {\n        const approvedPackagesJson = JsonFile.loadAndValidate(this._jsonFilename, ApprovedPackagesConfiguration._jsonSchema);\n        this.clear();\n        for (const browserPackage of approvedPackagesJson.packages) {\n            this._addItemJson(browserPackage, this._jsonFilename);\n        }\n    }\n    /**\n     * Loads the configuration data to the filename that was passed to the constructor.\n     */\n    saveToFile() {\n        // Update the JSON structure that we already loaded, preserving any existing state\n        // (which passed schema validation).\n        // eslint-disable-next-line dot-notation\n        this._loadedJson['$schema'] = JsonSchemaUrls.approvedPackages;\n        this._loadedJson.packages = [];\n        this.items.sort((a, b) => {\n            return a.packageName.localeCompare(b.packageName);\n        });\n        for (const item of this.items) {\n            // Sort the items from the set.\n            const allowedCategories = Array.from(item.allowedCategories);\n            allowedCategories.sort();\n            const itemJson = {\n                name: item.packageName,\n                allowedCategories: allowedCategories\n            };\n            this._loadedJson.packages.push(itemJson);\n        }\n        // Save the file\n        let body = JsonFile.stringify(this._loadedJson);\n        // Unindent the allowedCategories array to improve readability\n        body = body.replace(/(\"allowedCategories\": +\\[)([^\\]]+)/g, (substring, ...args) => {\n            return args[0] + args[1].replace(/\\s+/g, ' ');\n        });\n        // Add a header\n        body = '// DO NOT ADD COMMENTS IN THIS FILE.  They will be lost when the Rush tool resaves it.\\n' + body;\n        FileSystem.writeFile(this._jsonFilename, body, {\n            convertLineEndings: NewlineKind.CrLf\n        });\n    }\n    /**\n     * Helper function only used by the constructor when loading the file.\n     */\n    _addItemJson(itemJson, jsonFilename) {\n        if (this._itemsByName.has(itemJson.name)) {\n            throw new Error(`Error loading package review file ${jsonFilename}:\\n` +\n                ` the name \"${itemJson.name}\" appears more than once`);\n        }\n        const item = new ApprovedPackagesItem(itemJson.name);\n        if (itemJson.allowedCategories) {\n            for (const allowedCategory of itemJson.allowedCategories) {\n                item.allowedCategories.add(allowedCategory);\n            }\n        }\n        this._addItem(item);\n    }\n    /**\n     * Helper function that adds an already created ApprovedPackagesItem to the\n     * list and set.\n     */\n    _addItem(item) {\n        if (this._itemsByName.has(item.packageName)) {\n            throw new InternalError('Duplicate key');\n        }\n        this.items.push(item);\n        this._itemsByName.set(item.packageName, item);\n    }\n}\nApprovedPackagesConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=ApprovedPackagesConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { ApprovedPackagesConfiguration } from './ApprovedPackagesConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\n/**\n * This is a helper object for RushConfiguration.\n * It exposes the \"approvedPackagesPolicy\" feature from rush.json.\n * @public\n */\nexport class ApprovedPackagesPolicy {\n    /** @internal */\n    constructor(rushConfiguration, rushConfigurationJson) {\n        const approvedPackagesPolicy = rushConfigurationJson.approvedPackagesPolicy || {};\n        this.enabled = !!rushConfigurationJson.approvedPackagesPolicy;\n        this.ignoredNpmScopes = new Set(approvedPackagesPolicy.ignoredNpmScopes);\n        this.reviewCategories = new Set(approvedPackagesPolicy.reviewCategories);\n        if (this.enabled) {\n            if (!this.reviewCategories.size) {\n                throw new Error(`The \"approvedPackagesPolicy\" feature is enabled ${RushConstants.rushJsonFilename}, but the reviewCategories` +\n                    ` list is not configured.`);\n            }\n        }\n        // Load browser-approved-packages.json\n        const browserApprovedPackagesPath = path.join(rushConfiguration.commonRushConfigFolder, RushConstants.browserApprovedPackagesFilename);\n        this.browserApprovedPackages = new ApprovedPackagesConfiguration(browserApprovedPackagesPath);\n        this.browserApprovedPackages.tryLoadFromFile(this.enabled);\n        // Load nonbrowser-approved-packages.json\n        const nonbrowserApprovedPackagesPath = path.join(rushConfiguration.commonRushConfigFolder, RushConstants.nonbrowserApprovedPackagesFilename);\n        this.nonbrowserApprovedPackages = new ApprovedPackagesConfiguration(nonbrowserApprovedPackagesPath);\n        this.nonbrowserApprovedPackages.tryLoadFromFile(this.enabled);\n    }\n}\n//# sourceMappingURL=ApprovedPackagesPolicy.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { JsonFile, JsonSchema, FileSystem, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { FileSystemBuildCacheProvider } from '../logic/buildCache/FileSystemBuildCacheProvider';\nimport { RushConstants } from '../logic/RushConstants';\nimport { RushUserConfiguration } from './RushUserConfiguration';\nimport { EnvironmentConfiguration } from './EnvironmentConfiguration';\nimport { CacheEntryId } from '../logic/buildCache/CacheEntryId';\nimport schemaJson from '../schemas/build-cache.schema.json';\n/**\n * Use this class to load and save the \"common/config/rush/build-cache.json\" config file.\n * This file provides configuration options for cached project build output.\n * @beta\n */\nexport class BuildCacheConfiguration {\n    constructor({ getCacheEntryId, buildCacheJson, rushUserConfiguration, rushConfiguration, cloudCacheProvider }) {\n        var _a;\n        this.buildCacheEnabled = (_a = EnvironmentConfiguration.buildCacheEnabled) !== null && _a !== void 0 ? _a : buildCacheJson.buildCacheEnabled;\n        this.cacheWriteEnabled =\n            !!this.buildCacheEnabled && EnvironmentConfiguration.buildCacheWriteAllowed !== false;\n        this.getCacheEntryId = getCacheEntryId;\n        this.localCacheProvider = new FileSystemBuildCacheProvider({\n            rushUserConfiguration: rushUserConfiguration,\n            rushConfiguration: rushConfiguration\n        });\n        this.cloudCacheProvider = cloudCacheProvider;\n        this.cacheHashSalt = buildCacheJson.cacheHashSalt;\n    }\n    /**\n     * Attempts to load the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.\n     * If the file has not been created yet, then undefined is returned.\n     */\n    static async tryLoadAsync(terminal, rushConfiguration, rushSession) {\n        const jsonFilePath = BuildCacheConfiguration.getBuildCacheConfigFilePath(rushConfiguration);\n        if (!FileSystem.exists(jsonFilePath)) {\n            return undefined;\n        }\n        return await BuildCacheConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession);\n    }\n    /**\n     * Loads the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.\n     * If the file has not been created yet, or if the feature is not enabled, then an error is reported.\n     */\n    static async loadAndRequireEnabledAsync(terminal, rushConfiguration, rushSession) {\n        const jsonFilePath = BuildCacheConfiguration.getBuildCacheConfigFilePath(rushConfiguration);\n        if (!FileSystem.exists(jsonFilePath)) {\n            terminal.writeErrorLine(`The build cache feature is not enabled. This config file is missing:\\n` + jsonFilePath);\n            terminal.writeLine(`\\nThe Rush website documentation has instructions for enabling the build cache.`);\n            throw new AlreadyReportedError();\n        }\n        const buildCacheConfiguration = await BuildCacheConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession);\n        if (!buildCacheConfiguration.buildCacheEnabled) {\n            terminal.writeErrorLine(`The build cache feature is not enabled. You can enable it by editing this config file:\\n` +\n                jsonFilePath);\n            throw new AlreadyReportedError();\n        }\n        return buildCacheConfiguration;\n    }\n    /**\n     * Gets the absolute path to the build-cache.json file in the specified rush workspace.\n     */\n    static getBuildCacheConfigFilePath(rushConfiguration) {\n        return path.resolve(rushConfiguration.commonRushConfigFolder, RushConstants.buildCacheFilename);\n    }\n    static async _loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession) {\n        const buildCacheJson = await JsonFile.loadAndValidateAsync(jsonFilePath, BuildCacheConfiguration._jsonSchema);\n        const rushUserConfiguration = await RushUserConfiguration.initializeAsync();\n        let getCacheEntryId;\n        try {\n            getCacheEntryId = CacheEntryId.parsePattern(buildCacheJson.cacheEntryNamePattern);\n        }\n        catch (e) {\n            terminal.writeErrorLine(`Error parsing cache entry name pattern \"${buildCacheJson.cacheEntryNamePattern}\": ${e}`);\n            throw new AlreadyReportedError();\n        }\n        let cloudCacheProvider;\n        // Don't configure a cloud cache provider if local-only\n        if (buildCacheJson.cacheProvider !== 'local-only') {\n            const cloudCacheProviderFactory = rushSession.getCloudBuildCacheProviderFactory(buildCacheJson.cacheProvider);\n            if (!cloudCacheProviderFactory) {\n                throw new Error(`Unexpected cache provider: ${buildCacheJson.cacheProvider}`);\n            }\n            cloudCacheProvider = await cloudCacheProviderFactory(buildCacheJson);\n        }\n        return new BuildCacheConfiguration({\n            buildCacheJson,\n            getCacheEntryId,\n            rushConfiguration,\n            rushUserConfiguration,\n            rushSession,\n            cloudCacheProvider\n        });\n    }\n}\nBuildCacheConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=BuildCacheConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { JsonFile } from '@rushstack/node-core-library';\nimport { Git } from '../logic/Git';\n/**\n * This class represents a single change file.\n */\nexport class ChangeFile {\n    /**\n     * @internal\n     */\n    constructor(changeFileData, rushConfiguration) {\n        if (!changeFileData) {\n            throw new Error(`changeFileData does not have a value`);\n        }\n        if (!rushConfiguration) {\n            throw new Error(`rushConfiguration does not have a value`);\n        }\n        this._changeFileData = changeFileData;\n        this._rushConfiguration = rushConfiguration;\n    }\n    /**\n     * Adds a change entry into the change file\n     * @param data - change information\n     */\n    addChange(data) {\n        this._changeFileData.changes.push(data);\n    }\n    /**\n     * Gets all the change entries about the specified package from the change file.\n     * @param packageName - package name\n     */\n    getChanges(packageName) {\n        const changes = [];\n        for (const info of this._changeFileData.changes) {\n            if (info.packageName === packageName) {\n                changes.push(info);\n            }\n        }\n        return changes;\n    }\n    /**\n     * Writes the change file to disk in sync mode.\n     * Returns the file path.\n     * @returns the path to the file that was written (based on generatePath())\n     */\n    writeSync() {\n        const filePath = this.generatePath();\n        JsonFile.save(this._changeFileData, filePath, {\n            ensureFolderExists: true\n        });\n        return filePath;\n    }\n    /**\n     * Generates a file path for storing the change file to disk.\n     * Note that this value may change if called twice in a row,\n     * as it is partially based on the current date/time.\n     */\n    generatePath() {\n        let branch = undefined;\n        const git = new Git(this._rushConfiguration);\n        const repoInfo = git.getGitInfo();\n        branch = repoInfo && repoInfo.branch;\n        if (!branch) {\n            // eslint-disable-next-line no-console\n            console.log('Could not automatically detect git branch name, using timestamp instead.');\n        }\n        // example filename: yourbranchname_2017-05-01-20-20.json\n        const filename = branch\n            ? this._escapeFilename(`${branch}_${this._getTimestamp()}.json`)\n            : `${this._getTimestamp()}.json`;\n        const filePath = path.join(this._rushConfiguration.changesFolder, ...this._changeFileData.packageName.split('/'), filename);\n        return filePath;\n    }\n    /**\n     * Gets the current time, formatted as YYYY-MM-DD-HH-MM\n     * Optionally will include seconds\n     */\n    _getTimestamp(useSeconds = false) {\n        // Create a date string with the current time\n        // dateString === \"2016-10-19T22:47:49.606Z\"\n        const dateString = new Date().toJSON();\n        // Parse out 2 capture groups, the date and the time\n        const dateParseRegex = /([0-9]{4}-[0-9]{2}-[0-9]{2}).*([0-9]{2}:[0-9]{2}:[0-9]{2})/;\n        // matches[1] === \"2016-10-19\"\n        // matches[2] === \"22:47:49\"\n        const matches = dateString.match(dateParseRegex);\n        if (matches) {\n            // formattedDate === \"2016-10-19\"\n            const formattedDate = matches[1];\n            let formattedTime;\n            if (useSeconds) {\n                // formattedTime === \"22-47-49\"\n                formattedTime = matches[2].replace(':', '-');\n            }\n            else {\n                // formattedTime === \"22-47\"\n                const timeParts = matches[2].split(':');\n                formattedTime = `${timeParts[0]}-${timeParts[1]}`;\n            }\n            return `${formattedDate}-${formattedTime}`;\n        }\n        return undefined;\n    }\n    _escapeFilename(filename, replacer = '-') {\n        // Removes / ? < > \\ : * | \", really anything that isn't a letter, number, '.' '_' or '-'\n        const badCharacters = /[^a-zA-Z0-9._-]/g;\n        return filename.replace(badCharacters, replacer);\n    }\n}\n//# sourceMappingURL=ChangeFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Represents all of the types of change requests.\n */\nexport var ChangeType;\n(function (ChangeType) {\n    ChangeType[ChangeType[\"none\"] = 0] = \"none\";\n    ChangeType[ChangeType[\"dependency\"] = 1] = \"dependency\";\n    ChangeType[ChangeType[\"hotfix\"] = 2] = \"hotfix\";\n    ChangeType[ChangeType[\"patch\"] = 3] = \"patch\";\n    ChangeType[ChangeType[\"minor\"] = 4] = \"minor\";\n    ChangeType[ChangeType[\"major\"] = 5] = \"major\";\n})(ChangeType || (ChangeType = {}));\n//# sourceMappingURL=ChangeManagement.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { ChangeFile } from './ChangeFile';\n/**\n * A class that helps with programmatically interacting with Rush's change files.\n * @public\n */\nexport class ChangeManager {\n    /**\n     * Creates a change file that has a 'none' type.\n     * @param rushConfiguration - The rush configuration we are working with\n     * @param projectName - The name of the project for which to create a change file\n     * @param emailAddress - The email address which should be associated with this change\n     * @returns the path to the file that was created, or undefined if no file was written\n     */\n    static createEmptyChangeFiles(rushConfiguration, projectName, emailAddress) {\n        const projectInfo = rushConfiguration.getProjectByName(projectName);\n        if (projectInfo && projectInfo.shouldPublish) {\n            const changefile = {\n                // eslint-disable-line @typescript-eslint/no-explicit-any\n                changes: [\n                    {\n                        comment: '',\n                        packageName: projectName,\n                        type: 'none'\n                    }\n                ],\n                packageName: projectName,\n                email: emailAddress\n            };\n            return new ChangeFile(changefile, rushConfiguration).writeSync();\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=ChangeManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport { v4 as uuidv4 } from 'uuid';\nimport { EnvironmentConfiguration } from './EnvironmentConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\nimport schemaJson from '../schemas/cobuild.schema.json';\n/**\n * Use this class to load and save the \"common/config/rush/cobuild.json\" config file.\n * This file provides configuration options for the Rush Cobuild feature.\n * @beta\n */\nexport class CobuildConfiguration {\n    constructor(options) {\n        var _a, _b;\n        const { cobuildJson, cobuildLockProviderFactory, rushConfiguration } = options;\n        this.cobuildContextId = EnvironmentConfiguration.cobuildContextId;\n        this.cobuildFeatureEnabled = this.cobuildContextId ? cobuildJson.cobuildFeatureEnabled : false;\n        this.cobuildRunnerId = EnvironmentConfiguration.cobuildRunnerId || uuidv4();\n        this.cobuildLeafProjectLogOnlyAllowed =\n            (_a = EnvironmentConfiguration.cobuildLeafProjectLogOnlyAllowed) !== null && _a !== void 0 ? _a : false;\n        this.cobuildWithoutCacheAllowed =\n            (_b = rushConfiguration.experimentsConfiguration.configuration.allowCobuildWithoutCache) !== null && _b !== void 0 ? _b : false;\n        this._cobuildLockProviderFactory = cobuildLockProviderFactory;\n        this._cobuildJson = cobuildJson;\n    }\n    /**\n     * Attempts to load the cobuild.json data from the standard file path `common/config/rush/cobuild.json`.\n     * If the file has not been created yet, then undefined is returned.\n     */\n    static async tryLoadAsync(terminal, rushConfiguration, rushSession) {\n        const jsonFilePath = CobuildConfiguration.getCobuildConfigFilePath(rushConfiguration);\n        try {\n            return await CobuildConfiguration._loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession);\n        }\n        catch (err) {\n            if (!FileSystem.isNotExistError(err)) {\n                throw err;\n            }\n        }\n    }\n    static getCobuildConfigFilePath(rushConfiguration) {\n        return `${rushConfiguration.commonRushConfigFolder}/${RushConstants.cobuildFilename}`;\n    }\n    static async _loadAsync(jsonFilePath, terminal, rushConfiguration, rushSession) {\n        let cobuildJson;\n        try {\n            cobuildJson = await JsonFile.loadAndValidateAsync(jsonFilePath, CobuildConfiguration._jsonSchema);\n        }\n        catch (e) {\n            if (FileSystem.isNotExistError(e)) {\n                return undefined;\n            }\n            throw e;\n        }\n        if (!(cobuildJson === null || cobuildJson === void 0 ? void 0 : cobuildJson.cobuildFeatureEnabled)) {\n            return undefined;\n        }\n        const cobuildLockProviderFactory = rushSession.getCobuildLockProviderFactory(cobuildJson.cobuildLockProvider);\n        if (!cobuildLockProviderFactory) {\n            throw new Error(`Unexpected cobuild lock provider: ${cobuildJson.cobuildLockProvider}`);\n        }\n        return new CobuildConfiguration({\n            cobuildJson,\n            rushConfiguration,\n            rushSession,\n            cobuildLockProviderFactory\n        });\n    }\n    async createLockProviderAsync(terminal) {\n        if (this.cobuildFeatureEnabled) {\n            terminal.writeLine(`Running cobuild (runner ${this.cobuildContextId}/${this.cobuildRunnerId})`);\n            const cobuildLockProvider = await this._cobuildLockProviderFactory(this._cobuildJson);\n            this._cobuildLockProvider = cobuildLockProvider;\n            await this._cobuildLockProvider.connectAsync();\n        }\n    }\n    async destroyLockProviderAsync() {\n        var _a;\n        if (this.cobuildFeatureEnabled) {\n            await ((_a = this._cobuildLockProvider) === null || _a === void 0 ? void 0 : _a.disconnectAsync());\n        }\n    }\n    getCobuildLockProvider() {\n        if (!this._cobuildLockProvider) {\n            throw new Error(`Cobuild lock provider has not been created`);\n        }\n        return this._cobuildLockProvider;\n    }\n}\nCobuildConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=CobuildConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, JsonSchema, FileSystem } from '@rushstack/node-core-library';\nimport { RushConstants } from '../logic/RushConstants';\nimport schemaJson from '../schemas/command-line.schema.json';\nconst DEFAULT_BUILD_COMMAND_JSON = {\n    commandKind: RushConstants.bulkCommandKind,\n    name: RushConstants.buildCommandName,\n    summary: \"Build all projects that haven't been built, or have changed since they were last built.\",\n    description: 'This command is similar to \"rush rebuild\", except that \"rush build\" performs' +\n        ' an incremental build. In other words, it only builds projects whose source files have changed' +\n        ' since the last successful build. The analysis requires a Git working tree, and only considers' +\n        ' source files that are tracked by Git and whose path is under the project folder. (For more details' +\n        ' about this algorithm, see the documentation for the \"package-deps-hash\" NPM package.) The incremental' +\n        ' build state is tracked in a per-project folder called \".rush/temp\" which should NOT be added to Git. The' +\n        ' build command is tracked by the \"arguments\" field in the \"package-deps_build.json\" file contained' +\n        ' therein; a full rebuild is forced whenever the command has changed (e.g. \"--production\" or not).',\n    safeForSimultaneousRushProcesses: false,\n    enableParallelism: true,\n    incremental: true\n};\nconst DEFAULT_REBUILD_COMMAND_JSON = {\n    commandKind: RushConstants.bulkCommandKind,\n    name: RushConstants.rebuildCommandName,\n    summary: 'Clean and rebuild the entire set of projects.',\n    description: 'This command assumes that the package.json file for each project contains' +\n        ' a \"scripts\" entry for \"npm run build\" that performs a full clean build.' +\n        ` Rush invokes this script to build each project that is registered in ${RushConstants.rushJsonFilename}.` +\n        ' Projects are built in parallel where possible, but always respecting the dependency' +\n        ' graph for locally linked projects.  The number of simultaneous processes will be' +\n        ' based on the number of machine cores unless overridden by the --parallelism flag.' +\n        ' (For an incremental build, see \"rush build\" instead of \"rush rebuild\".)',\n    safeForSimultaneousRushProcesses: false,\n    enableParallelism: true,\n    incremental: false\n};\n/**\n * This function replaces colons (\":\") with underscores (\"_\").\n *\n * ts-command-line restricts command names to lowercase letters, numbers, underscores, and colons.\n * Replacing colons with underscores produces a filesystem-safe name.\n */\nfunction _normalizeNameForLogFilenameIdentifiers(name) {\n    return name.replace(/:/g, '_'); // Replace colons with underscores to be filesystem-safe\n}\n/**\n * Custom Commands and Options for the Rush Command Line\n */\nexport class CommandLineConfiguration {\n    /**\n     * Use CommandLineConfiguration.loadFromFile()\n     *\n     * @internal\n     */\n    constructor(commandLineJson, options = {}) {\n        var _a, _b, _c;\n        this.commands = new Map();\n        this.phases = new Map();\n        this.parameters = [];\n        /**\n         * These path will be prepended to the PATH environment variable\n         */\n        this.additionalPathFolders = [];\n        /**\n         * A map of bulk command names to their corresponding synthetic phase identifiers\n         */\n        this._syntheticPhasesByTranslatedBulkCommandName = new Map();\n        const phasesJson = commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.phases;\n        if (phasesJson) {\n            const phaseNameRegexp = new RegExp(`^${RushConstants.phaseNamePrefix}[a-z][a-z0-9]*([-][a-z0-9]+)*$`);\n            for (const phase of phasesJson) {\n                if (this.phases.has(phase.name)) {\n                    throw new Error(`In ${RushConstants.commandLineFilename}, the phase \"${phase.name}\" is specified ` +\n                        'more than once.');\n                }\n                if (!phase.name.match(phaseNameRegexp)) {\n                    throw new Error(`In ${RushConstants.commandLineFilename}, the phase \"${phase.name}\"'s name ` +\n                        'is not a valid phase name. Phase names must begin with the ' +\n                        `required prefix \"${RushConstants.phaseNamePrefix}\" followed by a name containing ` +\n                        'lowercase letters, numbers, or hyphens. The name must start with a letter and ' +\n                        'must not end with a hyphen.');\n                }\n                if (phase.ignoreMissingScript !== undefined && phase.missingScriptBehavior !== undefined) {\n                    throw new Error(`In ${RushConstants.commandLineFilename}, the phase \"${phase.name}\"'s defines ` +\n                        'both \"ignoreMissingScript\" and \"missingScriptBehavior\". If using the \"missingScriptBehavior\", ' +\n                        `remove \"ignoreMissingScript\", since it subsumes the functionality.`);\n                }\n                // This is a completely fresh object. Avoid use of the `...` operator in its construction\n                // to guarantee monomorphism.\n                const processedPhase = {\n                    name: phase.name,\n                    isSynthetic: false,\n                    logFilenameIdentifier: _normalizeNameForLogFilenameIdentifiers(phase.name),\n                    associatedParameters: new Set(),\n                    dependencies: {\n                        self: new Set(),\n                        upstream: new Set()\n                    },\n                    missingScriptBehavior: (_a = phase.missingScriptBehavior) !== null && _a !== void 0 ? _a : (phase.ignoreMissingScript ? 'log' : 'error'),\n                    allowWarningsOnSuccess: !!phase.allowWarningsOnSuccess\n                };\n                this.phases.set(phase.name, processedPhase);\n            }\n            // Resolve phase names to the underlying objects\n            for (const rawPhase of phasesJson) {\n                // The named phase not existing was already handled in the loop above\n                const phase = this.phases.get(rawPhase.name);\n                const selfDependencies = (_b = rawPhase.dependencies) === null || _b === void 0 ? void 0 : _b.self;\n                const upstreamDependencies = (_c = rawPhase.dependencies) === null || _c === void 0 ? void 0 : _c.upstream;\n                if (selfDependencies) {\n                    for (const dependencyName of selfDependencies) {\n                        const dependency = this.phases.get(dependencyName);\n                        if (!dependency) {\n                            throw new Error(`In ${RushConstants.commandLineFilename}, in the phase \"${phase.name}\", the self ` +\n                                `dependency phase \"${dependencyName}\" does not exist.`);\n                        }\n                        phase.dependencies.self.add(dependency);\n                    }\n                }\n                if (upstreamDependencies) {\n                    for (const dependencyName of upstreamDependencies) {\n                        const dependency = this.phases.get(dependencyName);\n                        if (!dependency) {\n                            throw new Error(`In ${RushConstants.commandLineFilename}, in the phase \"${phase.name}\", ` +\n                                `the upstream dependency phase \"${dependencyName}\" does not exist.`);\n                        }\n                        phase.dependencies.upstream.add(dependency);\n                    }\n                }\n            }\n            // Do the recursive stuff after the dependencies have been converted\n            const safePhases = new Set();\n            const cycleDetector = new Set();\n            for (const phase of this.phases.values()) {\n                this._checkForPhaseSelfCycles(phase, cycleDetector, safePhases);\n            }\n        }\n        const commandsJson = commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.commands;\n        let buildCommandPhases;\n        let buildCommandOriginalPhases;\n        if (commandsJson) {\n            for (const command of commandsJson) {\n                if (this.commands.has(command.name)) {\n                    throw new Error(`In ${RushConstants.commandLineFilename}, the command \"${command.name}\" is specified ` +\n                        'more than once.');\n                }\n                let normalizedCommand;\n                switch (command.commandKind) {\n                    case RushConstants.phasedCommandKind: {\n                        const originalPhases = new Set();\n                        const commandPhases = new Set();\n                        const watchPhases = new Set();\n                        normalizedCommand = Object.assign(Object.assign({}, command), { isSynthetic: false, associatedParameters: new Set(), originalPhases, phases: commandPhases, watchPhases, alwaysWatch: false, alwaysInstall: undefined });\n                        for (const phaseName of command.phases) {\n                            const phase = this.phases.get(phaseName);\n                            if (!phase) {\n                                throw new Error(`In ${RushConstants.commandLineFilename}, in the \"phases\" property of the ` +\n                                    `\"${normalizedCommand.name}\" command, the phase \"${phaseName}\" does not exist.`);\n                            }\n                            originalPhases.add(phase);\n                            commandPhases.add(phase);\n                        }\n                        // Apply implicit phase dependency expansion\n                        // The equivalent of the \"--to\" operator used for projects\n                        // Appending to the set while iterating it accomplishes a full breadth-first search\n                        for (const phase of commandPhases) {\n                            for (const dependency of phase.dependencies.self) {\n                                commandPhases.add(dependency);\n                            }\n                            for (const dependency of phase.dependencies.upstream) {\n                                commandPhases.add(dependency);\n                            }\n                        }\n                        const { watchOptions, installOptions } = command;\n                        if (watchOptions) {\n                            normalizedCommand.alwaysWatch = watchOptions.alwaysWatch;\n                            normalizedCommand.watchDebounceMs = watchOptions.debounceMs;\n                            // No implicit phase dependency expansion for watch mode.\n                            for (const phaseName of watchOptions.watchPhases) {\n                                const phase = this.phases.get(phaseName);\n                                if (!phase) {\n                                    throw new Error(`In ${RushConstants.commandLineFilename}, in the \"watchPhases\" property of the ` +\n                                        `\"${normalizedCommand.name}\" command, the phase \"${phaseName}\" does not exist.`);\n                                }\n                                watchPhases.add(phase);\n                            }\n                        }\n                        if (installOptions) {\n                            normalizedCommand.alwaysInstall = installOptions.alwaysInstall;\n                        }\n                        break;\n                    }\n                    case RushConstants.globalCommandKind: {\n                        normalizedCommand = Object.assign(Object.assign({}, command), { associatedParameters: new Set() });\n                        break;\n                    }\n                    case RushConstants.bulkCommandKind: {\n                        // Translate the bulk command into a phased command\n                        normalizedCommand = this._translateBulkCommandToPhasedCommand(command);\n                        break;\n                    }\n                }\n                if (normalizedCommand.name === RushConstants.buildCommandName ||\n                    normalizedCommand.name === RushConstants.rebuildCommandName) {\n                    if (normalizedCommand.commandKind === RushConstants.globalCommandKind) {\n                        throw new Error(`${RushConstants.commandLineFilename} defines a command \"${normalizedCommand.name}\" using ` +\n                            `the command kind \"${RushConstants.globalCommandKind}\". This command can only be designated as a command ` +\n                            `kind \"${RushConstants.bulkCommandKind}\" or \"${RushConstants.phasedCommandKind}\".`);\n                    }\n                    else if (command.safeForSimultaneousRushProcesses) {\n                        throw new Error(`${RushConstants.commandLineFilename} defines a command \"${normalizedCommand.name}\" using ` +\n                            `\"safeForSimultaneousRushProcesses=true\". This configuration is not supported for \"${normalizedCommand.name}\".`);\n                    }\n                    else if (normalizedCommand.name === RushConstants.buildCommandName) {\n                        // Record the build command phases in case we need to construct a synthetic \"rebuild\" command\n                        buildCommandPhases = normalizedCommand.phases;\n                        buildCommandOriginalPhases = normalizedCommand.originalPhases;\n                    }\n                }\n                this.commands.set(normalizedCommand.name, normalizedCommand);\n            }\n        }\n        if (!options.doNotIncludeDefaultBuildCommands) {\n            let buildCommand = this.commands.get(RushConstants.buildCommandName);\n            if (!buildCommand) {\n                // If the build command was not specified in the config file, add the default build command\n                buildCommand = this._translateBulkCommandToPhasedCommand(DEFAULT_BUILD_COMMAND_JSON);\n                buildCommand.disableBuildCache = DEFAULT_BUILD_COMMAND_JSON.disableBuildCache;\n                buildCommandPhases = buildCommand.phases;\n                buildCommandOriginalPhases = buildCommand.originalPhases;\n                this.commands.set(buildCommand.name, buildCommand);\n            }\n            if (!this.commands.has(RushConstants.rebuildCommandName)) {\n                // If a rebuild command was not specified in the config file, add the default rebuild command\n                if (!buildCommandPhases || !buildCommandOriginalPhases) {\n                    throw new Error(`Phases for the \"${RushConstants.buildCommandName}\" were not found.`);\n                }\n                const rebuildCommand = Object.assign(Object.assign({}, DEFAULT_REBUILD_COMMAND_JSON), { commandKind: RushConstants.phasedCommandKind, isSynthetic: true, phases: buildCommandPhases, disableBuildCache: DEFAULT_REBUILD_COMMAND_JSON.disableBuildCache, associatedParameters: buildCommand.associatedParameters, originalPhases: buildCommandOriginalPhases, watchPhases: new Set(), alwaysWatch: false, alwaysInstall: undefined });\n                this.commands.set(rebuildCommand.name, rebuildCommand);\n            }\n        }\n        const parametersJson = commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.parameters;\n        if (parametersJson) {\n            for (const parameter of parametersJson) {\n                const normalizedParameter = Object.assign(Object.assign({}, parameter), { associatedPhases: parameter.associatedPhases ? [...parameter.associatedPhases] : [], associatedCommands: parameter.associatedCommands ? [...parameter.associatedCommands] : [] });\n                this.parameters.push(normalizedParameter);\n                // Do some basic validation\n                switch (normalizedParameter.parameterKind) {\n                    case 'choice': {\n                        const alternativeNames = normalizedParameter.alternatives.map((x) => x.name);\n                        if (normalizedParameter.defaultValue &&\n                            alternativeNames.indexOf(normalizedParameter.defaultValue) < 0) {\n                            throw new Error(`In ${RushConstants.commandLineFilename}, the parameter \"${normalizedParameter.longName}\",` +\n                                ` specifies a default value \"${normalizedParameter.defaultValue}\"` +\n                                ` which is not one of the defined alternatives: \"${alternativeNames.toString()}\"`);\n                        }\n                        break;\n                    }\n                }\n                let parameterHasAssociatedCommands = false;\n                if (normalizedParameter.associatedCommands) {\n                    for (const associatedCommandName of normalizedParameter.associatedCommands) {\n                        const syntheticPhase = this._syntheticPhasesByTranslatedBulkCommandName.get(associatedCommandName);\n                        if (syntheticPhase) {\n                            // If this parameter was associated with a bulk command, include the association\n                            // with the synthetic phase\n                            normalizedParameter.associatedPhases.push(syntheticPhase.name);\n                        }\n                        const associatedCommand = this.commands.get(associatedCommandName);\n                        if (!associatedCommand) {\n                            throw new Error(`${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                                `that is associated with a command \"${associatedCommandName}\" that does not exist or does ` +\n                                'not support custom parameters.');\n                        }\n                        else {\n                            associatedCommand.associatedParameters.add(normalizedParameter);\n                            parameterHasAssociatedCommands = true;\n                        }\n                    }\n                }\n                if (normalizedParameter.associatedPhases) {\n                    for (const associatedPhaseName of normalizedParameter.associatedPhases) {\n                        const associatedPhase = this.phases.get(associatedPhaseName);\n                        if (!associatedPhase) {\n                            throw new Error(`${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                                `that is associated with a phase \"${associatedPhaseName}\" that does not exist.`);\n                        }\n                    }\n                }\n                if (!parameterHasAssociatedCommands) {\n                    throw new Error(`${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\"` +\n                        ` that lists no associated commands.`);\n                }\n                // In the presence of plugins, there is utility to defining parameters that are associated with a phased\n                // command but no phases. Don't enforce that a parameter is associated with at least one phase.\n            }\n        }\n    }\n    /**\n     * Performs a depth-first search to detect cycles in the directed graph of phase \"self\" dependencies.\n     *\n     * @param phase The phase node currently being checked\n     * @param phasesInPath The current path from the start node to `phase`\n     * @param cycleFreePhases Phases that have already been fully walked and confirmed to not be in any cycles\n     */\n    _checkForPhaseSelfCycles(phase, phasesInPath, cycleFreePhases) {\n        if (cycleFreePhases.has(phase)) {\n            // phase is known to not be reachable from itself, i.e. not in a cycle. Skip.\n            return;\n        }\n        for (const dependency of phase.dependencies.self) {\n            if (phasesInPath.has(dependency)) {\n                throw new Error(`In ${RushConstants.commandLineFilename}, there exists a cycle within the ` +\n                    `set of ${dependency.name} dependencies: ${Array.from(phasesInPath, (phaseInPath) => phaseInPath.name).join(', ')}`);\n            }\n            else {\n                phasesInPath.add(dependency);\n                this._checkForPhaseSelfCycles(dependency, phasesInPath, cycleFreePhases);\n                phasesInPath.delete(dependency);\n            }\n        }\n        // phase is not reachable from itself, mark for skipping\n        cycleFreePhases.add(phase);\n    }\n    /**\n     * Load the command-line.json configuration file from the specified path. Note that this\n     * does not include the default build settings. This option is intended to be used to load\n     * command-line.json files from plugins. To load a common/config/rush/command-line.json file,\n     * use {@see loadFromFileOrDefault} instead.\n     *\n     * If the file does not exist, this function returns `undefined`\n     */\n    static tryLoadFromFile(jsonFilePath) {\n        let commandLineJson;\n        try {\n            commandLineJson = JsonFile.loadAndValidate(jsonFilePath, CommandLineConfiguration._jsonSchema);\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n        if (commandLineJson) {\n            return new CommandLineConfiguration(commandLineJson, { doNotIncludeDefaultBuildCommands: true });\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Loads the configuration from the specified file and applies any omitted default build\n     * settings.  If the file does not exist, then a default instance is returned.\n     * If the file contains errors, then an exception is thrown.\n     */\n    static loadFromFileOrDefault(jsonFilePath) {\n        let commandLineJson = undefined;\n        if (jsonFilePath) {\n            try {\n                commandLineJson = JsonFile.load(jsonFilePath);\n            }\n            catch (e) {\n                if (!FileSystem.isNotExistError(e)) {\n                    throw e;\n                }\n            }\n            // merge commands specified in command-line.json and default (re)build settings\n            // Ensure both build commands are included and preserve any other commands specified\n            if (commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.commands) {\n                for (let i = 0; i < commandLineJson.commands.length; i++) {\n                    const command = commandLineJson.commands[i];\n                    // Determine if we have a set of default parameters\n                    let commandDefaultDefinition = {};\n                    switch (command.commandKind) {\n                        case RushConstants.phasedCommandKind:\n                        case RushConstants.bulkCommandKind: {\n                            switch (command.name) {\n                                case RushConstants.buildCommandName: {\n                                    commandDefaultDefinition = DEFAULT_BUILD_COMMAND_JSON;\n                                    break;\n                                }\n                                case RushConstants.rebuildCommandName: {\n                                    commandDefaultDefinition = DEFAULT_REBUILD_COMMAND_JSON;\n                                    break;\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    // Merge the default parameters into the repo-specified parameters\n                    commandLineJson.commands[i] = Object.assign(Object.assign({}, commandDefaultDefinition), command);\n                }\n                CommandLineConfiguration._jsonSchema.validateObject(commandLineJson, jsonFilePath);\n            }\n        }\n        return new CommandLineConfiguration(commandLineJson, { doNotIncludeDefaultBuildCommands: false });\n    }\n    prependAdditionalPathFolder(pathFolder) {\n        this.additionalPathFolders.unshift(pathFolder);\n    }\n    _translateBulkCommandToPhasedCommand(command) {\n        const phaseName = command.name;\n        const phase = {\n            name: phaseName,\n            isSynthetic: true,\n            logFilenameIdentifier: _normalizeNameForLogFilenameIdentifiers(command.name),\n            associatedParameters: new Set(),\n            dependencies: {\n                self: new Set(),\n                upstream: new Set()\n            },\n            missingScriptBehavior: command.ignoreMissingScript ? 'log' : 'error',\n            allowWarningsOnSuccess: !!command.allowWarningsInSuccessfulBuild,\n            shellCommand: command.shellCommand\n        };\n        if (!command.ignoreDependencyOrder) {\n            phase.dependencies.upstream.add(phase);\n        }\n        this.phases.set(phaseName, phase);\n        this._syntheticPhasesByTranslatedBulkCommandName.set(command.name, phase);\n        const phases = new Set([phase]);\n        const translatedCommand = Object.assign(Object.assign({}, command), { commandKind: 'phased', isSynthetic: true, associatedParameters: new Set(), phases, originalPhases: phases, \n            // Bulk commands used the same phases for watch as for regular execution. Preserve behavior.\n            watchPhases: command.watchForChanges ? phases : new Set(), alwaysWatch: !!command.watchForChanges, alwaysInstall: undefined });\n        return translatedCommand;\n    }\n}\nCommandLineConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=CommandLineConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport crypto from 'crypto';\nimport * as path from 'path';\nimport { JsonFile, JsonSchema, MapExtensions, ProtectableMap, FileSystem, Sort } from '@rushstack/node-core-library';\nimport { PackageNameParsers } from './PackageNameParsers';\nimport { JsonSchemaUrls } from '../logic/JsonSchemaUrls';\nimport { RushConstants } from '../logic/RushConstants';\nimport schemaJson from '../schemas/common-versions.schema.json';\n/**\n * Use this class to load and save the \"common/config/rush/common-versions.json\" config file.\n * This config file stores dependency version information that affects all projects in the repo.\n * @public\n */\nexport class CommonVersionsConfiguration {\n    constructor(commonVersionsJson, filePath, rushConfiguration) {\n        var _a;\n        this._modified = false;\n        this._preferredVersions = new ProtectableMap({\n            onSet: this._onSetPreferredVersions.bind(this)\n        });\n        this.preferredVersions = this._preferredVersions.protectedView;\n        if (commonVersionsJson && commonVersionsJson.implicitlyPreferredVersions !== undefined) {\n            this.implicitlyPreferredVersions = commonVersionsJson.implicitlyPreferredVersions;\n        }\n        else {\n            this.implicitlyPreferredVersions = undefined;\n        }\n        this._allowedAlternativeVersions = new ProtectableMap({\n            onSet: this._onSetAllowedAlternativeVersions.bind(this)\n        });\n        this.allowedAlternativeVersions = this._allowedAlternativeVersions.protectedView;\n        const subspacesFeatureEnabled = rushConfiguration === null || rushConfiguration === void 0 ? void 0 : rushConfiguration.subspacesFeatureEnabled;\n        const rushJsonEnsureConsistentVersions = rushConfiguration === null || rushConfiguration === void 0 ? void 0 : rushConfiguration._ensureConsistentVersionsJsonValue;\n        const commonVersionsEnsureConsistentVersions = commonVersionsJson === null || commonVersionsJson === void 0 ? void 0 : commonVersionsJson.ensureConsistentVersions;\n        if (subspacesFeatureEnabled && rushJsonEnsureConsistentVersions !== undefined) {\n            throw new Error(`When using subspaces, the ensureConsistentVersions config is now defined in the ${RushConstants.commonVersionsFilename} file, ` +\n                `you must remove the old setting \"ensureConsistentVersions\" from ${RushConstants.rushJsonFilename}`);\n        }\n        else if (!subspacesFeatureEnabled &&\n            rushJsonEnsureConsistentVersions !== undefined &&\n            commonVersionsEnsureConsistentVersions !== undefined) {\n            throw new Error(`When the ensureConsistentVersions config is defined in the ${RushConstants.rushJsonFilename} file, ` +\n                `it cannot also be defined in the ${RushConstants.commonVersionsFilename} file`);\n        }\n        this.ensureConsistentVersions =\n            (_a = commonVersionsEnsureConsistentVersions !== null && commonVersionsEnsureConsistentVersions !== void 0 ? commonVersionsEnsureConsistentVersions : rushJsonEnsureConsistentVersions) !== null && _a !== void 0 ? _a : false;\n        if (commonVersionsJson) {\n            try {\n                CommonVersionsConfiguration._deserializeTable(this.preferredVersions, commonVersionsJson.preferredVersions);\n                CommonVersionsConfiguration._deserializeTable(this.allowedAlternativeVersions, commonVersionsJson.allowedAlternativeVersions);\n            }\n            catch (e) {\n                throw new Error(`Error loading \"${path.basename(filePath)}\": ${e.message}`);\n            }\n        }\n        this.filePath = filePath;\n    }\n    /**\n     * Loads the common-versions.json data from the specified file path.\n     * If the file has not been created yet, then an empty object is returned.\n     */\n    static loadFromFile(jsonFilePath, rushConfiguration) {\n        let commonVersionsJson = undefined;\n        if (FileSystem.exists(jsonFilePath)) {\n            commonVersionsJson = JsonFile.loadAndValidate(jsonFilePath, CommonVersionsConfiguration._jsonSchema);\n        }\n        return new CommonVersionsConfiguration(commonVersionsJson, jsonFilePath, rushConfiguration);\n    }\n    static _deserializeTable(map, object) {\n        if (object) {\n            for (const [key, value] of Object.entries(object)) {\n                map.set(key, value);\n            }\n        }\n    }\n    static _serializeTable(map) {\n        const table = {};\n        const keys = [...map.keys()];\n        keys.sort();\n        for (const key of keys) {\n            table[key] = map.get(key);\n        }\n        return table;\n    }\n    /**\n     * Get a sha1 hash of the preferred versions.\n     */\n    getPreferredVersionsHash() {\n        // Sort so that the hash is stable\n        const orderedPreferredVersions = new Map(this._preferredVersions.protectedView);\n        Sort.sortMapKeys(orderedPreferredVersions);\n        // JSON.stringify does not support maps, so we need to convert to an object first\n        const preferredVersionsObj = MapExtensions.toObject(orderedPreferredVersions);\n        return crypto.createHash('sha1').update(JSON.stringify(preferredVersionsObj)).digest('hex');\n    }\n    /**\n     * Writes the \"common-versions.json\" file to disk, using the filename that was passed to loadFromFile().\n     */\n    save() {\n        if (this._modified) {\n            JsonFile.save(this._serialize(), this.filePath, { updateExistingFile: true });\n            this._modified = false;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns preferredVersions.\n     */\n    getAllPreferredVersions() {\n        const allPreferredVersions = new Map();\n        MapExtensions.mergeFromMap(allPreferredVersions, this.preferredVersions);\n        return allPreferredVersions;\n    }\n    _onSetPreferredVersions(source, key, value) {\n        PackageNameParsers.permissive.validate(key);\n        this._modified = true;\n        return value;\n    }\n    _onSetAllowedAlternativeVersions(source, key, value) {\n        PackageNameParsers.permissive.validate(key);\n        this._modified = true;\n        return value;\n    }\n    _serialize() {\n        const result = {\n            $schema: JsonSchemaUrls.commonVersions\n        };\n        if (this._preferredVersions.size) {\n            result.preferredVersions = CommonVersionsConfiguration._serializeTable(this.preferredVersions);\n        }\n        if (this._allowedAlternativeVersions.size) {\n            result.allowedAlternativeVersions = CommonVersionsConfiguration._serializeTable(this.allowedAlternativeVersions);\n        }\n        return result;\n    }\n}\nCommonVersionsConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=CommonVersionsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport { PrintUtilities, Colorize } from '@rushstack/terminal';\nimport schemaJson from '../schemas/custom-tips.schema.json';\n/**\n * An identifier representing a Rush message that can be customized by\n * defining a custom tip in `common/config/rush/custom-tips.json`.\n * @remarks\n * Custom tip ids always start with the `TIP_` prefix.\n *\n * @privateRemarks\n * Events from the Rush process should with \"TIP_RUSH_\".\n * Events from a PNPM subprocess should start with \"TIP_PNPM_\".\n *\n * @beta\n */\nexport var CustomTipId;\n(function (CustomTipId) {\n    // Events from the Rush process should with \"TIP_RUSH_\".\n    CustomTipId[\"TIP_RUSH_INCONSISTENT_VERSIONS\"] = \"TIP_RUSH_INCONSISTENT_VERSIONS\";\n    CustomTipId[\"TIP_RUSH_DISALLOW_INSECURE_SHA1\"] = \"TIP_RUSH_DISALLOW_INSECURE_SHA1\";\n    // Events from a PNPM subprocess should start with \"TIP_PNPM_\".\n    CustomTipId[\"TIP_PNPM_UNEXPECTED_STORE\"] = \"TIP_PNPM_UNEXPECTED_STORE\";\n    CustomTipId[\"TIP_PNPM_NO_MATCHING_VERSION\"] = \"TIP_PNPM_NO_MATCHING_VERSION\";\n    CustomTipId[\"TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE\"] = \"TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE\";\n    CustomTipId[\"TIP_PNPM_PEER_DEP_ISSUES\"] = \"TIP_PNPM_PEER_DEP_ISSUES\";\n    CustomTipId[\"TIP_PNPM_OUTDATED_LOCKFILE\"] = \"TIP_PNPM_OUTDATED_LOCKFILE\";\n    CustomTipId[\"TIP_PNPM_TARBALL_INTEGRITY\"] = \"TIP_PNPM_TARBALL_INTEGRITY\";\n    CustomTipId[\"TIP_PNPM_MISMATCHED_RELEASE_CHANNEL\"] = \"TIP_PNPM_MISMATCHED_RELEASE_CHANNEL\";\n    CustomTipId[\"TIP_PNPM_INVALID_NODE_VERSION\"] = \"TIP_PNPM_INVALID_NODE_VERSION\";\n})(CustomTipId || (CustomTipId = {}));\n/**\n * The severity of a custom tip.\n * It determines the printing severity (\"Error\" = red, \"Warning\" = yellow, \"Info\" = normal).\n *\n * @beta\n */\nexport var CustomTipSeverity;\n(function (CustomTipSeverity) {\n    CustomTipSeverity[\"Warning\"] = \"Warning\";\n    CustomTipSeverity[\"Error\"] = \"Error\";\n    CustomTipSeverity[\"Info\"] = \"Info\";\n})(CustomTipSeverity || (CustomTipSeverity = {}));\n/**\n * The type of the custom tip.\n *\n * @remarks\n * There might be types like `git` in the future.\n *\n * @beta\n */\nexport var CustomTipType;\n(function (CustomTipType) {\n    CustomTipType[\"rush\"] = \"rush\";\n    CustomTipType[\"pnpm\"] = \"pnpm\";\n})(CustomTipType || (CustomTipType = {}));\nexport const RUSH_CUSTOM_TIPS = {\n    [CustomTipId.TIP_RUSH_DISALLOW_INSECURE_SHA1]: {\n        tipId: CustomTipId.TIP_RUSH_DISALLOW_INSECURE_SHA1,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            return str.includes('ERR_PNPM_DISALLOW_INSECURE_SHA1');\n        }\n    },\n    [CustomTipId.TIP_RUSH_INCONSISTENT_VERSIONS]: {\n        tipId: CustomTipId.TIP_RUSH_INCONSISTENT_VERSIONS,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.rush\n    }\n};\nexport const PNPM_CUSTOM_TIPS = {\n    [CustomTipId.TIP_PNPM_UNEXPECTED_STORE]: {\n        tipId: CustomTipId.TIP_PNPM_UNEXPECTED_STORE,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            return str.includes('ERR_PNPM_UNEXPECTED_STORE');\n        }\n    },\n    [CustomTipId.TIP_PNPM_NO_MATCHING_VERSION]: {\n        tipId: CustomTipId.TIP_PNPM_NO_MATCHING_VERSION,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            // Example message: (do notice the difference between this one and the TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE)\n            // Error Message: ERR_PNPM_NO_MATCHING_VERSION  No matching version found for @babel/types@^7.22.5\n            // The latest release of @babel/types is \"7.22.4\".\n            // Other releases are:\n            // * esm: 7.21.4-esm.4\n            return str.includes('No matching version found for') && str.includes('The latest release of');\n        }\n    },\n    [CustomTipId.TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE]: {\n        tipId: CustomTipId.TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            return str.includes('ERR_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE');\n        }\n    },\n    [CustomTipId.TIP_PNPM_PEER_DEP_ISSUES]: {\n        tipId: CustomTipId.TIP_PNPM_PEER_DEP_ISSUES,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            return str.includes('ERR_PNPM_PEER_DEP_ISSUES');\n        }\n    },\n    [CustomTipId.TIP_PNPM_OUTDATED_LOCKFILE]: {\n        tipId: CustomTipId.TIP_PNPM_OUTDATED_LOCKFILE,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            // Todo: verify this\n            return str.includes('ERR_PNPM_OUTDATED_LOCKFILE');\n        }\n    },\n    [CustomTipId.TIP_PNPM_TARBALL_INTEGRITY]: {\n        tipId: CustomTipId.TIP_PNPM_TARBALL_INTEGRITY,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            // Todo: verify this\n            return str.includes('ERR_PNPM_TARBALL_INTEGRITY');\n        }\n    },\n    [CustomTipId.TIP_PNPM_MISMATCHED_RELEASE_CHANNEL]: {\n        tipId: CustomTipId.TIP_PNPM_MISMATCHED_RELEASE_CHANNEL,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            // Todo: verify this\n            return str.includes('ERR_PNPM_MISMATCHED_RELEASE_CHANNEL');\n        }\n    },\n    [CustomTipId.TIP_PNPM_INVALID_NODE_VERSION]: {\n        tipId: CustomTipId.TIP_PNPM_INVALID_NODE_VERSION,\n        severity: CustomTipSeverity.Error,\n        type: CustomTipType.pnpm,\n        isMatch: (str) => {\n            // Todo: verify this\n            return str.includes('ERR_PNPM_INVALID_NODE_VERSION');\n        }\n    }\n};\n/**\n * Used to access the `common/config/rush/custom-tips.json` config file,\n * which allows repo maintainers to configure extra details to be printed alongside\n * certain Rush messages.\n * @beta\n */\nexport class CustomTipsConfiguration {\n    constructor(configFilePath) {\n        const providedCustomTips = new Map();\n        let configuration;\n        try {\n            configuration = JsonFile.loadAndValidate(configFilePath, CustomTipsConfiguration._jsonSchema);\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n        const customTips = configuration === null || configuration === void 0 ? void 0 : configuration.customTips;\n        if (customTips) {\n            for (const tipItem of customTips) {\n                if (!(tipItem.tipId in CustomTipId)) {\n                    throw new Error(`The ${path.basename(configFilePath)} configuration` +\n                        ` references an unknown ID \"${tipItem.tipId}\"`);\n                }\n                if (providedCustomTips.has(tipItem.tipId)) {\n                    throw new Error(`The ${path.basename(configFilePath)} configuration` +\n                        ` specifies a duplicate definition for \"${tipItem.tipId}\"`);\n                }\n                else {\n                    providedCustomTips.set(tipItem.tipId, tipItem);\n                }\n            }\n        }\n        this.providedCustomTipsByTipId = providedCustomTips;\n    }\n    /**\n     * If custom-tips.json defines a tip for the specified tipId,  display the tip on the terminal.\n     *\n     * @remarks\n     * The severity of the tip is defined in ${@link CustomTipsConfiguration.customTipRegistry}.\n     * If you want to change the severity specifically for this call,\n     * use other APIs such as {@link CustomTipsConfiguration._showErrorTip}.\n     *\n     * Custom tips by design do not replace Rush's standard messaging; instead, they annotate Rush's\n     * output with additional team-specific advice.\n     *\n     * @internal\n     */\n    _showTip(terminal, tipId) {\n        const severityOfOriginalMessage = CustomTipsConfiguration.customTipRegistry[tipId].severity;\n        this._writeMessageWithPipes(terminal, severityOfOriginalMessage, tipId);\n    }\n    /**\n     * If custom-tips.json defines a tip for the specified tipId, display the tip on the terminal.\n     * @remarks\n     * Custom tips by design do not replace Rush's standard messaging; instead, they annotate Rush's\n     * output with additional team-specific advice.\n     * @internal\n     */\n    _showInfoTip(terminal, tipId) {\n        this._writeMessageWithPipes(terminal, CustomTipSeverity.Info, tipId);\n    }\n    /**\n     * If custom-tips.json defines a tip for the specified tipId, display the tip on the terminal.\n     * @remarks\n     * Custom tips by design do not replace Rush's standard messaging; instead, they annotate Rush's\n     * output with additional team-specific advice.\n     * @internal\n     */\n    _showWarningTip(terminal, tipId) {\n        this._writeMessageWithPipes(terminal, CustomTipSeverity.Warning, tipId);\n    }\n    /**\n     * If custom-tips.json defines a tip for the specified tipId, display the tip on the terminal.\n     * @remarks\n     * Custom tips by design do not replace Rush's standard messaging; instead, they annotate Rush's\n     * output with additional team-specific advice.\n     * @internal\n     */\n    _showErrorTip(terminal, tipId) {\n        this._writeMessageWithPipes(terminal, CustomTipSeverity.Error, tipId);\n    }\n    _writeMessageWithPipes(terminal, severity, tipId) {\n        const customTipJsonItem = this.providedCustomTipsByTipId.get(tipId);\n        if (customTipJsonItem) {\n            let writeFunction;\n            let prefix;\n            switch (severity) {\n                case CustomTipSeverity.Error:\n                    writeFunction = terminal.writeErrorLine.bind(terminal);\n                    prefix = Colorize.red('| ');\n                    break;\n                case CustomTipSeverity.Warning:\n                    writeFunction = terminal.writeWarningLine.bind(terminal);\n                    prefix = Colorize.yellow('| ');\n                    break;\n                default:\n                    writeFunction = terminal.writeLine.bind(terminal);\n                    prefix = '| ';\n                    break;\n            }\n            writeFunction(`| Custom Tip (${tipId})`);\n            writeFunction('|');\n            const message = customTipJsonItem.message;\n            const wrappedAndIndentedMessage = PrintUtilities.wrapWords(message, undefined, prefix);\n            writeFunction(...wrappedAndIndentedMessage, { doNotOverrideSgrCodes: true });\n            terminal.writeLine();\n        }\n    }\n}\nCustomTipsConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n/**\n * A registry mapping custom tip IDs to their corresponding metadata.\n *\n * @remarks\n * This registry is used to look up metadata for custom tips based on their IDs. The metadata includes\n * information such as the severity level, the type of tip, and an optional matching function.\n *\n * Each key in the registry corresponds to a `CustomTipIdEnum` value, and each value is an object\n * implementing the `ICustomTipInfo` interface.\n *\n * @example\n * ```typescript\n * const tipInfo = CustomTipsConfiguration.customTipRegistry[CustomTipIdEnum.TIP_RUSH_INCONSISTENT_VERSIONS];\n * console.log(tipInfo.severity);  // Output: CustomTipSeverity.Error\n * ```\n *\n * See {@link CustomTipId} for the list of custom tip IDs.\n * See {@link ICustomTipInfo} for the structure of the metadata.\n */\nCustomTipsConfiguration.customTipRegistry = Object.assign(Object.assign({}, RUSH_CUSTOM_TIPS), PNPM_CUSTOM_TIPS);\n//# sourceMappingURL=CustomTipsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as os from 'os';\nimport * as path from 'path';\nimport { trueCasePathSync } from 'true-case-path';\n/**\n * Names of environment variables used by Rush.\n * @beta\n */\n// eslint-disable-next-line @typescript-eslint/typedef\nexport const EnvironmentVariableNames = {\n    /**\n     * This variable overrides the temporary folder used by Rush.\n     * The default value is \"common/temp\" under the repository root.\n     *\n     * @remarks This environment variable is not compatible with workspace installs. If attempting\n     * to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.\n     */\n    RUSH_TEMP_FOLDER: 'RUSH_TEMP_FOLDER',\n    /**\n     * This variable overrides the version of Rush that will be installed by\n     * the version selector.  The default value is determined by the \"rushVersion\"\n     * field from rush.json.\n     */\n    RUSH_PREVIEW_VERSION: 'RUSH_PREVIEW_VERSION',\n    /**\n     * If this variable is set to \"1\", Rush will not fail the build when running a version\n     * of Node that does not match the criteria specified in the \"nodeSupportedVersionRange\"\n     * field from rush.json.\n     */\n    RUSH_ALLOW_UNSUPPORTED_NODEJS: 'RUSH_ALLOW_UNSUPPORTED_NODEJS',\n    /**\n     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`\n     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,\n     * or `0` to disallow them. (See the comments in the command-line.json file for more information).\n     */\n    RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: 'RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD',\n    /**\n     * This variable selects a specific installation variant for Rush to use when installing\n     * and linking package dependencies.\n     * For more information, see the command-line help for the `--variant` parameter\n     * and this article:  https://rushjs.io/pages/advanced/installation_variants/\n     */\n    RUSH_VARIANT: 'RUSH_VARIANT',\n    /**\n     * Specifies the maximum number of concurrent processes to launch during a build.\n     * For more information, see the command-line help for the `--parallelism` parameter for \"rush build\".\n     */\n    RUSH_PARALLELISM: 'RUSH_PARALLELISM',\n    /**\n     * If this variable is set to \"1\", Rush will create symlinks with absolute paths instead\n     * of relative paths. This can be necessary when a repository is moved during a build or\n     * if parts of a repository are moved into a sandbox.\n     */\n    RUSH_ABSOLUTE_SYMLINKS: 'RUSH_ABSOLUTE_SYMLINKS',\n    /**\n     * When using PNPM as the package manager, this variable can be used to configure the path that\n     * PNPM will use as the store directory.\n     *\n     * If a relative path is used, then the store path will be resolved relative to the process's\n     * current working directory.  An absolute path is recommended.\n     */\n    RUSH_PNPM_STORE_PATH: 'RUSH_PNPM_STORE_PATH',\n    /**\n     * When using PNPM as the package manager, this variable can be used to control whether or not PNPM\n     * validates the integrity of the PNPM store during installation. The value of this environment variable must be\n     * `1` (for true) or `0` (for false). If not specified, defaults to the value in .npmrc.\n     */\n    RUSH_PNPM_VERIFY_STORE_INTEGRITY: 'RUSH_PNPM_VERIFY_STORE_INTEGRITY',\n    /**\n     * This environment variable can be used to specify the `--target-folder` parameter\n     * for the \"rush deploy\" command.\n     */\n    RUSH_DEPLOY_TARGET_FOLDER: 'RUSH_DEPLOY_TARGET_FOLDER',\n    /**\n     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.\n     *\n     * @remarks\n     *\n     * Most of the temporary files created by Rush are stored separately for each monorepo working folder,\n     * to avoid issues of concurrency and compatibility between tool versions.  However, a small set\n     * of files (e.g. installations of the `@microsoft/rush-lib` engine and the package manager) are stored\n     * in a global folder to speed up installations.  The default location is `~/.rush` on POSIX-like\n     * operating systems or `C:\\Users\\YourName` on Windows.\n     *\n     * Use `RUSH_GLOBAL_FOLDER` to specify a different folder path.  This is useful for example if a Windows\n     * group policy forbids executing scripts installed in a user's home directory.\n     *\n     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\n     */\n    RUSH_GLOBAL_FOLDER: 'RUSH_GLOBAL_FOLDER',\n    /**\n     * Provides a credential for a remote build cache, if configured.  This credential overrides any cached credentials.\n     *\n     * @remarks\n     * Setting this environment variable overrides whatever credential has been saved in the\n     * local cloud cache credentials using `rush update-cloud-credentials`.\n     *\n     *\n     * If Azure Blob Storage is used to store cache entries, this must be a SAS token serialized as query\n     * parameters.\n     *\n     * For information on SAS tokens, see here: https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview\n     */\n    RUSH_BUILD_CACHE_CREDENTIAL: 'RUSH_BUILD_CACHE_CREDENTIAL',\n    /**\n     * Setting this environment variable overrides the value of `buildCacheEnabled` in the `build-cache.json`\n     * configuration file.\n     *\n     * @remarks\n     * Specify `1` to enable the build cache or `0` to disable it.\n     *\n     * If there is no build cache configured, then this environment variable is ignored.\n     */\n    RUSH_BUILD_CACHE_ENABLED: 'RUSH_BUILD_CACHE_ENABLED',\n    /**\n     * Overrides the value of `isCacheWriteAllowed` in the `build-cache.json` configuration file. The value of this\n     * environment variable must be `1` (for true) or `0` (for false). If there is no build cache configured, then\n     * this environment variable is ignored.\n     */\n    RUSH_BUILD_CACHE_WRITE_ALLOWED: 'RUSH_BUILD_CACHE_WRITE_ALLOWED',\n    /**\n     * Setting this environment variable opts into running with cobuilds. The context id should be the same across\n     * multiple VMs, but changed when it is a new round of cobuilds.\n     *\n     * e.g. `Build.BuildNumber` in Azure DevOps Pipeline.\n     *\n     * @remarks\n     * If there is no cobuild configured, then this environment variable is ignored.\n     */\n    RUSH_COBUILD_CONTEXT_ID: 'RUSH_COBUILD_CONTEXT_ID',\n    /**\n     * Explicitly specifies a name for each participating cobuild runner.\n     *\n     * Setting this environment variable opts into running with cobuilds.\n     *\n     * @remarks\n     * This environment variable is optional, if it is not provided, a random id is used.\n     *\n     * If there is no cobuild configured, then this environment variable is ignored.\n     */\n    RUSH_COBUILD_RUNNER_ID: 'RUSH_COBUILD_RUNNER_ID',\n    /**\n     * If this variable is set to \"1\", When getting distributed builds, Rush will automatically handle the leaf project\n     * with build cache \"disabled\" by writing to the cache in a special \"log files only mode\". This is useful when you\n     * want to use Cobuilds to improve the performance in CI validations and the leaf projects have not enabled cache.\n     */\n    RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: 'RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED',\n    /**\n     * Explicitly specifies the path for the Git binary that is invoked by certain Rush operations.\n     */\n    RUSH_GIT_BINARY_PATH: 'RUSH_GIT_BINARY_PATH',\n    /**\n     * Explicitly specifies the path for the `tar` binary that is invoked by certain Rush operations.\n     */\n    RUSH_TAR_BINARY_PATH: 'RUSH_TAR_BINARY_PATH',\n    /**\n     * Internal variable used by `rushx` when recursively invoking another `rushx` process, to avoid\n     * nesting event hooks.\n     */\n    _RUSH_RECURSIVE_RUSHX_CALL: '_RUSH_RECURSIVE_RUSHX_CALL',\n    /**\n     * Internal variable that explicitly specifies the path for the version of `@microsoft/rush-lib` being executed.\n     * Will be set upon loading Rush.\n     */\n    _RUSH_LIB_PATH: '_RUSH_LIB_PATH',\n    /**\n     * When Rush executes shell scripts, it sometimes changes the working directory to be a project folder or\n     * the repository root folder.  The original working directory (where the Rush command was invoked) is assigned\n     * to the the child process's `RUSH_INVOKED_FOLDER` environment variable, in case it is needed by the script.\n     *\n     * @remarks\n     * The `RUSH_INVOKED_FOLDER` variable is the same idea as the `INIT_CWD` variable that package managers\n     * assign when they execute lifecycle scripts.\n     */\n    RUSH_INVOKED_FOLDER: 'RUSH_INVOKED_FOLDER',\n    /**\n     * When running a hook script, this environment variable communicates the original arguments\n     * passed to the `rush` or `rushx` command.\n     *\n     * @remarks\n     * Unlike `RUSH_INVOKED_FOLDER`, the `RUSH_INVOKED_ARGS` variable is only available for hook scripts.\n     * Other lifecycle scripts should not make assumptions about Rush's command line syntax\n     * if Rush did not explicitly pass along command-line parameters to their process.\n     */\n    RUSH_INVOKED_ARGS: 'RUSH_INVOKED_ARGS'\n};\n/**\n * Provides Rush-specific environment variable data. All Rush environment variables must start with \"RUSH_\". This class\n * is designed to be used by RushConfiguration.\n * @beta\n *\n * @remarks\n * Initialize will throw if any unknown parameters are present.\n */\nexport class EnvironmentConfiguration {\n    /**\n     * An override for the common/temp folder path.\n     */\n    static get rushTempFolderOverride() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._rushTempFolderOverride;\n    }\n    /**\n     * If \"1\", create symlinks with absolute paths instead of relative paths.\n     * See {@link EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS}\n     */\n    static get absoluteSymlinks() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._absoluteSymlinks;\n    }\n    /**\n     * If this environment variable is set to \"1\", the Node.js version check will print a warning\n     * instead of causing a hard error if the environment's Node.js version doesn't match the\n     * version specifier in `rush.json`'s \"nodeSupportedVersionRange\" property.\n     *\n     * See {@link EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS}.\n     */\n    static get allowUnsupportedNodeVersion() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._allowUnsupportedNodeVersion;\n    }\n    /**\n     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`\n     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,\n     * or `0` to disallow them. (See the comments in the command-line.json file for more information).\n     */\n    static get allowWarningsInSuccessfulBuild() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._allowWarningsInSuccessfulBuild;\n    }\n    /**\n     * An override for the PNPM store path, if `pnpmStore` configuration is set to 'path'\n     * See {@link EnvironmentVariableNames.RUSH_PNPM_STORE_PATH}\n     */\n    static get pnpmStorePathOverride() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._pnpmStorePathOverride;\n    }\n    /**\n     * If specified, enables or disables integrity verification of the pnpm store during install.\n     * See {@link EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY}\n     */\n    static get pnpmVerifyStoreIntegrity() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._pnpmVerifyStoreIntegrity;\n    }\n    /**\n     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.\n     * See {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER}\n     */\n    static get rushGlobalFolderOverride() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._rushGlobalFolderOverride;\n    }\n    /**\n     * Provides a credential for reading from and writing to a remote build cache, if configured.\n     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL}\n     */\n    static get buildCacheCredential() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._buildCacheCredential;\n    }\n    /**\n     * If set, enables or disables the cloud build cache feature.\n     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED}\n     */\n    static get buildCacheEnabled() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._buildCacheEnabled;\n    }\n    /**\n     * If set, enables or disables writing to the cloud build cache.\n     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED}\n     */\n    static get buildCacheWriteAllowed() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._buildCacheWriteAllowed;\n    }\n    /**\n     * Provides a determined cobuild context id if configured\n     * See {@link EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID}\n     */\n    static get cobuildContextId() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._cobuildContextId;\n    }\n    /**\n     * Provides a determined cobuild runner id if configured\n     * See {@link EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID}\n     */\n    static get cobuildRunnerId() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._cobuildRunnerId;\n    }\n    /**\n     * If set, enables or disables the cobuild leaf project log only feature.\n     * See {@link EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED}\n     */\n    static get cobuildLeafProjectLogOnlyAllowed() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._cobuildLeafProjectLogOnlyAllowed;\n    }\n    /**\n     * Allows the git binary path to be explicitly provided.\n     * See {@link EnvironmentVariableNames.RUSH_GIT_BINARY_PATH}\n     */\n    static get gitBinaryPath() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._gitBinaryPath;\n    }\n    /**\n     * Allows the tar binary path to be explicitly provided.\n     * See {@link EnvironmentVariableNames.RUSH_TAR_BINARY_PATH}\n     */\n    static get tarBinaryPath() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._tarBinaryPath;\n    }\n    /**\n     * The front-end RushVersionSelector relies on `RUSH_GLOBAL_FOLDER`, so its value must be read before\n     * `EnvironmentConfiguration` is initialized (and actually before the correct version of `EnvironmentConfiguration`\n     * is even installed). Thus we need to read this environment variable differently from all the others.\n     * @internal\n     */\n    static _getRushGlobalFolderOverride(processEnv) {\n        const value = processEnv[EnvironmentVariableNames.RUSH_GLOBAL_FOLDER];\n        if (value) {\n            const normalizedValue = EnvironmentConfiguration._normalizeDeepestParentFolderPath(value);\n            return normalizedValue;\n        }\n    }\n    /**\n     * Reads and validates environment variables. If any are invalid, this function will throw.\n     */\n    static validate(options = {}) {\n        var _a, _b, _c;\n        EnvironmentConfiguration.reset();\n        const unknownEnvVariables = [];\n        for (const envVarName in process.env) {\n            if (process.env.hasOwnProperty(envVarName) && envVarName.match(/^RUSH_/i)) {\n                const value = process.env[envVarName];\n                // Environment variables are only case-insensitive on Windows\n                const normalizedEnvVarName = os.platform() === 'win32' ? envVarName.toUpperCase() : envVarName;\n                switch (normalizedEnvVarName) {\n                    case EnvironmentVariableNames.RUSH_TEMP_FOLDER: {\n                        EnvironmentConfiguration._rushTempFolderOverride =\n                            value && !options.doNotNormalizePaths\n                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value\n                                : value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS: {\n                        EnvironmentConfiguration._absoluteSymlinks =\n                            (_a = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS, value)) !== null && _a !== void 0 ? _a : false;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS: {\n                        if (value === 'true' || value === 'false') {\n                            // Small, undocumented acceptance of old \"true\" and \"false\" values for\n                            // users of RUSH_ALLOW_UNSUPPORTED_NODEJS in rush pre-v5.46.\n                            EnvironmentConfiguration._allowUnsupportedNodeVersion = value === 'true';\n                        }\n                        else {\n                            EnvironmentConfiguration._allowUnsupportedNodeVersion =\n                                (_b = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS, value)) !== null && _b !== void 0 ? _b : false;\n                        }\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: {\n                        EnvironmentConfiguration._allowWarningsInSuccessfulBuild =\n                            (_c = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD, value)) !== null && _c !== void 0 ? _c : false;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_PNPM_STORE_PATH: {\n                        EnvironmentConfiguration._pnpmStorePathOverride =\n                            value && !options.doNotNormalizePaths\n                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value\n                                : value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY: {\n                        EnvironmentConfiguration._pnpmVerifyStoreIntegrity =\n                            value === '1' ? true : value === '0' ? false : undefined;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_GLOBAL_FOLDER: {\n                        // Handled specially below\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL: {\n                        EnvironmentConfiguration._buildCacheCredential = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED: {\n                        EnvironmentConfiguration._buildCacheEnabled =\n                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED, value);\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED: {\n                        EnvironmentConfiguration._buildCacheWriteAllowed =\n                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED, value);\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID: {\n                        EnvironmentConfiguration._cobuildContextId = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID: {\n                        EnvironmentConfiguration._cobuildRunnerId = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: {\n                        EnvironmentConfiguration._cobuildLeafProjectLogOnlyAllowed =\n                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED, value);\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_GIT_BINARY_PATH: {\n                        EnvironmentConfiguration._gitBinaryPath = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_TAR_BINARY_PATH: {\n                        EnvironmentConfiguration._tarBinaryPath = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_PARALLELISM:\n                    case EnvironmentVariableNames.RUSH_PREVIEW_VERSION:\n                    case EnvironmentVariableNames.RUSH_VARIANT:\n                    case EnvironmentVariableNames.RUSH_DEPLOY_TARGET_FOLDER:\n                        // Handled by @microsoft/rush front end\n                        break;\n                    case EnvironmentVariableNames.RUSH_INVOKED_FOLDER:\n                    case EnvironmentVariableNames.RUSH_INVOKED_ARGS:\n                    case EnvironmentVariableNames._RUSH_LIB_PATH:\n                        // Assigned by Rush itself\n                        break;\n                    case EnvironmentVariableNames._RUSH_RECURSIVE_RUSHX_CALL:\n                        // Assigned/read internally by RushXCommandLine\n                        break;\n                    default:\n                        unknownEnvVariables.push(envVarName);\n                        break;\n                }\n            }\n        }\n        // This strictness intends to catch mistakes where variables are misspelled or not used correctly.\n        if (unknownEnvVariables.length > 0) {\n            throw new Error('The following environment variables were found with the \"RUSH_\" prefix, but they are not ' +\n                `recognized by this version of Rush: ${unknownEnvVariables.join(', ')}`);\n        }\n        // See doc comment for EnvironmentConfiguration._getRushGlobalFolderOverride().\n        EnvironmentConfiguration._rushGlobalFolderOverride =\n            EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);\n        EnvironmentConfiguration._hasBeenValidated = true;\n    }\n    /**\n     * Resets EnvironmentConfiguration into an un-initialized state.\n     */\n    static reset() {\n        EnvironmentConfiguration._rushTempFolderOverride = undefined;\n        EnvironmentConfiguration._hasBeenValidated = false;\n    }\n    static _ensureValidated() {\n        if (!EnvironmentConfiguration._hasBeenValidated) {\n            EnvironmentConfiguration.validate();\n        }\n    }\n    static parseBooleanEnvironmentVariable(name, value) {\n        if (value === '' || value === undefined) {\n            return undefined;\n        }\n        else if (value === '0') {\n            return false;\n        }\n        else if (value === '1') {\n            return true;\n        }\n        else {\n            throw new Error(`Invalid value \"${value}\" for the environment variable ${name}. Valid choices are 0 or 1.`);\n        }\n    }\n    /**\n     * Given a path to a folder (that may or may not exist), normalize the path, including casing,\n     * to the first existing parent folder in the path.\n     *\n     * If no existing path can be found (for example, if the root is a volume that doesn't exist),\n     * this function returns undefined.\n     *\n     * @example\n     * If the following path exists on disk: `C:\\Folder1\\folder2\\`\n     * _normalizeFirstExistingFolderPath('c:\\\\folder1\\\\folder2\\\\temp\\\\subfolder')\n     * returns 'C:\\\\Folder1\\\\folder2\\\\temp\\\\subfolder'\n     */\n    static _normalizeDeepestParentFolderPath(folderPath) {\n        folderPath = path.normalize(folderPath);\n        const endsWithSlash = folderPath.charAt(folderPath.length - 1) === path.sep;\n        const parsedPath = path.parse(folderPath);\n        const pathRoot = parsedPath.root;\n        const pathWithoutRoot = parsedPath.dir.substr(pathRoot.length);\n        const pathParts = [...pathWithoutRoot.split(path.sep), parsedPath.name].filter((part) => !!part);\n        // Starting with all path sections, and eliminating one from the end during each loop iteration,\n        // run trueCasePathSync. If trueCasePathSync returns without exception, we've found a subset\n        // of the path that exists and we've now gotten the correct casing.\n        //\n        // Once we've found a parent folder that exists, append the path sections that didn't exist.\n        for (let i = pathParts.length; i >= 0; i--) {\n            const constructedPath = path.join(pathRoot, ...pathParts.slice(0, i));\n            try {\n                const normalizedConstructedPath = trueCasePathSync(constructedPath);\n                const result = path.join(normalizedConstructedPath, ...pathParts.slice(i));\n                if (endsWithSlash) {\n                    return `${result}${path.sep}`;\n                }\n                else {\n                    return result;\n                }\n            }\n            catch (e) {\n                // This path doesn't exist, continue to the next subpath\n            }\n        }\n        return undefined;\n    }\n}\nEnvironmentConfiguration._hasBeenValidated = false;\nEnvironmentConfiguration._absoluteSymlinks = false;\nEnvironmentConfiguration._allowUnsupportedNodeVersion = false;\nEnvironmentConfiguration._allowWarningsInSuccessfulBuild = false;\n//# sourceMappingURL=EnvironmentConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Enum } from '@rushstack/node-core-library';\n/**\n * Events happen during Rush runs.\n * @beta\n */\nexport var Event;\n(function (Event) {\n    /**\n     * Pre Rush install event\n     */\n    Event[Event[\"preRushInstall\"] = 1] = \"preRushInstall\";\n    /**\n     * Post Rush install event\n     */\n    Event[Event[\"postRushInstall\"] = 2] = \"postRushInstall\";\n    /**\n     * Pre Rush build event\n     */\n    Event[Event[\"preRushBuild\"] = 3] = \"preRushBuild\";\n    /**\n     * Post Rush build event\n     */\n    Event[Event[\"postRushBuild\"] = 4] = \"postRushBuild\";\n    /**\n     * Start of rushx execution event\n     */\n    Event[Event[\"preRushx\"] = 5] = \"preRushx\";\n    /**\n     * End of rushx execution event\n     */\n    Event[Event[\"postRushx\"] = 6] = \"postRushx\";\n})(Event || (Event = {}));\n/**\n * This class represents Rush event hooks configured for this repo.\n * Hooks are customized script actions that Rush executes when specific events occur.\n * The actions are expressed as a command-line that is executed using the operating system shell.\n * @beta\n */\nexport class EventHooks {\n    /**\n     * @internal\n     */\n    constructor(eventHooksJson) {\n        this._hooks = new Map();\n        for (const [name, eventHooks] of Object.entries(eventHooksJson)) {\n            const eventName = Enum.tryGetValueByKey(Event, name);\n            if (eventName) {\n                this._hooks.set(eventName, [...eventHooks] || []);\n            }\n        }\n    }\n    /**\n     * Return all the scripts associated with the specified event.\n     * @param event - Rush event\n     */\n    get(event) {\n        return this._hooks.get(event) || [];\n    }\n}\n//# sourceMappingURL=EventHooks.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, JsonSchema, FileSystem } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport schemaJson from '../schemas/experiments.schema.json';\nconst GRADUATED_EXPERIMENTS = new Set(['phasedCommands']);\nconst _EXPERIMENTS_JSON_SCHEMA = JsonSchema.fromLoadedObject(schemaJson);\n/**\n * Use this class to load the \"common/config/rush/experiments.json\" config file.\n * This file allows repo maintainers to enable and disable experimental Rush features.\n * @public\n */\nexport class ExperimentsConfiguration {\n    /**\n     * @internal\n     */\n    constructor(jsonFilePath) {\n        try {\n            this.configuration = JsonFile.loadAndValidate(jsonFilePath, _EXPERIMENTS_JSON_SCHEMA);\n        }\n        catch (e) {\n            if (FileSystem.isNotExistError(e)) {\n                this.configuration = {};\n            }\n            else {\n                throw e;\n            }\n        }\n        for (const experimentName of Object.getOwnPropertyNames(this.configuration)) {\n            if (GRADUATED_EXPERIMENTS.has(experimentName)) {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.yellow(`The experiment \"${experimentName}\" has graduated to a standard feature. Remove this experiment from ` +\n                    `\"${jsonFilePath}\".`));\n            }\n        }\n    }\n}\n//# sourceMappingURL=ExperimentsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile } from '@rushstack/node-core-library';\nimport { objectsAreDeepEqual } from '../utilities/objectUtilities';\n/**\n * A base class for flag file.\n * @internal\n */\nexport class FlagFile {\n    /**\n     * Creates a new flag file\n     * @param folderPath - the folder that this flag is managing\n     * @param state - optional, the state that should be managed or compared\n     */\n    constructor(folderPath, flagName, initialState) {\n        this.path = `${folderPath}/${flagName}.flag`;\n        this._state = initialState;\n    }\n    /**\n     * Returns true if the file exists and the contents match the current state.\n     */\n    async isValidAsync() {\n        let oldState;\n        try {\n            oldState = await JsonFile.loadAsync(this.path);\n            const newState = this._state;\n            return objectsAreDeepEqual(oldState, newState);\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    /**\n     * Writes the flag file to disk with the current state\n     */\n    async createAsync() {\n        await JsonFile.saveAsync(this._state, this.path, {\n            ensureFolderExists: true\n        });\n    }\n    /**\n     * Removes the flag file\n     */\n    async clearAsync() {\n        await FileSystem.deleteFileAsync(this.path);\n    }\n}\n//# sourceMappingURL=FlagFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, Path } from '@rushstack/node-core-library';\nimport { pnpmSyncGetJsonVersion } from 'pnpm-sync-lib';\nimport * as objectUtilities from '../utilities/objectUtilities';\nimport { Selection } from '../logic/Selection';\nimport { FlagFile } from './FlagFile';\nconst LAST_INSTALL_FLAG_FILE_NAME = 'last-install';\n/**\n * A helper class for managing last-install flags, which are persistent and\n * indicate that something installed in the folder was successfully completed.\n * It also compares state, so that if something like the Node.js version has changed,\n * it can invalidate the last install.\n */\nexport class LastInstallFlag extends FlagFile {\n    /**\n     * Creates a new LastInstall flag\n     * @param folderPath - the folder that this flag is managing\n     * @param state - optional, the state that should be managed or compared\n     */\n    constructor(folderPath, state) {\n        super(folderPath, LAST_INSTALL_FLAG_FILE_NAME, state || {});\n    }\n    /**\n     * Returns true if the file exists and the contents match the current state.\n     */\n    async isValidAsync() {\n        return await this._isValidAsync(false, {});\n    }\n    /**\n     * Same as isValid(), but with an additional check:  If the current state is not equal to the previous\n     * state, and an the current state causes an error, then throw an exception with a friendly message.\n     *\n     * @internal\n     */\n    async checkValidAndReportStoreIssuesAsync(options) {\n        return this._isValidAsync(true, options);\n    }\n    async _isValidAsync(checkValidAndReportStoreIssues, { rushVerb = 'update', statePropertiesToIgnore } = {}) {\n        let oldState;\n        try {\n            oldState = await JsonFile.loadAsync(this.path);\n        }\n        catch (err) {\n            return false;\n        }\n        const newState = Object.assign({}, this._state);\n        if (statePropertiesToIgnore) {\n            for (const optionToIgnore of statePropertiesToIgnore) {\n                delete newState[optionToIgnore];\n                delete oldState[optionToIgnore];\n            }\n        }\n        if (!objectUtilities.objectsAreDeepEqual(oldState, newState)) {\n            if (checkValidAndReportStoreIssues) {\n                const pkgManager = newState.packageManager;\n                if (pkgManager === 'pnpm') {\n                    if (\n                    // Only throw an error if the package manager hasn't changed from PNPM\n                    oldState.packageManager === pkgManager) {\n                        const normalizedOldStorePath = oldState.storePath\n                            ? Path.convertToPlatformDefault(oldState.storePath)\n                            : '<global>';\n                        const normalizedNewStorePath = newState.storePath\n                            ? Path.convertToPlatformDefault(newState.storePath)\n                            : '<global>';\n                        if (\n                        // Throw if the store path changed\n                        normalizedOldStorePath !== normalizedNewStorePath) {\n                            throw new Error('Current PNPM store path does not match the last one used. This may cause inconsistency in your builds.\\n\\n' +\n                                `If you wish to install with the new store path, please run \"rush ${rushVerb} --purge\"\\n\\n` +\n                                `Old Path: ${normalizedOldStorePath}\\n` +\n                                `New Path: ${normalizedNewStorePath}`);\n                        }\n                    }\n                    // check whether new selected projects are installed\n                    if (newState.selectedProjectNames) {\n                        if (!oldState.selectedProjectNames) {\n                            // used to be a full install\n                            return true;\n                        }\n                        else if (Selection.union(newState.selectedProjectNames, oldState.selectedProjectNames).size ===\n                            oldState.selectedProjectNames.length) {\n                            // current selected projects are included in old selected projects\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Merge new data into current state by \"merge\"\n     */\n    mergeFromObject(data) {\n        if (objectUtilities.isMatch(this._state, data)) {\n            return;\n        }\n        objectUtilities.merge(this._state, data);\n    }\n}\n/**\n * Gets the LastInstall flag and sets the current state. This state is used to compare\n * against the last-known-good state tracked by the LastInstall flag.\n * @param rushConfiguration - the configuration of the Rush repo to get the install\n * state from\n *\n * @internal\n */\nexport function getCommonTempFlag(rushConfiguration, subspace, extraState = {}) {\n    const currentState = Object.assign({ node: process.versions.node, packageManager: rushConfiguration.packageManager, packageManagerVersion: rushConfiguration.packageManagerToolVersion, rushJsonFolder: rushConfiguration.rushJsonFolder, ignoreScripts: false, pnpmSync: pnpmSyncGetJsonVersion() }, extraState);\n    if (currentState.packageManager === 'pnpm' && rushConfiguration.pnpmOptions) {\n        currentState.storePath = rushConfiguration.pnpmOptions.pnpmStorePath;\n        if (rushConfiguration.pnpmOptions.useWorkspaces) {\n            currentState.workspaces = rushConfiguration.pnpmOptions.useWorkspaces;\n        }\n    }\n    return new LastInstallFlag(subspace.getSubspaceTempFolderPath(), currentState);\n}\n//# sourceMappingURL=LastInstallFlag.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { InternalError, JsonFile, Sort, JsonSyntax } from '@rushstack/node-core-library';\nimport { cloneDeep } from '../utilities/objectUtilities';\n/**\n * @public\n */\nexport var DependencyType;\n(function (DependencyType) {\n    DependencyType[\"Regular\"] = \"dependencies\";\n    DependencyType[\"Dev\"] = \"devDependencies\";\n    DependencyType[\"Optional\"] = \"optionalDependencies\";\n    DependencyType[\"Peer\"] = \"peerDependencies\";\n    DependencyType[\"YarnResolutions\"] = \"resolutions\";\n})(DependencyType || (DependencyType = {}));\n/**\n * @public\n */\nexport class PackageJsonDependency {\n    constructor(name, version, type, onChange) {\n        this.name = name;\n        this._version = version;\n        this.dependencyType = type;\n        this._onChange = onChange;\n    }\n    get version() {\n        return this._version;\n    }\n    setVersion(newVersion) {\n        if (!semver.valid(newVersion) && !semver.validRange(newVersion)) {\n            throw new Error(`Cannot set version to invalid value: \"${newVersion}\"`);\n        }\n        this._version = newVersion;\n        this._onChange();\n    }\n}\n/**\n * @public\n */\nexport class PackageJsonDependencyMeta {\n    constructor(name, injected, onChange) {\n        this.name = name;\n        this._injected = injected;\n        this._onChange = onChange;\n    }\n    get injected() {\n        return this._injected;\n    }\n}\n/**\n * @public\n */\nexport class PackageJsonEditor {\n    /**\n     * @internal\n     */\n    constructor(filepath, data) {\n        this.filePath = filepath;\n        this._sourceData = data;\n        this._modified = false;\n        this._dependencies = new Map();\n        this._devDependencies = new Map();\n        this._resolutions = new Map();\n        this._dependenciesMeta = new Map();\n        const dependencies = data.dependencies || {};\n        const optionalDependencies = data.optionalDependencies || {};\n        const peerDependencies = data.peerDependencies || {};\n        const devDependencies = data.devDependencies || {};\n        const resolutions = data.resolutions || {};\n        const dependenciesMeta = data.dependenciesMeta || {};\n        const _onChange = this._onChange.bind(this);\n        try {\n            Object.keys(dependencies || {}).forEach((packageName) => {\n                if (Object.prototype.hasOwnProperty.call(optionalDependencies, packageName)) {\n                    throw new Error(`The package \"${packageName}\" cannot be listed in both ` +\n                        `\"dependencies\" and \"optionalDependencies\"`);\n                }\n                if (Object.prototype.hasOwnProperty.call(peerDependencies, packageName)) {\n                    throw new Error(`The package \"${packageName}\" cannot be listed in both \"dependencies\" and \"peerDependencies\"`);\n                }\n                this._dependencies.set(packageName, new PackageJsonDependency(packageName, dependencies[packageName], DependencyType.Regular, _onChange));\n            });\n            Object.keys(optionalDependencies || {}).forEach((packageName) => {\n                if (Object.prototype.hasOwnProperty.call(peerDependencies, packageName)) {\n                    throw new Error(`The package \"${packageName}\" cannot be listed in both ` +\n                        `\"optionalDependencies\" and \"peerDependencies\"`);\n                }\n                this._dependencies.set(packageName, new PackageJsonDependency(packageName, optionalDependencies[packageName], DependencyType.Optional, _onChange));\n            });\n            Object.keys(peerDependencies || {}).forEach((packageName) => {\n                this._dependencies.set(packageName, new PackageJsonDependency(packageName, peerDependencies[packageName], DependencyType.Peer, _onChange));\n            });\n            Object.keys(devDependencies || {}).forEach((packageName) => {\n                this._devDependencies.set(packageName, new PackageJsonDependency(packageName, devDependencies[packageName], DependencyType.Dev, _onChange));\n            });\n            Object.keys(resolutions || {}).forEach((packageName) => {\n                this._resolutions.set(packageName, new PackageJsonDependency(packageName, resolutions[packageName], DependencyType.YarnResolutions, _onChange));\n            });\n            Object.keys(dependenciesMeta || {}).forEach((packageName) => {\n                this._dependenciesMeta.set(packageName, new PackageJsonDependencyMeta(packageName, dependenciesMeta[packageName].injected, _onChange));\n            });\n            // (Do not sort this._resolutions because order may be significant; the RFC is unclear about that.)\n            Sort.sortMapKeys(this._dependencies);\n            Sort.sortMapKeys(this._devDependencies);\n        }\n        catch (e) {\n            throw new Error(`Error loading \"${filepath}\": ${e.message}`);\n        }\n    }\n    static load(filePath) {\n        return new PackageJsonEditor(filePath, JsonFile.load(filePath));\n    }\n    static fromObject(object, filename) {\n        return new PackageJsonEditor(filename, object);\n    }\n    get name() {\n        return this._sourceData.name;\n    }\n    get version() {\n        return this._sourceData.version;\n    }\n    /**\n     * The list of dependencies of type DependencyType.Regular, DependencyType.Optional, or DependencyType.Peer.\n     */\n    get dependencyList() {\n        return [...this._dependencies.values()];\n    }\n    /**\n     * The list of dependencies of type DependencyType.Dev.\n     */\n    get devDependencyList() {\n        return [...this._devDependencies.values()];\n    }\n    /**\n     * The list of dependenciesMeta in package.json.\n     */\n    get dependencyMetaList() {\n        return [...this._dependenciesMeta.values()];\n    }\n    /**\n     * This field is a Yarn-specific feature that allows overriding of package resolution.\n     *\n     * @remarks\n     * See the {@link https://github.com/yarnpkg/rfcs/blob/master/implemented/0000-selective-versions-resolutions.md\n     * | 0000-selective-versions-resolutions.md RFC} for details.\n     */\n    get resolutionsList() {\n        return [...this._resolutions.values()];\n    }\n    tryGetDependency(packageName) {\n        return this._dependencies.get(packageName);\n    }\n    tryGetDevDependency(packageName) {\n        return this._devDependencies.get(packageName);\n    }\n    addOrUpdateDependency(packageName, newVersion, dependencyType) {\n        const dependency = new PackageJsonDependency(packageName, newVersion, dependencyType, this._onChange.bind(this));\n        // Rush collapses everything that isn't a devDependency into the dependencies\n        // field, so we need to set the value depending on dependency type\n        switch (dependencyType) {\n            case DependencyType.Regular:\n            case DependencyType.Optional:\n            case DependencyType.Peer:\n                this._dependencies.set(packageName, dependency);\n                break;\n            case DependencyType.Dev:\n                this._devDependencies.set(packageName, dependency);\n                break;\n            case DependencyType.YarnResolutions:\n                this._resolutions.set(packageName, dependency);\n                break;\n            default:\n                throw new InternalError('Unsupported DependencyType');\n        }\n        this._modified = true;\n    }\n    removeDependency(packageName, dependencyType) {\n        switch (dependencyType) {\n            case DependencyType.Regular:\n            case DependencyType.Optional:\n            case DependencyType.Peer:\n                this._dependencies.delete(packageName);\n                break;\n            case DependencyType.Dev:\n                this._devDependencies.delete(packageName);\n                break;\n            case DependencyType.YarnResolutions:\n                this._resolutions.delete(packageName);\n                break;\n            default:\n                throw new InternalError('Unsupported DependencyType');\n        }\n        this._modified = true;\n    }\n    saveIfModified() {\n        if (this._modified) {\n            this._modified = false;\n            this._sourceData = this._normalize(this._sourceData);\n            JsonFile.save(this._sourceData, this.filePath, {\n                updateExistingFile: true,\n                jsonSyntax: JsonSyntax.Strict\n            });\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Get the normalized package.json that represents the current state of the\n     * PackageJsonEditor. This method does not save any changes that were made to the\n     * package.json, but instead returns the object representation of what would be saved\n     * if saveIfModified() is called.\n     */\n    saveToObject() {\n        // Only normalize if we need to\n        const sourceData = this._modified ? this._normalize(this._sourceData) : this._sourceData;\n        // Provide a clone to avoid reference back to the original data object\n        return cloneDeep(sourceData);\n    }\n    _onChange() {\n        this._modified = true;\n    }\n    /**\n     * Create a normalized shallow copy of the provided package.json without modifying the\n     * original. If the result of this method is being returned via a public facing method,\n     * it will still need to be deep-cloned to avoid propogating changes back to the\n     * original dataset.\n     */\n    _normalize(source) {\n        const normalizedData = Object.assign({}, source);\n        delete normalizedData.dependencies;\n        delete normalizedData.optionalDependencies;\n        delete normalizedData.peerDependencies;\n        delete normalizedData.devDependencies;\n        delete normalizedData.resolutions;\n        const keys = [...this._dependencies.keys()].sort();\n        for (const packageName of keys) {\n            const dependency = this._dependencies.get(packageName);\n            switch (dependency.dependencyType) {\n                case DependencyType.Regular:\n                    if (!normalizedData.dependencies) {\n                        normalizedData.dependencies = {};\n                    }\n                    normalizedData.dependencies[dependency.name] = dependency.version;\n                    break;\n                case DependencyType.Optional:\n                    if (!normalizedData.optionalDependencies) {\n                        normalizedData.optionalDependencies = {};\n                    }\n                    normalizedData.optionalDependencies[dependency.name] = dependency.version;\n                    break;\n                case DependencyType.Peer:\n                    if (!normalizedData.peerDependencies) {\n                        normalizedData.peerDependencies = {};\n                    }\n                    normalizedData.peerDependencies[dependency.name] = dependency.version;\n                    break;\n                case DependencyType.Dev: // uses this._devDependencies instead\n                case DependencyType.YarnResolutions: // uses this._resolutions instead\n                default:\n                    throw new InternalError('Unsupported DependencyType');\n            }\n        }\n        const devDependenciesKeys = [...this._devDependencies.keys()].sort();\n        for (const packageName of devDependenciesKeys) {\n            const dependency = this._devDependencies.get(packageName);\n            if (!normalizedData.devDependencies) {\n                normalizedData.devDependencies = {};\n            }\n            normalizedData.devDependencies[dependency.name] = dependency.version;\n        }\n        // (Do not sort this._resolutions because order may be significant; the RFC is unclear about that.)\n        for (const packageName of this._resolutions.keys()) {\n            const dependency = this._resolutions.get(packageName);\n            if (!normalizedData.resolutions) {\n                normalizedData.resolutions = {};\n            }\n            normalizedData.resolutions[dependency.name] = dependency.version;\n        }\n        return normalizedData;\n    }\n}\n//# sourceMappingURL=PackageJsonEditor.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageNameParser } from '@rushstack/node-core-library';\nexport class PackageNameParsers {\n}\n/**\n * This is the default for `RushConfiguration.packageNameParser`.\n */\nPackageNameParsers.rushDefault = new PackageNameParser({});\n/**\n * This is the `RushConfiguration.packageNameParser` used when `allowMostlyStandardPackageNames = true`\n * in rush.json.\n */\nPackageNameParsers.mostlyStandard = new PackageNameParser({\n    allowUpperCase: true\n});\n/**\n * Use this in contexts where we don't have easy access to `RushConfiguration.packageNameParser`\n * AND the package name was already validated at some earlier stage.\n */\nPackageNameParsers.permissive = PackageNameParsers.mostlyStandard;\n//# sourceMappingURL=PackageNameParsers.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { InternalError, PackageJsonLookup } from '@rushstack/node-core-library';\nimport '../utilities/SetRushLibPath';\nimport { RushCommandLineParser } from '../cli/RushCommandLineParser';\nimport { RushStartupBanner } from '../cli/RushStartupBanner';\nimport { RushXCommandLine } from '../cli/RushXCommandLine';\nimport { CommandLineMigrationAdvisor } from '../cli/CommandLineMigrationAdvisor';\nimport { EnvironmentVariableNames } from './EnvironmentConfiguration';\nimport { RushPnpmCommandLine } from '../cli/RushPnpmCommandLine';\n/**\n * General operations for the Rush engine.\n *\n * @public\n */\nexport class Rush {\n    /**\n     * This API is used by the `@microsoft/rush` front end to launch the \"rush\" command-line.\n     * Third-party tools should not use this API.  Instead, they should execute the \"rush\" binary\n     * and start a new Node.js process.\n     *\n     * @remarks\n     * Earlier versions of the rush frontend used a different API contract. In the old contract,\n     * the second argument was the `isManaged` value of the {@link ILaunchOptions} object.\n     *\n     * Even though this API isn't documented, it is still supported for legacy compatibility.\n     */\n    static launch(launcherVersion, options) {\n        options = Rush._normalizeLaunchOptions(options);\n        if (!RushCommandLineParser.shouldRestrictConsoleOutput()) {\n            RushStartupBanner.logBanner(Rush.version, options.isManaged);\n        }\n        if (!CommandLineMigrationAdvisor.checkArgv(process.argv)) {\n            // The migration advisor recognized an obsolete command-line\n            process.exitCode = 1;\n            return;\n        }\n        Rush._assignRushInvokedFolder();\n        const parser = new RushCommandLineParser({\n            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError,\n            builtInPluginConfigurations: options.builtInPluginConfigurations\n        });\n        // eslint-disable-next-line no-console\n        parser.executeAsync().catch(console.error); // CommandLineParser.executeAsync() should never reject the promise\n    }\n    /**\n     * This API is used by the `@microsoft/rush` front end to launch the \"rushx\" command-line.\n     * Third-party tools should not use this API.  Instead, they should execute the \"rushx\" binary\n     * and start a new Node.js process.\n     */\n    static launchRushX(launcherVersion, options) {\n        options = Rush._normalizeLaunchOptions(options);\n        Rush._assignRushInvokedFolder();\n        // eslint-disable-next-line no-console\n        RushXCommandLine.launchRushXAsync(launcherVersion, options).catch(console.error); // CommandLineParser.executeAsync() should never reject the promise\n    }\n    /**\n     * This API is used by the `@microsoft/rush` front end to launch the \"rush-pnpm\" command-line.\n     * Third-party tools should not use this API.  Instead, they should execute the \"rush-pnpm\" binary\n     * and start a new Node.js process.\n     */\n    static launchRushPnpm(launcherVersion, options) {\n        Rush._assignRushInvokedFolder();\n        RushPnpmCommandLine.launch(launcherVersion, Object.assign({}, options));\n    }\n    /**\n     * The currently executing version of the \"rush-lib\" library.\n     * This is the same as the Rush tool version for that release.\n     */\n    static get version() {\n        return this._rushLibPackageJson.version;\n    }\n    /**\n     * @internal\n     */\n    static get _rushLibPackageJson() {\n        Rush._ensureOwnPackageJsonIsLoaded();\n        return Rush.__rushLibPackageJson;\n    }\n    static get _rushLibPackageFolder() {\n        Rush._ensureOwnPackageJsonIsLoaded();\n        return Rush.__rushLibPackageFolder;\n    }\n    static _ensureOwnPackageJsonIsLoaded() {\n        if (!Rush.__rushLibPackageJson) {\n            const packageJsonFilePath = PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(__dirname);\n            if (!packageJsonFilePath) {\n                throw new InternalError('Unable to locate the package.json file for this module');\n            }\n            Rush.__rushLibPackageFolder = path.dirname(packageJsonFilePath);\n            Rush.__rushLibPackageJson = PackageJsonLookup.instance.loadPackageJson(packageJsonFilePath);\n        }\n    }\n    /**\n     * Assign the `RUSH_INVOKED_FOLDER` environment variable during startup.  This is only applied when\n     * Rush is invoked via the CLI, not via the `@microsoft/rush-lib` automation API.\n     *\n     * @remarks\n     * Modifying the parent process's environment is not a good design.  The better design is (1) to consolidate\n     * Rush's code paths that invoke scripts, and (2) to pass down the invoked folder with each code path,\n     * so that it can finally be applied in a centralized helper like `Utilities._createEnvironmentForRushCommand()`.\n     * The natural time to do that refactoring is when we rework `Utilities.executeCommand()` to use\n     * `Executable.spawn()` or rushell.\n     */\n    static _assignRushInvokedFolder() {\n        process.env[EnvironmentVariableNames.RUSH_INVOKED_FOLDER] = process.cwd();\n    }\n    /**\n     * This function normalizes legacy options to the current {@link ILaunchOptions} object.\n     */\n    static _normalizeLaunchOptions(arg) {\n        return typeof arg === 'boolean'\n            ? { isManaged: arg } // In older versions of Rush, this the `launch` functions took a boolean arg for \"isManaged\"\n            : arg;\n    }\n}\nRush.__rushLibPackageJson = undefined;\nRush.__rushLibPackageFolder = undefined;\n//# sourceMappingURL=Rush.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { CommandLineParameterKind } from '@rushstack/ts-command-line';\nimport { RushCommandLineParser } from '../cli/RushCommandLineParser';\nconst _commandLineSpecByWorkspaceFolder = new Map();\n/**\n * Information about the available CLI commands\n *\n * @beta\n */\nexport class RushCommandLine {\n    static getCliSpec(rushJsonFolder) {\n        let result = _commandLineSpecByWorkspaceFolder.get(rushJsonFolder);\n        if (!result) {\n            const commandLineParser = new RushCommandLineParser({ cwd: rushJsonFolder });\n            // extract the set of command line elements from the command line parser\n            const actions = [];\n            for (const { actionName, parameters: rawParameters } of commandLineParser.actions) {\n                const parameters = [];\n                for (const { kind: rawKind, longName, shortName, description, required, environmentVariable } of rawParameters) {\n                    parameters.push({\n                        kind: CommandLineParameterKind[rawKind],\n                        longName,\n                        shortName,\n                        description,\n                        required,\n                        environmentVariable\n                    });\n                }\n                actions.push({\n                    actionName,\n                    parameters\n                });\n            }\n            result = { actions };\n            _commandLineSpecByWorkspaceFolder.set(rushJsonFolder, result);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=RushCommandLine.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/* eslint max-lines: off */\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { JsonFile, JsonSchema, Path, FileSystem, InternalError } from '@rushstack/node-core-library';\nimport { LookupByPath } from '@rushstack/lookup-by-path';\nimport { trueCasePathSync } from 'true-case-path';\nimport { Rush } from './Rush';\nimport { RushConfigurationProject } from './RushConfigurationProject';\nimport { RushConstants } from '../logic/RushConstants';\nimport { ApprovedPackagesPolicy } from './ApprovedPackagesPolicy';\nimport { EventHooks } from './EventHooks';\nimport { VersionPolicyConfiguration } from './VersionPolicyConfiguration';\nimport { EnvironmentConfiguration } from './EnvironmentConfiguration';\nimport { Utilities } from '../utilities/Utilities';\nimport { NpmPackageManager } from './packageManager/NpmPackageManager';\nimport { YarnPackageManager } from './packageManager/YarnPackageManager';\nimport { PnpmPackageManager } from './packageManager/PnpmPackageManager';\nimport { ExperimentsConfiguration } from './ExperimentsConfiguration';\nimport { PackageNameParsers } from './PackageNameParsers';\nimport { RushPluginsConfiguration } from './RushPluginsConfiguration';\nimport { PnpmOptionsConfiguration } from '../logic/pnpm/PnpmOptionsConfiguration';\nimport { NpmOptionsConfiguration } from '../logic/npm/NpmOptionsConfiguration';\nimport { YarnOptionsConfiguration } from '../logic/yarn/YarnOptionsConfiguration';\nimport schemaJson from '../schemas/rush.schema.json';\nimport { CustomTipsConfiguration } from './CustomTipsConfiguration';\nimport { SubspacesConfiguration } from './SubspacesConfiguration';\nimport { Subspace } from './Subspace';\nconst MINIMUM_SUPPORTED_RUSH_JSON_VERSION = '0.0.0';\nconst DEFAULT_BRANCH = 'main';\nconst DEFAULT_REMOTE = 'origin';\n/**\n * A list of known config filenames that are expected to appear in the \"./common/config/rush\" folder.\n * To avoid confusion/mistakes, any extra files will be reported as an error.\n */\nconst knownRushConfigFilenames = [\n    '.npmrc-publish',\n    '.npmrc',\n    'deploy.json',\n    RushConstants.artifactoryFilename,\n    RushConstants.browserApprovedPackagesFilename,\n    RushConstants.buildCacheFilename,\n    RushConstants.cobuildFilename,\n    RushConstants.commandLineFilename,\n    RushConstants.commonVersionsFilename,\n    RushConstants.customTipsFilename,\n    RushConstants.experimentsFilename,\n    RushConstants.nonbrowserApprovedPackagesFilename,\n    RushConstants.pinnedVersionsFilename,\n    RushConstants.repoStateFilename,\n    RushConstants.versionPoliciesFilename,\n    RushConstants.rushPluginsConfigFilename,\n    RushConstants.pnpmConfigFilename,\n    RushConstants.subspacesConfigFilename,\n    RushConstants.rushAlertsConfigFilename\n];\n/**\n * This represents the Rush configuration for a repository, based on the \"rush.json\"\n * configuration file.\n * @public\n */\nexport class RushConfiguration {\n    /**\n     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()\n     * instead.\n     */\n    constructor(rushConfigurationJson, rushJsonFilename) {\n        var _a, _b;\n        this._subspaces = [];\n        this.rushConfigurationJson = rushConfigurationJson;\n        EnvironmentConfiguration.validate();\n        if (rushConfigurationJson.nodeSupportedVersionRange) {\n            if (!semver.validRange(rushConfigurationJson.nodeSupportedVersionRange)) {\n                throw new Error('Error parsing the node-semver expression in the \"nodeSupportedVersionRange\"' +\n                    ` field from ${RushConstants.rushJsonFilename}: \"${rushConfigurationJson.nodeSupportedVersionRange}\"`);\n            }\n            if (!semver.satisfies(process.version, rushConfigurationJson.nodeSupportedVersionRange)) {\n                let message = `Your dev environment is running Node.js version ${process.version} which does` +\n                    ` not meet the requirements for building this repository.  (The ${RushConstants.rushJsonFilename} configuration` +\n                    ` requires nodeSupportedVersionRange=\"${rushConfigurationJson.nodeSupportedVersionRange}\")`;\n                if (rushConfigurationJson.nodeSupportedVersionInstructions) {\n                    message += '\\n\\n' + rushConfigurationJson.nodeSupportedVersionInstructions;\n                }\n                if (EnvironmentConfiguration.allowUnsupportedNodeVersion) {\n                    // eslint-disable-next-line no-console\n                    console.warn(message);\n                }\n                else {\n                    throw new Error(message);\n                }\n            }\n        }\n        this.rushJsonFile = rushJsonFilename;\n        this.rushJsonFolder = path.dirname(rushJsonFilename);\n        this.commonFolder = path.resolve(path.join(this.rushJsonFolder, RushConstants.commonFolderName));\n        this.commonRushConfigFolder = path.join(this.commonFolder, 'config', 'rush');\n        this.commonTempFolder =\n            EnvironmentConfiguration.rushTempFolderOverride ||\n                path.join(this.commonFolder, RushConstants.rushTempFolderName);\n        this.commonScriptsFolder = path.join(this.commonFolder, 'scripts');\n        this.npmCacheFolder = path.resolve(path.join(this.commonTempFolder, 'npm-cache'));\n        this.npmTmpFolder = path.resolve(path.join(this.commonTempFolder, 'npm-tmp'));\n        this.yarnCacheFolder = path.resolve(path.join(this.commonTempFolder, 'yarn-cache'));\n        this.changesFolder = path.join(this.commonFolder, RushConstants.changeFilesFolderName);\n        this.currentVariantJsonFilePath = path.join(this.commonTempFolder, RushConstants.currentVariantsFilename);\n        this.suppressNodeLtsWarning = !!rushConfigurationJson.suppressNodeLtsWarning;\n        this._ensureConsistentVersionsJsonValue = rushConfigurationJson.ensureConsistentVersions;\n        this.ensureConsistentVersions = !!rushConfigurationJson.ensureConsistentVersions;\n        // Try getting a subspace configuration\n        this.subspacesConfiguration = SubspacesConfiguration.tryLoadFromDefaultLocation(this);\n        this.subspacesFeatureEnabled = !!((_a = this.subspacesConfiguration) === null || _a === void 0 ? void 0 : _a.subspacesEnabled);\n        this._subspacesByName = new Map();\n        const experimentsConfigFile = path.join(this.commonRushConfigFolder, RushConstants.experimentsFilename);\n        this.experimentsConfiguration = new ExperimentsConfiguration(experimentsConfigFile);\n        const rushPluginsConfigFilename = path.join(this.commonRushConfigFolder, RushConstants.rushPluginsConfigFilename);\n        this._rushPluginsConfiguration = new RushPluginsConfiguration(rushPluginsConfigFilename);\n        this.npmOptions = new NpmOptionsConfiguration(rushConfigurationJson.npmOptions || {});\n        this.yarnOptions = new YarnOptionsConfiguration(rushConfigurationJson.yarnOptions || {});\n        try {\n            this.pnpmOptions = PnpmOptionsConfiguration.loadFromJsonFileOrThrow(`${this.commonRushConfigFolder}/${RushConstants.pnpmConfigFilename}`, this.commonTempFolder);\n            if (rushConfigurationJson.pnpmOptions) {\n                throw new Error('Because the new config file \"common/config/rush/pnpm-config.json\" is being used, ' +\n                    `you must remove the old setting \"pnpmOptions\" from ${RushConstants.rushJsonFilename}`);\n            }\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                this.pnpmOptions = PnpmOptionsConfiguration.loadFromJsonObject(rushConfigurationJson.pnpmOptions || {}, this.commonTempFolder);\n            }\n            else {\n                throw error;\n            }\n        }\n        // TODO: Add an actual \"packageManager\" field in rush.json\n        const packageManagerFields = [];\n        this.isPnpm = false;\n        if (rushConfigurationJson.npmVersion) {\n            this.packageManager = 'npm';\n            this.packageManagerOptions = this.npmOptions;\n            packageManagerFields.push('npmVersion');\n        }\n        if (rushConfigurationJson.pnpmVersion) {\n            this.packageManager = 'pnpm';\n            this.isPnpm = true;\n            this.packageManagerOptions = this.pnpmOptions;\n            packageManagerFields.push('pnpmVersion');\n        }\n        if (rushConfigurationJson.yarnVersion) {\n            this.packageManager = 'yarn';\n            this.packageManagerOptions = this.yarnOptions;\n            packageManagerFields.push('yarnVersion');\n        }\n        if (packageManagerFields.length === 0) {\n            throw new Error(`The ${RushConstants.rushJsonFilename} configuration must specify one of: npmVersion, pnpmVersion, or yarnVersion`);\n        }\n        if (packageManagerFields.length > 1) {\n            throw new Error(`The ${RushConstants.rushJsonFilename} configuration cannot specify both ${packageManagerFields[0]}` +\n                ` and ${packageManagerFields[1]} `);\n        }\n        if (this.packageManager === 'npm') {\n            this.packageManagerToolVersion = rushConfigurationJson.npmVersion;\n            this.packageManagerWrapper = new NpmPackageManager(this.packageManagerToolVersion);\n        }\n        else if (this.packageManager === 'pnpm') {\n            this.packageManagerToolVersion = rushConfigurationJson.pnpmVersion;\n            this.packageManagerWrapper = new PnpmPackageManager(this.packageManagerToolVersion);\n        }\n        else {\n            this.packageManagerToolVersion = rushConfigurationJson.yarnVersion;\n            this.packageManagerWrapper = new YarnPackageManager(this.packageManagerToolVersion);\n        }\n        this.shrinkwrapFilename = this.packageManagerWrapper.shrinkwrapFilename;\n        this.packageManagerToolFilename = path.resolve(path.join(this.commonTempFolder, `${this.packageManager}-local`, 'node_modules', '.bin', `${this.packageManager}`));\n        RushConfiguration._validateCommonRushConfigFolder(this.commonRushConfigFolder, this.packageManagerWrapper, this.experimentsConfiguration, this.subspacesFeatureEnabled);\n        this.projectFolderMinDepth =\n            rushConfigurationJson.projectFolderMinDepth !== undefined\n                ? rushConfigurationJson.projectFolderMinDepth\n                : 1;\n        if (this.projectFolderMinDepth < 1) {\n            throw new Error('Invalid projectFolderMinDepth; the minimum possible value is 1');\n        }\n        this.projectFolderMaxDepth =\n            rushConfigurationJson.projectFolderMaxDepth !== undefined\n                ? rushConfigurationJson.projectFolderMaxDepth\n                : 2;\n        if (this.projectFolderMaxDepth < this.projectFolderMinDepth) {\n            throw new Error('The projectFolderMaxDepth cannot be smaller than the projectFolderMinDepth');\n        }\n        this.allowMostlyStandardPackageNames = !!rushConfigurationJson.allowMostlyStandardPackageNames;\n        this.packageNameParser = this.allowMostlyStandardPackageNames\n            ? PackageNameParsers.mostlyStandard\n            : PackageNameParsers.rushDefault;\n        this.approvedPackagesPolicy = new ApprovedPackagesPolicy(this, rushConfigurationJson);\n        this.gitAllowedEmailRegExps = [];\n        this.gitSampleEmail = '';\n        if (rushConfigurationJson.gitPolicy) {\n            if (rushConfigurationJson.gitPolicy.sampleEmail) {\n                this.gitSampleEmail = rushConfigurationJson.gitPolicy.sampleEmail;\n            }\n            if (rushConfigurationJson.gitPolicy.allowedEmailRegExps) {\n                this.gitAllowedEmailRegExps = rushConfigurationJson.gitPolicy.allowedEmailRegExps;\n                if (this.gitSampleEmail.trim().length < 1) {\n                    throw new Error(`The ${RushConstants.rushJsonFilename} file is missing the \"sampleEmail\" option, ` +\n                        'which is required when using \"allowedEmailRegExps\"');\n                }\n            }\n            if (rushConfigurationJson.gitPolicy.versionBumpCommitMessage) {\n                this.gitVersionBumpCommitMessage = rushConfigurationJson.gitPolicy.versionBumpCommitMessage;\n            }\n            if (rushConfigurationJson.gitPolicy.changeLogUpdateCommitMessage) {\n                this.gitChangeLogUpdateCommitMessage = rushConfigurationJson.gitPolicy.changeLogUpdateCommitMessage;\n            }\n            if (rushConfigurationJson.gitPolicy.changefilesCommitMessage) {\n                this.gitChangefilesCommitMessage = rushConfigurationJson.gitPolicy.changefilesCommitMessage;\n            }\n            if (rushConfigurationJson.gitPolicy.tagSeparator) {\n                this.gitTagSeparator = rushConfigurationJson.gitPolicy.tagSeparator;\n            }\n        }\n        this.hotfixChangeEnabled = false;\n        if (rushConfigurationJson.hotfixChangeEnabled) {\n            this.hotfixChangeEnabled = rushConfigurationJson.hotfixChangeEnabled;\n        }\n        if (!rushConfigurationJson.repository) {\n            rushConfigurationJson.repository = {};\n        }\n        this.repositoryDefaultBranch = rushConfigurationJson.repository.defaultBranch || DEFAULT_BRANCH;\n        this.repositoryDefaultRemote = rushConfigurationJson.repository.defaultRemote || DEFAULT_REMOTE;\n        const repositoryFieldWithMultipleUrls = rushConfigurationJson.repository;\n        const repositoryFieldWithSingleUrl = rushConfigurationJson.repository;\n        if (repositoryFieldWithMultipleUrls.urls) {\n            if (repositoryFieldWithSingleUrl.url) {\n                throw new Error(\"The 'repository.url' field cannot be used when 'repository.urls' is present\");\n            }\n            this.repositoryUrls = repositoryFieldWithMultipleUrls.urls;\n        }\n        else if (repositoryFieldWithSingleUrl.url) {\n            this.repositoryUrls = [repositoryFieldWithSingleUrl.url];\n        }\n        else {\n            this.repositoryUrls = [];\n        }\n        this.telemetryEnabled = !!rushConfigurationJson.telemetryEnabled;\n        this.eventHooks = new EventHooks(rushConfigurationJson.eventHooks || {});\n        this.versionPolicyConfigurationFilePath = path.join(this.commonRushConfigFolder, RushConstants.versionPoliciesFilename);\n        this.versionPolicyConfiguration = new VersionPolicyConfiguration(this.versionPolicyConfigurationFilePath);\n        this.customTipsConfigurationFilePath = path.join(this.commonRushConfigFolder, RushConstants.customTipsFilename);\n        this.customTipsConfiguration = new CustomTipsConfiguration(this.customTipsConfigurationFilePath);\n        const variants = new Set();\n        for (const variantOptions of (_b = rushConfigurationJson.variants) !== null && _b !== void 0 ? _b : []) {\n            const { variantName } = variantOptions;\n            if (variants.has(variantName)) {\n                throw new Error(`Duplicate variant named '${variantName}' specified in configuration.`);\n            }\n            variants.add(variantName);\n        }\n        this.variants = variants;\n        this._pathTrees = new Map();\n    }\n    _initializeAndValidateLocalProjects() {\n        var _a;\n        this._projects = [];\n        this._projectsByName = new Map();\n        this._subspacesByName.clear();\n        this._subspaces.length = 0;\n        // Build the subspaces map\n        const subspaceNames = [];\n        let splitWorkspaceCompatibility = false;\n        if ((_a = this.subspacesConfiguration) === null || _a === void 0 ? void 0 : _a.subspacesEnabled) {\n            splitWorkspaceCompatibility = this.subspacesConfiguration.splitWorkspaceCompatibility;\n            subspaceNames.push(...this.subspacesConfiguration.subspaceNames);\n        }\n        if (subspaceNames.indexOf(RushConstants.defaultSubspaceName) < 0) {\n            subspaceNames.push(RushConstants.defaultSubspaceName);\n        }\n        // Sort the subspaces in alphabetical order.  This ensures that they are processed\n        // in a deterministic order by the various Rush algorithms.\n        subspaceNames.sort();\n        for (const subspaceName of subspaceNames) {\n            const subspace = new Subspace({\n                subspaceName,\n                rushConfiguration: this,\n                splitWorkspaceCompatibility\n            });\n            this._subspacesByName.set(subspaceName, subspace);\n            this._subspaces.push(subspace);\n        }\n        const defaultSubspace = this._subspacesByName.get(RushConstants.defaultSubspaceName);\n        if (!defaultSubspace) {\n            throw new InternalError('The default subspace was not created');\n        }\n        // Sort the projects array in alphabetical order.  This ensures that the packages\n        // are processed in a deterministic order by the various Rush algorithms.\n        const sortedProjectJsons = this.rushConfigurationJson.projects.slice(0);\n        sortedProjectJsons.sort((a, b) => a.packageName.localeCompare(b.packageName));\n        const allowedProjectTags = this.rushConfigurationJson.allowedProjectTags\n            ? new Set(this.rushConfigurationJson.allowedProjectTags)\n            : undefined;\n        const usedTempNames = new Set();\n        for (let i = 0, len = sortedProjectJsons.length; i < len; i++) {\n            const projectJson = sortedProjectJsons[i];\n            const tempProjectName = RushConfiguration._generateTempNameForProject(projectJson, usedTempNames);\n            let subspace = undefined;\n            if (this.subspacesFeatureEnabled) {\n                if (projectJson.subspaceName) {\n                    subspace = this._subspacesByName.get(projectJson.subspaceName);\n                    if (subspace === undefined) {\n                        throw new Error(`The project \"${projectJson.packageName}\" in ${RushConstants.rushJsonFilename} references` +\n                            ` a nonexistent subspace \"${projectJson.subspaceName}\"`);\n                    }\n                }\n            }\n            if (subspace === undefined) {\n                subspace = defaultSubspace;\n            }\n            const project = new RushConfigurationProject({\n                projectJson,\n                rushConfiguration: this,\n                tempProjectName,\n                allowedProjectTags,\n                subspace\n            });\n            subspace._addProject(project);\n            this._projects.push(project);\n            if (this._projectsByName.has(project.packageName)) {\n                throw new Error(`The project name \"${project.packageName}\" was specified more than once` +\n                    ` in the ${RushConstants.rushJsonFilename} configuration file.`);\n            }\n            this._projectsByName.set(project.packageName, project);\n        }\n        for (const project of this._projects) {\n            project.decoupledLocalDependencies.forEach((decoupledLocalDependency) => {\n                if (!this.getProjectByName(decoupledLocalDependency)) {\n                    throw new Error(`In ${RushConstants.rushJsonFilename}, the \"${decoupledLocalDependency}\" project does not exist,` +\n                        ` but was referenced by the decoupledLocalDependencies (previously cyclicDependencyProjects) for ${project.packageName}`);\n                }\n            });\n            this.versionPolicyConfiguration.validate(this.projectsByName);\n            // Consumer relationships will be established the first time one is requested\n        }\n    }\n    /**\n     * Loads the configuration data from an Rush.json configuration file and returns\n     * an RushConfiguration object.\n     */\n    static loadFromConfigurationFile(rushJsonFilename) {\n        let resolvedRushJsonFilename = path.resolve(rushJsonFilename);\n        // Load the rush.json before we fix the casing. If the case is wrong on a case-sensitive filesystem,\n        // the next line show throw.\n        const rushConfigurationJson = JsonFile.load(resolvedRushJsonFilename);\n        try {\n            resolvedRushJsonFilename = trueCasePathSync(resolvedRushJsonFilename);\n        }\n        catch (error) {\n            /* ignore errors from true-case-path */\n        }\n        // Check the Rush version *before* we validate the schema, since if the version is outdated\n        // then the schema may have changed. This should no longer be a problem after Rush 4.0 and the C2R wrapper,\n        // but we'll validate anyway.\n        const expectedRushVersion = rushConfigurationJson.rushVersion;\n        const rushJsonBaseName = path.basename(resolvedRushJsonFilename);\n        // If the version is missing or malformed, fall through and let the schema handle it.\n        if (expectedRushVersion && semver.valid(expectedRushVersion)) {\n            // Make sure the requested version isn't too old\n            if (semver.lt(expectedRushVersion, MINIMUM_SUPPORTED_RUSH_JSON_VERSION)) {\n                throw new Error(`${rushJsonBaseName} is version ${expectedRushVersion}, which is too old for this tool. ` +\n                    `The minimum supported version is ${MINIMUM_SUPPORTED_RUSH_JSON_VERSION}.`);\n            }\n            // Make sure the requested version isn't too new.\n            //\n            // If the major/minor versions are the same, then we consider the file to be compatible.\n            // This is somewhat lax, e.g. \"5.0.2-dev.3\" will be assumed to be loadable by rush-lib 5.0.0.\n            //\n            // IMPORTANT: Whenever a breaking change is introduced for one of the config files, we must\n            // increment the minor version number for Rush.\n            if (semver.major(Rush.version) !== semver.major(expectedRushVersion) ||\n                semver.minor(Rush.version) !== semver.minor(expectedRushVersion)) {\n                // If the major/minor are different, then make sure it's an older version.\n                if (semver.lt(Rush.version, expectedRushVersion)) {\n                    throw new Error(`Unable to load ${rushJsonBaseName} because its RushVersion is` +\n                        ` ${rushConfigurationJson.rushVersion}, whereas @microsoft/rush-lib is version ${Rush.version}.` +\n                        ` Consider upgrading the library.`);\n                }\n            }\n        }\n        RushConfiguration._jsonSchema.validateObject(rushConfigurationJson, resolvedRushJsonFilename);\n        return new RushConfiguration(rushConfigurationJson, resolvedRushJsonFilename);\n    }\n    static tryLoadFromDefaultLocation(options) {\n        const rushJsonLocation = RushConfiguration.tryFindRushJsonLocation(options);\n        if (rushJsonLocation) {\n            return RushConfiguration.loadFromConfigurationFile(rushJsonLocation);\n        }\n    }\n    static loadFromDefaultLocation(options) {\n        const rushConfiguration = RushConfiguration.tryLoadFromDefaultLocation(options);\n        if (rushConfiguration) {\n            return rushConfiguration;\n        }\n        else {\n            throw Utilities.getRushConfigNotFoundError();\n        }\n    }\n    /**\n     * Find the rush.json location and return the path, or undefined if a rush.json can't be found.\n     *\n     * @privateRemarks\n     * Keep this in sync with `findRushJsonLocation` in `rush-sdk/src/index.ts`.\n     */\n    static tryFindRushJsonLocation(options) {\n        const optionsIn = options || {};\n        const verbose = optionsIn.showVerbose || false;\n        let currentFolder = optionsIn.startingFolder || process.cwd();\n        let parentFolder = path.dirname(currentFolder);\n        // look upwards at parent folders until we find a folder containing rush.json,\n        // or we reach the root directory without finding a rush.json file\n        while (parentFolder && parentFolder !== currentFolder) {\n            const rushJsonFilename = path.join(currentFolder, RushConstants.rushJsonFilename);\n            if (FileSystem.exists(rushJsonFilename)) {\n                if (currentFolder !== optionsIn.startingFolder && verbose) {\n                    // eslint-disable-next-line no-console\n                    console.log('Found configuration in ' + rushJsonFilename);\n                }\n                if (verbose) {\n                    // eslint-disable-next-line no-console\n                    console.log('');\n                }\n                return rushJsonFilename;\n            }\n            currentFolder = parentFolder;\n            parentFolder = path.dirname(currentFolder);\n        }\n        // no match\n        return undefined;\n    }\n    /**\n     * This generates the unique names that are used to create temporary projects\n     * in the Rush common folder.\n     * NOTE: sortedProjectJsons is sorted by the caller.\n     */\n    static _generateTempNameForProject(projectJson, usedTempNames) {\n        // If the name is \"@ms/MyProject\", extract the \"MyProject\" part\n        const unscopedName = PackageNameParsers.permissive.getUnscopedName(projectJson.packageName);\n        // Generate a unique like name \"@rush-temp/MyProject\", or \"@rush-temp/MyProject-2\" if\n        // there is a naming conflict\n        let counter = 0;\n        let tempProjectName = `${RushConstants.rushTempNpmScope}/${unscopedName}`;\n        while (usedTempNames.has(tempProjectName)) {\n            ++counter;\n            tempProjectName = `${RushConstants.rushTempNpmScope}/${unscopedName}-${counter}`;\n        }\n        usedTempNames.add(tempProjectName);\n        return tempProjectName;\n    }\n    /**\n     * If someone adds a config file in the \"common/rush/config\" folder, it would be a bad\n     * experience for Rush to silently ignore their file simply because they misspelled the\n     * filename, or maybe it's an old format that's no longer supported.  The\n     * _validateCommonRushConfigFolder() function makes sure that this folder only contains\n     * recognized config files.\n     */\n    static _validateCommonRushConfigFolder(commonRushConfigFolder, packageManagerWrapper, experiments, subspacesFeatureEnabled) {\n        if (!FileSystem.exists(commonRushConfigFolder)) {\n            // eslint-disable-next-line no-console\n            console.log(`Creating folder: ${commonRushConfigFolder}`);\n            FileSystem.ensureFolder(commonRushConfigFolder);\n            return;\n        }\n        for (const filename of FileSystem.readFolderItemNames(commonRushConfigFolder)) {\n            // Ignore things that aren't actual files\n            const stat = FileSystem.getLinkStatistics(path.join(commonRushConfigFolder, filename));\n            if (!stat.isFile() && !stat.isSymbolicLink()) {\n                continue;\n            }\n            // Ignore harmless file extensions\n            const fileExtension = path.extname(filename);\n            if (['.bak', '.disabled', '.md', '.old', '.orig'].indexOf(fileExtension) >= 0) {\n                continue;\n            }\n            // Check if there are prohibited files when subspaces is enabled\n            if (subspacesFeatureEnabled) {\n                if (filename === RushConstants.pnpmfileV6Filename || filename === RushConstants.pnpmfileV1Filename) {\n                    throw new Error('When the subspaces feature is enabled, a separate lockfile is stored in each subspace folder. ' +\n                        `To avoid confusion, remove this file: ${commonRushConfigFolder}/${filename}`);\n                }\n            }\n            // Ignore hidden files such as \".DS_Store\"\n            if (filename.startsWith('.')) {\n                continue;\n            }\n            if (filename.startsWith('deploy-') && fileExtension === '.json') {\n                // Ignore \"rush deploy\" files, which use the naming pattern \"deploy-<scenario-name>.json\".\n                continue;\n            }\n            const knownSet = new Set(knownRushConfigFilenames.map((x) => x.toUpperCase()));\n            // Add the shrinkwrap filename for the package manager to the known set.\n            knownSet.add(packageManagerWrapper.shrinkwrapFilename.toUpperCase());\n            // If the package manager is pnpm, then also add the pnpm file to the known set.\n            if (packageManagerWrapper.packageManager === 'pnpm') {\n                const pnpmPackageManager = packageManagerWrapper;\n                knownSet.add(pnpmPackageManager.pnpmfileFilename.toUpperCase());\n            }\n            // Is the filename something we know?  If not, report an error.\n            if (!knownSet.has(filename.toUpperCase())) {\n                throw new Error(`An unrecognized file \"${filename}\" was found in the Rush config folder:` +\n                    ` ${commonRushConfigFolder}`);\n            }\n        }\n        const pinnedVersionsFilename = path.join(commonRushConfigFolder, RushConstants.pinnedVersionsFilename);\n        if (FileSystem.exists(pinnedVersionsFilename)) {\n            throw new Error('The \"pinned-versions.json\" config file is no longer supported;' +\n                ' please move your settings to the \"preferredVersions\" field of a \"common-versions.json\" config file.' +\n                ` (See the ${RushConstants.rushWebSiteUrl} documentation for details.)\\n\\n` +\n                pinnedVersionsFilename);\n        }\n    }\n    /**\n     * The fully resolved path for the \"autoinstallers\" folder.\n     * Example: `C:\\MyRepo\\common\\autoinstallers`\n     */\n    get commonAutoinstallersFolder() {\n        return path.join(this.commonFolder, 'autoinstallers');\n    }\n    /**\n     * The folder where rush-plugin options json files are stored.\n     * Example: `C:\\MyRepo\\common\\config\\rush-plugins`\n     */\n    get rushPluginOptionsFolder() {\n        return path.join(this.commonFolder, 'config', 'rush-plugins');\n    }\n    /**\n     * The full path of the temporary shrinkwrap file that is used during \"rush install\".\n     * This file may get rewritten by the package manager during installation.\n     * @remarks\n     * This property merely reports the filename; the file itself may not actually exist.\n     * Example: `C:\\MyRepo\\common\\temp\\npm-shrinkwrap.json` or `C:\\MyRepo\\common\\temp\\pnpm-lock.yaml`\n     *\n     * @deprecated Introduced with subspaces is subspace specific tempShrinkwrapFilename accessible from the Subspace class.\n     */\n    get tempShrinkwrapFilename() {\n        if (this.subspacesFeatureEnabled) {\n            throw new Error('tempShrinkwrapFilename() is not available when using subspaces. Use the subspace specific temp shrinkwrap filename.');\n        }\n        return path.join(this.commonTempFolder, this.shrinkwrapFilename);\n    }\n    /**\n     * The full path of a backup copy of tempShrinkwrapFilename. This backup copy is made\n     * before installation begins, and can be compared to determine how the package manager\n     * modified tempShrinkwrapFilename.\n     * @remarks\n     * This property merely reports the filename; the file itself may not actually exist.\n     * Example: `C:\\MyRepo\\common\\temp\\npm-shrinkwrap-preinstall.json`\n     * or `C:\\MyRepo\\common\\temp\\pnpm-lock-preinstall.yaml`\n     *\n     * @deprecated Introduced with subspaces is subspace specific tempShrinkwrapPreinstallFilename accessible from the Subspace class.\n     */\n    get tempShrinkwrapPreinstallFilename() {\n        if (this.subspacesFeatureEnabled) {\n            throw new Error('tempShrinkwrapPreinstallFilename() is not available when using subspaces. Use the subspace specific temp shrinkwrap preinstall filename.');\n        }\n        const parsedPath = path.parse(this.tempShrinkwrapFilename);\n        return path.join(parsedPath.dir, parsedPath.name + '-preinstall' + parsedPath.ext);\n    }\n    /**\n     * Returns an English phrase such as \"shrinkwrap file\" that can be used in logging messages\n     * to refer to the shrinkwrap file using appropriate terminology for the currently selected\n     * package manager.\n     */\n    get shrinkwrapFilePhrase() {\n        return `shrinkwrap file (${this.shrinkwrapFilename})`;\n    }\n    /**\n     * The filename of the build dependency data file.  By default this is\n     * called 'rush-link.json' resides in the Rush common folder.\n     * Its data structure is defined by IRushLinkJson.\n     *\n     * Example: `C:\\MyRepo\\common\\temp\\rush-link.json`\n     *\n     * @deprecated The \"rush-link.json\" file was removed in Rush 5.30.0.\n     * Use `RushConfigurationProject.localDependencyProjects` instead.\n     */\n    get rushLinkJsonFilename() {\n        throw new Error('The \"rush-link.json\" file was removed in Rush 5.30.0. Use ' +\n            'RushConfigurationProject.localDependencyProjects instead.');\n    }\n    /**\n     * The default fully-qualified git remote branch of the repository. This helps \"rush change\" find the right branch to compare against.\n     */\n    get repositoryDefaultFullyQualifiedRemoteBranch() {\n        return `${this.repositoryDefaultRemote}/${this.repositoryDefaultBranch}`;\n    }\n    get projects() {\n        if (!this._projects) {\n            this._initializeAndValidateLocalProjects();\n        }\n        return this._projects;\n    }\n    /**\n     * @beta\n     */\n    get defaultSubspace() {\n        // TODO: Enable the default subspace to be obtained without initializing the full set of all projects\n        if (!this._projects) {\n            this._initializeAndValidateLocalProjects();\n        }\n        const defaultSubspace = this.tryGetSubspace(RushConstants.defaultSubspaceName);\n        if (!defaultSubspace) {\n            throw new InternalError('Default subspace was not created');\n        }\n        return defaultSubspace;\n    }\n    /**\n     * A list of all the available subspaces in this workspace.\n     * @beta\n     */\n    get subspaces() {\n        if (!this._projects) {\n            this._initializeAndValidateLocalProjects();\n        }\n        return this._subspaces;\n    }\n    /**\n     * @beta\n     */\n    tryGetSubspace(subspaceName) {\n        var _a;\n        if (!this._projects) {\n            this._initializeAndValidateLocalProjects();\n        }\n        const subspace = this._subspacesByName.get(subspaceName);\n        if (!subspace) {\n            // If the name is not even valid, that is more important information than if the subspace doesn't exist\n            SubspacesConfiguration.requireValidSubspaceName(subspaceName, (_a = this.subspacesConfiguration) === null || _a === void 0 ? void 0 : _a.splitWorkspaceCompatibility);\n        }\n        return subspace;\n    }\n    /**\n     * @beta\n     */\n    getSubspace(subspaceName) {\n        const subspace = this.tryGetSubspace(subspaceName);\n        if (!subspace) {\n            throw new Error(`The specified subspace \"${subspaceName}\" does not exist`);\n        }\n        return subspace;\n    }\n    /**\n     * Returns the set of subspaces that the given projects belong to\n     * @beta\n     */\n    getSubspacesForProjects(projects) {\n        if (!this._projects) {\n            this._initializeAndValidateLocalProjects();\n        }\n        const subspaceSet = new Set();\n        for (const project of projects) {\n            subspaceSet.add(project.subspace);\n        }\n        return subspaceSet;\n    }\n    /**\n     * @beta\n     */\n    get projectsByName() {\n        if (!this._projectsByName) {\n            this._initializeAndValidateLocalProjects();\n        }\n        return this._projectsByName;\n    }\n    /**\n     * Obtains the mapping from custom tags to projects.\n     * @beta\n     */\n    get projectsByTag() {\n        if (!this._projectsByTag) {\n            const projectsByTag = new Map();\n            for (const project of this.projects) {\n                for (const tag of project.tags) {\n                    let collection = projectsByTag.get(tag);\n                    if (!collection) {\n                        projectsByTag.set(tag, (collection = new Set()));\n                    }\n                    collection.add(project);\n                }\n            }\n            this._projectsByTag = projectsByTag;\n        }\n        return this._projectsByTag;\n    }\n    /**\n     * Settings from the common-versions.json config file.\n     * @remarks\n     * If the common-versions.json file is missing, this property will not be undefined.\n     * Instead it will be initialized in an empty state, and calling CommonVersionsConfiguration.save()\n     * will create the file.\n     *\n     * @deprecated Use `getCommonVersions` instead, which gets the correct common version data\n     * for a given active variant.\n     */\n    get commonVersions() {\n        return this.defaultSubspace.getCommonVersions(undefined);\n    }\n    /**\n     * Gets the currently-installed variant, if an installation has occurred.\n     * For Rush operations which do not take a --variant parameter, this method\n     * determines which variant, if any, was last specified when performing \"rush install\"\n     * or \"rush update\".\n     */\n    async getCurrentlyInstalledVariantAsync() {\n        var _a, _b;\n        if (!this._currentVariantJsonLoadingPromise) {\n            this._currentVariantJsonLoadingPromise = this._loadCurrentVariantJsonAsync();\n        }\n        return (_b = (_a = (await this._currentVariantJsonLoadingPromise)) === null || _a === void 0 ? void 0 : _a.variant) !== null && _b !== void 0 ? _b : undefined;\n    }\n    /**\n     * @deprecated Use {@link Subspace.getCommonVersionsFilePath} instead\n     */\n    getCommonVersionsFilePath(subspace, variant) {\n        return (subspace !== null && subspace !== void 0 ? subspace : this.defaultSubspace).getCommonVersionsFilePath(variant);\n    }\n    /**\n     * @deprecated Use {@link Subspace.getCommonVersions} instead\n     */\n    getCommonVersions(subspace, variant) {\n        return (subspace !== null && subspace !== void 0 ? subspace : this.defaultSubspace).getCommonVersions(variant);\n    }\n    /**\n     * Returns a map of all direct dependencies that only have a single semantic version specifier.\n     *\n     * @param subspace - The subspace to use\n     * @param variant - The name of the current variant in use by the active command.\n     *\n     * @returns A map of dependency name --\\> version specifier for implicitly preferred versions.\n     */\n    getImplicitlyPreferredVersions(subspace, variant) {\n        // TODO: During the next major release of Rush, replace this `require` call with a dynamic import, and\n        // change this function to be async.\n        const DependencyAnalyzerModule = require('../logic/DependencyAnalyzer');\n        const dependencyAnalyzer = DependencyAnalyzerModule.DependencyAnalyzer.forRushConfiguration(this);\n        const dependencyAnalysis = dependencyAnalyzer.getAnalysis(subspace, variant, false);\n        return dependencyAnalysis.implicitlyPreferredVersionByPackageName;\n    }\n    /**\n     * @deprecated Use {@link Subspace.getRepoStateFilePath} instead\n     */\n    getRepoStateFilePath(subspace) {\n        return (subspace !== null && subspace !== void 0 ? subspace : this.defaultSubspace).getRepoStateFilePath();\n    }\n    /**\n     * @deprecated Use {@link Subspace.getRepoState} instead\n     */\n    getRepoState(subspace) {\n        return (subspace !== null && subspace !== void 0 ? subspace : this.defaultSubspace).getRepoState();\n    }\n    /**\n     * @deprecated Use {@link Subspace.getCommittedShrinkwrapFilePath} instead\n     */\n    getCommittedShrinkwrapFilename(subspace, variant) {\n        return (subspace !== null && subspace !== void 0 ? subspace : this.defaultSubspace).getCommittedShrinkwrapFilePath(variant);\n    }\n    /**\n     * @deprecated Use {@link Subspace.getPnpmfilePath} instead\n     */\n    getPnpmfilePath(subspace, variant) {\n        return (subspace !== null && subspace !== void 0 ? subspace : this.defaultSubspace).getPnpmfilePath(variant);\n    }\n    /**\n     * Looks up a project in the projectsByName map.  If the project is not found,\n     * then undefined is returned.\n     */\n    getProjectByName(projectName) {\n        return this.projectsByName.get(projectName);\n    }\n    /**\n     * This is used e.g. by command-line interfaces such as \"rush build --to example\".\n     * If \"example\" is not a project name, then it also looks for a scoped name\n     * like `@something/example`.  If exactly one project matches this heuristic, it\n     * is returned.  Otherwise, undefined is returned.\n     */\n    findProjectByShorthandName(shorthandProjectName) {\n        // Is there an exact match?\n        let result = this.projectsByName.get(shorthandProjectName);\n        if (result) {\n            return result;\n        }\n        // Is there an approximate match?\n        for (const project of this.projects) {\n            if (this.packageNameParser.getUnscopedName(project.packageName) === shorthandProjectName) {\n                if (result) {\n                    // Ambiguous -- there is more than one match\n                    return undefined;\n                }\n                else {\n                    result = project;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Looks up a project by its RushConfigurationProject.tempProjectName field.\n     * @returns The found project, or undefined if no match was found.\n     */\n    findProjectByTempName(tempProjectName) {\n        // Is there an approximate match?\n        for (const project of this.projects) {\n            if (project.tempProjectName === tempProjectName) {\n                return project;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * @returns An optimized lookup engine to find a project by its path relative to the specified root.\n     * @beta\n     */\n    getProjectLookupForRoot(rootPath) {\n        let pathTree = this._pathTrees.get(rootPath);\n        if (!pathTree) {\n            this._pathTrees.set(rootPath, (pathTree = new LookupByPath()));\n            for (const project of this.projects) {\n                const relativePath = path.relative(rootPath, project.projectFolder);\n                pathTree.setItemFromSegments(LookupByPath.iteratePathSegments(relativePath, path.sep), project);\n            }\n        }\n        return pathTree;\n    }\n    /**\n     * Returns the project for which the specified path is underneath that project's folder.\n     * If the path is not under any project's folder, returns undefined.\n     */\n    tryGetProjectForPath(currentFolderPath) {\n        // TODO: Improve the method in which a package is found, perhaps without having to sort / loop though the entire package list\n        const resolvedPath = path.resolve(currentFolderPath);\n        const sortedProjects = this.projects.sort((a, b) => b.projectFolder.length - a.projectFolder.length);\n        for (const project of sortedProjects) {\n            if (Path.isUnderOrEqual(resolvedPath, project.projectFolder)) {\n                return project;\n            }\n        }\n        return undefined;\n    }\n    async _loadCurrentVariantJsonAsync() {\n        try {\n            return await JsonFile.loadAsync(this.currentVariantJsonFilePath);\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n    }\n}\nRushConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=RushConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { FileSystem, FileConstants } from '@rushstack/node-core-library';\nimport { RushConstants } from '../logic/RushConstants';\nimport { PackageNameParsers } from './PackageNameParsers';\nimport { DependencySpecifier, DependencySpecifierType } from '../logic/DependencySpecifier';\nimport { SaveCallbackPackageJsonEditor } from './SaveCallbackPackageJsonEditor';\n/**\n * This represents the configuration of a project that is built by Rush, based on\n * the Rush.json configuration file.\n * @public\n */\nexport class RushConfigurationProject {\n    /**\n     * The parsed NPM \"package.json\" file from projectFolder.\n     */\n    get packageJson() {\n        return this._packageJson;\n    }\n    /** @internal */\n    constructor(options) {\n        this._versionPolicy = undefined;\n        this._dependencyProjects = undefined;\n        this._consumingProjects = undefined;\n        const { projectJson, rushConfiguration, tempProjectName, allowedProjectTags } = options;\n        const { packageName, projectFolder: projectRelativeFolder } = projectJson;\n        this.rushConfiguration = rushConfiguration;\n        this.packageName = packageName;\n        this.projectRelativeFolder = projectRelativeFolder;\n        validateRelativePathField(projectRelativeFolder, 'projectFolder', rushConfiguration.rushJsonFile);\n        // For example, the depth of \"a/b/c\" would be 3.  The depth of \"a\" is 1.\n        const projectFolderDepth = projectRelativeFolder.split('/').length;\n        if (projectFolderDepth < rushConfiguration.projectFolderMinDepth) {\n            throw new Error(`To keep things organized, this repository has a projectFolderMinDepth policy` +\n                ` requiring project folders to be at least ${rushConfiguration.projectFolderMinDepth} levels deep.` +\n                `  Problem folder: \"${projectRelativeFolder}\"`);\n        }\n        if (projectFolderDepth > rushConfiguration.projectFolderMaxDepth) {\n            throw new Error(`To keep things organized, this repository has a projectFolderMaxDepth policy` +\n                ` preventing project folders from being deeper than ${rushConfiguration.projectFolderMaxDepth} levels.` +\n                `  Problem folder:  \"${projectRelativeFolder}\"`);\n        }\n        const absoluteProjectFolder = path.join(rushConfiguration.rushJsonFolder, projectRelativeFolder);\n        this.projectFolder = absoluteProjectFolder;\n        const packageJsonFilename = path.join(absoluteProjectFolder, FileConstants.PackageJson);\n        try {\n            const packageJsonText = FileSystem.readFile(packageJsonFilename);\n            // JSON.parse is native and runs in less than 1/2 the time of jju.parse. package.json is required to be strict JSON by NodeJS.\n            this._packageJson = JSON.parse(packageJsonText);\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                throw new Error(`Could not find package.json for ${packageName} at ${packageJsonFilename}`);\n            }\n            // Encountered an error while loading the package.json file. Please append the error message with the corresponding file location.\n            if (error instanceof SyntaxError) {\n                error.message = `${error.message}\\nFilename: ${packageJsonFilename}`;\n            }\n            throw error;\n        }\n        this.projectRushConfigFolder = path.join(absoluteProjectFolder, 'config', 'rush');\n        this.projectRushTempFolder = path.join(absoluteProjectFolder, RushConstants.projectRushFolderName, RushConstants.rushTempFolderName);\n        // Are we using a package review file?\n        if (rushConfiguration.approvedPackagesPolicy.enabled) {\n            // If so, then every project needs to have a reviewCategory that was defined\n            // by the reviewCategories array.\n            if (!projectJson.reviewCategory) {\n                throw new Error(`The \"approvedPackagesPolicy\" feature is enabled ${RushConstants.rushJsonFilename}, but a reviewCategory` +\n                    ` was not specified for the project \"${packageName}\".`);\n            }\n            if (!rushConfiguration.approvedPackagesPolicy.reviewCategories.has(projectJson.reviewCategory)) {\n                throw new Error(`The project \"${packageName}\" specifies its reviewCategory as` +\n                    `\"${projectJson.reviewCategory}\" which is not one of the defined reviewCategories.`);\n            }\n            this.reviewCategory = projectJson.reviewCategory;\n        }\n        if (this.packageJson.name !== this.packageName) {\n            throw new Error(`The package name \"${this.packageName}\" specified in ${RushConstants.rushJsonFilename} does not` +\n                ` match the name \"${this.packageJson.name}\" from package.json`);\n        }\n        if (!semver.valid(this.packageJson.version)) {\n            throw new Error(`The value \"${this.packageJson.version}\" is not valid SemVer syntax for the \\\"version\\\" field` +\n                ` in the file \"${packageJsonFilename}\"`);\n        }\n        this.packageJsonEditor = SaveCallbackPackageJsonEditor.fromObjectWithCallback({\n            object: this.packageJson,\n            filename: packageJsonFilename,\n            onSaved: (newObject) => {\n                // Just update the in-memory copy, don't bother doing the validation again\n                this._packageJson = newObject;\n                this._dependencyProjects = undefined; // Reset the cached dependency projects\n            }\n        });\n        this.tempProjectName = tempProjectName;\n        // The \"rushProject.tempProjectName\" is guaranteed to be unique name (e.g. by adding the \"-2\"\n        // suffix).  Even after we strip the NPM scope, it will still be unique.\n        // Example: \"my-project-2\"\n        this.unscopedTempProjectName = PackageNameParsers.permissive.getUnscopedName(tempProjectName);\n        this.decoupledLocalDependencies = new Set();\n        if (projectJson.cyclicDependencyProjects || projectJson.decoupledLocalDependencies) {\n            if (projectJson.cyclicDependencyProjects && projectJson.decoupledLocalDependencies) {\n                throw new Error('A project configuration cannot specify both \"decoupledLocalDependencies\" and \"cyclicDependencyProjects\". Please use \"decoupledLocalDependencies\" only -- the other name is deprecated.');\n            }\n            for (const cyclicDependencyProject of projectJson.cyclicDependencyProjects ||\n                projectJson.decoupledLocalDependencies) {\n                this.decoupledLocalDependencies.add(cyclicDependencyProject);\n            }\n        }\n        this._shouldPublish = !!projectJson.shouldPublish;\n        this.skipRushCheck = !!projectJson.skipRushCheck;\n        this.versionPolicyName = projectJson.versionPolicyName;\n        if (this._shouldPublish && this.packageJson.private) {\n            throw new Error(`The project \"${packageName}\" specifies \"shouldPublish\": true, ` +\n                `but the package.json file specifies \"private\": true.`);\n        }\n        this.publishFolder = absoluteProjectFolder;\n        const { publishFolder } = projectJson;\n        if (publishFolder) {\n            validateRelativePathField(publishFolder, 'publishFolder', rushConfiguration.rushJsonFile);\n            this.publishFolder = path.join(this.publishFolder, publishFolder);\n        }\n        if (allowedProjectTags && projectJson.tags) {\n            const tags = new Set();\n            for (const tag of projectJson.tags) {\n                if (!allowedProjectTags.has(tag)) {\n                    throw new Error(`The tag \"${tag}\" specified for project \"${packageName}\" is not listed in the ` +\n                        `allowedProjectTags field in ${RushConstants.rushJsonFilename}.`);\n                }\n                else {\n                    tags.add(tag);\n                }\n            }\n            this.tags = tags;\n        }\n        else {\n            this.tags = new Set(projectJson.tags);\n        }\n        this.configuredSubspaceName = projectJson.subspaceName;\n        this.subspace = options.subspace;\n    }\n    /**\n     * A list of local projects that appear as devDependencies for this project, but cannot be\n     * locally linked because it would create a cyclic dependency; instead, the last published\n     * version will be installed in the Common folder.\n     *\n     * These are package names that would be found by RushConfiguration.getProjectByName().\n     *\n     * @deprecated Use `decoupledLocalDependencies` instead, as it better describes the purpose of the data.\n     */\n    get cyclicDependencyProjects() {\n        return this.decoupledLocalDependencies;\n    }\n    /**\n     * An array of projects within the Rush configuration which directly depend on this package.\n     * @deprecated Use `consumingProjectNames` instead, as it has Set semantics, which better reflect the nature\n     * of the data.\n     */\n    get downstreamDependencyProjects() {\n        return Array.from(this.consumingProjects, (project) => project.packageName);\n    }\n    /**\n     * An array of projects within the Rush configuration which this project declares as dependencies.\n     * @deprecated Use `dependencyProjects` instead, as it has Set semantics, which better reflect the nature\n     * of the data.\n     */\n    get localDependencyProjects() {\n        return [...this.dependencyProjects];\n    }\n    /**\n     * The set of projects within the Rush configuration which this project declares as dependencies.\n     *\n     * @remarks\n     * Can be used recursively to walk the project dependency graph to find all projects that are directly or indirectly\n     * referenced from this project.\n     */\n    get dependencyProjects() {\n        var _a, _b;\n        let dependencyProjects = this._dependencyProjects;\n        if (!dependencyProjects) {\n            this._dependencyProjects = dependencyProjects = new Set();\n            const { packageJson } = this;\n            for (const dependencySet of [\n                packageJson.dependencies,\n                packageJson.devDependencies,\n                packageJson.optionalDependencies\n            ]) {\n                if (dependencySet) {\n                    for (const [dependency, version] of Object.entries(dependencySet)) {\n                        const dependencySpecifier = new DependencySpecifier(dependency, version);\n                        const dependencyName = (_b = (_a = dependencySpecifier.aliasTarget) === null || _a === void 0 ? void 0 : _a.packageName) !== null && _b !== void 0 ? _b : dependencySpecifier.packageName;\n                        // Skip if we can't find the local project or it's a cyclic dependency\n                        const localProject = this.rushConfiguration.getProjectByName(dependencyName);\n                        if (localProject && !this.decoupledLocalDependencies.has(dependency)) {\n                            // Set the value if it's a workspace project, or if we have a local project and the semver is satisfied\n                            switch (dependencySpecifier.specifierType) {\n                                case DependencySpecifierType.Version:\n                                case DependencySpecifierType.Range:\n                                    if (semver.satisfies(localProject.packageJson.version, dependencySpecifier.versionSpecifier)) {\n                                        dependencyProjects.add(localProject);\n                                    }\n                                    break;\n                                case DependencySpecifierType.Workspace:\n                                    dependencyProjects.add(localProject);\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dependencyProjects;\n    }\n    /**\n     * The set of projects within the Rush configuration which declare this project as a dependency.\n     * Excludes those that declare this project as a `cyclicDependencyProject`.\n     *\n     * @remarks\n     * This field is the counterpart to `dependencyProjects`, and can be used recursively to walk the project dependency\n     * graph to find all projects which will be impacted by changes to this project.\n     */\n    get consumingProjects() {\n        if (!this._consumingProjects) {\n            // Force initialize all dependency relationships\n            // This needs to operate on every project in the set because the relationships are only specified\n            // in the consuming project\n            const { projects } = this.rushConfiguration;\n            for (const project of projects) {\n                project._consumingProjects = new Set();\n            }\n            for (const project of projects) {\n                for (const dependency of project.dependencyProjects) {\n                    dependency._consumingProjects.add(project);\n                }\n            }\n        }\n        return this._consumingProjects;\n    }\n    /**\n     * A flag which indicates whether changes to this project should be published. This controls\n     * whether or not the project would show up when running `rush change`, and whether or not it\n     * should be published during `rush publish`.\n     */\n    get shouldPublish() {\n        return this._shouldPublish || !!this.versionPolicyName;\n    }\n    /**\n     * Version policy of the project\n     * @beta\n     */\n    get versionPolicy() {\n        if (!this._versionPolicy) {\n            if (this.versionPolicyName && this.rushConfiguration.versionPolicyConfiguration) {\n                this._versionPolicy = this.rushConfiguration.versionPolicyConfiguration.getVersionPolicy(this.versionPolicyName);\n            }\n        }\n        return this._versionPolicy;\n    }\n    /**\n     * Indicate whether this project is the main project for the related version policy.\n     *\n     * False if the project is not for publishing.\n     * True if the project is individually versioned or if its lockstep version policy does not specify main project.\n     * False if the project is lockstepped and is not the main project for its version policy.\n     *\n     * @beta\n     */\n    get isMainProject() {\n        if (!this.shouldPublish) {\n            return false;\n        }\n        let isMain = true;\n        if (this.versionPolicy && this.versionPolicy.isLockstepped) {\n            const lockStepPolicy = this.versionPolicy;\n            if (lockStepPolicy.mainProject && lockStepPolicy.mainProject !== this.packageName) {\n                isMain = false;\n            }\n        }\n        return isMain;\n    }\n}\nexport function validateRelativePathField(relativePath, field, file) {\n    // path.isAbsolute delegates depending on platform; however, path.posix.isAbsolute('C:/a') returns false,\n    // while path.win32.isAbsolute('C:/a') returns true. We want consistent validation across platforms.\n    if (path.posix.isAbsolute(relativePath) || path.win32.isAbsolute(relativePath)) {\n        throw new Error(`The value \"${relativePath}\" in the \"${field}\" field in \"${file}\" must be a relative path.`);\n    }\n    if (relativePath.includes('\\\\')) {\n        throw new Error(`The value \"${relativePath}\" in the \"${field}\" field in \"${file}\" may not contain backslashes ('\\\\'), since they are interpreted differently` +\n            ` on POSIX and Windows. Paths must use '/' as the path separator.`);\n    }\n    if (relativePath.endsWith('/')) {\n        throw new Error(`The value \"${relativePath}\" in the \"${field}\" field in \"${file}\" may not end with a trailing '/' character.`);\n    }\n    const normalized = path.posix.normalize(relativePath);\n    if (relativePath !== normalized) {\n        throw new Error(`The value \"${relativePath}\" in the \"${field}\" field in \"${file}\" should be replaced with its normalized form \"${normalized}\".`);\n    }\n}\n//# sourceMappingURL=RushConfigurationProject.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { Utilities } from '../utilities/Utilities';\nimport { EnvironmentConfiguration } from './EnvironmentConfiguration';\n/**\n * This class provides global folders that are used for rush's internal install locations.\n *\n * @internal\n */\nexport class RushGlobalFolder {\n    constructor() {\n        // Because RushGlobalFolder is used by the front-end VersionSelector before EnvironmentConfiguration\n        // is initialized, we need to read it using a special internal API.\n        const rushGlobalFolderOverride = EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);\n        if (rushGlobalFolderOverride !== undefined) {\n            this.path = rushGlobalFolderOverride;\n        }\n        else {\n            this.path = path.join(Utilities.getHomeFolder(), '.rush');\n        }\n        const normalizedNodeVersion = process.version.match(/^[a-z0-9\\-\\.]+$/i)\n            ? process.version\n            : 'unknown-version';\n        this.nodeSpecificPath = path.join(this.path, `node-${normalizedNodeVersion}`);\n    }\n}\n//# sourceMappingURL=RushGlobalFolder.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Rush } from './Rush';\n/**\n * Used by rush-sdk to access internals of rush-lib.\n * @internal\n */\nexport class RushInternals {\n    /**\n     * Used by rush-sdk to load an internal API specified by its module path.\n     *\n     * @param srcImportPath - The module path to load.  For example, to refer to `src/api/ChangeFile.ts`,\n     * the `srcImportPath` would be `\"api/ChangeFile\"`.\n     * @returns the module object as would be returned by `require()`\n     */\n    static loadModule(srcImportPath) {\n        const libPath = `${Rush._rushLibPackageFolder}/lib/${srcImportPath}`;\n        try {\n            return require(libPath);\n        }\n        catch (e) {\n            throw new Error(`The specified internal API \"src/${srcImportPath}\" is not implemented by Rush ${Rush.version}`);\n        }\n    }\n}\n//# sourceMappingURL=RushInternals.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport schemaJson from '../schemas/rush-plugins.schema.json';\nexport class RushPluginsConfiguration {\n    constructor(jsonFilename) {\n        this._jsonFilename = jsonFilename;\n        this.configuration = {\n            plugins: []\n        };\n        if (FileSystem.exists(this._jsonFilename)) {\n            this.configuration = JsonFile.loadAndValidate(this._jsonFilename, RushPluginsConfiguration._jsonSchema);\n        }\n    }\n}\nRushPluginsConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=RushPluginsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError, Async, Path } from '@rushstack/node-core-library';\nimport { ProjectConfigurationFile, InheritanceType } from '@rushstack/heft-config-file';\nimport { RigConfig } from '@rushstack/rig-package';\nimport { RushConstants } from '../logic/RushConstants';\nimport { OverlappingPathAnalyzer } from '../utilities/OverlappingPathAnalyzer';\nimport schemaJson from '../schemas/rush-project.schema.json';\nimport anythingSchemaJson from '../schemas/rush-project.schema.json';\nconst RUSH_PROJECT_CONFIGURATION_FILE = new ProjectConfigurationFile({\n    projectRelativeFilePath: `config/${RushConstants.rushProjectConfigFilename}`,\n    jsonSchemaObject: schemaJson,\n    propertyInheritance: {\n        operationSettings: {\n            inheritanceType: InheritanceType.custom,\n            inheritanceFunction: (child, parent) => {\n                if (!child) {\n                    return parent;\n                }\n                else if (!parent) {\n                    return child;\n                }\n                else {\n                    // Merge any properties that need to be merged\n                    const resultOperationSettingsByOperationName = new Map();\n                    for (const parentOperationSettings of parent) {\n                        resultOperationSettingsByOperationName.set(parentOperationSettings.operationName, parentOperationSettings);\n                    }\n                    const childEncounteredOperationNames = new Set();\n                    for (const childOperationSettings of child) {\n                        const operationName = childOperationSettings.operationName;\n                        if (childEncounteredOperationNames.has(operationName)) {\n                            // If the operation settings already exist, but didn't come from the parent, then\n                            // it shows up multiple times in the child.\n                            const childSourceFilePath = RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(child);\n                            throw new Error(`The operation \"${operationName}\" occurs multiple times in the \"operationSettings\" array ` +\n                                `in \"${childSourceFilePath}\".`);\n                        }\n                        childEncounteredOperationNames.add(operationName);\n                        let mergedOperationSettings = resultOperationSettingsByOperationName.get(operationName);\n                        if (mergedOperationSettings) {\n                            // The parent operation settings object already exists\n                            const outputFolderNames = mergedOperationSettings.outputFolderNames && childOperationSettings.outputFolderNames\n                                ? [\n                                    ...mergedOperationSettings.outputFolderNames,\n                                    ...childOperationSettings.outputFolderNames\n                                ]\n                                : mergedOperationSettings.outputFolderNames || childOperationSettings.outputFolderNames;\n                            const dependsOnEnvVars = mergedOperationSettings.dependsOnEnvVars && childOperationSettings.dependsOnEnvVars\n                                ? [\n                                    ...mergedOperationSettings.dependsOnEnvVars,\n                                    ...childOperationSettings.dependsOnEnvVars\n                                ]\n                                : mergedOperationSettings.dependsOnEnvVars || childOperationSettings.dependsOnEnvVars;\n                            mergedOperationSettings = Object.assign(Object.assign(Object.assign(Object.assign({}, mergedOperationSettings), childOperationSettings), (outputFolderNames ? { outputFolderNames } : {})), (dependsOnEnvVars ? { dependsOnEnvVars } : {}));\n                            resultOperationSettingsByOperationName.set(operationName, mergedOperationSettings);\n                        }\n                        else {\n                            resultOperationSettingsByOperationName.set(operationName, childOperationSettings);\n                        }\n                    }\n                    return Array.from(resultOperationSettingsByOperationName.values());\n                }\n            }\n        },\n        incrementalBuildIgnoredGlobs: {\n            inheritanceType: InheritanceType.replace\n        }\n    }\n});\nconst OLD_RUSH_PROJECT_CONFIGURATION_FILE = new ProjectConfigurationFile({\n    projectRelativeFilePath: RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath,\n    jsonSchemaObject: anythingSchemaJson\n});\n/**\n * Use this class to load the \"config/rush-project.json\" config file.\n *\n * This file provides project-specific configuration options.\n * @alpha\n */\nexport class RushProjectConfiguration {\n    constructor(project, rushProjectJson, operationSettingsByOperationName) {\n        this._validationCache = new WeakSet();\n        this.project = project;\n        this.incrementalBuildIgnoredGlobs = rushProjectJson.incrementalBuildIgnoredGlobs || [];\n        this.disableBuildCacheForProject = rushProjectJson.disableBuildCacheForProject || false;\n        this.operationSettingsByOperationName = operationSettingsByOperationName;\n    }\n    /**\n     * Validates that the requested phases are compatible.\n     * Deferral of this logic to its own method means that Rush no longer eagerly validates\n     * all defined commands in command-line.json. As such, while validation will be run for a given\n     * command upon invoking that command, defining overlapping phases in \"rush custom-command\"\n     * that are not used by \"rush build\" will not cause \"rush build\" to exit with an error.\n     */\n    validatePhaseConfiguration(phases, terminal) {\n        // Don't repeatedly validate the same set of phases for the same project.\n        if (this._validationCache.has(phases)) {\n            return;\n        }\n        const overlappingPathAnalyzer = new OverlappingPathAnalyzer();\n        const { operationSettingsByOperationName, project } = this;\n        let hasErrors = false;\n        for (const phase of phases) {\n            const operationName = phase.name;\n            const operationSettings = operationSettingsByOperationName.get(operationName);\n            if (operationSettings) {\n                if (operationSettings.outputFolderNames) {\n                    for (const outputFolderName of operationSettings.outputFolderNames) {\n                        const otherOverlappingOperationNames = overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(outputFolderName, operationName);\n                        if (otherOverlappingOperationNames) {\n                            const overlapsWithOwnOperation = otherOverlappingOperationNames === null || otherOverlappingOperationNames === void 0 ? void 0 : otherOverlappingOperationNames.includes(operationName);\n                            if (overlapsWithOwnOperation) {\n                                terminal.writeErrorLine(`The project \"${project.packageName}\" has a ` +\n                                    `\"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" configuration that defines an ` +\n                                    `operation with overlapping paths in the \"outputFolderNames\" list. The operation is ` +\n                                    `\"${operationName}\", and the conflicting path is \"${outputFolderName}\".`);\n                            }\n                            else {\n                                terminal.writeErrorLine(`The project \"${project.packageName}\" has a ` +\n                                    `\"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" configuration that defines ` +\n                                    'two operations in the same command whose \"outputFolderNames\" would overlap. ' +\n                                    'Operations outputs in the same command must be disjoint so that they can be independently cached. ' +\n                                    `The \"${outputFolderName}\" path overlaps between these operations: ` +\n                                    `\"${operationName}\", \"${otherOverlappingOperationNames.join('\", \"')}\"`);\n                            }\n                            hasErrors = true;\n                        }\n                    }\n                }\n            }\n        }\n        this._validationCache.add(phases);\n        if (hasErrors) {\n            throw new AlreadyReportedError();\n        }\n    }\n    /**\n     * Examines the list of source files for the project and the target phase and returns a reason\n     * why the project cannot enable the build cache for that phase, or undefined if it is safe to so do.\n     */\n    getCacheDisabledReason(trackedFileNames, phaseName, isNoOp) {\n        // Skip no-op operations as they won't have any output/cacheable things.\n        if (isNoOp) {\n            return undefined;\n        }\n        if (this.disableBuildCacheForProject) {\n            return 'Caching has been disabled for this project.';\n        }\n        const operationSettings = this.operationSettingsByOperationName.get(phaseName);\n        if (!operationSettings) {\n            return `This project does not define the caching behavior of the \"${phaseName}\" command, so caching has been disabled.`;\n        }\n        if (operationSettings.disableBuildCacheForOperation) {\n            return `Caching has been disabled for this project's \"${phaseName}\" command.`;\n        }\n        const { outputFolderNames } = operationSettings;\n        if (!outputFolderNames) {\n            return;\n        }\n        const normalizedProjectRelativeFolder = Path.convertToSlashes(this.project.projectRelativeFolder);\n        const normalizedOutputFolders = outputFolderNames.map((outputFolderName) => `${normalizedProjectRelativeFolder}/${outputFolderName}/`);\n        const inputOutputFiles = [];\n        for (const file of trackedFileNames) {\n            for (const outputFolder of normalizedOutputFolders) {\n                if (file.startsWith(outputFolder)) {\n                    inputOutputFiles.push(file);\n                }\n            }\n        }\n        if (inputOutputFiles.length > 0) {\n            return ('The following files are used to calculate project state ' +\n                `and are considered project output: ${inputOutputFiles.join(', ')}`);\n        }\n    }\n    /**\n     * Source of truth for whether a project is unable to use the build cache for a given phase.\n     * As some operations may not have a rush-project.json file defined at all, but may be no-op operations\n     *  we'll want to ignore those completely.\n     */\n    static getCacheDisabledReasonForProject(options) {\n        const { projectConfiguration, trackedFileNames, phaseName, isNoOp } = options;\n        if (isNoOp) {\n            return undefined;\n        }\n        if (!projectConfiguration) {\n            return (`Project does not have a ${RushConstants.rushProjectConfigFilename} configuration file, ` +\n                'or one provided by a rig, so it does not support caching.');\n        }\n        return projectConfiguration.getCacheDisabledReason(trackedFileNames, phaseName, isNoOp);\n    }\n    /**\n     * Loads the rush-project.json data for the specified project.\n     */\n    static async tryLoadForProjectAsync(project, terminal) {\n        // false is a signal that the project config does not exist\n        const cacheEntry = RushProjectConfiguration._configCache.get(project);\n        if (cacheEntry !== undefined) {\n            return cacheEntry || undefined;\n        }\n        const rushProjectJson = await this._tryLoadJsonForProjectAsync(project, terminal);\n        if (rushProjectJson) {\n            const result = RushProjectConfiguration._getRushProjectConfiguration(project, rushProjectJson, terminal);\n            RushProjectConfiguration._configCache.set(project, result);\n            return result;\n        }\n        else {\n            RushProjectConfiguration._configCache.set(project, false);\n            return undefined;\n        }\n    }\n    /**\n     * Load only the `incrementalBuildIgnoredGlobs` property from the rush-project.json file, skipping\n     * validation of other parts of the config file.\n     *\n     * @remarks\n     * This function exists to allow the ProjectChangeAnalyzer to load just the ignore globs without\n     * having to validate the rest of the `rush-project.json` file against the repo's command-line configuration.\n     */\n    static async tryLoadIgnoreGlobsForProjectAsync(project, terminal) {\n        const rushProjectJson = await this._tryLoadJsonForProjectAsync(project, terminal);\n        return rushProjectJson === null || rushProjectJson === void 0 ? void 0 : rushProjectJson.incrementalBuildIgnoredGlobs;\n    }\n    /**\n     * Load the rush-project.json data for all selected projects.\n     * Validate compatibility of output folders across all selected phases.\n     */\n    static async tryLoadForProjectsAsync(projects, terminal) {\n        const result = new Map();\n        await Async.forEachAsync(projects, async (project) => {\n            const projectConfig = await RushProjectConfiguration.tryLoadForProjectAsync(project, terminal);\n            if (projectConfig) {\n                result.set(project, projectConfig);\n            }\n        }, { concurrency: 50 });\n        return result;\n    }\n    static async _tryLoadJsonForProjectAsync(project, terminal) {\n        const rigConfig = await RigConfig.loadForProjectFolderAsync({\n            projectFolderPath: project.projectFolder\n        });\n        try {\n            return await RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);\n        }\n        catch (e1) {\n            // Detect if the project is using the old rush-project.json schema\n            let oldRushProjectJson;\n            try {\n                oldRushProjectJson =\n                    await OLD_RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);\n            }\n            catch (e2) {\n                // Ignore\n            }\n            if ((oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.projectOutputFolderNames) ||\n                (oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.phaseOptions) ||\n                (oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.buildCacheOptions)) {\n                throw new Error(`The ${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file appears to be ` +\n                    'in an outdated format. Please see the UPGRADING.md notes for details. ' +\n                    'Quick link: https://rushjs.io/link/upgrading');\n            }\n            else {\n                throw e1;\n            }\n        }\n    }\n    static _getRushProjectConfiguration(project, rushProjectJson, terminal) {\n        var _a;\n        const operationSettingsByOperationName = new Map();\n        let hasErrors = false;\n        if (rushProjectJson.operationSettings) {\n            for (const operationSettings of rushProjectJson.operationSettings) {\n                const operationName = operationSettings.operationName;\n                const existingOperationSettings = operationSettingsByOperationName.get(operationName);\n                if (existingOperationSettings) {\n                    const existingOperationSettingsJsonPath = RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(existingOperationSettings);\n                    const operationSettingsJsonPath = RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(operationSettings);\n                    hasErrors = true;\n                    let errorMessage = `The operation \"${operationName}\" appears multiple times in the \"${project.packageName}\" project's ` +\n                        `${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file's ` +\n                        'operationSettings property.';\n                    if (existingOperationSettingsJsonPath && operationSettingsJsonPath) {\n                        if (existingOperationSettingsJsonPath !== operationSettingsJsonPath) {\n                            errorMessage +=\n                                ` It first appears in \"${existingOperationSettingsJsonPath}\" and again ` +\n                                    `in \"${operationSettingsJsonPath}\".`;\n                        }\n                        else if (!Path.convertToSlashes(existingOperationSettingsJsonPath).startsWith(Path.convertToSlashes(project.projectFolder))) {\n                            errorMessage += ` It appears multiple times in \"${operationSettingsJsonPath}\".`;\n                        }\n                    }\n                    terminal.writeErrorLine(errorMessage);\n                }\n                else {\n                    operationSettingsByOperationName.set(operationName, operationSettings);\n                }\n            }\n            for (const [operationName, operationSettings] of operationSettingsByOperationName) {\n                if ((_a = operationSettings.sharding) === null || _a === void 0 ? void 0 : _a.shardOperationSettings) {\n                    terminal.writeWarningLine(`DEPRECATED: The \"sharding.shardOperationSettings\" field is deprecated. Please create a new operation, '${operationName}:shard' to track shard operation settings.`);\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new AlreadyReportedError();\n        }\n        return new RushProjectConfiguration(project, rushProjectJson, operationSettingsByOperationName);\n    }\n}\nRushProjectConfiguration._configCache = new Map();\n//# sourceMappingURL=RushProjectConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport * as path from 'path';\nimport { Utilities } from '../utilities/Utilities';\nimport { RushConstants } from '../logic/RushConstants';\nimport schemaJson from '../schemas/rush-user-settings.schema.json';\n/**\n * Rush per-user configuration data.\n *\n * @beta\n */\nexport class RushUserConfiguration {\n    constructor(rushUserConfigurationJson) {\n        this.buildCacheFolder = rushUserConfigurationJson === null || rushUserConfigurationJson === void 0 ? void 0 : rushUserConfigurationJson.buildCacheFolder;\n        if (this.buildCacheFolder && !path.isAbsolute(this.buildCacheFolder)) {\n            throw new Error('buildCacheFolder must be an absolute path');\n        }\n    }\n    static async initializeAsync() {\n        const rushUserFolderPath = RushUserConfiguration.getRushUserFolderPath();\n        const rushUserSettingsFilePath = path.join(rushUserFolderPath, 'settings.json');\n        let rushUserSettingsJson;\n        try {\n            rushUserSettingsJson = await JsonFile.loadAndValidateAsync(rushUserSettingsFilePath, RushUserConfiguration._schema);\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n        return new RushUserConfiguration(rushUserSettingsJson);\n    }\n    static getRushUserFolderPath() {\n        const homeFolderPath = Utilities.getHomeFolder();\n        const rushUserSettingsFilePath = path.join(homeFolderPath, RushConstants.rushUserConfigurationFolderName);\n        return rushUserSettingsFilePath;\n    }\n}\nRushUserConfiguration._schema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=RushUserConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageJsonEditor } from './PackageJsonEditor';\nexport class SaveCallbackPackageJsonEditor extends PackageJsonEditor {\n    constructor(options) {\n        super(options.filename, options.object);\n        this._onSaved = options.onSaved;\n    }\n    static fromObjectWithCallback(options) {\n        return new SaveCallbackPackageJsonEditor(options);\n    }\n    saveIfModified() {\n        const modified = super.saveIfModified();\n        if (this._onSaved) {\n            this._onSaved(this.saveToObject());\n        }\n        return modified;\n    }\n}\n//# sourceMappingURL=SaveCallbackPackageJsonEditor.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport { FileSystem } from '@rushstack/node-core-library';\nimport { EnvironmentConfiguration } from './EnvironmentConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\nimport { CommonVersionsConfiguration } from './CommonVersionsConfiguration';\nimport { RepoStateFile } from '../logic/RepoStateFile';\nimport { PnpmOptionsConfiguration } from '../logic/pnpm/PnpmOptionsConfiguration';\nimport { SubspacePnpmfileConfiguration } from '../logic/pnpm/SubspacePnpmfileConfiguration';\n/**\n * This represents the subspace configurations for a repository, based on the \"subspaces.json\"\n * configuration file.\n * @public\n */\nexport class Subspace {\n    constructor(options) {\n        this._projects = [];\n        this._commonVersionsConfiguration = undefined;\n        this._cachedPnpmOptions = undefined;\n        // If true, then _cachedPnpmOptions has been initialized.\n        this._cachedPnpmOptionsInitialized = false;\n        this.subspaceName = options.subspaceName;\n        this._rushConfiguration = options.rushConfiguration;\n        this._splitWorkspaceCompatibility = options.splitWorkspaceCompatibility;\n    }\n    /**\n     * Returns the list of projects belonging to this subspace.\n     * @beta\n     */\n    getProjects() {\n        return this._projects;\n    }\n    /**\n     * Returns the parsed contents of the pnpm-config.json config file.\n     * @beta\n     */\n    getPnpmOptions() {\n        if (!this._cachedPnpmOptionsInitialized) {\n            // Calculate these outside the try/catch block since their error messages shouldn't be annotated:\n            const subspaceTempFolder = this.getSubspaceTempFolderPath();\n            try {\n                this._cachedPnpmOptions = PnpmOptionsConfiguration.loadFromJsonFileOrThrow(this.getPnpmConfigFilePath(), subspaceTempFolder);\n                this._cachedPnpmOptionsInitialized = true;\n            }\n            catch (e) {\n                if (FileSystem.isNotExistError(e)) {\n                    this._cachedPnpmOptions = undefined;\n                    this._cachedPnpmOptionsInitialized = true;\n                }\n                else {\n                    throw new Error(`The subspace \"${this.subspaceName}\" has an invalid pnpm-config.json file:\\n` + e.message);\n                }\n            }\n        }\n        return this._cachedPnpmOptions;\n    }\n    _ensureDetail() {\n        if (!this._detail) {\n            const rushConfiguration = this._rushConfiguration;\n            let subspaceConfigFolderPath;\n            let subspacePnpmPatchesFolderPath;\n            if (rushConfiguration.subspacesFeatureEnabled) {\n                if (!rushConfiguration.pnpmOptions.useWorkspaces) {\n                    throw new Error(`The Rush subspaces feature is enabled.  You must set useWorkspaces=true in pnpm-config.json.`);\n                }\n                // If this subspace doesn't have a configuration folder, check if it is in the project folder itself\n                // if the splitWorkspaceCompatibility option is enabled in the subspace configuration\n                // Example: C:\\MyRepo\\common\\config\\subspaces\\my-subspace\n                const standardSubspaceConfigFolder = `${rushConfiguration.commonFolder}/config/subspaces/${this.subspaceName}`;\n                subspaceConfigFolderPath = standardSubspaceConfigFolder;\n                if (this._splitWorkspaceCompatibility && this.subspaceName.startsWith('split_')) {\n                    if (FileSystem.exists(standardSubspaceConfigFolder + '/pnpm-lock.yaml')) {\n                        throw new Error(`The split workspace subspace \"${this.subspaceName}\" cannot use a common/config folder: ` +\n                            standardSubspaceConfigFolder);\n                    }\n                    if (this._projects.length !== 1) {\n                        throw new Error(`The split workspace subspace \"${this.subspaceName}\" contains ${this._projects.length}` +\n                            ` projects; there must be exactly one project.`);\n                    }\n                    const project = this._projects[0];\n                    subspaceConfigFolderPath = `${project.projectFolder}/subspace/${this.subspaceName}`;\n                    // Ensure that this project does not have it's own pnpmfile.cjs or .npmrc file\n                    if (FileSystem.exists(`${project.projectFolder}/.npmrc`)) {\n                        throw new Error(`The project level configuration file ${project.projectFolder}/.npmrc is no longer valid. Please use a ${subspaceConfigFolderPath}/.npmrc file instead.`);\n                    }\n                    if (FileSystem.exists(`${project.projectFolder}/.pnpmfile.cjs`)) {\n                        throw new Error(`The project level configuration file ${project.projectFolder}/.pnpmfile.cjs is no longer valid. Please use a ${subspaceConfigFolderPath}/.pnpmfile.cjs file instead.`);\n                    }\n                }\n                if (!FileSystem.exists(subspaceConfigFolderPath)) {\n                    throw new Error(`The configuration folder for the \"${this.subspaceName}\" subspace does not exist: ` +\n                        subspaceConfigFolderPath);\n                }\n                subspacePnpmPatchesFolderPath = `${subspaceConfigFolderPath}/${RushConstants.pnpmPatchesCommonFolderName}`;\n            }\n            else {\n                // Example: C:\\MyRepo\\common\\config\\rush\n                subspaceConfigFolderPath = rushConfiguration.commonRushConfigFolder;\n                // Example: C:\\MyRepo\\common\\pnpm-patches\n                subspacePnpmPatchesFolderPath = `${rushConfiguration.commonFolder}/${RushConstants.pnpmPatchesCommonFolderName}`;\n            }\n            // Example: C:\\MyRepo\\common\\temp\n            const commonTempFolder = EnvironmentConfiguration.rushTempFolderOverride || rushConfiguration.commonTempFolder;\n            let subspaceTempFolderPath;\n            if (rushConfiguration.subspacesFeatureEnabled) {\n                // Example: C:\\MyRepo\\common\\temp\\my-subspace\n                subspaceTempFolderPath = `${commonTempFolder}/${this.subspaceName}`;\n            }\n            else {\n                // Example: C:\\MyRepo\\common\\temp\n                subspaceTempFolderPath = commonTempFolder;\n            }\n            // Example: C:\\MyRepo\\common\\temp\\my-subspace\\pnpm-lock.yaml\n            const tempShrinkwrapFilePath = `${subspaceTempFolderPath}/${rushConfiguration.shrinkwrapFilename}`;\n            /// From \"C:\\MyRepo\\common\\temp\\pnpm-lock.yaml\" --> \"C:\\MyRepo\\common\\temp\\pnpm-lock-preinstall.yaml\"\n            const parsedPath = path.parse(tempShrinkwrapFilePath);\n            const tempShrinkwrapPreinstallFilePath = `${parsedPath.dir}/${parsedPath.name}-preinstall${parsedPath.ext}`;\n            this._detail = {\n                subspaceConfigFolderPath,\n                subspacePnpmPatchesFolderPath,\n                subspaceTempFolderPath,\n                tempShrinkwrapFilePath,\n                tempShrinkwrapPreinstallFilePath\n            };\n        }\n        return this._detail;\n    }\n    /**\n     * Returns the full path of the folder containing this subspace's variant-dependent configuration files\n     * such as `pnpm-lock.yaml`.\n     *\n     * Example: `common/config/subspaces/my-subspace` or `common/config/subspaces/my-subspace/variants/my-variant`\n     * @beta\n     *\n     * @remarks\n     * The following files may be variant-dependent:\n     * - Lockfiles: (i.e. - `pnpm-lock.yaml`, `npm-shrinkwrap.json`, `yarn.lock`, etc)\n     * - 'common-versions.json'\n     * - 'pnpmfile.js'/'.pnpmfile.cjs'\n     */\n    getVariantDependentSubspaceConfigFolderPath(variant) {\n        const subspaceConfigFolderPath = this.getSubspaceConfigFolderPath();\n        if (!variant) {\n            return subspaceConfigFolderPath;\n        }\n        else {\n            return `${subspaceConfigFolderPath}/${RushConstants.rushVariantsFolderName}/${variant}`;\n        }\n    }\n    /**\n     * Returns the full path of the folder containing this subspace's configuration files such as `pnpm-lock.yaml`.\n     *\n     * Example: `common/config/subspaces/my-subspace`\n     * @beta\n     */\n    getSubspaceConfigFolderPath() {\n        return this._ensureDetail().subspaceConfigFolderPath;\n    }\n    /**\n     * Returns the full path of the folder containing this subspace's configuration files such as `pnpm-lock.yaml`.\n     *\n     * Example: `common/config/subspaces/my-subspace/pnpm-patches` (subspaces feature enabled)\n     * Example: `common/config/pnpm-patches` (subspaces feature disabled)\n     * @beta\n     */\n    getSubspacePnpmPatchesFolderPath() {\n        return this._ensureDetail().subspacePnpmPatchesFolderPath;\n    }\n    /**\n     * The folder where the subspace's node_modules and other temporary files will be stored.\n     *\n     * Example: `common/temp/subspaces/my-subspace`\n     * @beta\n     */\n    getSubspaceTempFolderPath() {\n        return this._ensureDetail().subspaceTempFolderPath;\n    }\n    /**\n     * Returns full path of the temporary shrinkwrap file for a specific subspace and returns the common workspace\n     * shrinkwrap if no subspaceName is provided.\n     * @remarks\n     * This function takes the subspace name, and returns the full path for the subspace's shrinkwrap file.\n     * This function also consults the deprecated option to allow for shrinkwraps to be stored under a package folder.\n     * This shrinkwrap file is used during \"rush install\", and may be rewritten by the package manager during installation\n     * This property merely reports the filename, the file itself may not actually exist.\n     * example: `C:\\MyRepo\\common\\<subspace_name>\\pnpm-lock.yaml`\n     * @beta\n     */\n    getTempShrinkwrapFilename() {\n        return this._ensureDetail().tempShrinkwrapFilePath;\n    }\n    /**\n     * @deprecated - Use {@link Subspace.getTempShrinkwrapPreinstallFilePath} instead.\n     */\n    getTempShrinkwrapPreinstallFilename(subspaceName) {\n        return this.getTempShrinkwrapPreinstallFilePath();\n    }\n    /**\n     * The full path of a backup copy of tempShrinkwrapFilename. This backup copy is made\n     * before installation begins, and can be compared to determine how the package manager\n     * modified tempShrinkwrapFilename.\n     * @remarks\n     * This property merely reports the filename; the file itself may not actually exist.\n     * Example: `C:\\MyRepo\\common\\temp\\npm-shrinkwrap-preinstall.json`\n     * or `C:\\MyRepo\\common\\temp\\pnpm-lock-preinstall.yaml`\n     * @beta\n     */\n    getTempShrinkwrapPreinstallFilePath() {\n        return this._ensureDetail().tempShrinkwrapPreinstallFilePath;\n    }\n    /**\n     * Gets the path to the common-versions.json config file for this subspace.\n     *\n     * Example: `C:\\MyRepo\\common\\subspaces\\my-subspace\\common-versions.json`\n     * @beta\n     */\n    getCommonVersionsFilePath(variant) {\n        return (this.getVariantDependentSubspaceConfigFolderPath(variant) + '/' + RushConstants.commonVersionsFilename);\n    }\n    /**\n     * Gets the path to the pnpm-config.json config file for this subspace.\n     *\n     * Example: `C:\\MyRepo\\common\\subspaces\\my-subspace\\pnpm-config.json`\n     * @beta\n     */\n    getPnpmConfigFilePath() {\n        return this.getSubspaceConfigFolderPath() + '/' + RushConstants.pnpmConfigFilename;\n    }\n    /**\n     * Gets the settings from the common-versions.json config file.\n     * @beta\n     */\n    getCommonVersions(variant) {\n        const commonVersionsFilePath = this.getCommonVersionsFilePath(variant);\n        if (!this._commonVersionsConfiguration) {\n            this._commonVersionsConfiguration = CommonVersionsConfiguration.loadFromFile(commonVersionsFilePath, this._rushConfiguration);\n        }\n        return this._commonVersionsConfiguration;\n    }\n    /**\n     * Gets the ensureConsistentVersions property from the common-versions.json config file,\n     * or from the rush.json file if it isn't defined in common-versions.json\n     * @beta\n     */\n    shouldEnsureConsistentVersions(variant) {\n        // If the ensureConsistentVersions field is defined, return the value of the field\n        const commonVersions = this.getCommonVersions(variant);\n        if (commonVersions.ensureConsistentVersions !== undefined) {\n            return commonVersions.ensureConsistentVersions;\n        }\n        // Fallback to ensureConsistentVersions in rush.json if the setting is not defined in\n        // the common-versions.json file\n        return this._rushConfiguration.ensureConsistentVersions;\n    }\n    /**\n     * Gets the path to the repo-state.json file.\n     * @beta\n     */\n    getRepoStateFilePath() {\n        return this.getSubspaceConfigFolderPath() + '/' + RushConstants.repoStateFilename;\n    }\n    /**\n     * Gets the contents from the repo-state.json file.\n     * @param subspaceName - The name of the subspace in use by the active command.\n     * @beta\n     */\n    getRepoState() {\n        const repoStateFilePath = this.getRepoStateFilePath();\n        return RepoStateFile.loadFromFile(repoStateFilePath);\n    }\n    /**\n     * @deprecated - Use {@link Subspace.getCommittedShrinkwrapFilePath} instead.\n     */\n    getCommittedShrinkwrapFilename() {\n        return this.getCommittedShrinkwrapFilePath(undefined);\n    }\n    /**\n     * Gets the committed shrinkwrap file name for a specific variant.\n     * @param variant - The name of the current variant in use by the active command.\n     * @beta\n     */\n    getCommittedShrinkwrapFilePath(variant) {\n        const subspaceConfigFolderPath = this.getVariantDependentSubspaceConfigFolderPath(variant);\n        return `${subspaceConfigFolderPath}/${this._rushConfiguration.shrinkwrapFilename}`;\n    }\n    /**\n     * Gets the absolute path for \"pnpmfile.js\" for a specific subspace.\n     * @param subspace - The name of the current subspace in use by the active command.\n     * @remarks\n     * The file path is returned even if PNPM is not configured as the package manager.\n     * @beta\n     */\n    getPnpmfilePath(variant) {\n        const subspaceConfigFolderPath = this.getVariantDependentSubspaceConfigFolderPath(variant);\n        const pnpmFilename = this._rushConfiguration.packageManagerWrapper\n            .pnpmfileFilename;\n        return `${subspaceConfigFolderPath}/${pnpmFilename}`;\n    }\n    /**\n     * Returns true if the specified project belongs to this subspace.\n     * @beta\n     */\n    contains(project) {\n        return project.subspace.subspaceName === this.subspaceName;\n    }\n    /** @internal */\n    _addProject(project) {\n        this._projects.push(project);\n    }\n    /**\n     * Returns hash value of injected dependencies in related package.json.\n     * @beta\n     */\n    getPackageJsonInjectedDependenciesHash(variant) {\n        var _a;\n        const allPackageJson = [];\n        const relatedProjects = [];\n        const subspacePnpmfileShimSettings = SubspacePnpmfileConfiguration.getSubspacePnpmfileShimSettings(this._rushConfiguration, this, variant);\n        for (const rushProject of this.getProjects()) {\n            const injectedDependencies = ((_a = subspacePnpmfileShimSettings === null || subspacePnpmfileShimSettings === void 0 ? void 0 : subspacePnpmfileShimSettings.subspaceProjects[rushProject.packageName]) === null || _a === void 0 ? void 0 : _a.injectedDependencies) || [];\n            if (injectedDependencies.length === 0) {\n                continue;\n            }\n            const injectedDependencySet = new Set(injectedDependencies);\n            for (const dependencyProject of rushProject.dependencyProjects) {\n                if (injectedDependencySet.has(dependencyProject.packageName)) {\n                    relatedProjects.push(dependencyProject);\n                }\n            }\n        }\n        // this means no injected dependencies found for current subspace\n        if (relatedProjects.length === 0) {\n            return undefined;\n        }\n        const allWorkspaceProjectSet = new Set(this._rushConfiguration.projects.map((rushProject) => rushProject.packageName));\n        // get all related package.json\n        while (relatedProjects.length > 0) {\n            const rushProject = relatedProjects.pop();\n            // collect fields that could update the `pnpm-lock.yaml`\n            const { name, bin, dependencies, devDependencies, peerDependencies, optionalDependencies, dependenciesMeta, peerDependenciesMeta, resolutions } = rushProject.packageJson;\n            // special handing for peerDependencies\n            // for workspace packages, the version range is meaningless here.\n            if (peerDependencies) {\n                for (const packageName of Object.keys(peerDependencies)) {\n                    if (allWorkspaceProjectSet.has(packageName)) {\n                        peerDependencies[packageName] = 'workspace:*';\n                    }\n                }\n            }\n            allPackageJson.push({\n                name,\n                bin,\n                dependencies,\n                devDependencies,\n                peerDependencies,\n                optionalDependencies,\n                dependenciesMeta,\n                peerDependenciesMeta,\n                resolutions\n            });\n            relatedProjects.push(...rushProject.dependencyProjects);\n        }\n        const collator = new Intl.Collator('en');\n        allPackageJson.sort((pa, pb) => collator.compare(pa.name, pb.name));\n        const hash = crypto.createHash('sha1');\n        for (const packageFile of allPackageJson) {\n            hash.update(JSON.stringify(packageFile));\n        }\n        const packageJsonInjectedDependenciesHash = hash.digest('hex');\n        return packageJsonInjectedDependenciesHash;\n    }\n}\n//# sourceMappingURL=Subspace.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport schemaJson from '../schemas/subspaces.schema.json';\nimport { RushConstants } from '../logic/RushConstants';\n/**\n * The allowed naming convention for subspace names.\n * Allows for names to be formed of identifiers separated by hyphens (-)\n *\n * Example: \"my-subspace\"\n */\nexport const SUBSPACE_NAME_REGEXP = /^[a-z][a-z0-9]*(-[a-z0-9]+)*$/;\nexport const SPLIT_WORKSPACE_SUBSPACE_NAME_REGEXP = /^[a-z0-9][+_\\-a-z0-9]*$/;\n/**\n * This represents the subspace configurations for a repository, based on the \"subspaces.json\"\n * configuration file.\n * @beta\n */\nexport class SubspacesConfiguration {\n    constructor(configuration, subspaceJsonFilePath) {\n        this.subspaceJsonFilePath = subspaceJsonFilePath;\n        this.subspacesEnabled = configuration.subspacesEnabled;\n        this.splitWorkspaceCompatibility = !!configuration.splitWorkspaceCompatibility;\n        this.preventSelectingAllSubspaces = !!configuration.preventSelectingAllSubspaces;\n        const subspaceNames = new Set();\n        for (const subspaceName of configuration.subspaceNames) {\n            SubspacesConfiguration.requireValidSubspaceName(subspaceName, this.splitWorkspaceCompatibility);\n            subspaceNames.add(subspaceName);\n        }\n        // Add the default subspace if it wasn't explicitly declared\n        subspaceNames.add(RushConstants.defaultSubspaceName);\n        this.subspaceNames = subspaceNames;\n    }\n    /**\n     * Checks whether the provided string could be used as a subspace name.\n     * Returns `undefined` if the name is valid; otherwise returns an error message.\n     * @remarks\n     * This is a syntax check only; it does not test whether the subspace is actually defined in the Rush configuration.\n     */\n    static explainIfInvalidSubspaceName(subspaceName, splitWorkspaceCompatibility = false) {\n        if (subspaceName.length === 0) {\n            return `The subspace name cannot be empty`;\n        }\n        let regexToUse;\n        if (splitWorkspaceCompatibility) {\n            regexToUse = SPLIT_WORKSPACE_SUBSPACE_NAME_REGEXP;\n        }\n        else {\n            regexToUse = SUBSPACE_NAME_REGEXP;\n        }\n        if (!regexToUse.test(subspaceName)) {\n            if (splitWorkspaceCompatibility) {\n                return (`Invalid name \"${subspaceName}\". ` +\n                    `Subspace names must consist of lowercase letters and numbers separated by hyphens, underscores, or plus signs.`);\n            }\n            return (`Invalid name \"${subspaceName}\". ` +\n                `Subspace names must consist of lowercase letters and numbers separated by hyphens.`);\n        }\n        return undefined; // name is okay\n    }\n    /**\n     * Checks whether the provided string could be used as a subspace name.\n     * If not, an exception is thrown.\n     * @remarks\n     * This is a syntax check only; it does not test whether the subspace is actually defined in the Rush configuration.\n     */\n    static requireValidSubspaceName(subspaceName, splitWorkspaceCompatibility = false) {\n        const message = SubspacesConfiguration.explainIfInvalidSubspaceName(subspaceName, splitWorkspaceCompatibility);\n        if (message) {\n            throw new Error(message);\n        }\n    }\n    static tryLoadFromConfigurationFile(subspaceJsonFilePath) {\n        let configuration;\n        try {\n            configuration = JsonFile.loadAndValidate(subspaceJsonFilePath, SubspacesConfiguration._jsonSchema);\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n        if (configuration) {\n            return new SubspacesConfiguration(configuration, subspaceJsonFilePath);\n        }\n    }\n    static tryLoadFromDefaultLocation(rushConfiguration) {\n        const commonRushConfigFolder = rushConfiguration.commonRushConfigFolder;\n        const subspaceJsonLocation = `${commonRushConfigFolder}/${RushConstants.subspacesConfigFilename}`;\n        return SubspacesConfiguration.tryLoadFromConfigurationFile(subspaceJsonLocation);\n    }\n}\nSubspacesConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=SubspacesConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { EnvironmentVariableNames } from './EnvironmentConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\n/**\n * Provides the parameter configuration for '--variant'.\n */\nexport const VARIANT_PARAMETER = {\n    parameterLongName: '--variant',\n    argumentName: 'VARIANT',\n    description: 'Run command using a variant installation configuration',\n    environmentVariable: EnvironmentVariableNames.RUSH_VARIANT\n};\nexport async function getVariantAsync(variantsParameter, rushConfiguration, defaultToCurrentlyInstalledVariant) {\n    let variant = variantsParameter === null || variantsParameter === void 0 ? void 0 : variantsParameter.value;\n    if (variant && !rushConfiguration.variants.has(variant)) {\n        throw new Error(`The variant \"${variant}\" is not defined in ${RushConstants.rushJsonFilename}`);\n    }\n    if (!variant && defaultToCurrentlyInstalledVariant) {\n        variant = await rushConfiguration.getCurrentlyInstalledVariantAsync();\n    }\n    return variant;\n}\n//# sourceMappingURL=Variants.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { Enum } from '@rushstack/node-core-library';\nimport { VersionFormatForCommit, VersionFormatForPublish } from './VersionPolicyConfiguration';\nimport { cloneDeep } from '../utilities/objectUtilities';\n/**\n * Type of version bumps\n * @public\n *\n * @internalRemarks\n * This is a copy of the semver ReleaseType enum, but with the `none` value added and\n * the `premajor` and `prepatch` omitted.\n * See {@link LockStepVersionPolicy._getReleaseType}.\n *\n * TODO: Consider supporting `premajor` and `prepatch` in the future.\n */\nexport var BumpType;\n(function (BumpType) {\n    // No version bump\n    BumpType[BumpType[\"none\"] = 0] = \"none\";\n    // Prerelease version bump\n    BumpType[BumpType[\"prerelease\"] = 1] = \"prerelease\";\n    // Patch version bump\n    BumpType[BumpType[\"patch\"] = 2] = \"patch\";\n    // Preminor version bump\n    BumpType[BumpType[\"preminor\"] = 3] = \"preminor\";\n    // Minor version bump\n    BumpType[BumpType[\"minor\"] = 4] = \"minor\";\n    // Major version bump\n    BumpType[BumpType[\"major\"] = 5] = \"major\";\n})(BumpType || (BumpType = {}));\n/**\n * Version policy base type names\n * @public\n */\nexport var VersionPolicyDefinitionName;\n(function (VersionPolicyDefinitionName) {\n    VersionPolicyDefinitionName[VersionPolicyDefinitionName[\"lockStepVersion\"] = 0] = \"lockStepVersion\";\n    VersionPolicyDefinitionName[VersionPolicyDefinitionName[\"individualVersion\"] = 1] = \"individualVersion\";\n})(VersionPolicyDefinitionName || (VersionPolicyDefinitionName = {}));\n/**\n * This is the base class for version policy which controls how versions get bumped.\n * @public\n */\nexport class VersionPolicy {\n    /**\n     * @internal\n     */\n    constructor(versionPolicyJson) {\n        this.policyName = versionPolicyJson.policyName;\n        this.definitionName = Enum.getValueByKey(VersionPolicyDefinitionName, versionPolicyJson.definitionName);\n        this.exemptFromRushChange = versionPolicyJson.exemptFromRushChange || false;\n        this.includeEmailInChangeFile = versionPolicyJson.includeEmailInChangeFile || false;\n        const jsonDependencies = versionPolicyJson.dependencies || {};\n        this._versionFormatForCommit = jsonDependencies.versionFormatForCommit || VersionFormatForCommit.original;\n        this._versionFormatForPublish =\n            jsonDependencies.versionFormatForPublish || VersionFormatForPublish.original;\n    }\n    /**\n     * Loads from version policy json\n     *\n     * @param versionPolicyJson - version policy Json\n     *\n     * @internal\n     */\n    static load(versionPolicyJson) {\n        const definition = Enum.getValueByKey(VersionPolicyDefinitionName, versionPolicyJson.definitionName);\n        if (definition === VersionPolicyDefinitionName.lockStepVersion) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new LockStepVersionPolicy(versionPolicyJson);\n        }\n        else if (definition === VersionPolicyDefinitionName.individualVersion) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new IndividualVersionPolicy(versionPolicyJson);\n        }\n        return undefined;\n    }\n    /**\n     * Whether it is a lockstepped version policy\n     */\n    get isLockstepped() {\n        return this.definitionName === VersionPolicyDefinitionName.lockStepVersion;\n    }\n    /**\n     * Tells the version policy to modify any dependencies in the target package\n     * to values used for publishing.\n     */\n    setDependenciesBeforePublish(packageName, configuration) {\n        if (this._versionFormatForPublish === VersionFormatForPublish.exact) {\n            const project = configuration.getProjectByName(packageName);\n            const packageJsonEditor = project.packageJsonEditor;\n            for (const dependency of packageJsonEditor.dependencyList) {\n                const rushDependencyProject = configuration.getProjectByName(dependency.name);\n                if (rushDependencyProject) {\n                    const dependencyVersion = rushDependencyProject.packageJson.version;\n                    dependency.setVersion(dependencyVersion);\n                }\n            }\n            packageJsonEditor.saveIfModified();\n        }\n    }\n    /**\n     * Tells the version policy to modify any dependencies in the target package\n     * to values used for checked-in source.\n     */\n    setDependenciesBeforeCommit(packageName, configuration) {\n        if (this._versionFormatForCommit === VersionFormatForCommit.wildcard) {\n            const project = configuration.getProjectByName(packageName);\n            const packageJsonEditor = project.packageJsonEditor;\n            for (const dependency of packageJsonEditor.dependencyList) {\n                const rushDependencyProject = configuration.getProjectByName(dependency.name);\n                if (rushDependencyProject) {\n                    dependency.setVersion('*');\n                }\n            }\n            packageJsonEditor.saveIfModified();\n        }\n    }\n}\n/**\n * This policy indicates all related projects should use the same version.\n * @public\n */\nexport class LockStepVersionPolicy extends VersionPolicy {\n    /**\n     * @internal\n     */\n    constructor(versionPolicyJson) {\n        super(versionPolicyJson);\n        this._version = new semver.SemVer(versionPolicyJson.version);\n        this.nextBump =\n            versionPolicyJson.nextBump !== undefined\n                ? Enum.getValueByKey(BumpType, versionPolicyJson.nextBump)\n                : undefined;\n        this.mainProject = versionPolicyJson.mainProject;\n    }\n    /**\n     * The value of the lockstep version\n     */\n    get version() {\n        return this._version.format();\n    }\n    /**\n     * Serialized json for this policy\n     *\n     * @internal\n     */\n    get _json() {\n        const json = {\n            policyName: this.policyName,\n            definitionName: VersionPolicyDefinitionName[this.definitionName],\n            version: this.version\n        };\n        if (this.nextBump !== undefined) {\n            json.nextBump = BumpType[this.nextBump];\n        }\n        if (this.mainProject !== undefined) {\n            json.mainProject = this.mainProject;\n        }\n        return json;\n    }\n    /**\n     * Returns an updated package json that satisfies the version policy.\n     *\n     * @param project - input package json\n     * @param force - force update even when the project version is higher than the policy version.\n     */\n    ensure(project, force) {\n        const packageVersion = new semver.SemVer(project.version);\n        const compareResult = packageVersion.compare(this._version);\n        if (compareResult === 0) {\n            return undefined;\n        }\n        else if (compareResult > 0 && !force) {\n            const errorMessage = `Version ${project.version} in package ${project.name}` +\n                ` is higher than locked version ${this._version.format()}.`;\n            throw new Error(errorMessage);\n        }\n        return this._updatePackageVersion(project, this._version);\n    }\n    /**\n     * Bumps the version of the lockstep policy\n     *\n     * @param bumpType - Overwrite bump type in version-policy.json with the provided value.\n     * @param identifier - Prerelease identifier if bump type is prerelease.\n     */\n    bump(bumpType, identifier) {\n        const nextBump = bumpType !== null && bumpType !== void 0 ? bumpType : this.nextBump;\n        if (nextBump === undefined) {\n            // let change files drive version bump.\n            return;\n        }\n        this._version.inc(this._getReleaseType(nextBump), identifier);\n    }\n    /**\n     * Updates the version of the policy directly with a new value\n     * @param newVersionString - New version\n     */\n    update(newVersionString) {\n        const newVersion = new semver.SemVer(newVersionString);\n        if (!newVersion || this._version === newVersion) {\n            return false;\n        }\n        this._version = newVersion;\n        return true;\n    }\n    /**\n     * Validates the specified version and throws if the version does not satisfy lockstep version.\n     *\n     * @param versionString - version string\n     * @param packageName - package name\n     */\n    validate(versionString, packageName) {\n        const versionToTest = new semver.SemVer(versionString, false);\n        if (this._version.compare(versionToTest) !== 0) {\n            throw new Error(`Invalid version ${versionString} in ${packageName}`);\n        }\n    }\n    _updatePackageVersion(project, newVersion) {\n        const updatedProject = cloneDeep(project);\n        updatedProject.version = newVersion.format();\n        return updatedProject;\n    }\n    _getReleaseType(bumpType) {\n        // Eventually we should just use ReleaseType and get rid of bump type.\n        return BumpType[bumpType];\n    }\n}\n/**\n * This policy indicates all related projects get version bump driven by their own changes.\n * @public\n */\nexport class IndividualVersionPolicy extends VersionPolicy {\n    /**\n     * @internal\n     */\n    constructor(versionPolicyJson) {\n        super(versionPolicyJson);\n        this.lockedMajor = versionPolicyJson.lockedMajor;\n    }\n    /**\n     * Serialized json for this policy\n     *\n     * @internal\n     */\n    get _json() {\n        const json = {\n            policyName: this.policyName,\n            definitionName: VersionPolicyDefinitionName[this.definitionName]\n        };\n        if (this.lockedMajor !== undefined) {\n            json.lockedMajor = this.lockedMajor;\n        }\n        return json;\n    }\n    /**\n     * Returns an updated package json that satisfies the version policy.\n     *\n     * @param project - input package json\n     * @param force - force update even when the project version is higher than the policy version.\n     */\n    ensure(project, force) {\n        if (this.lockedMajor) {\n            const version = new semver.SemVer(project.version);\n            if (version.major < this.lockedMajor) {\n                const updatedProject = cloneDeep(project);\n                updatedProject.version = `${this.lockedMajor}.0.0`;\n                return updatedProject;\n            }\n            else if (version.major > this.lockedMajor) {\n                const errorMessage = `Version ${project.version} in package ${project.name}` +\n                    ` is higher than locked major version ${this.lockedMajor}.`;\n                throw new Error(errorMessage);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Bumps version.\n     * Individual version policy lets change files drive version bump. This method currently does not do anything.\n     *\n     * @param bumpType - bump type\n     * @param identifier - prerelease id\n     */\n    bump(bumpType, identifier) {\n        // individual version policy lets change files drive version bump.\n    }\n    /**\n     * Validates the specified version and throws if the version does not satisfy the policy.\n     *\n     * @param versionString - version string\n     * @param packageName - package name\n     */\n    validate(versionString, packageName) {\n        const versionToTest = new semver.SemVer(versionString, false);\n        if (this.lockedMajor !== undefined) {\n            if (this.lockedMajor !== versionToTest.major) {\n                throw new Error(`Invalid major version ${versionString} in ${packageName}`);\n            }\n        }\n    }\n}\n//# sourceMappingURL=VersionPolicy.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, JsonSchema, FileSystem } from '@rushstack/node-core-library';\nimport { VersionPolicy } from './VersionPolicy';\nimport schemaJson from '../schemas/version-policies.schema.json';\nexport var VersionFormatForPublish;\n(function (VersionFormatForPublish) {\n    VersionFormatForPublish[\"original\"] = \"original\";\n    VersionFormatForPublish[\"exact\"] = \"exact\";\n})(VersionFormatForPublish || (VersionFormatForPublish = {}));\nexport var VersionFormatForCommit;\n(function (VersionFormatForCommit) {\n    VersionFormatForCommit[\"wildcard\"] = \"wildcard\";\n    VersionFormatForCommit[\"original\"] = \"original\";\n})(VersionFormatForCommit || (VersionFormatForCommit = {}));\n/**\n * Use this class to load and save the \"common/config/rush/version-policies.json\" config file.\n * This config file configures how different groups of projects will be published by Rush,\n * and how their version numbers will be determined.\n * @public\n */\nexport class VersionPolicyConfiguration {\n    /**\n     * @internal\n     */\n    constructor(jsonFileName) {\n        this._jsonFileName = jsonFileName;\n        this.versionPolicies = new Map();\n        this._loadFile();\n    }\n    /**\n     * Validate the version policy configuration against the rush config\n     */\n    validate(projectsByName) {\n        if (!this.versionPolicies) {\n            return;\n        }\n        this.versionPolicies.forEach((policy) => {\n            const lockStepPolicy = policy;\n            if (lockStepPolicy.mainProject && !projectsByName.get(lockStepPolicy.mainProject)) {\n                throw new Error(`Version policy \\\"${policy.policyName}\\\" has a non-existing mainProject:` +\n                    ` ${lockStepPolicy.mainProject}.`);\n            }\n        });\n    }\n    /**\n     * Gets the version policy by its name.\n     * Throws error if the version policy is not found.\n     * @param policyName - Name of the version policy\n     */\n    getVersionPolicy(policyName) {\n        const policy = this.versionPolicies.get(policyName);\n        if (!policy) {\n            throw new Error(`Failed to find version policy by name \\'${policyName}\\'`);\n        }\n        return policy;\n    }\n    /**\n     * Bumps up versions for the specified version policy or all version policies\n     *\n     * @param versionPolicyName - version policy name\n     * @param bumpType - bump type to override what policy has defined.\n     * @param identifier - prerelease identifier to override what policy has defined.\n     * @param shouldCommit - should save to disk\n     */\n    bump(versionPolicyName, bumpType, identifier, shouldCommit) {\n        if (versionPolicyName) {\n            const policy = this.versionPolicies.get(versionPolicyName);\n            if (policy) {\n                policy.bump(bumpType, identifier);\n            }\n        }\n        else {\n            this.versionPolicies.forEach((versionPolicy) => {\n                if (versionPolicy) {\n                    versionPolicy.bump(bumpType, identifier);\n                }\n            });\n        }\n        this._saveFile(!!shouldCommit);\n    }\n    /**\n     * Updates the version directly for the specified version policy\n     * @param versionPolicyName - version policy name\n     * @param newVersion - new version\n     */\n    update(versionPolicyName, newVersion, shouldCommit) {\n        const policy = this.versionPolicies.get(versionPolicyName);\n        if (!policy || !policy.isLockstepped) {\n            throw new Error(`Lockstep Version policy with name \"${versionPolicyName}\" cannot be found`);\n        }\n        const lockStepVersionPolicy = policy;\n        const previousVersion = lockStepVersionPolicy.version;\n        if (lockStepVersionPolicy.update(newVersion)) {\n            // eslint-disable-next-line no-console\n            console.log(`\\nUpdate version policy ${versionPolicyName} from ${previousVersion} to ${newVersion}`);\n            this._saveFile(!!shouldCommit);\n        }\n    }\n    _loadFile() {\n        if (!FileSystem.exists(this._jsonFileName)) {\n            return;\n        }\n        const versionPolicyJson = JsonFile.loadAndValidate(this._jsonFileName, VersionPolicyConfiguration._jsonSchema);\n        versionPolicyJson.forEach((policyJson) => {\n            const policy = VersionPolicy.load(policyJson);\n            if (policy) {\n                this.versionPolicies.set(policy.policyName, policy);\n            }\n        });\n    }\n    _saveFile(shouldCommit) {\n        const versionPolicyJson = [];\n        this.versionPolicies.forEach((versionPolicy) => {\n            versionPolicyJson.push(versionPolicy._json);\n        });\n        if (shouldCommit) {\n            JsonFile.save(versionPolicyJson, this._jsonFileName, { updateExistingFile: true });\n        }\n    }\n}\nVersionPolicyConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=VersionPolicyConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushConstants } from '../../logic/RushConstants';\nimport { PackageManager } from './PackageManager';\n/**\n * Support for interacting with the NPM package manager.\n */\nexport class NpmPackageManager extends PackageManager {\n    /** @internal */\n    constructor(version) {\n        super(version, 'npm', RushConstants.npmShrinkwrapFilename);\n    }\n}\n//# sourceMappingURL=NpmPackageManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * An abstraction for controlling the supported package managers: PNPM, NPM, and Yarn.\n * @public\n */\nexport class PackageManager {\n    /** @internal */\n    constructor(version, packageManager, shrinkwrapFilename) {\n        this.version = version;\n        this.packageManager = packageManager;\n        this.shrinkwrapFilename = shrinkwrapFilename;\n    }\n}\n//# sourceMappingURL=PackageManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport * as path from 'path';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { PackageManager } from './PackageManager';\n/**\n * Support for interacting with the PNPM package manager.\n */\nexport class PnpmPackageManager extends PackageManager {\n    /** @internal */\n    constructor(version) {\n        super(version, 'pnpm', RushConstants.pnpmV3ShrinkwrapFilename);\n        const parsedVersion = new semver.SemVer(version);\n        if (parsedVersion.major >= 6) {\n            // Introduced in version 6.0.0\n            this.pnpmfileFilename = RushConstants.pnpmfileV6Filename;\n        }\n        else {\n            this.pnpmfileFilename = RushConstants.pnpmfileV1Filename;\n        }\n        // node_modules/.pnpm/lock.yaml\n        // See https://github.com/pnpm/pnpm/releases/tag/v4.0.0 for more details.\n        this.internalShrinkwrapRelativePath = path.join('node_modules', '.pnpm', 'lock.yaml');\n    }\n}\n//# sourceMappingURL=PnpmPackageManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushConstants } from '../../logic/RushConstants';\nimport { PackageManager } from './PackageManager';\n/**\n * Support for interacting with the Yarn package manager.\n */\nexport class YarnPackageManager extends PackageManager {\n    /** @internal */\n    constructor(version) {\n        super(version, 'yarn', RushConstants.yarnShrinkwrapFilename);\n    }\n}\n//# sourceMappingURL=YarnPackageManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Colorize, PrintUtilities } from '@rushstack/terminal';\nimport { RushConstants } from '../logic/RushConstants';\nexport class CommandLineMigrationAdvisor {\n    // NOTE: THIS RUNS BEFORE THE REAL COMMAND-LINE PARSING.\n    // TAKE EXTREME CARE THAT THE HEURISTICS CANNOT FALSELY MATCH A VALID COMMAND LINE.\n    static checkArgv(argv) {\n        // 0=node.exe, 1=script name\n        const args = process.argv.slice(2);\n        if (args.length > 0) {\n            if (args[0] === 'generate') {\n                CommandLineMigrationAdvisor._reportDeprecated('Instead of \"rush generate\", use \"rush update\" or \"rush update --full\".');\n                return false;\n            }\n            if (args[0] === 'install') {\n                if (args.indexOf('--full-clean') >= 0) {\n                    CommandLineMigrationAdvisor._reportDeprecated('Instead of \"rush install --full-clean\", use \"rush purge --unsafe\".');\n                    return false;\n                }\n                if (args.indexOf('-C') >= 0) {\n                    CommandLineMigrationAdvisor._reportDeprecated('Instead of \"rush install -C\", use \"rush purge --unsafe\".');\n                    return false;\n                }\n                if (args.indexOf('--clean') >= 0) {\n                    CommandLineMigrationAdvisor._reportDeprecated('Instead of \"rush install --clean\", use \"rush install --purge\".');\n                    return false;\n                }\n                if (args.indexOf('-c') >= 0) {\n                    CommandLineMigrationAdvisor._reportDeprecated('Instead of \"rush install -c\", use \"rush install --purge\".');\n                    return false;\n                }\n            }\n        }\n        // Everything is okay\n        return true;\n    }\n    static _reportDeprecated(message) {\n        // eslint-disable-next-line no-console\n        console.error(Colorize.red(PrintUtilities.wrapWords('ERROR: You specified an outdated command-line that is no longer supported by this version of Rush:')));\n        // eslint-disable-next-line no-console\n        console.error(Colorize.yellow(PrintUtilities.wrapWords(message)));\n        // eslint-disable-next-line no-console\n        console.error();\n        // eslint-disable-next-line no-console\n        console.error(PrintUtilities.wrapWords(`For command-line help, type \"rush -h\".  For migration instructions,` +\n            ` please visit ${RushConstants.rushWebSiteUrl}`));\n    }\n}\n//# sourceMappingURL=CommandLineMigrationAdvisor.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { CommandLineParser, CommandLineHelper } from '@rushstack/ts-command-line';\nimport { InternalError, AlreadyReportedError, Text } from '@rushstack/node-core-library';\nimport { ConsoleTerminalProvider, Terminal, PrintUtilities, Colorize } from '@rushstack/terminal';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\nimport { CommandLineConfiguration } from '../api/CommandLineConfiguration';\nimport { AddAction } from './actions/AddAction';\nimport { ChangeAction } from './actions/ChangeAction';\nimport { CheckAction } from './actions/CheckAction';\nimport { DeployAction } from './actions/DeployAction';\nimport { InitAction } from './actions/InitAction';\nimport { InitAutoinstallerAction } from './actions/InitAutoinstallerAction';\nimport { InitDeployAction } from './actions/InitDeployAction';\nimport { InstallAction } from './actions/InstallAction';\nimport { LinkAction } from './actions/LinkAction';\nimport { ListAction } from './actions/ListAction';\nimport { PublishAction } from './actions/PublishAction';\nimport { PurgeAction } from './actions/PurgeAction';\nimport { RemoveAction } from './actions/RemoveAction';\nimport { ScanAction } from './actions/ScanAction';\nimport { UnlinkAction } from './actions/UnlinkAction';\nimport { UpdateAction } from './actions/UpdateAction';\nimport { UpdateAutoinstallerAction } from './actions/UpdateAutoinstallerAction';\nimport { VersionAction } from './actions/VersionAction';\nimport { UpdateCloudCredentialsAction } from './actions/UpdateCloudCredentialsAction';\nimport { UpgradeInteractiveAction } from './actions/UpgradeInteractiveAction';\nimport { AlertAction } from './actions/AlertAction';\nimport { GlobalScriptAction } from './scriptActions/GlobalScriptAction';\nimport { Telemetry } from '../logic/Telemetry';\nimport { RushGlobalFolder } from '../api/RushGlobalFolder';\nimport { NodeJsCompatibility } from '../logic/NodeJsCompatibility';\nimport { SetupAction } from './actions/SetupAction';\nimport { PluginManager } from '../pluginFramework/PluginManager';\nimport { RushSession } from '../pluginFramework/RushSession';\nimport { PhasedScriptAction } from './scriptActions/PhasedScriptAction';\nimport { InitSubspaceAction } from './actions/InitSubspaceAction';\nimport { RushAlerts } from '../utilities/RushAlerts';\nimport { InstallAutoinstallerAction } from './actions/InstallAutoinstallerAction';\nexport class RushCommandLineParser extends CommandLineParser {\n    constructor(options) {\n        super({\n            toolFilename: 'rush',\n            toolDescription: 'Rush makes life easier for JavaScript developers who develop, build, and publish' +\n                ' many packages from a central Git repo.  It is designed to handle very large repositories' +\n                ' supporting many projects and people.  Rush provides policies, protections, and customizations' +\n                ' that help coordinate teams and safely onboard new contributors.  Rush also generates change logs' +\n                ' and automates package publishing.  It can manage decoupled subsets of projects with different' +\n                ' release and versioning strategies.  A full API is included to facilitate integration with other' +\n                ' automation tools.  If you are looking for a proven turnkey solution for monorepo management,' +\n                ' Rush is for you.',\n            enableTabCompletionAction: true\n        });\n        this._restrictConsoleOutput = RushCommandLineParser.shouldRestrictConsoleOutput();\n        this._debugParameter = this.defineFlagParameter({\n            parameterLongName: '--debug',\n            parameterShortName: '-d',\n            description: 'Show the full call stack if an error occurs while executing the tool'\n        });\n        this._quietParameter = this.defineFlagParameter({\n            parameterLongName: '--quiet',\n            parameterShortName: '-q',\n            description: 'Hide rush startup information'\n        });\n        this._terminalProvider = new ConsoleTerminalProvider();\n        this._terminal = new Terminal(this._terminalProvider);\n        this._rushOptions = this._normalizeOptions(options || {});\n        try {\n            const rushJsonFilename = RushConfiguration.tryFindRushJsonLocation({\n                startingFolder: this._rushOptions.cwd,\n                showVerbose: !this._restrictConsoleOutput\n            });\n            if (rushJsonFilename) {\n                this.rushConfiguration = RushConfiguration.loadFromConfigurationFile(rushJsonFilename);\n            }\n        }\n        catch (error) {\n            this._reportErrorAndSetExitCode(error);\n        }\n        NodeJsCompatibility.warnAboutCompatibilityIssues({\n            isRushLib: true,\n            alreadyReportedNodeTooNewError: this._rushOptions.alreadyReportedNodeTooNewError,\n            rushConfiguration: this.rushConfiguration\n        });\n        this.rushGlobalFolder = new RushGlobalFolder();\n        this.rushSession = new RushSession({\n            getIsDebugMode: () => this.isDebug,\n            terminalProvider: this._terminalProvider\n        });\n        this.pluginManager = new PluginManager({\n            rushSession: this.rushSession,\n            rushConfiguration: this.rushConfiguration,\n            terminal: this._terminal,\n            builtInPluginConfigurations: this._rushOptions.builtInPluginConfigurations,\n            restrictConsoleOutput: this._restrictConsoleOutput,\n            rushGlobalFolder: this.rushGlobalFolder\n        });\n        this._populateActions();\n        const pluginCommandLineConfigurations = this.pluginManager.tryGetCustomCommandLineConfigurationInfos();\n        for (const { commandLineConfiguration, pluginLoader } of pluginCommandLineConfigurations) {\n            try {\n                this._addCommandLineConfigActions(commandLineConfiguration);\n            }\n            catch (e) {\n                this._terminal.writeErrorLine(`Error from plugin ${pluginLoader.pluginName} by ${pluginLoader.packageName}: ${e.toString()}`);\n            }\n        }\n    }\n    get isDebug() {\n        return this._debugParameter.value;\n    }\n    get isQuiet() {\n        return this._quietParameter.value;\n    }\n    get terminal() {\n        return this._terminal;\n    }\n    /**\n     * Utility to determine if the app should restrict writing to the console.\n     */\n    static shouldRestrictConsoleOutput() {\n        if (CommandLineHelper.isTabCompletionActionRequest(process.argv)) {\n            return true;\n        }\n        for (let i = 2; i < process.argv.length; i++) {\n            const arg = process.argv[i];\n            if (arg === '-q' || arg === '--quiet' || arg === '--json') {\n                return true;\n            }\n        }\n        return false;\n    }\n    flushTelemetry() {\n        var _a;\n        (_a = this.telemetry) === null || _a === void 0 ? void 0 : _a.flush();\n    }\n    async executeAsync(args) {\n        // debugParameter will be correctly parsed during super.executeAsync(), so manually parse here.\n        this._terminalProvider.verboseEnabled = this._terminalProvider.debugEnabled =\n            process.argv.indexOf('--debug') >= 0;\n        await this.pluginManager.tryInitializeUnassociatedPluginsAsync();\n        return await super.executeAsync(args);\n    }\n    async onExecute() {\n        var _a;\n        // Defensively set the exit code to 1 so if Rush crashes for whatever reason, we'll have a nonzero exit code.\n        // For example, Node.js currently has the inexcusable design of terminating with zero exit code when\n        // there is an uncaught promise exception.  This will supposedly be fixed in Node.js 9.\n        // Ideally we should do this for all the Rush actions, but \"rush build\" is the most critical one\n        // -- if it falsely appears to succeed, we could merge bad PRs, publish empty packages, etc.\n        process.exitCode = 1;\n        if (this._debugParameter.value) {\n            InternalError.breakInDebugger = true;\n        }\n        try {\n            await this._wrapOnExecuteAsync();\n            // TODO: rushConfiguration is typed as \"!: RushConfiguration\" here, but can sometimes be undefined\n            if (this.rushConfiguration) {\n                try {\n                    const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;\n                    if (experiments.rushAlerts) {\n                        // TODO: Fix this\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        const actionName = this\n                            ._getArgumentParser()\n                            .parseArgs(process.argv.slice(2)).action;\n                        // only display alerts when certain specific actions are triggered\n                        if (RushAlerts.alertTriggerActions.includes(actionName)) {\n                            this._terminal.writeDebugLine('Checking Rush alerts...');\n                            const rushAlerts = await RushAlerts.loadFromConfigurationAsync(this.rushConfiguration, this._terminal);\n                            // Print out alerts if have after each successful command actions\n                            await rushAlerts.printAlertsAsync();\n                        }\n                    }\n                }\n                catch (error) {\n                    if (error instanceof AlreadyReportedError) {\n                        throw error;\n                    }\n                    // Generally the RushAlerts implementation should handle its own error reporting; if not,\n                    // clarify the source, since the Rush Alerts behavior is nondeterministic and may not repro easily:\n                    this._terminal.writeErrorLine(`\\nAn unexpected error was encountered by the Rush alerts feature:`);\n                    this._terminal.writeErrorLine(error.message);\n                    throw new AlreadyReportedError();\n                }\n            }\n            // If we make it here, everything went fine, so reset the exit code back to 0\n            process.exitCode = 0;\n        }\n        catch (error) {\n            this._reportErrorAndSetExitCode(error);\n        }\n        // This only gets hit if the wrapped execution completes successfully\n        await ((_a = this.telemetry) === null || _a === void 0 ? void 0 : _a.ensureFlushedAsync());\n    }\n    _normalizeOptions(options) {\n        return {\n            cwd: options.cwd || process.cwd(),\n            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError || false,\n            builtInPluginConfigurations: options.builtInPluginConfigurations || []\n        };\n    }\n    async _wrapOnExecuteAsync() {\n        if (this.rushConfiguration) {\n            this.telemetry = new Telemetry(this.rushConfiguration, this.rushSession);\n        }\n        try {\n            await super.onExecute();\n        }\n        finally {\n            if (this.telemetry) {\n                this.flushTelemetry();\n            }\n        }\n    }\n    _populateActions() {\n        try {\n            // Alphabetical order\n            this.addAction(new AddAction(this));\n            this.addAction(new ChangeAction(this));\n            this.addAction(new CheckAction(this));\n            this.addAction(new DeployAction(this));\n            this.addAction(new InitAction(this));\n            this.addAction(new InitAutoinstallerAction(this));\n            this.addAction(new InitDeployAction(this));\n            this.addAction(new InitSubspaceAction(this));\n            this.addAction(new InstallAction(this));\n            this.addAction(new LinkAction(this));\n            this.addAction(new ListAction(this));\n            this.addAction(new PublishAction(this));\n            this.addAction(new PurgeAction(this));\n            this.addAction(new RemoveAction(this));\n            this.addAction(new ScanAction(this));\n            this.addAction(new SetupAction(this));\n            this.addAction(new UnlinkAction(this));\n            this.addAction(new UpdateAction(this));\n            this.addAction(new InstallAutoinstallerAction(this));\n            this.addAction(new UpdateAutoinstallerAction(this));\n            this.addAction(new UpdateCloudCredentialsAction(this));\n            this.addAction(new UpgradeInteractiveAction(this));\n            this.addAction(new VersionAction(this));\n            this.addAction(new AlertAction(this));\n            this._populateScriptActions();\n        }\n        catch (error) {\n            this._reportErrorAndSetExitCode(error);\n        }\n    }\n    _populateScriptActions() {\n        // If there is not a rush.json file, we still want \"build\" and \"rebuild\" to appear in the\n        // command-line help\n        let commandLineConfigFilePath;\n        if (this.rushConfiguration) {\n            commandLineConfigFilePath = path.join(this.rushConfiguration.commonRushConfigFolder, RushConstants.commandLineFilename);\n        }\n        const commandLineConfiguration = CommandLineConfiguration.loadFromFileOrDefault(commandLineConfigFilePath);\n        this._addCommandLineConfigActions(commandLineConfiguration);\n    }\n    _addCommandLineConfigActions(commandLineConfiguration) {\n        // Register each custom command\n        for (const command of commandLineConfiguration.commands.values()) {\n            this._addCommandLineConfigAction(commandLineConfiguration, command);\n        }\n    }\n    _addCommandLineConfigAction(commandLineConfiguration, command) {\n        if (this.tryGetAction(command.name)) {\n            throw new Error(`${RushConstants.commandLineFilename} defines a command \"${command.name}\"` +\n                ` using a name that already exists`);\n        }\n        switch (command.commandKind) {\n            case RushConstants.globalCommandKind: {\n                this._addGlobalScriptAction(commandLineConfiguration, command);\n                break;\n            }\n            case RushConstants.phasedCommandKind: {\n                this._addPhasedCommandLineConfigAction(commandLineConfiguration, command);\n                break;\n            }\n            default:\n                throw new Error(`${RushConstants.commandLineFilename} defines a command \"${command.name}\"` +\n                    ` using an unsupported command kind \"${command.commandKind}\"`);\n        }\n    }\n    _getSharedCommandActionOptions(commandLineConfiguration, command) {\n        return {\n            actionName: command.name,\n            summary: command.summary,\n            documentation: command.description || command.summary,\n            safeForSimultaneousRushProcesses: command.safeForSimultaneousRushProcesses,\n            command,\n            parser: this,\n            commandLineConfiguration: commandLineConfiguration\n        };\n    }\n    _addGlobalScriptAction(commandLineConfiguration, command) {\n        if (command.name === RushConstants.buildCommandName ||\n            command.name === RushConstants.rebuildCommandName) {\n            throw new Error(`${RushConstants.commandLineFilename} defines a command \"${command.name}\" using ` +\n                `the command kind \"${RushConstants.globalCommandKind}\". This command can only be designated as a command ` +\n                `kind \"${RushConstants.bulkCommandKind}\" or \"${RushConstants.phasedCommandKind}\".`);\n        }\n        const sharedCommandOptions = this._getSharedCommandActionOptions(commandLineConfiguration, command);\n        this.addAction(new GlobalScriptAction(Object.assign(Object.assign({}, sharedCommandOptions), { shellCommand: command.shellCommand, autoinstallerName: command.autoinstallerName })));\n    }\n    _addPhasedCommandLineConfigAction(commandLineConfiguration, command) {\n        var _a;\n        const baseCommandOptions = this._getSharedCommandActionOptions(commandLineConfiguration, command);\n        this.addAction(new PhasedScriptAction(Object.assign(Object.assign({}, baseCommandOptions), { enableParallelism: command.enableParallelism, incremental: command.incremental || false, disableBuildCache: command.disableBuildCache || false, initialPhases: command.phases, originalPhases: command.originalPhases, watchPhases: command.watchPhases, watchDebounceMs: (_a = command.watchDebounceMs) !== null && _a !== void 0 ? _a : RushConstants.defaultWatchDebounceMs, phases: commandLineConfiguration.phases, alwaysWatch: command.alwaysWatch, alwaysInstall: command.alwaysInstall })));\n    }\n    _reportErrorAndSetExitCode(error) {\n        if (!(error instanceof AlreadyReportedError)) {\n            const prefix = 'ERROR: ';\n            // The colors package will eat multi-newlines, which could break formatting\n            // in user-specified messages and instructions, so we prefer to color each\n            // line individually.\n            const message = Text.splitByNewLines(PrintUtilities.wrapWords(prefix + error.message))\n                .map((line) => Colorize.red(line))\n                .join('\\n');\n            // eslint-disable-next-line no-console\n            console.error(`\\n${message}`);\n        }\n        if (this._debugParameter.value) {\n            // If catchSyncErrors() called this, then show a call stack similar to what Node.js\n            // would show for an uncaught error\n            // eslint-disable-next-line no-console\n            console.error(`\\n${error.stack}`);\n        }\n        this.flushTelemetry();\n        const handleExit = () => {\n            // Ideally we want to eliminate all calls to process.exit() from our code, and replace them\n            // with normal control flow that properly cleans up its data structures.\n            // For this particular call, we have a problem that the RushCommandLineParser constructor\n            // performs nontrivial work that can throw an exception.  Either the Rush class would need\n            // to handle reporting for those exceptions, or else _populateActions() should be moved\n            // to a RushCommandLineParser lifecycle stage that can handle it.\n            if (process.exitCode !== undefined) {\n                process.exit(process.exitCode);\n            }\n            else {\n                process.exit(1);\n            }\n        };\n        if (this.telemetry && this.rushSession.hooks.flushTelemetry.isUsed()) {\n            this.telemetry.ensureFlushedAsync().then(handleExit).catch(handleExit);\n        }\n        else {\n            handleExit();\n        }\n    }\n}\n//# sourceMappingURL=RushCommandLineParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushPnpmCommandLineParser } from './RushPnpmCommandLineParser';\nexport class RushPnpmCommandLine {\n    static launch(launcherVersion, options) {\n        RushPnpmCommandLineParser.initializeAsync(options)\n            // RushPnpmCommandLineParser.executeAsync should never reject the promise\n            .then((rushPnpmCommandLineParser) => rushPnpmCommandLineParser.executeAsync())\n            // eslint-disable-next-line no-console\n            .catch(console.error);\n    }\n}\n//# sourceMappingURL=RushPnpmCommandLine.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { AlreadyReportedError, EnvironmentMap, FileConstants, FileSystem, JsonFile } from '@rushstack/node-core-library';\nimport { Colorize, ConsoleTerminalProvider, Terminal } from '@rushstack/terminal';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { NodeJsCompatibility } from '../logic/NodeJsCompatibility';\nimport { PrintUtilities } from '@rushstack/terminal';\nimport { RushConstants } from '../logic/RushConstants';\nimport { RushGlobalFolder } from '../api/RushGlobalFolder';\nimport { PurgeManager } from '../logic/PurgeManager';\nimport { objectsAreDeepEqual } from '../utilities/objectUtilities';\nimport { Utilities } from '../utilities/Utilities';\nimport { EnvironmentVariableNames } from '../api/EnvironmentConfiguration';\nconst RUSH_SKIP_CHECKS_PARAMETER = '--rush-skip-checks';\nfunction _reportErrorAndSetExitCode(error, terminal, debugEnabled) {\n    var _a;\n    if (!(error instanceof AlreadyReportedError)) {\n        const prefix = 'ERROR: ';\n        terminal.writeErrorLine('\\n' + PrintUtilities.wrapWords(prefix + error.message));\n    }\n    if (debugEnabled) {\n        // If catchSyncErrors() called this, then show a call stack similar to what Node.js\n        // would show for an uncaught error\n        terminal.writeErrorLine('\\n' + error.stack);\n    }\n    process.exit((_a = process.exitCode) !== null && _a !== void 0 ? _a : 1);\n}\nexport class RushPnpmCommandLineParser {\n    constructor(options, terminal, debugEnabled) {\n        this._debugEnabled = debugEnabled;\n        this._terminal = terminal;\n        // Are we in a Rush repo?\n        const rushConfiguration = RushConfiguration.tryLoadFromDefaultLocation({\n            // showVerbose is false because the logging message may break JSON output\n            showVerbose: false\n        });\n        NodeJsCompatibility.warnAboutCompatibilityIssues({\n            isRushLib: true,\n            alreadyReportedNodeTooNewError: !!options.alreadyReportedNodeTooNewError,\n            rushConfiguration\n        });\n        if (!rushConfiguration) {\n            throw new Error('The \"rush-pnpm\" command must be executed in a folder that is under a Rush workspace folder');\n        }\n        this._rushConfiguration = rushConfiguration;\n        if (rushConfiguration.packageManager !== 'pnpm') {\n            throw new Error(`The \"rush-pnpm\" command requires your ${RushConstants.rushJsonFilename} to be configured to use the PNPM package manager`);\n        }\n        if (!rushConfiguration.pnpmOptions.useWorkspaces) {\n            const pnpmConfigFilename = rushConfiguration.pnpmOptions.jsonFilename || RushConstants.rushJsonFilename;\n            throw new Error(`The \"rush-pnpm\" command requires the \"useWorkspaces\" setting to be enabled in ${pnpmConfigFilename}`);\n        }\n        let pnpmArgs = [];\n        let subspaceName = 'default';\n        if (process.argv.indexOf('--subspace') >= 0) {\n            if (process.argv[2] !== '--subspace') {\n                throw new Error('If you want to specify a subspace, you should place \"--subspace <subspace_name>\" immediately after the \"rush-pnpm\" command');\n            }\n            subspaceName = process.argv[3];\n            // 0 = node.exe\n            // 1 = rush-pnpm\n            // 2 = --subspace\n            // 3 = <subspace_name>\n            pnpmArgs = process.argv.slice(4);\n        }\n        else {\n            // 0 = node.exe\n            // 1 = rush-pnpm\n            pnpmArgs = process.argv.slice(2);\n        }\n        this._pnpmArgs = pnpmArgs;\n        const subspace = rushConfiguration.getSubspace(subspaceName);\n        this._subspace = subspace;\n        const workspaceFolder = subspace.getSubspaceTempFolderPath();\n        const workspaceFilePath = path.join(workspaceFolder, 'pnpm-workspace.yaml');\n        if (!FileSystem.exists(workspaceFilePath)) {\n            this._terminal.writeErrorLine('Error: The PNPM workspace file has not been generated:');\n            this._terminal.writeErrorLine(`  ${workspaceFilePath}\\n`);\n            this._terminal.writeLine(Colorize.cyan(`Do you need to run \"rush install\" or \"rush update\"?`));\n            throw new AlreadyReportedError();\n        }\n        if (!FileSystem.exists(rushConfiguration.packageManagerToolFilename)) {\n            this._terminal.writeErrorLine('Error: The PNPM local binary has not been installed yet.');\n            this._terminal.writeLine('\\n' + Colorize.cyan(`Do you need to run \"rush install\" or \"rush update\"?`));\n            throw new AlreadyReportedError();\n        }\n    }\n    static async initializeAsync(options) {\n        var _a;\n        const debugEnabled = process.argv.indexOf('--debug') >= 0;\n        const verboseEnabled = process.argv.indexOf('--verbose') >= 0;\n        const localTerminalProvider = (_a = options.terminalProvider) !== null && _a !== void 0 ? _a : new ConsoleTerminalProvider({\n            debugEnabled,\n            verboseEnabled\n        });\n        const terminal = new Terminal(localTerminalProvider);\n        try {\n            const rushPnpmCommandLineParser = new RushPnpmCommandLineParser(options, terminal, debugEnabled);\n            await rushPnpmCommandLineParser._validatePnpmUsageAsync(rushPnpmCommandLineParser._pnpmArgs);\n            return rushPnpmCommandLineParser;\n        }\n        catch (error) {\n            _reportErrorAndSetExitCode(error, terminal, debugEnabled);\n        }\n    }\n    async executeAsync() {\n        // Node.js can sometimes accidentally terminate with a zero exit code  (e.g. for an uncaught\n        // promise exception), so we start with the assumption that the exit code is 1\n        // and set it to 0 only on success.\n        process.exitCode = 1;\n        await this._executeAsync();\n        if (process.exitCode === 0) {\n            await this._postExecuteAsync();\n        }\n    }\n    async _validatePnpmUsageAsync(pnpmArgs) {\n        if (pnpmArgs[0] === RUSH_SKIP_CHECKS_PARAMETER) {\n            pnpmArgs.shift();\n            // Ignore other checks\n            return;\n        }\n        if (pnpmArgs.length === 0) {\n            return;\n        }\n        const firstArg = pnpmArgs[0];\n        // Detect common safe invocations\n        if (pnpmArgs.includes('-h') || pnpmArgs.includes('--help') || pnpmArgs.includes('-?')) {\n            return;\n        }\n        if (pnpmArgs.length === 1) {\n            if (firstArg === '-v' || firstArg === '--version') {\n                return;\n            }\n        }\n        const BYPASS_NOTICE = `To bypass this check, add \"${RUSH_SKIP_CHECKS_PARAMETER}\" as the very first command line option.`;\n        if (!/^[a-z]+([a-z0-9\\-])*$/.test(firstArg)) {\n            // We can't parse this CLI syntax\n            this._terminal.writeErrorLine(`Warning: The \"rush-pnpm\" wrapper expects a command verb before \"${firstArg}\"\\n`);\n            this._terminal.writeLine(Colorize.cyan(BYPASS_NOTICE));\n            throw new AlreadyReportedError();\n        }\n        else {\n            const commandName = firstArg;\n            // Also accept SKIP_RUSH_CHECKS_PARAMETER immediately after the command verb\n            if (pnpmArgs[1] === RUSH_SKIP_CHECKS_PARAMETER) {\n                pnpmArgs.splice(1, 1);\n                return;\n            }\n            if (pnpmArgs.indexOf(RUSH_SKIP_CHECKS_PARAMETER) >= 0) {\n                // We do not attempt to parse PNPM's complete CLI syntax, so we cannot be sure how to interpret\n                // strings that appear outside of the specific patterns that this parser recognizes\n                this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"${RUSH_SKIP_CHECKS_PARAMETER}\" option must be the first parameter for the \"rush-pnpm\" command.`));\n                throw new AlreadyReportedError();\n            }\n            this._commandName = commandName;\n            // Warn about commands known not to work\n            /* eslint-disable no-fallthrough */\n            switch (commandName) {\n                // Blocked\n                case 'import': {\n                    this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm ${commandName}\" command is known to be incompatible with Rush's environment.`) + '\\n');\n                    this._terminal.writeLine(Colorize.cyan(BYPASS_NOTICE));\n                    throw new AlreadyReportedError();\n                }\n                // Show warning for install commands\n                case 'add':\n                case 'install':\n                /* synonym */\n                case 'i':\n                case 'install-test':\n                /* synonym */\n                case 'it': {\n                    this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm ${commandName}\" command is incompatible with Rush's environment.` +\n                        ` Use the \"rush install\" or \"rush update\" commands instead.`) + '\\n');\n                    this._terminal.writeLine(Colorize.cyan(BYPASS_NOTICE));\n                    throw new AlreadyReportedError();\n                }\n                // Show warning\n                case 'link':\n                /* synonym */\n                case 'ln':\n                case 'remove':\n                /* synonym */\n                case 'rm':\n                case 'unlink':\n                case 'update':\n                /* synonym */\n                case 'up': {\n                    this._terminal.writeWarningLine(PrintUtilities.wrapWords(`Warning: The \"pnpm ${commandName}\" command makes changes that may invalidate Rush's workspace state.`) + '\\n');\n                    this._terminal.writeWarningLine(`==> Consider running \"rush install\" or \"rush update\" afterwards.\\n`);\n                    break;\n                }\n                // Know safe after validation\n                case 'patch': {\n                    const semver = await import('semver');\n                    /**\n                     * If you were to accidentally attempt to use rush-pnpm patch with a pnpmVersion < 7.4.0, pnpm patch may fallback to the system patch command.\n                     * For instance, /usr/bin/patch which may just hangs forever\n                     * So, erroring out the command if the pnpm version is < 7.4.0\n                     */\n                    if (semver.lt(this._rushConfiguration.packageManagerToolVersion, '7.4.0')) {\n                        this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm patch\" command is added after pnpm@7.4.0.` +\n                            ` Please update \"pnpmVersion\" >= 7.4.0 in ${RushConstants.rushJsonFilename} file and run \"rush update\" to use this command.`) + '\\n');\n                        throw new AlreadyReportedError();\n                    }\n                    break;\n                }\n                case 'patch-commit': {\n                    const pnpmOptionsJsonFilename = path.join(this._rushConfiguration.commonRushConfigFolder, RushConstants.pnpmConfigFilename);\n                    if (this._rushConfiguration.rushConfigurationJson.pnpmOptions) {\n                        this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm patch-commit\" command is incompatible with specifying \"pnpmOptions\" in ${RushConstants.rushJsonFilename} file.` +\n                            ` Please move the content of \"pnpmOptions\" in ${RushConstants.rushJsonFilename} file to ${pnpmOptionsJsonFilename}`) + '\\n');\n                        throw new AlreadyReportedError();\n                    }\n                    break;\n                }\n                case 'patch-remove': {\n                    const semver = await import('semver');\n                    /**\n                     * The \"patch-remove\" command was introduced in pnpm version 8.5.0\n                     */\n                    if (semver.lt(this._rushConfiguration.packageManagerToolVersion, '8.5.0')) {\n                        this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm patch-remove\" command is added after pnpm@8.5.0.` +\n                            ` Please update \"pnpmVersion\" >= 8.5.0 in ${RushConstants.rushJsonFilename} file and run \"rush update\" to use this command.`) + '\\n');\n                        throw new AlreadyReportedError();\n                    }\n                    break;\n                }\n                // Known safe\n                case 'audit':\n                case 'exec':\n                case 'list':\n                /* synonym */\n                case 'ls':\n                case 'outdated':\n                case 'pack':\n                case 'prune':\n                case 'publish':\n                case 'rebuild':\n                /* synonym */\n                case 'rb':\n                case 'root':\n                case 'run':\n                case 'start':\n                case 'store':\n                case 'test':\n                /* synonym */\n                case 't':\n                case 'why': {\n                    break;\n                }\n                // Unknown\n                default: {\n                    this._terminal.writeErrorLine(PrintUtilities.wrapWords(`Error: The \"pnpm ${commandName}\" command has not been tested with Rush's environment. It may be incompatible.`) + '\\n');\n                    this._terminal.writeLine(Colorize.cyan(BYPASS_NOTICE));\n                }\n            }\n            /* eslint-enable no-fallthrough */\n        }\n    }\n    async _executeAsync() {\n        const rushConfiguration = this._rushConfiguration;\n        const workspaceFolder = this._subspace.getSubspaceTempFolderPath();\n        const pnpmEnvironmentMap = new EnvironmentMap(process.env);\n        pnpmEnvironmentMap.set('NPM_CONFIG_WORKSPACE_DIR', workspaceFolder);\n        if (rushConfiguration.pnpmOptions.pnpmStorePath) {\n            pnpmEnvironmentMap.set('NPM_CONFIG_STORE_DIR', rushConfiguration.pnpmOptions.pnpmStorePath);\n            pnpmEnvironmentMap.set('NPM_CONFIG_CACHE_DIR', rushConfiguration.pnpmOptions.pnpmStorePath);\n            pnpmEnvironmentMap.set('NPM_CONFIG_STATE_DIR', rushConfiguration.pnpmOptions.pnpmStorePath);\n        }\n        if (rushConfiguration.pnpmOptions.environmentVariables) {\n            for (const [envKey, { value: envValue, override }] of Object.entries(rushConfiguration.pnpmOptions.environmentVariables)) {\n                if (override) {\n                    pnpmEnvironmentMap.set(envKey, envValue);\n                }\n                else {\n                    if (undefined === pnpmEnvironmentMap.get(envKey)) {\n                        pnpmEnvironmentMap.set(envKey, envValue);\n                    }\n                }\n            }\n        }\n        let onStdoutStreamChunk;\n        switch (this._commandName) {\n            case 'patch': {\n                // Replace `pnpm patch-commit` with `rush-pnpm patch-commit` when running\n                // `pnpm patch` to avoid the `pnpm patch` command being suggested in the output\n                onStdoutStreamChunk = (stdoutChunk) => {\n                    return stdoutChunk.replace(/pnpm patch-commit/g, `rush-pnpm --subspace ${this._subspace.subspaceName} patch-commit`);\n                };\n                break;\n            }\n        }\n        try {\n            const { exitCode } = await Utilities.executeCommandAsync({\n                command: rushConfiguration.packageManagerToolFilename,\n                args: this._pnpmArgs,\n                workingDirectory: process.cwd(),\n                environment: pnpmEnvironmentMap.toObject(),\n                keepEnvironment: true,\n                onStdoutStreamChunk,\n                captureExitCodeAndSignal: true\n            });\n            if (typeof exitCode === 'number') {\n                process.exitCode = exitCode;\n            }\n            else {\n                // If the exit code is not a number, the process was terminated by a signal\n                process.exitCode = 1;\n            }\n        }\n        catch (e) {\n            this._terminal.writeDebugLine(`Error: ${e}`);\n        }\n    }\n    async _postExecuteAsync() {\n        var _a;\n        const commandName = this._commandName;\n        if (!commandName) {\n            return;\n        }\n        const subspaceTempFolder = this._subspace.getSubspaceTempFolderPath();\n        switch (commandName) {\n            case 'patch-remove':\n            case 'patch-commit': {\n                // why need to throw error when pnpm-config.json not exists?\n                // 1. pnpm-config.json is required for `rush-pnpm patch-commit`. Rush writes the patched dependency to the pnpm-config.json when finishes.\n                // 2. we can not fallback to use Monorepo config folder (common/config/rush) due to that this command is intended to apply to input subspace only.\n                //    It will produce unexpected behavior if we use the fallback.\n                if (this._subspace.getPnpmOptions() === undefined) {\n                    const subspaceConfigFolder = this._subspace.getSubspaceConfigFolderPath();\n                    this._terminal.writeErrorLine(`The \"rush-pnpm patch-commit\" command cannot proceed without a pnpm-config.json file.` +\n                        `  Create one in this folder: ${subspaceConfigFolder}`);\n                    break;\n                }\n                // Example: \"C:\\MyRepo\\common\\temp\\package.json\"\n                const commonPackageJsonFilename = `${subspaceTempFolder}/${FileConstants.PackageJson}`;\n                const commonPackageJson = JsonFile.load(commonPackageJsonFilename);\n                const newGlobalPatchedDependencies = (_a = commonPackageJson === null || commonPackageJson === void 0 ? void 0 : commonPackageJson.pnpm) === null || _a === void 0 ? void 0 : _a.patchedDependencies;\n                const pnpmOptions = this._subspace.getPnpmOptions();\n                const currentGlobalPatchedDependencies = pnpmOptions === null || pnpmOptions === void 0 ? void 0 : pnpmOptions.globalPatchedDependencies;\n                if (!objectsAreDeepEqual(currentGlobalPatchedDependencies, newGlobalPatchedDependencies)) {\n                    const commonTempPnpmPatchesFolder = `${subspaceTempFolder}/${RushConstants.pnpmPatchesFolderName}`;\n                    const rushPnpmPatchesFolder = this._subspace.getSubspacePnpmPatchesFolderPath();\n                    // Copy (or delete) common\\temp\\subspace\\patches\\ --> common\\config\\pnpm-patches\\ OR common\\config\\rush\\pnpm-patches\\\n                    if (FileSystem.exists(commonTempPnpmPatchesFolder)) {\n                        FileSystem.ensureEmptyFolder(rushPnpmPatchesFolder);\n                        // eslint-disable-next-line no-console\n                        console.log(`Copying ${commonTempPnpmPatchesFolder}`);\n                        // eslint-disable-next-line no-console\n                        console.log(`  --> ${rushPnpmPatchesFolder}`);\n                        FileSystem.copyFiles({\n                            sourcePath: commonTempPnpmPatchesFolder,\n                            destinationPath: rushPnpmPatchesFolder\n                        });\n                    }\n                    else {\n                        if (FileSystem.exists(rushPnpmPatchesFolder)) {\n                            // eslint-disable-next-line no-console\n                            console.log(`Deleting ${rushPnpmPatchesFolder}`);\n                            FileSystem.deleteFolder(rushPnpmPatchesFolder);\n                        }\n                    }\n                    // Update patchedDependencies to pnpm configuration file\n                    pnpmOptions === null || pnpmOptions === void 0 ? void 0 : pnpmOptions.updateGlobalPatchedDependencies(newGlobalPatchedDependencies);\n                    // Rerun installation to update\n                    await this._doRushUpdateAsync();\n                    this._terminal.writeWarningLine(`Rush refreshed the ${RushConstants.pnpmConfigFilename}, shrinkwrap file and patch files under the ` +\n                        `\"${commonTempPnpmPatchesFolder}\" folder.\\n` +\n                        '  Please commit this change to Git.');\n                }\n                break;\n            }\n        }\n    }\n    async _doRushUpdateAsync() {\n        this._terminal.writeLine();\n        this._terminal.writeLine(Colorize.green('Running \"rush update\"'));\n        this._terminal.writeLine();\n        const rushGlobalFolder = new RushGlobalFolder();\n        const purgeManager = new PurgeManager(this._rushConfiguration, rushGlobalFolder);\n        const installManagerOptions = {\n            debug: this._debugEnabled,\n            allowShrinkwrapUpdates: true,\n            bypassPolicy: false,\n            noLink: false,\n            fullUpgrade: false,\n            recheckShrinkwrap: true,\n            networkConcurrency: undefined,\n            offline: false,\n            collectLogFile: false,\n            variant: process.env[EnvironmentVariableNames.RUSH_VARIANT], // For `rush-pnpm`, only use the env var\n            maxInstallAttempts: RushConstants.defaultMaxInstallAttempts,\n            pnpmFilterArgumentValues: [],\n            selectedProjects: new Set(this._rushConfiguration.projects),\n            checkOnly: false,\n            subspace: this._subspace,\n            terminal: this._terminal\n        };\n        const installManagerFactoryModule = await import(\n        /* webpackChunkName: 'InstallManagerFactory' */\n        '../logic/InstallManagerFactory');\n        const installManager = await installManagerFactoryModule.InstallManagerFactory.getInstallManagerAsync(this._rushConfiguration, rushGlobalFolder, purgeManager, installManagerOptions);\n        try {\n            await installManager.doInstallAsync();\n        }\n        finally {\n            await purgeManager.startDeleteAllAsync();\n        }\n    }\n}\n//# sourceMappingURL=RushPnpmCommandLineParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Colorize } from '@rushstack/terminal';\nimport { RushConstants } from '../logic/RushConstants';\nimport { NodeJsCompatibility } from '../logic/NodeJsCompatibility';\nexport class RushStartupBanner {\n    static logBanner(rushVersion, isManaged) {\n        const nodeVersion = this._formatNodeVersion();\n        const versionSuffix = rushVersion ? ' ' + this._formatRushVersion(rushVersion, isManaged) : '';\n        // eslint-disable-next-line no-console\n        console.log('\\n' +\n            Colorize.bold(`Rush Multi-Project Build Tool${versionSuffix}`) +\n            Colorize.cyan(` - ${RushConstants.rushWebSiteUrl}`) +\n            `\\nNode.js version is ${nodeVersion}\\n`);\n    }\n    static logStreamlinedBanner(rushVersion, isManaged) {\n        const nodeVersion = this._formatNodeVersion();\n        const versionSuffix = rushVersion ? ' ' + this._formatRushVersion(rushVersion, isManaged) : '';\n        // eslint-disable-next-line no-console\n        console.log(Colorize.bold(`Rush Multi-Project Build Tool${versionSuffix}`) + ` - Node.js ${nodeVersion}`);\n    }\n    static _formatNodeVersion() {\n        const nodeVersion = process.versions.node;\n        const nodeReleaseLabel = NodeJsCompatibility.isOddNumberedVersion\n            ? 'unstable'\n            : NodeJsCompatibility.isLtsVersion\n                ? 'LTS'\n                : 'pre-LTS';\n        return `${nodeVersion} (${nodeReleaseLabel})`;\n    }\n    static _formatRushVersion(rushVersion, isManaged) {\n        return rushVersion + Colorize.yellow(isManaged ? '' : ' (unmanaged)');\n    }\n}\n//# sourceMappingURL=RushStartupBanner.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { PackageJsonLookup, Text, FileSystem, Async } from '@rushstack/node-core-library';\nimport { Colorize, ConsoleTerminalProvider, DEFAULT_CONSOLE_WIDTH, PrintUtilities, Terminal } from '@rushstack/terminal';\nimport { pnpmSyncCopyAsync } from 'pnpm-sync-lib';\nimport { Utilities } from '../utilities/Utilities';\nimport { ProjectCommandSet } from '../logic/ProjectCommandSet';\nimport { Rush } from '../api/Rush';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { NodeJsCompatibility } from '../logic/NodeJsCompatibility';\nimport { RushStartupBanner } from './RushStartupBanner';\nimport { EventHooksManager } from '../logic/EventHooksManager';\nimport { Event } from '../api/EventHooks';\nimport { EnvironmentVariableNames } from '../api/EnvironmentConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\nimport { PnpmSyncUtilities } from '../utilities/PnpmSyncUtilities';\nclass ProcessError extends Error {\n    constructor(message, exitCode) {\n        super(message);\n        // Manually set the prototype, as we can no longer extend built-in classes like Error, Array, Map, etc.\n        // https://github.com/microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        //\n        // Note: the prototype must also be set on any classes which extend this one\n        this.__proto__ = ProcessError.prototype; // eslint-disable-line @typescript-eslint/no-explicit-any\n        this.exitCode = exitCode;\n    }\n}\nexport class RushXCommandLine {\n    static async launchRushXAsync(launcherVersion, options) {\n        try {\n            const rushxArguments = RushXCommandLine._parseCommandLineArguments();\n            const rushConfiguration = RushConfiguration.tryLoadFromDefaultLocation({\n                showVerbose: false\n            });\n            const eventHooksManager = rushConfiguration\n                ? new EventHooksManager(rushConfiguration)\n                : undefined;\n            const suppressHooks = process.env[EnvironmentVariableNames._RUSH_RECURSIVE_RUSHX_CALL] === '1';\n            const attemptHooks = !suppressHooks && !rushxArguments.help;\n            if (attemptHooks) {\n                try {\n                    eventHooksManager === null || eventHooksManager === void 0 ? void 0 : eventHooksManager.handle(Event.preRushx, rushxArguments.isDebug, rushxArguments.ignoreHooks);\n                }\n                catch (error) {\n                    // eslint-disable-next-line no-console\n                    console.error(Colorize.red('PreRushx hook error: ' + error.message));\n                }\n            }\n            // Node.js can sometimes accidentally terminate with a zero exit code  (e.g. for an uncaught\n            // promise exception), so we start with the assumption that the exit code is 1\n            // and set it to 0 only on success.\n            process.exitCode = 1;\n            await RushXCommandLine._launchRushXInternalAsync(rushxArguments, rushConfiguration, options);\n            if (attemptHooks) {\n                try {\n                    eventHooksManager === null || eventHooksManager === void 0 ? void 0 : eventHooksManager.handle(Event.postRushx, rushxArguments.isDebug, rushxArguments.ignoreHooks);\n                }\n                catch (error) {\n                    // eslint-disable-next-line no-console\n                    console.error(Colorize.red('PostRushx hook error: ' + error.message));\n                }\n            }\n            // Getting here means that we are all done with no major errors\n            process.exitCode = 0;\n        }\n        catch (error) {\n            if (error instanceof ProcessError) {\n                process.exitCode = error.exitCode;\n            }\n            else {\n                process.exitCode = 1;\n            }\n            // eslint-disable-next-line no-console\n            console.error(Colorize.red('Error: ' + error.message));\n        }\n    }\n    static async _launchRushXInternalAsync(rushxArguments, rushConfiguration, options) {\n        if (!rushxArguments.quiet) {\n            RushStartupBanner.logStreamlinedBanner(Rush.version, options.isManaged);\n        }\n        // Are we in a Rush repo?\n        NodeJsCompatibility.warnAboutCompatibilityIssues({\n            isRushLib: true,\n            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError || false,\n            rushConfiguration\n        });\n        // Find the governing package.json for this folder:\n        const packageJsonLookup = new PackageJsonLookup();\n        const packageJsonFilePath = packageJsonLookup.tryGetPackageJsonFilePathFor(process.cwd());\n        if (!packageJsonFilePath) {\n            throw Error('This command should be used inside a project folder. ' +\n                'Unable to find a package.json file in the current working directory or any of its parents.');\n        }\n        if (rushConfiguration && !rushConfiguration.tryGetProjectForPath(process.cwd())) {\n            // GitHub #2713: Users reported confusion resulting from a situation where \"rush install\"\n            // did not install the project's dependencies, because the project was not registered.\n            // eslint-disable-next-line no-console\n            console.log(Colorize.yellow('Warning: You are invoking \"rushx\" inside a Rush repository, but this project is not registered in ' +\n                `${RushConstants.rushJsonFilename}.`));\n        }\n        const packageJson = packageJsonLookup.loadPackageJson(packageJsonFilePath);\n        const projectCommandSet = new ProjectCommandSet(packageJson);\n        if (rushxArguments.help) {\n            RushXCommandLine._showUsage(packageJson, projectCommandSet);\n            return;\n        }\n        const scriptBody = projectCommandSet.tryGetScriptBody(rushxArguments.commandName);\n        if (scriptBody === undefined) {\n            let errorMessage = `The command \"${rushxArguments.commandName}\" is not defined in the package.json file for this project.`;\n            if (projectCommandSet.commandNames.length > 0) {\n                errorMessage +=\n                    '\\nAvailable commands for this project are: ' +\n                        projectCommandSet.commandNames.map((x) => `\"${x}\"`).join(', ');\n            }\n            throw Error(errorMessage);\n        }\n        let commandWithArgs = scriptBody;\n        let commandWithArgsForDisplay = scriptBody;\n        if (rushxArguments.commandArgs.length > 0) {\n            // This approach is based on what NPM 7 now does:\n            // https://github.com/npm/run-script/blob/47a4d539fb07220e7215cc0e482683b76407ef9b/lib/run-script-pkg.js#L34\n            const escapedRemainingArgs = rushxArguments.commandArgs.map((x) => Utilities.escapeShellParameter(x));\n            commandWithArgs += ' ' + escapedRemainingArgs.join(' ');\n            // Display it nicely without the extra quotes\n            commandWithArgsForDisplay += ' ' + rushxArguments.commandArgs.join(' ');\n        }\n        if (!rushxArguments.quiet) {\n            // eslint-disable-next-line no-console\n            console.log(`> ${JSON.stringify(commandWithArgsForDisplay)}\\n`);\n        }\n        const packageFolder = path.dirname(packageJsonFilePath);\n        const exitCode = Utilities.executeLifecycleCommand(commandWithArgs, {\n            rushConfiguration,\n            workingDirectory: packageFolder,\n            // If there is a rush.json then use its .npmrc from the temp folder.\n            // Otherwise look for npmrc in the project folder.\n            initCwd: rushConfiguration ? rushConfiguration.commonTempFolder : packageFolder,\n            handleOutput: false,\n            environmentPathOptions: {\n                includeProjectBin: true\n            }\n        });\n        const terminalProvider = new ConsoleTerminalProvider({\n            debugEnabled: rushxArguments.isDebug,\n            verboseEnabled: rushxArguments.isDebug\n        });\n        const terminal = new Terminal(terminalProvider);\n        if ((rushConfiguration === null || rushConfiguration === void 0 ? void 0 : rushConfiguration.isPnpm) && (rushConfiguration === null || rushConfiguration === void 0 ? void 0 : rushConfiguration.experimentsConfiguration)) {\n            const { configuration: experiments } = rushConfiguration === null || rushConfiguration === void 0 ? void 0 : rushConfiguration.experimentsConfiguration;\n            if (experiments === null || experiments === void 0 ? void 0 : experiments.usePnpmSyncForInjectedDependencies) {\n                const pnpmSyncJsonPath = packageFolder + '/node_modules/.pnpm-sync.json';\n                if (await FileSystem.existsAsync(pnpmSyncJsonPath)) {\n                    const { PackageExtractor } = await import(\n                    /* webpackChunkName: 'PackageExtractor' */\n                    '@rushstack/package-extractor');\n                    await pnpmSyncCopyAsync({\n                        pnpmSyncJsonPath,\n                        ensureFolderAsync: FileSystem.ensureFolderAsync,\n                        forEachAsyncWithConcurrency: Async.forEachAsync,\n                        getPackageIncludedFiles: PackageExtractor.getPackageIncludedFilesAsync,\n                        logMessageCallback: (logMessageOptions) => PnpmSyncUtilities.processLogMessage(logMessageOptions, terminal)\n                    });\n                }\n            }\n        }\n        if (exitCode > 0) {\n            throw new ProcessError(`Failed calling ${commandWithArgsForDisplay}.  Exit code: ${exitCode}`, exitCode);\n        }\n    }\n    static _parseCommandLineArguments() {\n        // 0 = node.exe\n        // 1 = rushx\n        const args = process.argv.slice(2);\n        const unknownArgs = [];\n        let help = false;\n        let quiet = false;\n        let commandName = '';\n        let isDebug = false;\n        let ignoreHooks = false;\n        const commandArgs = [];\n        for (let index = 0; index < args.length; index++) {\n            const argValue = args[index];\n            if (!commandName) {\n                if (argValue === '-q' || argValue === '--quiet') {\n                    quiet = true;\n                }\n                else if (argValue === '-h' || argValue === '--help') {\n                    help = true;\n                }\n                else if (argValue === '-d' || argValue === '--debug') {\n                    isDebug = true;\n                }\n                else if (argValue === '--ignore-hooks') {\n                    ignoreHooks = true;\n                }\n                else if (argValue.startsWith('-')) {\n                    unknownArgs.push(args[index]);\n                }\n                else {\n                    commandName = args[index];\n                }\n            }\n            else {\n                commandArgs.push(args[index]);\n            }\n        }\n        if (!commandName) {\n            help = true;\n        }\n        if (unknownArgs.length > 0) {\n            // Future TODO: Instead of just displaying usage info, we could display a\n            // specific error about the unknown flag the user tried to pass to rushx.\n            // eslint-disable-next-line no-console\n            console.log(Colorize.red(`Unknown arguments: ${unknownArgs.map((x) => JSON.stringify(x)).join(', ')}`));\n            help = true;\n        }\n        return {\n            help,\n            quiet,\n            isDebug,\n            ignoreHooks,\n            commandName,\n            commandArgs\n        };\n    }\n    static _showUsage(packageJson, projectCommandSet) {\n        // eslint-disable-next-line no-console\n        console.log('usage: rushx [-h]');\n        // eslint-disable-next-line no-console\n        console.log('       rushx [-q/--quiet] [-d/--debug] [--ignore-hooks] <command> ...\\n');\n        // eslint-disable-next-line no-console\n        console.log('Optional arguments:');\n        // eslint-disable-next-line no-console\n        console.log('  -h, --help            Show this help message and exit.');\n        // eslint-disable-next-line no-console\n        console.log('  -q, --quiet           Hide rushx startup information.');\n        // eslint-disable-next-line no-console\n        console.log('  -d, --debug           Run in debug mode.\\n');\n        if (projectCommandSet.commandNames.length > 0) {\n            // eslint-disable-next-line no-console\n            console.log(`Project commands for ${Colorize.cyan(packageJson.name)}:`);\n            // Calculate the length of the longest script name, for formatting\n            let maxLength = 0;\n            for (const commandName of projectCommandSet.commandNames) {\n                maxLength = Math.max(maxLength, commandName.length);\n            }\n            for (const commandName of projectCommandSet.commandNames) {\n                const escapedScriptBody = JSON.stringify(projectCommandSet.getScriptBody(commandName));\n                // The length of the string e.g. \"  command: \"\n                const firstPartLength = 2 + maxLength + 2;\n                // The length for truncating the escaped escapedScriptBody so it doesn't wrap\n                // to the next line\n                const consoleWidth = PrintUtilities.getConsoleWidth() || DEFAULT_CONSOLE_WIDTH;\n                const truncateLength = Math.max(0, consoleWidth - firstPartLength) - 1;\n                // eslint-disable-next-line no-console\n                console.log(\n                // Example: \"  command: \"\n                '  ' +\n                    Colorize.cyan(Text.padEnd(commandName + ':', maxLength + 2)) +\n                    // Example: \"do some thin...\"\n                    Text.truncateWithEllipsis(escapedScriptBody, truncateLength));\n            }\n            if (projectCommandSet.malformedScriptNames.length > 0) {\n                // eslint-disable-next-line no-console\n                console.log('\\n' +\n                    Colorize.yellow('Warning: Some \"scripts\" entries in the package.json file' +\n                        ' have malformed names: ' +\n                        projectCommandSet.malformedScriptNames.map((x) => `\"${x}\"`).join(', ')));\n            }\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(Colorize.yellow('Warning: No commands are defined yet for this project.'));\n            // eslint-disable-next-line no-console\n            console.log('You can define a command by adding a \"scripts\" table to the project\\'s package.json file.');\n        }\n    }\n}\n//# sourceMappingURL=RushXCommandLine.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { BaseAddAndRemoveAction } from './BaseAddAndRemoveAction';\nimport { DependencySpecifier } from '../../logic/DependencySpecifier';\nimport { SemVerStyle } from '../../logic/PackageJsonUpdaterTypes';\nimport { getVariantAsync, VARIANT_PARAMETER } from '../../api/Variants';\nexport class AddAction extends BaseAddAndRemoveAction {\n    constructor(parser) {\n        const documentation = [\n            'Adds specified package(s) to the dependencies of the current project (as determined by the current working directory)' +\n                ' and then runs \"rush update\". If no version is specified, a version will be automatically detected (typically' +\n                ' either the latest version or a version that won\\'t break the \"ensureConsistentVersions\" policy). If a version' +\n                ' range (or a workspace range) is specified, the latest version in the range will be used. The version will be' +\n                ' automatically prepended with a tilde, unless the \"--exact\" or \"--caret\" flags are used. The \"--make-consistent\"' +\n                ' flag can be used to update all packages with the dependency.'\n        ].join('\\n');\n        super({\n            actionName: 'add',\n            summary: 'Adds one or more dependencies to the package.json and runs rush update.',\n            documentation,\n            safeForSimultaneousRushProcesses: false,\n            parser\n        });\n        this._packageNameList = this.defineStringListParameter({\n            parameterLongName: '--package',\n            parameterShortName: '-p',\n            required: true,\n            argumentName: 'PACKAGE',\n            description: 'The name of the package which should be added as a dependency.' +\n                ' A SemVer version specifier can be appended after an \"@\" sign.  WARNING: Symbol characters' +\n                \" are usually interpreted by your shell, so it's recommended to use quotes.\" +\n                ' For example, write \"rush add --package \"example@^1.2.3\"\" instead of \"rush add --package example@^1.2.3\".' +\n                ' To add multiple packages, write \"rush add --package foo --package bar\".'\n        });\n        this._exactFlag = this.defineFlagParameter({\n            parameterLongName: '--exact',\n            description: 'If specified, the SemVer specifier added to the' +\n                ' package.json will be an exact version (e.g. without tilde or caret).'\n        });\n        this._caretFlag = this.defineFlagParameter({\n            parameterLongName: '--caret',\n            description: 'If specified, the SemVer specifier added to the' +\n                ' package.json will be a prepended with a \"caret\" specifier (\"^\").'\n        });\n        this._devDependencyFlag = this.defineFlagParameter({\n            parameterLongName: '--dev',\n            description: 'If specified, the package will be added to the \"devDependencies\" section of the package.json'\n        });\n        this._peerDependencyFlag = this.defineFlagParameter({\n            parameterLongName: '--peer',\n            description: 'If specified, the package will be added to the \"peerDependencies\" section of the package.json'\n        });\n        this._makeConsistentFlag = this.defineFlagParameter({\n            parameterLongName: '--make-consistent',\n            parameterShortName: '-m',\n            description: 'If specified, other packages with this dependency will have their package.json' +\n                ' files updated to use the same version of the dependency.'\n        });\n        this._allFlag = this.defineFlagParameter({\n            parameterLongName: '--all',\n            description: 'If specified, the dependency will be added to all projects.'\n        });\n        this._variantParameter = this.defineStringParameter(VARIANT_PARAMETER);\n    }\n    async getUpdateOptionsAsync() {\n        const projects = super.getProjects();\n        if (this._caretFlag.value && this._exactFlag.value) {\n            throw new Error(`Only one of \"${this._caretFlag.longName}\" and \"${this._exactFlag.longName}\" should be specified`);\n        }\n        const packagesToAdd = [];\n        for (const specifiedPackageName of this.specifiedPackageNameList) {\n            /**\n             * Name & Version\n             */\n            let packageName = specifiedPackageName;\n            let version = undefined;\n            const parts = packageName.split('@');\n            if (parts[0] === '') {\n                // this is a scoped package\n                packageName = '@' + parts[1];\n                version = parts[2];\n            }\n            else {\n                packageName = parts[0];\n                version = parts[1];\n            }\n            if (!this.rushConfiguration.packageNameParser.isValidName(packageName)) {\n                throw new Error(`The package name \"${packageName}\" is not valid.`);\n            }\n            if (version && version !== 'latest') {\n                const specifier = new DependencySpecifier(packageName, version);\n                if (!semver.validRange(specifier.versionSpecifier) && !semver.valid(specifier.versionSpecifier)) {\n                    throw new Error(`The SemVer specifier \"${version}\" is not valid.`);\n                }\n            }\n            /**\n             * RangeStyle\n             */\n            let rangeStyle;\n            if (version && version !== 'latest') {\n                if (this._exactFlag.value || this._caretFlag.value) {\n                    throw new Error(`The \"${this._caretFlag.longName}\" and \"${this._exactFlag.longName}\" flags may not be specified if a ` +\n                        `version is provided in the ${this._packageNameList.longName} specifier. In this case \"${version}\" was provided.`);\n                }\n                rangeStyle = SemVerStyle.Passthrough;\n            }\n            else {\n                rangeStyle = this._caretFlag.value\n                    ? SemVerStyle.Caret\n                    : this._exactFlag.value\n                        ? SemVerStyle.Exact\n                        : SemVerStyle.Tilde;\n            }\n            packagesToAdd.push({ packageName, version, rangeStyle });\n        }\n        const variant = await getVariantAsync(this._variantParameter, this.rushConfiguration, true);\n        return {\n            projects: projects,\n            packagesToUpdate: packagesToAdd,\n            devDependency: this._devDependencyFlag.value,\n            peerDependency: this._peerDependencyFlag.value,\n            updateOtherPackages: this._makeConsistentFlag.value,\n            skipUpdate: this._skipUpdateFlag.value,\n            debugInstall: this.parser.isDebug,\n            actionName: this.actionName,\n            variant\n        };\n    }\n}\n//# sourceMappingURL=AddAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { ConsoleTerminalProvider, Terminal } from '@rushstack/terminal';\nimport { BaseRushAction } from './BaseRushAction';\nimport { RushAlerts } from '../../utilities/RushAlerts';\nexport class AlertAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'alert',\n            summary: '(EXPERIMENTAL) View and manage Rush alerts for the repository',\n            documentation: 'This command displays the Rush alerts for this repository.  Rush alerts are customizable announcements' +\n                ' and reminders that Rush prints occasionally on the command line.' +\n                '  The alert definitions can be found in the rush-alerts.json config file.',\n            parser\n        });\n        this._terminal = new Terminal(new ConsoleTerminalProvider({ verboseEnabled: parser.isDebug }));\n        this._snoozeParameter = this.defineStringParameter({\n            parameterLongName: '--snooze',\n            parameterShortName: '-s',\n            argumentName: 'ALERT_ID',\n            description: 'Temporarily suspend the specified alert for one week'\n        });\n        this._snoozeTimeFlagParameter = this.defineFlagParameter({\n            parameterLongName: '--forever',\n            description: 'Combined with \"--snooze\", causes that alert to be suspended permanently'\n        });\n    }\n    async runAsync() {\n        const rushAlerts = await RushAlerts.loadFromConfigurationAsync(this.rushConfiguration, this._terminal);\n        const snoozeAlertId = this._snoozeParameter.value;\n        if (snoozeAlertId) {\n            const snoozeTimeFlag = this._snoozeTimeFlagParameter.value;\n            await rushAlerts.snoozeAlertsByAlertIdAsync(snoozeAlertId, snoozeTimeFlag);\n        }\n        await rushAlerts.printAllAlertsAsync();\n    }\n}\n//# sourceMappingURL=AlertAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from './BaseRushAction';\nimport { RushConstants } from '../../logic/RushConstants';\n/**\n * This is the common base class for AddAction and RemoveAction.\n */\nexport class BaseAddAndRemoveAction extends BaseRushAction {\n    get specifiedPackageNameList() {\n        return this._packageNameList.values;\n    }\n    constructor(options) {\n        super(options);\n        this._skipUpdateFlag = this.defineFlagParameter({\n            parameterLongName: '--skip-update',\n            parameterShortName: '-s',\n            description: 'If specified, the \"rush update\" command will not be run after updating the package.json files.'\n        });\n    }\n    getProjects() {\n        if (this._allFlag.value) {\n            return this.rushConfiguration.projects;\n        }\n        else {\n            const currentProject = this.rushConfiguration.tryGetProjectForPath(process.cwd());\n            if (!currentProject) {\n                throw new Error(`The rush \"${this.actionName}\" command must be invoked under a project` +\n                    ` folder that is registered in ${RushConstants.rushJsonFilename} unless the ${this._allFlag.longName} is used.`);\n            }\n            return [currentProject];\n        }\n    }\n    async runAsync() {\n        const packageJsonUpdater = await import(\n        /* webpackChunkName: 'PackageJsonUpdater' */ '../../logic/PackageJsonUpdater');\n        const updater = new packageJsonUpdater.PackageJsonUpdater(this.rushConfiguration, this.rushGlobalFolder);\n        const updateOptions = await this.getUpdateOptionsAsync();\n        await updater.doRushUpdateAsync(updateOptions);\n    }\n}\n//# sourceMappingURL=BaseAddAndRemoveAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from './BaseRushAction';\nimport { Autoinstaller } from '../../logic/Autoinstaller';\nexport class BaseAutoinstallerAction extends BaseRushAction {\n    constructor(options) {\n        super(options);\n        this._name = this.defineStringParameter({\n            parameterLongName: '--name',\n            argumentName: 'AUTOINSTALLER_NAME',\n            required: true,\n            description: 'The name of the autoinstaller, which must be one of the folders under common/autoinstallers.'\n        });\n        this._terminal = this.parser.terminal;\n    }\n    async runAsync() {\n        const autoinstallerName = this._name.value;\n        const autoinstaller = new Autoinstaller({\n            autoinstallerName,\n            rushConfiguration: this.rushConfiguration,\n            rushGlobalFolder: this.rushGlobalFolder\n        });\n        await this.prepareAsync(autoinstaller);\n        this._terminal.writeLine();\n        this._terminal.writeLine('Success.');\n    }\n}\n//# sourceMappingURL=BaseAutoinstallerAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { BaseRushAction } from './BaseRushAction';\nimport { Event } from '../../api/EventHooks';\nimport { PurgeManager } from '../../logic/PurgeManager';\nimport { SetupChecks } from '../../logic/SetupChecks';\nimport { StandardScriptUpdater } from '../../logic/StandardScriptUpdater';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { VersionMismatchFinder } from '../../logic/versionMismatch/VersionMismatchFinder';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { SUBSPACE_LONG_ARG_NAME } from '../parsing/SelectionParameterSet';\nimport { getVariantAsync, VARIANT_PARAMETER } from '../../api/Variants';\n/**\n * This is the common base class for InstallAction and UpdateAction.\n */\nexport class BaseInstallAction extends BaseRushAction {\n    constructor(options) {\n        super(options);\n        this._terminal = options.parser.terminal;\n        this._purgeParameter = this.defineFlagParameter({\n            parameterLongName: '--purge',\n            parameterShortName: '-p',\n            description: 'Perform \"rush purge\" before starting the installation'\n        });\n        this._bypassPolicyParameter = this.defineFlagParameter({\n            parameterLongName: RushConstants.bypassPolicyFlagLongName,\n            description: `Overrides enforcement of the \"gitPolicy\" rules from ${RushConstants.rushJsonFilename} (use honorably!)`\n        });\n        this._noLinkParameter = this.defineFlagParameter({\n            parameterLongName: '--no-link',\n            description: 'If \"--no-link\" is specified, then project symlinks will NOT be created' +\n                ' after the installation completes.  You will need to run \"rush link\" manually.' +\n                ' This flag is useful for automated builds that want to report stages individually' +\n                ' or perform extra operations in between the two stages. This flag is not supported' +\n                ' when using workspaces.'\n        });\n        this._networkConcurrencyParameter = this.defineIntegerParameter({\n            parameterLongName: '--network-concurrency',\n            argumentName: 'COUNT',\n            description: 'If specified, limits the maximum number of concurrent network requests.' +\n                '  This is useful when troubleshooting network failures.'\n        });\n        this._debugPackageManagerParameter = this.defineFlagParameter({\n            parameterLongName: '--debug-package-manager',\n            description: 'Activates verbose logging for the package manager. You will probably want to pipe' +\n                ' the output of Rush to a file when using this command.'\n        });\n        this._maxInstallAttempts = this.defineIntegerParameter({\n            parameterLongName: '--max-install-attempts',\n            argumentName: 'NUMBER',\n            description: `Overrides the default maximum number of install attempts.`,\n            defaultValue: RushConstants.defaultMaxInstallAttempts\n        });\n        this._ignoreHooksParameter = this.defineFlagParameter({\n            parameterLongName: '--ignore-hooks',\n            description: `Skips execution of the \"eventHooks\" scripts defined in ${RushConstants.rushJsonFilename}. ` +\n                'Make sure you know what you are skipping.'\n        });\n        this._offlineParameter = this.defineFlagParameter({\n            parameterLongName: '--offline',\n            description: `Enables installation to be performed without internet access. PNPM will instead report an error` +\n                ` if the necessary NPM packages cannot be obtained from the local cache.` +\n                ` For details, see the documentation for PNPM's \"--offline\" parameter.`\n        });\n        this._variantParameter = this.defineStringParameter(VARIANT_PARAMETER);\n    }\n    async runAsync() {\n        var _a, _b, _c;\n        const installManagerOptions = await this.buildInstallOptionsAsync();\n        // If we are doing a filtered install and subspaces is enabled, we need to find the affected subspaces and install for all of them.\n        let selectedSubspaces;\n        const subspaceInstallationDataBySubspace = new Map();\n        if (this.rushConfiguration.subspacesFeatureEnabled) {\n            // Selecting all subspaces if preventSelectingAllSubspaces is not enabled in subspaces.json\n            if (((_a = this.rushConfiguration.subspacesConfiguration) === null || _a === void 0 ? void 0 : _a.preventSelectingAllSubspaces) &&\n                !((_b = this._selectionParameters) === null || _b === void 0 ? void 0 : _b.didUserSelectAnything())) {\n                this._terminal.writeLine();\n                this._terminal.writeLine(Colorize.red(`The subspaces preventSelectingAllSubspaces configuration is enabled, which enforces installation for a specified set of subspace,` +\n                    ` passed by the \"${SUBSPACE_LONG_ARG_NAME}\" parameter or selected from targeted projects using any project selector.`));\n                throw new AlreadyReportedError();\n            }\n            const { selectedProjects } = installManagerOptions;\n            if (selectedProjects.size === this.rushConfiguration.projects.length) {\n                // Optimization for the common case, equivalent to the logic below\n                selectedSubspaces = new Set(this.rushConfiguration.subspaces);\n            }\n            else {\n                selectedSubspaces = this.rushConfiguration.getSubspacesForProjects(selectedProjects);\n                for (const selectedSubspace of selectedSubspaces) {\n                    let subspaceSelectedProjects;\n                    let pnpmFilterArgumentValues;\n                    if ((_c = selectedSubspace.getPnpmOptions()) === null || _c === void 0 ? void 0 : _c.alwaysFullInstall) {\n                        subspaceSelectedProjects = new Set(selectedSubspace.getProjects());\n                        pnpmFilterArgumentValues = [];\n                    }\n                    else {\n                        // This may involve filtered installs. Go through each project, add its subspace's pnpm filter arguments\n                        subspaceSelectedProjects = new Set();\n                        pnpmFilterArgumentValues = [];\n                        for (const project of selectedSubspace.getProjects()) {\n                            if (selectedProjects.has(project)) {\n                                subspaceSelectedProjects.add(project);\n                                pnpmFilterArgumentValues.push(project.packageName);\n                            }\n                        }\n                    }\n                    subspaceInstallationDataBySubspace.set(selectedSubspace, {\n                        selectedProjects: subspaceSelectedProjects,\n                        pnpmFilterArgumentValues\n                    });\n                }\n            }\n        }\n        const variant = await getVariantAsync(this._variantParameter, this.rushConfiguration, false);\n        if (selectedSubspaces) {\n            // Check each subspace for version inconsistencies\n            for (const subspace of selectedSubspaces) {\n                VersionMismatchFinder.ensureConsistentVersions(this.rushConfiguration, this._terminal, {\n                    subspace,\n                    variant\n                });\n            }\n        }\n        else {\n            VersionMismatchFinder.ensureConsistentVersions(this.rushConfiguration, this._terminal, {\n                subspace: undefined,\n                variant\n            });\n        }\n        const stopwatch = Stopwatch.start();\n        SetupChecks.validate(this.rushConfiguration);\n        let warnAboutScriptUpdate = false;\n        if (this.actionName === 'update') {\n            warnAboutScriptUpdate = await StandardScriptUpdater.updateAsync(this.rushConfiguration);\n        }\n        else {\n            await StandardScriptUpdater.validateAsync(this.rushConfiguration);\n        }\n        this.eventHooksManager.handle(Event.preRushInstall, this.parser.isDebug, this._ignoreHooksParameter.value);\n        const purgeManager = new PurgeManager(this.rushConfiguration, this.rushGlobalFolder);\n        if (this._purgeParameter.value) {\n            // eslint-disable-next-line no-console\n            console.log('The --purge flag was specified, so performing \"rush purge\"');\n            purgeManager.purgeNormal();\n            // eslint-disable-next-line no-console\n            console.log('');\n        }\n        if (this._networkConcurrencyParameter.value) {\n            if (this.rushConfiguration.packageManager !== 'pnpm') {\n                throw new Error(`The \"${this._networkConcurrencyParameter.longName}\" parameter is` +\n                    ` only supported when using the PNPM package manager.`);\n            }\n        }\n        if (this._maxInstallAttempts.value < 1) {\n            throw new Error(`The value of \"${this._maxInstallAttempts.longName}\" must be positive and nonzero.`);\n        }\n        const installManagerFactoryModule = await import(\n        /* webpackChunkName: 'InstallManagerFactory' */\n        '../../logic/InstallManagerFactory');\n        let installSuccessful = true;\n        try {\n            if (selectedSubspaces) {\n                // Run the install for each affected subspace\n                for (const subspace of selectedSubspaces) {\n                    const subspaceInstallationData = subspaceInstallationDataBySubspace.get(subspace);\n                    // eslint-disable-next-line no-console\n                    console.log(Colorize.green(`Installing for subspace: ${subspace.subspaceName}`));\n                    let installManagerOptionsForInstall;\n                    if (subspaceInstallationData) {\n                        // This will install the selected of projects in the subspace\n                        const { selectedProjects, pnpmFilterArgumentValues } = subspaceInstallationData;\n                        installManagerOptionsForInstall = Object.assign(Object.assign({}, installManagerOptions), { selectedProjects,\n                            // IMPORTANT: SelectionParameterSet.getPnpmFilterArgumentValuesAsync() already calculated\n                            // installManagerOptions.pnpmFilterArgumentValues using PNPM CLI operators such as \"...my-app\".\n                            // But with subspaces, \"pnpm install\" can only see the subset of projects in subspace's temp workspace,\n                            // therefore an operator like \"--filter ...my-app\" will malfunction.  As a workaround, here we are\n                            // overwriting installManagerOptions.pnpmFilterArgumentValues with a flat last of project names that\n                            // were calculated by Rush.\n                            //\n                            // TODO: If the flat list produces too many \"--filter\" arguments, invoking \"pnpm install\" will exceed\n                            // the maximum command length and fail on Windows OS.  Once this is solved, we can eliminate the\n                            // redundant logic from SelectionParameterSet.getPnpmFilterArgumentValuesAsync().\n                            pnpmFilterArgumentValues,\n                            subspace });\n                    }\n                    else {\n                        // This will install all projects in the subspace\n                        installManagerOptionsForInstall = Object.assign(Object.assign({}, installManagerOptions), { pnpmFilterArgumentValues: [], subspace });\n                    }\n                    await this._doInstallAsync(installManagerFactoryModule, purgeManager, installManagerOptionsForInstall);\n                }\n            }\n            else {\n                // Simple case when subspacesFeatureEnabled=false\n                await this._doInstallAsync(installManagerFactoryModule, purgeManager, Object.assign(Object.assign({}, installManagerOptions), { subspace: this.rushConfiguration.defaultSubspace }));\n            }\n        }\n        catch (error) {\n            installSuccessful = false;\n            throw error;\n        }\n        finally {\n            await purgeManager.startDeleteAllAsync();\n            stopwatch.stop();\n            this._collectTelemetry(stopwatch, installManagerOptions, installSuccessful);\n            this.parser.flushTelemetry();\n            this.eventHooksManager.handle(Event.postRushInstall, this.parser.isDebug, this._ignoreHooksParameter.value);\n        }\n        if (warnAboutScriptUpdate) {\n            // eslint-disable-next-line no-console\n            console.log('\\n' +\n                Colorize.yellow('Rush refreshed some files in the \"common/scripts\" folder.' +\n                    '  Please commit this change to Git.'));\n        }\n        // eslint-disable-next-line no-console\n        console.log('\\n' + Colorize.green(`Rush ${this.actionName} finished successfully. (${stopwatch.toString()})`));\n    }\n    async _doInstallAsync(installManagerFactoryModule, purgeManager, installManagerOptions) {\n        const installManager = await installManagerFactoryModule.InstallManagerFactory.getInstallManagerAsync(this.rushConfiguration, this.rushGlobalFolder, purgeManager, installManagerOptions);\n        await installManager.doInstallAsync();\n    }\n    _collectTelemetry(stopwatch, installManagerOptions, success) {\n        var _a;\n        if (this.parser.telemetry) {\n            const extraData = Object.assign(Object.assign({ mode: this.actionName, clean: (!!this._purgeParameter.value).toString(), debug: installManagerOptions.debug.toString(), full: installManagerOptions.fullUpgrade.toString() }, this.getParameterStringMap()), (_a = this._selectionParameters) === null || _a === void 0 ? void 0 : _a.getTelemetry());\n            this.parser.telemetry.log({\n                name: 'install',\n                durationInSeconds: stopwatch.duration,\n                result: success ? 'Succeeded' : 'Failed',\n                extraData\n            });\n        }\n    }\n}\n//# sourceMappingURL=BaseInstallAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { CommandLineAction } from '@rushstack/ts-command-line';\nimport { LockFile } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { EventHooksManager } from '../../logic/EventHooksManager';\nimport { RushCommandLineParser } from '../RushCommandLineParser';\nimport { Utilities } from '../../utilities/Utilities';\n/**\n * The base class for a few specialized Rush command-line actions that\n * can be used without a rush.json configuration.\n */\nexport class BaseConfiglessRushAction extends CommandLineAction {\n    get rushConfiguration() {\n        return this.parser.rushConfiguration;\n    }\n    get rushSession() {\n        return this.parser.rushSession;\n    }\n    get rushGlobalFolder() {\n        return this.parser.rushGlobalFolder;\n    }\n    constructor(options) {\n        super(options);\n        this.parser = options.parser;\n        this._safeForSimultaneousRushProcesses = !!options.safeForSimultaneousRushProcesses;\n    }\n    onExecute() {\n        this._ensureEnvironment();\n        if (this.rushConfiguration) {\n            if (!this._safeForSimultaneousRushProcesses) {\n                if (!LockFile.tryAcquire(this.rushConfiguration.commonTempFolder, 'rush')) {\n                    // eslint-disable-next-line no-console\n                    console.log(Colorize.red(`Another Rush command is already running in this repository.`));\n                    process.exit(1);\n                }\n            }\n        }\n        if (!RushCommandLineParser.shouldRestrictConsoleOutput()) {\n            // eslint-disable-next-line no-console\n            console.log(`Starting \"rush ${this.actionName}\"\\n`);\n        }\n        return this.runAsync();\n    }\n    _ensureEnvironment() {\n        if (this.rushConfiguration) {\n            // eslint-disable-next-line dot-notation\n            let environmentPath = process.env['PATH'];\n            environmentPath =\n                path.join(this.rushConfiguration.commonTempFolder, 'node_modules', '.bin') +\n                    path.delimiter +\n                    environmentPath;\n            // eslint-disable-next-line dot-notation\n            process.env['PATH'] = environmentPath;\n        }\n    }\n}\n/**\n * The base class that most Rush command-line actions should extend.\n */\nexport class BaseRushAction extends BaseConfiglessRushAction {\n    get eventHooksManager() {\n        if (!this._eventHooksManager) {\n            this._eventHooksManager = new EventHooksManager(this.rushConfiguration);\n        }\n        return this._eventHooksManager;\n    }\n    get rushConfiguration() {\n        return super.rushConfiguration;\n    }\n    async onExecute() {\n        if (!this.rushConfiguration) {\n            throw Utilities.getRushConfigNotFoundError();\n        }\n        this._throwPluginErrorIfNeed();\n        await this.parser.pluginManager.tryInitializeAssociatedCommandPluginsAsync(this.actionName);\n        this._throwPluginErrorIfNeed();\n        const { hooks: sessionHooks } = this.rushSession;\n        if (sessionHooks.initialize.isUsed()) {\n            // Avoid the cost of compiling the hook if it wasn't tapped.\n            await sessionHooks.initialize.promise(this);\n        }\n        return super.onExecute();\n    }\n    /**\n     * If an error is encountered while trying to load plugins, it is saved in the `PluginManager.error`\n     * property, so we can defer throwing it until when `_throwPluginErrorIfNeed()` is called.\n     */\n    _throwPluginErrorIfNeed() {\n        // If the plugin configuration is broken, these three commands are used to fix the problem:\n        //\n        //   \"rush update\"\n        //   \"rush init-autoinstaller\"\n        //   \"rush update-autoinstaller\"\n        //\n        // In addition, the \"rush setup\" command is designed to help new users configure their access\n        // to a private NPM registry, which means it can't rely on plugins that might live in that\n        // registry.\n        //\n        // Thus we do not report plugin errors when invoking these commands.\n        if (!['update', 'init-autoinstaller', 'update-autoinstaller', 'setup'].includes(this.actionName)) {\n            const pluginError = this.parser.pluginManager.error;\n            if (pluginError) {\n                throw pluginError;\n            }\n        }\n    }\n}\n//# sourceMappingURL=BaseRushAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as child_process from 'child_process';\nimport { FileSystem, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Terminal, ConsoleTerminalProvider, Colorize } from '@rushstack/terminal';\nimport { getRepoRoot } from '@rushstack/package-deps-hash';\nimport { ChangeType } from '../../api/ChangeManagement';\nimport { ChangeFile } from '../../api/ChangeFile';\nimport { BaseRushAction } from './BaseRushAction';\nimport { ChangeFiles } from '../../logic/ChangeFiles';\nimport { VersionPolicyDefinitionName } from '../../api/VersionPolicy';\nimport { ProjectChangeAnalyzer } from '../../logic/ProjectChangeAnalyzer';\nimport { Git } from '../../logic/Git';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { Utilities } from '../../utilities/Utilities';\nconst BULK_LONG_NAME = '--bulk';\nconst BULK_MESSAGE_LONG_NAME = '--message';\nconst BULK_BUMP_TYPE_LONG_NAME = '--bump-type';\nexport class ChangeAction extends BaseRushAction {\n    constructor(parser) {\n        const documentation = [\n            'Asks a series of questions and then generates a <branchname>-<timestamp>.json file ' +\n                'in the common folder. The `publish` command will consume these files and perform the proper ' +\n                'version bumps. Note these changes will eventually be published in a changelog.md file in each package.',\n            '',\n            'The possible types of changes are: ',\n            '',\n            'MAJOR - these are breaking changes that are not backwards compatible. ' +\n                'Examples are: renaming a public class, adding/removing a non-optional ' +\n                'parameter from a public API, or renaming an variable or function that ' +\n                'is exported.',\n            '',\n            'MINOR - these are changes that are backwards compatible (but not ' +\n                'forwards compatible). Examples are: adding a new public API or adding an ' +\n                'optional parameter to a public API',\n            '',\n            'PATCH - these are changes that are backwards and forwards compatible. ' +\n                'Examples are: Modifying a private API or fixing a bug in the logic ' +\n                'of how an existing API works.',\n            '',\n            \"NONE - these are changes that are backwards and forwards compatible and don't require an immediate release. \" +\n                'Examples are: Modifying dev tooling configuration like eslint.',\n            '',\n            'HOTFIX (EXPERIMENTAL) - these are changes that are hotfixes targeting a ' +\n                'specific older version of the package. When a hotfix change is added, ' +\n                'other changes will not be able to increment the version number. ' +\n                `Enable this feature by setting 'hotfixChangeEnabled' in your ${RushConstants.rushJsonFilename}.`,\n            ''\n        ].join('\\n');\n        super({\n            actionName: 'change',\n            summary: 'Records changes made to projects, indicating how the package version number should be bumped ' +\n                'for the next publish.',\n            documentation,\n            safeForSimultaneousRushProcesses: true,\n            parser\n        });\n        this._git = new Git(this.rushConfiguration);\n        this._terminal = new Terminal(new ConsoleTerminalProvider({ verboseEnabled: parser.isDebug }));\n        this._verifyParameter = this.defineFlagParameter({\n            parameterLongName: '--verify',\n            parameterShortName: '-v',\n            description: 'Verify the change file has been generated and that it is a valid JSON file'\n        });\n        this._noFetchParameter = this.defineFlagParameter({\n            parameterLongName: '--no-fetch',\n            description: 'Skips fetching the baseline branch before running \"git diff\" to detect changes.'\n        });\n        this._targetBranchParameter = this.defineStringParameter({\n            parameterLongName: '--target-branch',\n            parameterShortName: '-b',\n            argumentName: 'BRANCH',\n            description: 'If this parameter is specified, compare the checked out branch with the specified branch to ' +\n                'determine which projects were changed. If this parameter is not specified, the checked out branch ' +\n                'is compared against the \"main\" branch.'\n        });\n        this._overwriteFlagParameter = this.defineFlagParameter({\n            parameterLongName: '--overwrite',\n            description: `If a changefile already exists, overwrite without prompting ` +\n                `(or erroring in ${BULK_LONG_NAME} mode).`\n        });\n        this._commitChangesFlagParameter = this.defineFlagParameter({\n            parameterLongName: '--commit',\n            parameterShortName: '-c',\n            description: `If this flag is specified generated changefiles will be commited automatically.`\n        });\n        this._commitChangesMessageStringParameter = this.defineStringParameter({\n            parameterLongName: '--commit-message',\n            argumentName: 'COMMIT_MESSAGE',\n            description: `If this parameter is specified generated changefiles will be commited automatically with the specified commit message.`\n        });\n        this._changeEmailParameter = this.defineStringParameter({\n            parameterLongName: '--email',\n            argumentName: 'EMAIL',\n            description: 'The email address to use in changefiles. If this parameter is not provided, the email address ' +\n                'will be detected or prompted for in interactive mode.'\n        });\n        this._bulkChangeParameter = this.defineFlagParameter({\n            parameterLongName: BULK_LONG_NAME,\n            description: 'If this flag is specified, apply the same change message and bump type to all changed projects. ' +\n                `The ${BULK_MESSAGE_LONG_NAME} and the ${BULK_BUMP_TYPE_LONG_NAME} parameters must be specified if the ` +\n                `${BULK_LONG_NAME} parameter is specified`\n        });\n        this._bulkChangeMessageParameter = this.defineStringParameter({\n            parameterLongName: BULK_MESSAGE_LONG_NAME,\n            argumentName: 'MESSAGE',\n            description: `The message to apply to all changed projects if the ${BULK_LONG_NAME} flag is provided.`\n        });\n        this._bulkChangeBumpTypeParameter = this.defineChoiceParameter({\n            parameterLongName: BULK_BUMP_TYPE_LONG_NAME,\n            alternatives: [...Object.keys(this._getBumpOptions())],\n            description: `The bump type to apply to all changed projects if the ${BULK_LONG_NAME} flag is provided.`\n        });\n    }\n    async runAsync() {\n        const targetBranch = await this._getTargetBranchAsync();\n        // eslint-disable-next-line no-console\n        console.log(`The target branch is ${targetBranch}`);\n        if (this._verifyParameter.value) {\n            const errors = [\n                this._bulkChangeParameter,\n                this._bulkChangeMessageParameter,\n                this._bulkChangeBumpTypeParameter,\n                this._overwriteFlagParameter,\n                this._commitChangesFlagParameter\n            ]\n                .map((parameter) => {\n                return parameter.value\n                    ? `The {${this._bulkChangeParameter.longName} parameter cannot be provided with the ` +\n                        `${this._verifyParameter.longName} parameter`\n                    : '';\n            })\n                .filter((error) => error !== '');\n            if (errors.length > 0) {\n                errors.forEach((error) => {\n                    // eslint-disable-next-line no-console\n                    console.error(error);\n                });\n                throw new AlreadyReportedError();\n            }\n            await this._verifyAsync();\n            return;\n        }\n        const sortedProjectList = (await this._getChangedProjectNamesAsync()).sort();\n        if (sortedProjectList.length === 0) {\n            this._logNoChangeFileRequired();\n            await this._warnUnstagedChangesAsync();\n            return;\n        }\n        await this._warnUnstagedChangesAsync();\n        const inquirer = await import('inquirer');\n        const promptModule = inquirer.createPromptModule();\n        let changeFileData = new Map();\n        let interactiveMode = false;\n        if (this._bulkChangeParameter.value) {\n            if (!this._bulkChangeBumpTypeParameter.value ||\n                (!this._bulkChangeMessageParameter.value &&\n                    this._bulkChangeBumpTypeParameter.value !== ChangeType[ChangeType.none])) {\n                throw new Error(`The ${this._bulkChangeBumpTypeParameter.longName} and ${this._bulkChangeMessageParameter.longName} ` +\n                    `parameters must provided if the ${this._bulkChangeParameter.longName} flag is provided. If the value ` +\n                    `\"${ChangeType[ChangeType.none]}\" is provided to the ${this._bulkChangeBumpTypeParameter.longName} ` +\n                    `parameter, the ${this._bulkChangeMessageParameter.longName} parameter may be omitted.`);\n            }\n            const email = this._changeEmailParameter.value || this._detectEmail();\n            if (!email) {\n                throw new Error(\"Unable to detect Git email and an email address wasn't provided using the \" +\n                    `${this._changeEmailParameter.longName} parameter.`);\n            }\n            const errors = [];\n            const comment = this._bulkChangeMessageParameter.value || '';\n            const changeType = this._bulkChangeBumpTypeParameter.value;\n            for (const packageName of sortedProjectList) {\n                const allowedBumpTypes = Object.keys(this._getBumpOptions(packageName));\n                let projectChangeType = changeType;\n                if (allowedBumpTypes.length === 0) {\n                    projectChangeType = ChangeType[ChangeType.none];\n                }\n                else if (projectChangeType !== ChangeType[ChangeType.none] &&\n                    allowedBumpTypes.indexOf(projectChangeType) === -1) {\n                    errors.push(`The \"${projectChangeType}\" change type is not allowed for package \"${packageName}\".`);\n                }\n                changeFileData.set(packageName, {\n                    changes: [\n                        {\n                            comment,\n                            type: projectChangeType,\n                            packageName\n                        }\n                    ],\n                    packageName,\n                    email\n                });\n            }\n            if (errors.length > 0) {\n                for (const error of errors) {\n                    // eslint-disable-next-line no-console\n                    console.error(error);\n                }\n                throw new AlreadyReportedError();\n            }\n        }\n        else if (this._bulkChangeBumpTypeParameter.value || this._bulkChangeMessageParameter.value) {\n            throw new Error(`The ${this._bulkChangeParameter.longName} flag must be provided with the ` +\n                `${this._bulkChangeBumpTypeParameter.longName} and ${this._bulkChangeMessageParameter.longName} parameters.`);\n        }\n        else {\n            interactiveMode = true;\n            const existingChangeComments = ChangeFiles.getChangeComments(await this._getChangeFilesAsync());\n            changeFileData = await this._promptForChangeFileDataAsync(promptModule, sortedProjectList, existingChangeComments);\n            if (this._isEmailRequired(changeFileData)) {\n                const email = this._changeEmailParameter.value\n                    ? this._changeEmailParameter.value\n                    : await this._detectOrAskForEmailAsync(promptModule);\n                changeFileData.forEach((changeFile) => {\n                    var _a, _b;\n                    changeFile.email = ((_b = (_a = this.rushConfiguration.getProjectByName(changeFile.packageName)) === null || _a === void 0 ? void 0 : _a.versionPolicy) === null || _b === void 0 ? void 0 : _b.includeEmailInChangeFile)\n                        ? email\n                        : '';\n                });\n            }\n        }\n        let changefiles;\n        try {\n            changefiles = await this._writeChangeFilesAsync(promptModule, changeFileData, this._overwriteFlagParameter.value, interactiveMode);\n        }\n        catch (error) {\n            throw new Error(`There was an error creating a change file: ${error.toString()}`);\n        }\n        if (this._commitChangesFlagParameter.value || this._commitChangesMessageStringParameter.value) {\n            if (changefiles && changefiles.length !== 0) {\n                await this._stageAndCommitGitChangesAsync(changefiles, this._commitChangesMessageStringParameter.value ||\n                    this.rushConfiguration.gitChangefilesCommitMessage ||\n                    'Rush change');\n            }\n            else {\n                this._terminal.writeWarningLine('Warning: No change files generated, nothing to commit.');\n            }\n        }\n    }\n    _generateHostMap() {\n        var _a;\n        const hostMap = new Map();\n        for (const project of this.rushConfiguration.projects) {\n            let hostProjectName = project.packageName;\n            if ((_a = project.versionPolicy) === null || _a === void 0 ? void 0 : _a.isLockstepped) {\n                const lockstepPolicy = project.versionPolicy;\n                hostProjectName = lockstepPolicy.mainProject || project.packageName;\n            }\n            hostMap.set(project, hostProjectName);\n        }\n        return hostMap;\n    }\n    async _verifyAsync() {\n        const changedPackages = await this._getChangedProjectNamesAsync();\n        if (changedPackages.length > 0) {\n            await this._validateChangeFileAsync(changedPackages);\n        }\n        else {\n            this._logNoChangeFileRequired();\n        }\n    }\n    async _getTargetBranchAsync() {\n        if (!this._targetBranchName) {\n            this._targetBranchName =\n                this._targetBranchParameter.value || (await this._git.getRemoteDefaultBranchAsync());\n        }\n        return this._targetBranchName;\n    }\n    async _getChangedProjectNamesAsync() {\n        var _a;\n        const projectChangeAnalyzer = new ProjectChangeAnalyzer(this.rushConfiguration);\n        const changedProjects = await projectChangeAnalyzer.getChangedProjectsAsync({\n            targetBranchName: await this._getTargetBranchAsync(),\n            terminal: this._terminal,\n            shouldFetch: !this._noFetchParameter.value,\n            // Lockfile evaluation will expand the set of projects that request change files\n            // Not enabling, since this would be a breaking change\n            includeExternalDependencies: false,\n            // Since install may not have happened, cannot read rush-project.json\n            enableFiltering: false\n        });\n        const projectHostMap = this._generateHostMap();\n        const changedProjectNames = new Set();\n        for (const changedProject of changedProjects) {\n            if (changedProject.shouldPublish && !((_a = changedProject.versionPolicy) === null || _a === void 0 ? void 0 : _a.exemptFromRushChange)) {\n                const hostName = projectHostMap.get(changedProject);\n                if (hostName) {\n                    changedProjectNames.add(hostName);\n                }\n            }\n        }\n        return Array.from(changedProjectNames);\n    }\n    async _validateChangeFileAsync(changedPackages) {\n        const files = await this._getChangeFilesAsync();\n        ChangeFiles.validate(files, changedPackages, this.rushConfiguration);\n    }\n    async _getChangeFilesAsync() {\n        const repoRoot = getRepoRoot(this.rushConfiguration.rushJsonFolder);\n        const relativeChangesFolder = path.relative(repoRoot, this.rushConfiguration.changesFolder);\n        const targetBranch = await this._getTargetBranchAsync();\n        const changedFiles = await this._git.getChangedFilesAsync(targetBranch, this._terminal, true, relativeChangesFolder);\n        const result = [];\n        for (const changedFile of changedFiles) {\n            result.push(path.join(repoRoot, changedFile));\n        }\n        return result;\n    }\n    /**\n     * The main loop which prompts the user for information on changed projects.\n     */\n    async _promptForChangeFileDataAsync(promptModule, sortedProjectList, existingChangeComments) {\n        const changedFileData = new Map();\n        for (const projectName of sortedProjectList) {\n            const changeInfo = await this._askQuestionsAsync(promptModule, projectName, existingChangeComments);\n            if (changeInfo) {\n                // Save the info into the change file\n                let changeFile = changedFileData.get(changeInfo.packageName);\n                if (!changeFile) {\n                    changeFile = {\n                        changes: [],\n                        packageName: changeInfo.packageName,\n                        email: undefined\n                    };\n                    changedFileData.set(changeInfo.packageName, changeFile);\n                }\n                changeFile.changes.push(changeInfo);\n            }\n        }\n        return changedFileData;\n    }\n    /**\n     * Asks all questions which are needed to generate changelist for a project.\n     */\n    async _askQuestionsAsync(promptModule, packageName, existingChangeComments) {\n        // eslint-disable-next-line no-console\n        console.log(`\\n${packageName}`);\n        const comments = existingChangeComments.get(packageName);\n        if (comments) {\n            // eslint-disable-next-line no-console\n            console.log(`Found existing comments:`);\n            comments.forEach((comment) => {\n                // eslint-disable-next-line no-console\n                console.log(`    > ${comment}`);\n            });\n            const { appendComment } = await promptModule({\n                name: 'appendComment',\n                type: 'list',\n                default: 'skip',\n                message: 'Append to existing comments or skip?',\n                choices: [\n                    {\n                        name: 'Skip',\n                        value: 'skip'\n                    },\n                    {\n                        name: 'Append',\n                        value: 'append'\n                    }\n                ]\n            });\n            if (appendComment === 'skip') {\n                return undefined;\n            }\n            else {\n                return await this._promptForCommentsAsync(promptModule, packageName);\n            }\n        }\n        else {\n            return await this._promptForCommentsAsync(promptModule, packageName);\n        }\n    }\n    async _promptForCommentsAsync(promptModule, packageName) {\n        const bumpOptions = this._getBumpOptions(packageName);\n        const { comment } = await promptModule({\n            name: 'comment',\n            type: 'input',\n            message: `Describe changes, or ENTER if no changes:`\n        });\n        if (Object.keys(bumpOptions).length === 0 || !comment) {\n            return {\n                packageName: packageName,\n                comment: comment || '',\n                type: ChangeType[ChangeType.none]\n            };\n        }\n        else {\n            const { bumpType } = await promptModule({\n                choices: Object.keys(bumpOptions).map((option) => {\n                    return {\n                        value: option,\n                        name: bumpOptions[option]\n                    };\n                }),\n                default: 'patch',\n                message: 'Select the type of change:',\n                name: 'bumpType',\n                type: 'list'\n            });\n            return {\n                packageName: packageName,\n                comment: comment,\n                type: bumpType\n            };\n        }\n    }\n    _getBumpOptions(packageName) {\n        let bumpOptions = this.rushConfiguration && this.rushConfiguration.hotfixChangeEnabled\n            ? {\n                [ChangeType[ChangeType.hotfix]]: 'hotfix - for changes that need to be published in a separate hotfix package'\n            }\n            : {\n                [ChangeType[ChangeType.major]]: 'major - for changes that break compatibility, e.g. removing an API',\n                [ChangeType[ChangeType.minor]]: 'minor - for backwards compatible changes, e.g. adding a new API',\n                [ChangeType[ChangeType.patch]]: 'patch - for changes that do not affect compatibility, e.g. fixing a bug',\n                [ChangeType[ChangeType.none]]: 'none - for changes that do not need an immediate release, e.g. eslint config change'\n            };\n        if (packageName) {\n            const project = this.rushConfiguration.getProjectByName(packageName);\n            const versionPolicy = project.versionPolicy;\n            if (versionPolicy) {\n                if (versionPolicy.definitionName === VersionPolicyDefinitionName.lockStepVersion) {\n                    const lockStepPolicy = versionPolicy;\n                    // No need to ask for bump types if project is lockstep versioned with an explicit nextBump\n                    if (lockStepPolicy.nextBump !== undefined) {\n                        bumpOptions = {};\n                    }\n                }\n                else if (versionPolicy.definitionName === VersionPolicyDefinitionName.individualVersion) {\n                    const individualPolicy = versionPolicy;\n                    if (individualPolicy.lockedMajor !== undefined) {\n                        delete bumpOptions[ChangeType[ChangeType.major]];\n                    }\n                }\n            }\n        }\n        return bumpOptions;\n    }\n    _isEmailRequired(changeFileData) {\n        return [...changeFileData.values()].some((changeFile) => {\n            var _a, _b;\n            return !!((_b = (_a = this.rushConfiguration.getProjectByName(changeFile.packageName)) === null || _a === void 0 ? void 0 : _a.versionPolicy) === null || _b === void 0 ? void 0 : _b.includeEmailInChangeFile);\n        });\n    }\n    /**\n     * Will determine a user's email by first detecting it from their Git config,\n     * or will ask for it if it is not found or the Git config is wrong.\n     */\n    async _detectOrAskForEmailAsync(promptModule) {\n        return ((await this._detectAndConfirmEmailAsync(promptModule)) ||\n            (await this._promptForEmailAsync(promptModule)));\n    }\n    _detectEmail() {\n        try {\n            return child_process\n                .execSync('git config user.email')\n                .toString()\n                .replace(/(\\r\\n|\\n|\\r)/gm, '');\n        }\n        catch (err) {\n            // eslint-disable-next-line no-console\n            console.log('There was an issue detecting your Git email...');\n            return undefined;\n        }\n    }\n    /**\n     * Detects the user's email address from their Git configuration, prompts the user to approve the\n     * detected email. It returns undefined if it cannot be detected.\n     */\n    async _detectAndConfirmEmailAsync(promptModule) {\n        const email = this._detectEmail();\n        if (email) {\n            const { isCorrectEmail } = await promptModule([\n                {\n                    type: 'confirm',\n                    name: 'isCorrectEmail',\n                    default: 'Y',\n                    message: `Is your email address ${email}?`\n                }\n            ]);\n            return isCorrectEmail ? email : undefined;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Asks the user for their email address\n     */\n    async _promptForEmailAsync(promptModule) {\n        const { email } = await promptModule([\n            {\n                type: 'input',\n                name: 'email',\n                message: 'What is your email address?',\n                validate: (input) => {\n                    return true; // @todo should be an email\n                }\n            }\n        ]);\n        return email;\n    }\n    async _warnUnstagedChangesAsync() {\n        try {\n            const hasUnstagedChanges = await this._git.hasUnstagedChangesAsync();\n            if (hasUnstagedChanges) {\n                // eslint-disable-next-line no-console\n                console.log('\\n' +\n                    Colorize.yellow('Warning: You have unstaged changes, which do not trigger prompting for change ' +\n                        'descriptions.'));\n            }\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.log(`An error occurred when detecting unstaged changes: ${error}`);\n        }\n    }\n    /**\n     * Writes change files to the common/changes folder. Will prompt for overwrite if file already exists.\n     */\n    async _writeChangeFilesAsync(promptModule, changeFileData, overwrite, interactiveMode) {\n        const writtenFiles = [];\n        await changeFileData.forEach(async (changeFile) => {\n            const writtenFile = await this._writeChangeFileAsync(promptModule, changeFile, overwrite, interactiveMode);\n            if (writtenFile) {\n                writtenFiles.push(writtenFile);\n            }\n        });\n        return writtenFiles;\n    }\n    async _writeChangeFileAsync(promptModule, changeFileData, overwrite, interactiveMode) {\n        const output = JSON.stringify(changeFileData, undefined, 2);\n        const changeFile = new ChangeFile(changeFileData, this.rushConfiguration);\n        const filePath = changeFile.generatePath();\n        const fileExists = FileSystem.exists(filePath);\n        const shouldWrite = !fileExists ||\n            overwrite ||\n            (interactiveMode ? await this._promptForOverwriteAsync(promptModule, filePath) : false);\n        if (!interactiveMode && fileExists && !overwrite) {\n            throw new Error(`Changefile ${filePath} already exists`);\n        }\n        if (shouldWrite) {\n            this._writeFile(filePath, output, shouldWrite && fileExists);\n            return filePath;\n        }\n    }\n    async _promptForOverwriteAsync(promptModule, filePath) {\n        const overwrite = await promptModule([\n            {\n                name: 'overwrite',\n                type: 'confirm',\n                message: `Overwrite ${filePath}?`\n            }\n        ]);\n        if (overwrite) {\n            return true;\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(`Not overwriting ${filePath}`);\n            return false;\n        }\n    }\n    /**\n     * Writes a file to disk, ensuring the directory structure up to that point exists\n     */\n    _writeFile(fileName, output, isOverwrite) {\n        FileSystem.writeFile(fileName, output, { ensureFolderExists: true });\n        if (isOverwrite) {\n            // eslint-disable-next-line no-console\n            console.log(`Overwrote file: ${fileName}`);\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(`Created file: ${fileName}`);\n        }\n    }\n    _logNoChangeFileRequired() {\n        // eslint-disable-next-line no-console\n        console.log('No changes were detected to relevant packages on this branch. Nothing to do.');\n    }\n    async _stageAndCommitGitChangesAsync(pattern, message) {\n        try {\n            await Utilities.executeCommandAsync({\n                command: 'git',\n                args: ['add', ...pattern],\n                workingDirectory: this.rushConfiguration.changesFolder\n            });\n            await Utilities.executeCommandAsync({\n                command: 'git',\n                args: ['commit', ...pattern, '-m', message],\n                workingDirectory: this.rushConfiguration.changesFolder\n            });\n        }\n        catch (error) {\n            this._terminal.writeErrorLine(`ERROR: Cannot stage and commit git changes ${error.message}`);\n        }\n    }\n}\n//# sourceMappingURL=ChangeAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Colorize } from '@rushstack/terminal';\nimport { BaseRushAction } from './BaseRushAction';\nimport { VersionMismatchFinder } from '../../logic/versionMismatch/VersionMismatchFinder';\nimport { getVariantAsync, VARIANT_PARAMETER } from '../../api/Variants';\nexport class CheckAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'check',\n            summary: \"Checks each project's package.json files and ensures that all dependencies are of the same \" +\n                'version throughout the repository.',\n            documentation: \"Checks each project's package.json files and ensures that all dependencies are of the \" +\n                'same version throughout the repository.',\n            safeForSimultaneousRushProcesses: true,\n            parser\n        });\n        this._terminal = parser.terminal;\n        this._jsonFlag = this.defineFlagParameter({\n            parameterLongName: '--json',\n            description: 'If this flag is specified, output will be in JSON format.'\n        });\n        this._verboseFlag = this.defineFlagParameter({\n            parameterLongName: '--verbose',\n            description: 'If this flag is specified, long lists of package names will not be truncated. ' +\n                `This has no effect if the ${this._jsonFlag.longName} flag is also specified.`\n        });\n        this._subspaceParameter = this.defineStringParameter({\n            parameterLongName: '--subspace',\n            argumentName: 'SUBSPACE_NAME',\n            description: '(EXPERIMENTAL) Specifies an individual Rush subspace to check, requiring versions to be ' +\n                'consistent only within that subspace (ignoring other subspaces). This parameter is required when ' +\n                'the \"subspacesEnabled\" setting is set to true in subspaces.json.'\n        });\n        this._variantParameter = this.defineStringParameter(VARIANT_PARAMETER);\n    }\n    async runAsync() {\n        var _a;\n        if (this.rushConfiguration.subspacesFeatureEnabled && !this._subspaceParameter) {\n            throw new Error(`The --subspace parameter must be specified with \"rush check\" when subspaces is enabled.`);\n        }\n        const currentlyInstalledVariant = await this.rushConfiguration.getCurrentlyInstalledVariantAsync();\n        const variant = await getVariantAsync(this._variantParameter, this.rushConfiguration, true);\n        if (!variant && currentlyInstalledVariant) {\n            this._terminal.writeWarningLine(Colorize.yellow(`Variant '${currentlyInstalledVariant}' has been installed, but 'rush check' is currently checking the default variant. ` +\n                `Use 'rush ${this.actionName} ${this._variantParameter.longName} '${currentlyInstalledVariant}' to check the current installation.`));\n        }\n        VersionMismatchFinder.rushCheck(this.rushConfiguration, this._terminal, {\n            variant,\n            printAsJson: this._jsonFlag.value,\n            truncateLongPackageNameLists: !this._verboseFlag.value,\n            subspace: ((_a = this._subspaceParameter) === null || _a === void 0 ? void 0 : _a.value)\n                ? this.rushConfiguration.getSubspace(this._subspaceParameter.value)\n                : this.rushConfiguration.defaultSubspace\n        });\n    }\n}\n//# sourceMappingURL=CheckAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { BaseRushAction } from './BaseRushAction';\nimport { PnpmfileConfiguration } from '../../logic/pnpm/PnpmfileConfiguration';\nexport class DeployAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'deploy',\n            summary: 'Prepares a deployment by copying a subset of Rush projects and their dependencies' +\n                ' to a target folder',\n            documentation: 'After building the repo, \"rush deploy\" can be used to prepare a deployment by copying' +\n                ' a subset of Rush projects and their dependencies to a target folder, which can then be uploaded to' +\n                ' a production server.  The \"rush deploy\" behavior is specified by a scenario config file that must' +\n                ' be created first, using the \"rush init-deploy\" command.',\n            parser,\n            // It is okay to invoke multiple instances of \"rush deploy\" simultaneously, if they are writing\n            // to different target folders.\n            safeForSimultaneousRushProcesses: true\n        });\n        this._logger = this.rushSession.getLogger('deploy');\n        this._project = this.defineStringParameter({\n            parameterLongName: '--project',\n            parameterShortName: '-p',\n            argumentName: 'PROJECT_NAME',\n            description: 'Specifies the name of the main Rush project to be deployed. It must appear in the' +\n                ' \"deploymentProjectNames\" setting in the deployment config file.'\n        });\n        this._scenario = this.defineStringParameter({\n            parameterLongName: '--scenario',\n            parameterShortName: '-s',\n            argumentName: 'SCENARIO_NAME',\n            description: 'By default, the deployment configuration is specified in \"common/config/rush/deploy.json\".' +\n                ' You can use \"--scenario\" to specify an alternate name. The name must be lowercase and separated by dashes.' +\n                ' For example, if SCENARIO_NAME is \"web\", then the config file would be \"common/config/rush/deploy-web.json\".'\n        });\n        this._overwrite = this.defineFlagParameter({\n            parameterLongName: '--overwrite',\n            description: 'By default, deployment will fail if the target folder is not empty.  SPECIFYING THIS FLAG' +\n                ' WILL RECURSIVELY DELETE EXISTING CONTENTS OF THE TARGET FOLDER.'\n        });\n        this._targetFolder = this.defineStringParameter({\n            parameterLongName: '--target-folder',\n            parameterShortName: '-t',\n            argumentName: 'PATH',\n            environmentVariable: 'RUSH_DEPLOY_TARGET_FOLDER',\n            description: 'By default, files are deployed to the \"common/deploy\" folder inside the Rush repo.' +\n                ' Use this parameter to specify a different location. ' +\n                ' WARNING: USE CAUTION WHEN COMBINING WITH \"--overwrite\"'\n        });\n        this._createArchivePath = this.defineStringParameter({\n            parameterLongName: '--create-archive',\n            argumentName: 'ARCHIVE_PATH',\n            description: 'If specified, after the deployment has been prepared, \"rush deploy\"' +\n                ' will create an archive containing the contents of the target folder.' +\n                ' The newly created archive file will be placed according to the designated path, relative' +\n                ' to the target folder. Supported file extensions: .zip'\n        });\n        this._createArchiveOnly = this.defineFlagParameter({\n            parameterLongName: '--create-archive-only',\n            description: 'If specified, \"rush deploy\" will only create an archive containing the contents of the target folder.' +\n                ' The target folder will not be modified other than to create the archive file.'\n        });\n    }\n    async runAsync() {\n        const scenarioName = this._scenario.value;\n        const { DeployScenarioConfiguration } = await import('../../logic/deploy/DeployScenarioConfiguration');\n        const scenarioFilePath = DeployScenarioConfiguration.getConfigFilePath(scenarioName, this.rushConfiguration);\n        const scenarioConfiguration = DeployScenarioConfiguration.loadFromFile(this._logger.terminal, scenarioFilePath, this.rushConfiguration);\n        let mainProjectName = this._project.value;\n        if (!mainProjectName) {\n            if (scenarioConfiguration.json.deploymentProjectNames.length === 1) {\n                // If there is only one project, then \"--project\" is optional\n                mainProjectName = scenarioConfiguration.json.deploymentProjectNames[0];\n            }\n            else {\n                throw new Error(`The ${path.basename(scenarioFilePath)} configuration specifies multiple items for` +\n                    ` \"deploymentProjectNames\". Use the \"--project\" parameter to indicate the project to be deployed.`);\n            }\n        }\n        else {\n            if (scenarioConfiguration.json.deploymentProjectNames.indexOf(mainProjectName) < 0) {\n                throw new Error(`The project \"${mainProjectName}\" does not appear in the list of \"deploymentProjectNames\"` +\n                    ` from ${path.basename(scenarioFilePath)}.`);\n            }\n        }\n        const targetRootFolder = this._targetFolder.value\n            ? path.resolve(this._targetFolder.value)\n            : path.join(this.rushConfiguration.commonFolder, 'deploy');\n        const createArchiveFilePath = this._createArchivePath.value\n            ? path.resolve(targetRootFolder, this._createArchivePath.value)\n            : undefined;\n        const createArchiveOnly = this._createArchiveOnly.value;\n        /**\n         * Subspaces that will be involved in deploy process.\n         * Each subspace may have its own configurations\n         */\n        const subspaces = new Map();\n        const rushConfigurationProject = this.rushConfiguration.getProjectByName(mainProjectName);\n        if (!rushConfigurationProject) {\n            throw new Error(`The specified deployment project \"${mainProjectName}\" was not found in rush.json`);\n        }\n        const projects = this.rushConfiguration.projects;\n        if (this.rushConfiguration.isPnpm) {\n            const currentlyInstalledVariant = await this.rushConfiguration.getCurrentlyInstalledVariantAsync();\n            for (const project of projects) {\n                const pnpmfileConfiguration = await PnpmfileConfiguration.initializeAsync(this.rushConfiguration, project.subspace, currentlyInstalledVariant);\n                const subspace = {\n                    subspaceName: project.subspace.subspaceName,\n                    transformPackageJson: pnpmfileConfiguration.transform.bind(pnpmfileConfiguration)\n                };\n                if (subspaces.has(subspace.subspaceName)) {\n                    continue;\n                }\n                if (!scenarioConfiguration.json.omitPnpmWorkaroundLinks) {\n                    subspace.pnpmInstallFolder = project.subspace.getSubspaceTempFolderPath();\n                }\n                subspaces.set(subspace.subspaceName, subspace);\n            }\n        }\n        // Construct the project list for the deployer\n        const projectConfigurations = [];\n        for (const project of projects) {\n            const scenarioProjectJson = scenarioConfiguration.projectJsonsByName.get(project.packageName);\n            projectConfigurations.push({\n                projectName: project.packageName,\n                projectFolder: project.projectFolder,\n                additionalProjectsToInclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.additionalProjectsToInclude,\n                additionalDependenciesToInclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.additionalDependenciesToInclude,\n                dependenciesToExclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.dependenciesToExclude,\n                patternsToInclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.patternsToInclude,\n                patternsToExclude: scenarioProjectJson === null || scenarioProjectJson === void 0 ? void 0 : scenarioProjectJson.patternsToExclude\n            });\n        }\n        // Call the deploy manager\n        const { PackageExtractor } = await import(\n        /* webpackChunkName: 'PackageExtractor' */\n        '@rushstack/package-extractor');\n        const deployManager = new PackageExtractor();\n        await deployManager.extractAsync({\n            terminal: this._logger.terminal,\n            overwriteExisting: !!this._overwrite.value,\n            includeDevDependencies: scenarioConfiguration.json.includeDevDependencies,\n            includeNpmIgnoreFiles: scenarioConfiguration.json.includeNpmIgnoreFiles,\n            folderToCopy: scenarioConfiguration.json.folderToCopy,\n            linkCreation: scenarioConfiguration.json.linkCreation,\n            sourceRootFolder: this.rushConfiguration.rushJsonFolder,\n            targetRootFolder,\n            mainProjectName,\n            projectConfigurations,\n            dependencyConfigurations: scenarioConfiguration.json.dependencySettings,\n            createArchiveFilePath,\n            createArchiveOnly,\n            subspaces: Array.from(subspaces.values())\n        });\n    }\n}\n//# sourceMappingURL=DeployAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, InternalError, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { BaseConfiglessRushAction } from './BaseRushAction';\nimport { assetsFolderPath } from '../../utilities/PathConstants';\nimport { copyTemplateFileAsync } from '../../utilities/templateUtilities';\nexport class InitAction extends BaseConfiglessRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'init',\n            summary: 'Initializes a new repository to be managed by Rush',\n            documentation: 'When invoked in an empty folder, this command provisions a standard' +\n                ' set of config file templates to start managing projects using Rush.',\n            parser\n        });\n        // template section name --> whether it should be commented out\n        this._commentedBySectionName = new Map();\n        this._overwriteParameter = this.defineFlagParameter({\n            parameterLongName: '--overwrite-existing',\n            description: 'By default \"rush init\" will not overwrite existing config files.' +\n                ' Specify this switch to override that. This can be useful when upgrading' +\n                ' your repo to a newer release of Rush. WARNING: USE WITH CARE!'\n        });\n        this._rushExampleParameter = this.defineFlagParameter({\n            parameterLongName: '--rush-example-repo',\n            description: 'When copying the template config files, this uncomments fragments that are used' +\n                ' by the \"rush-example\" GitHub repo, which is a sample monorepo that illustrates many Rush' +\n                ' features. This option is primarily intended for maintaining that example.'\n        });\n        this._experimentsParameter = this.defineFlagParameter({\n            parameterLongName: '--include-experiments',\n            description: 'Include features that may not be complete features, useful for demoing specific future features' +\n                ' or current work in progress features.'\n        });\n    }\n    async runAsync() {\n        const initFolder = process.cwd();\n        if (!this._overwriteParameter.value) {\n            if (!this._validateFolderIsEmpty(initFolder)) {\n                throw new AlreadyReportedError();\n            }\n        }\n        await this._copyTemplateFilesAsync(initFolder);\n    }\n    // Check whether it's safe to run \"rush init\" in the current working directory.\n    _validateFolderIsEmpty(initFolder) {\n        if (this.rushConfiguration !== undefined) {\n            // eslint-disable-next-line no-console\n            console.error(Colorize.red('ERROR: Found an existing configuration in: ' + this.rushConfiguration.rushJsonFile));\n            // eslint-disable-next-line no-console\n            console.log('\\nThe \"rush init\" command must be run in a new folder without an existing Rush configuration.');\n            return false;\n        }\n        for (const itemName of FileSystem.readFolderItemNames(initFolder)) {\n            if (itemName.substr(0, 1) === '.') {\n                // Ignore any items that start with \".\", for example \".git\"\n                continue;\n            }\n            const itemPath = path.join(initFolder, itemName);\n            const stats = FileSystem.getStatistics(itemPath);\n            // Ignore any loose files in the current folder, e.g. \"README.md\"\n            // or \"CONTRIBUTING.md\"\n            if (stats.isDirectory()) {\n                // eslint-disable-next-line no-console\n                console.error(Colorize.red(`ERROR: Found a subdirectory: \"${itemName}\"`));\n                // eslint-disable-next-line no-console\n                console.log('\\nThe \"rush init\" command must be run in a new folder with no projects added yet.');\n                return false;\n            }\n            else {\n                if (itemName.toLowerCase() === 'package.json') {\n                    // eslint-disable-next-line no-console\n                    console.error(Colorize.red(`ERROR: Found a package.json file in this folder`));\n                    // eslint-disable-next-line no-console\n                    console.log('\\nThe \"rush init\" command must be run in a new folder with no projects added yet.');\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    async _copyTemplateFilesAsync(initFolder) {\n        // The \"[dot]\" base name is used for hidden files to prevent various tools from interpreting them.\n        // For example, \"npm publish\" will always exclude the filename \".gitignore\"\n        const templateFilePaths = [\n            '[dot]github/workflows/ci.yml',\n            'common/config/rush/.pnpmfile.cjs',\n            'common/config/rush/[dot]npmrc',\n            'common/config/rush/[dot]npmrc-publish',\n            'common/config/rush/artifactory.json',\n            'common/config/rush/build-cache.json',\n            'common/config/rush/cobuild.json',\n            'common/config/rush/command-line.json',\n            'common/config/rush/common-versions.json',\n            'common/config/rush/custom-tips.json',\n            'common/config/rush/experiments.json',\n            'common/config/rush/pnpm-config.json',\n            'common/config/rush/rush-plugins.json',\n            'common/config/rush/subspaces.json',\n            'common/config/rush/version-policies.json',\n            'common/git-hooks/commit-msg.sample',\n            '[dot]gitattributes',\n            '[dot]gitignore',\n            'rush.json'\n        ];\n        const experimentalTemplateFilePaths = ['common/config/rush/rush-alerts.json'];\n        if (this._experimentsParameter.value) {\n            templateFilePaths.push(...experimentalTemplateFilePaths);\n        }\n        const assetsSubfolder = `${assetsFolderPath}/rush-init`;\n        for (const templateFilePath of templateFilePaths) {\n            const sourcePath = path.join(assetsSubfolder, templateFilePath);\n            if (!FileSystem.exists(sourcePath)) {\n                // If this happens, please report a Rush bug\n                throw new InternalError('Unable to find template input file: ' + sourcePath);\n            }\n            const destinationPath = path.join(initFolder, templateFilePath).replace('[dot]', '.');\n            // The \"DEMO\" sections are uncommented only when \"--rush-example-repo\" is specified.\n            await copyTemplateFileAsync(sourcePath, destinationPath, this._overwriteParameter.value, !this._rushExampleParameter.value);\n        }\n    }\n}\n//# sourceMappingURL=InitAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, NewlineKind, JsonFile } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { BaseRushAction } from './BaseRushAction';\nimport { Autoinstaller } from '../../logic/Autoinstaller';\nexport class InitAutoinstallerAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'init-autoinstaller',\n            summary: 'Initializes a new autoinstaller',\n            documentation: 'Use this command to initialize a new autoinstaller folder.  Autoinstallers provide a way to' +\n                ' manage a set of related dependencies that are used for scripting scenarios outside of the usual' +\n                ' \"rush install\" context.  See the command-line.json documentation for an example.',\n            parser\n        });\n        this._name = this.defineStringParameter({\n            parameterLongName: '--name',\n            argumentName: 'AUTOINSTALLER_NAME',\n            required: true,\n            description: 'Specifies the name of the autoinstaller folder, which must conform to the naming rules for NPM packages.'\n        });\n    }\n    async runAsync() {\n        const autoinstallerName = this._name.value;\n        const autoinstaller = new Autoinstaller({\n            autoinstallerName,\n            rushConfiguration: this.rushConfiguration,\n            rushGlobalFolder: this.rushGlobalFolder\n        });\n        if (FileSystem.exists(autoinstaller.folderFullPath)) {\n            // It's okay if the folder is empty\n            if (FileSystem.readFolderItemNames(autoinstaller.folderFullPath).length > 0) {\n                throw new Error('The target folder already exists: ' + autoinstaller.folderFullPath);\n            }\n        }\n        const packageJson = {\n            name: autoinstallerName,\n            version: '1.0.0',\n            private: true,\n            dependencies: {}\n        };\n        // eslint-disable-next-line no-console\n        console.log(Colorize.green('Creating package: ') + autoinstaller.packageJsonPath);\n        JsonFile.save(packageJson, autoinstaller.packageJsonPath, {\n            ensureFolderExists: true,\n            newlineConversion: NewlineKind.OsDefault\n        });\n        // eslint-disable-next-line no-console\n        console.log('\\nFile successfully written. Add your dependencies before committing.');\n    }\n}\n//# sourceMappingURL=InitAutoinstallerAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, NewlineKind } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { BaseRushAction } from './BaseRushAction';\nimport { DeployScenarioConfiguration } from '../../logic/deploy/DeployScenarioConfiguration';\nimport { assetsFolderPath } from '../../utilities/PathConstants';\nimport { RushConstants } from '../../logic/RushConstants';\nconst CONFIG_TEMPLATE_PATH = `${assetsFolderPath}/rush-init-deploy/scenario-template.json`;\nexport class InitDeployAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'init-deploy',\n            summary: 'Creates a deployment scenario config file for use with \"rush deploy\".',\n            documentation: 'Use this command to initialize a new scenario config file for use with \"rush deploy\".' +\n                ' The default filename is common/config/rush/deploy.json. However, if you need to manage multiple' +\n                ' deployments with different settings, you can use use \"--scenario\" to create additional config files.',\n            parser\n        });\n        this._project = this.defineStringParameter({\n            parameterLongName: '--project',\n            parameterShortName: '-p',\n            argumentName: 'PROJECT_NAME',\n            required: true,\n            description: 'Specifies the name of the main Rush project to be deployed in this scenario.' +\n                ' It will be added to the \"deploymentProjectNames\" setting.'\n        });\n        this._scenario = this.defineStringParameter({\n            parameterLongName: '--scenario',\n            parameterShortName: '-s',\n            argumentName: 'SCENARIO',\n            description: 'By default, the deployment configuration will be written to \"common/config/rush/deploy.json\".' +\n                ' You can use \"--scenario\" to specify an alternate name. The name must be lowercase and separated by dashes.' +\n                ' For example, if the name is \"web\", then the config file would be \"common/config/rush/deploy-web.json\".'\n        });\n    }\n    async runAsync() {\n        const scenarioFilePath = DeployScenarioConfiguration.getConfigFilePath(this._scenario.value, this.rushConfiguration);\n        if (FileSystem.exists(scenarioFilePath)) {\n            throw new Error('The target file already exists:\\n' +\n                scenarioFilePath +\n                '\\nIf you intend to replace it, please delete the old file first.');\n        }\n        // eslint-disable-next-line no-console\n        console.log(Colorize.green('Creating scenario file: ') + scenarioFilePath);\n        const shortProjectName = this._project.value;\n        const rushProject = this.rushConfiguration.findProjectByShorthandName(shortProjectName);\n        if (!rushProject) {\n            throw new Error(`The specified project was not found in ${RushConstants.rushJsonFilename}: \"${shortProjectName}\"`);\n        }\n        const templateContent = FileSystem.readFile(CONFIG_TEMPLATE_PATH);\n        const expandedContent = templateContent.replace('[%PROJECT_NAME_TO_DEPLOY%]', rushProject.packageName);\n        FileSystem.writeFile(scenarioFilePath, expandedContent, {\n            ensureFolderExists: true,\n            convertLineEndings: NewlineKind.OsDefault\n        });\n        // eslint-disable-next-line no-console\n        console.log('\\nFile successfully written. Please review the file contents before committing.');\n    }\n}\n//# sourceMappingURL=InitDeployAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { assetsFolderPath } from '../../utilities/PathConstants';\nimport { BaseRushAction } from './BaseRushAction';\nimport { SubspacesConfiguration } from '../../api/SubspacesConfiguration';\nimport { Async, FileSystem, JsonFile } from '@rushstack/node-core-library';\nimport { ConsoleTerminalProvider, Terminal } from '@rushstack/terminal';\nimport { copyTemplateFileAsync } from '../../utilities/templateUtilities';\nexport class InitSubspaceAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'init-subspace',\n            summary: 'Create a new subspace.',\n            documentation: 'Use this command to create a new subspace with the default subspace configuration files.',\n            parser\n        });\n        this._subspaceNameParameter = this.defineStringParameter({\n            parameterLongName: '--name',\n            parameterShortName: '-n',\n            argumentName: 'SUBSPACE_NAME',\n            description: 'The name of the subspace that is being initialized.',\n            required: true\n        });\n    }\n    async runAsync() {\n        var _a;\n        const terminal = new Terminal(new ConsoleTerminalProvider());\n        if (!this.rushConfiguration.subspacesFeatureEnabled) {\n            throw new Error('Unable to create a subspace because the subspaces feature is not enabled.');\n        }\n        const subspacesConfiguration = this.rushConfiguration\n            .subspacesConfiguration;\n        // Verify this subspace name does not already exist\n        const existingSubspaceNames = subspacesConfiguration.subspaceNames;\n        const newSubspaceName = this._subspaceNameParameter.value;\n        if (existingSubspaceNames.has(newSubspaceName)) {\n            throw new Error(`The subspace name: ${this._subspaceNameParameter.value} already exists in the subspace.json file.`);\n        }\n        if (SubspacesConfiguration.explainIfInvalidSubspaceName(newSubspaceName, (_a = this.rushConfiguration.subspacesConfiguration) === null || _a === void 0 ? void 0 : _a.splitWorkspaceCompatibility)) {\n            return;\n        }\n        const subspaceConfigPath = `${this.rushConfiguration.commonFolder}/config/subspaces/${newSubspaceName}`;\n        const assetsSubfolder = `${assetsFolderPath}/rush-init`;\n        const templateFilePaths = [\n            '[dot]npmrc',\n            '.pnpmfile.cjs',\n            'common-versions.json',\n            'pnpm-config.json'\n        ];\n        await FileSystem.ensureEmptyFolderAsync(subspaceConfigPath);\n        await Async.forEachAsync(templateFilePaths, async (templateFilePath) => {\n            const sourcePath = `${assetsSubfolder}/common/config/rush/${templateFilePath}`;\n            const destinationPath = `${subspaceConfigPath}/${templateFilePath.replace('[dot]', '.')}`;\n            await copyTemplateFileAsync(sourcePath, destinationPath, true);\n        }, { concurrency: 10 });\n        // Add the subspace name to subspaces.json\n        const subspaceJson = await JsonFile.loadAsync(subspacesConfiguration.subspaceJsonFilePath);\n        subspaceJson.subspaceNames.push(newSubspaceName);\n        await JsonFile.saveAsync(subspaceJson, subspacesConfiguration.subspaceJsonFilePath, {\n            updateExistingFile: true\n        });\n        // eslint-disable-next-line no-console\n        terminal.writeLine('\\nSubspace successfully created. Please review the subspace configuration files before committing.');\n    }\n}\n//# sourceMappingURL=InitSubspaceAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseInstallAction } from './BaseInstallAction';\nimport { SelectionParameterSet } from '../parsing/SelectionParameterSet';\nimport { getVariantAsync } from '../../api/Variants';\nexport class InstallAction extends BaseInstallAction {\n    constructor(parser) {\n        var _a;\n        super({\n            actionName: 'install',\n            summary: 'Install package dependencies for all projects in the repo according to the shrinkwrap file',\n            documentation: 'The \"rush install\" command installs package dependencies for all your projects,' +\n                ' based on the shrinkwrap file that is created/updated using \"rush update\".' +\n                ' (This \"shrinkwrap\" file stores a central inventory of all dependencies and versions' +\n                ' for projects in your repo. It is found in the \"common/config/rush\" folder.)' +\n                ' If the shrinkwrap file is missing or outdated (e.g. because project package.json files have' +\n                ' changed), \"rush install\" will fail and tell you to run \"rush update\" instead.' +\n                ' This read-only nature is the main feature:  Continuous integration builds should use' +\n                ' \"rush install\" instead of \"rush update\" to catch developers who forgot to commit their' +\n                ' shrinkwrap changes.  Cautious people can also use \"rush install\" if they want to avoid' +\n                ' accidentally updating their shrinkwrap file.',\n            parser\n        });\n        this._selectionParameters = new SelectionParameterSet(this.rushConfiguration, this, {\n            gitOptions: {\n                // Include lockfile processing since this expands the selection, and we need to select\n                // at least the same projects selected with the same query to \"rush build\"\n                includeExternalDependencies: true,\n                // Disable filtering because rush-project.json is riggable and therefore may not be available\n                enableFiltering: false\n            },\n            includeSubspaceSelector: true\n        });\n        this._checkOnlyParameter = this.defineFlagParameter({\n            parameterLongName: '--check-only',\n            description: `Only check the validity of the shrinkwrap file without performing an install.`\n        });\n        if ((_a = this.rushConfiguration) === null || _a === void 0 ? void 0 : _a.isPnpm) {\n            this._resolutionOnlyParameter = this.defineFlagParameter({\n                parameterLongName: '--resolution-only',\n                description: `Only perform dependency resolution, useful for ensuring peer dependendencies are up to date. Note that this flag is only supported when using the pnpm package manager.`\n            });\n        }\n    }\n    async buildInstallOptionsAsync() {\n        var _a, _b, _c, _d, _e;\n        const selectedProjects = (_b = (await ((_a = this._selectionParameters) === null || _a === void 0 ? void 0 : _a.getSelectedProjectsAsync(this._terminal)))) !== null && _b !== void 0 ? _b : new Set(this.rushConfiguration.projects);\n        const variant = await getVariantAsync(this._variantParameter, this.rushConfiguration, false);\n        return {\n            debug: this.parser.isDebug,\n            allowShrinkwrapUpdates: false,\n            bypassPolicyAllowed: true,\n            bypassPolicy: this._bypassPolicyParameter.value,\n            noLink: this._noLinkParameter.value,\n            fullUpgrade: false,\n            recheckShrinkwrap: false,\n            offline: this._offlineParameter.value,\n            networkConcurrency: this._networkConcurrencyParameter.value,\n            collectLogFile: this._debugPackageManagerParameter.value,\n            variant,\n            // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,\n            // it is safe to assume that the value is not null\n            maxInstallAttempts: this._maxInstallAttempts.value,\n            // These are derived independently of the selection for command line brevity\n            selectedProjects,\n            pnpmFilterArgumentValues: (_d = (await ((_c = this._selectionParameters) === null || _c === void 0 ? void 0 : _c.getPnpmFilterArgumentValuesAsync(this._terminal)))) !== null && _d !== void 0 ? _d : [],\n            checkOnly: this._checkOnlyParameter.value,\n            resolutionOnly: (_e = this._resolutionOnlyParameter) === null || _e === void 0 ? void 0 : _e.value,\n            beforeInstallAsync: (subspace) => this.rushSession.hooks.beforeInstall.promise(this, subspace, variant),\n            afterInstallAsync: (subspace) => this.rushSession.hooks.afterInstall.promise(this, subspace, variant),\n            terminal: this._terminal\n        };\n    }\n}\n//# sourceMappingURL=InstallAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseAutoinstallerAction } from './BaseAutoinstallerAction';\nexport class InstallAutoinstallerAction extends BaseAutoinstallerAction {\n    constructor(parser) {\n        super({\n            actionName: 'install-autoinstaller',\n            summary: 'Install autoinstaller package dependencies',\n            documentation: 'Use this command to install dependencies for an autoinstaller folder.',\n            parser\n        });\n    }\n    async prepareAsync(autoinstaller) {\n        await autoinstaller.prepareAsync();\n    }\n}\n//# sourceMappingURL=InstallAutoinstallerAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from './BaseRushAction';\nexport class LinkAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'link',\n            summary: 'Create node_modules symlinks for all projects',\n            documentation: 'Create node_modules symlinks for all projects.  This operation is normally performed' +\n                ' automatically as part of \"rush install\" or \"rush update\".  You should only need to use \"rush link\"' +\n                ' if you performed \"rush unlink\" for some reason, or if you specified the \"--no-link\" option' +\n                ' for \"rush install\" or \"rush update\".',\n            parser\n        });\n        this._force = this.defineFlagParameter({\n            parameterLongName: '--force',\n            parameterShortName: '-f',\n            description: 'Deletes and recreates all links, even if the filesystem state seems to indicate that this is ' +\n                'unnecessary.'\n        });\n    }\n    async runAsync() {\n        const linkManagerFactoryModule = await import(\n        /* webpackChunkName: 'LinkManagerFactory' */\n        '../../logic/LinkManagerFactory');\n        const linkManager = linkManagerFactoryModule.LinkManagerFactory.getLinkManager(this.rushConfiguration);\n        await linkManager.createSymlinksForProjectsAsync(this._force.value);\n    }\n}\n//# sourceMappingURL=LinkAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Sort } from '@rushstack/node-core-library';\nimport { ConsoleTerminalProvider, Terminal } from '@rushstack/terminal';\nimport { BaseRushAction } from './BaseRushAction';\nimport { VersionPolicyDefinitionName } from '../../api/VersionPolicy';\nimport { SelectionParameterSet } from '../parsing/SelectionParameterSet';\nexport class ListAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'list',\n            summary: 'List package information for all projects in the repo',\n            documentation: 'List package names, and optionally version (--version) and ' +\n                'path (--path) or full path (--full-path), for projects in the ' +\n                'current rush config.',\n            parser,\n            safeForSimultaneousRushProcesses: true\n        });\n        this._version = this.defineFlagParameter({\n            parameterLongName: '--version',\n            parameterShortName: '-v',\n            description: 'If this flag is specified, the project version will be ' +\n                'displayed in a column along with the package name.'\n        });\n        this._path = this.defineFlagParameter({\n            parameterLongName: '--path',\n            parameterShortName: '-p',\n            description: 'If this flag is specified, the project path will be ' +\n                'displayed in a column along with the package name.'\n        });\n        this._fullPath = this.defineFlagParameter({\n            parameterLongName: '--full-path',\n            description: 'If this flag is specified, the project full path will ' +\n                'be displayed in a column along with the package name.'\n        });\n        this._detailedFlag = this.defineFlagParameter({\n            parameterLongName: '--detailed',\n            description: 'For the non --json view, if this flag is specified, ' +\n                'include path (-p), version (-v) columns along with ' +\n                \"the project's applicable: versionPolicy, versionPolicyName, \" +\n                'shouldPublish, reviewPolicy, and tags fields.'\n        });\n        this._jsonFlag = this.defineFlagParameter({\n            parameterLongName: '--json',\n            description: 'If this flag is specified, output will be in JSON format.'\n        });\n        this._selectionParameters = new SelectionParameterSet(this.rushConfiguration, this, {\n            gitOptions: {\n                // Include lockfile processing since this expands the selection, and we need to select\n                // at least the same projects selected with the same query to \"rush build\"\n                includeExternalDependencies: true,\n                // Disable filtering because rush-project.json is riggable and therefore may not be available\n                enableFiltering: false\n            },\n            includeSubspaceSelector: false\n        });\n    }\n    async runAsync() {\n        const terminal = new Terminal(new ConsoleTerminalProvider());\n        const selection = await this._selectionParameters.getSelectedProjectsAsync(terminal);\n        Sort.sortSetBy(selection, (x) => x.packageName);\n        if (this._jsonFlag.value && this._detailedFlag.value) {\n            throw new Error(`The parameters \"--json\" and \"--detailed\" cannot be used together.`);\n        }\n        if (this._jsonFlag.value) {\n            this._printJson(selection);\n        }\n        else if (this._version.value || this._path.value || this._fullPath.value || this._detailedFlag.value) {\n            await this._printListTableAsync(selection);\n        }\n        else {\n            this._printList(selection);\n        }\n    }\n    _printJson(selection) {\n        const projects = Array.from(selection, (config) => {\n            let reviewCategory;\n            let shouldPublish;\n            let versionPolicy;\n            let versionPolicyName;\n            if (config.versionPolicy !== undefined) {\n                const definitionName = VersionPolicyDefinitionName[config.versionPolicy.definitionName];\n                versionPolicy = `${definitionName}`;\n                versionPolicyName = config.versionPolicy.policyName;\n            }\n            else {\n                shouldPublish = config.shouldPublish;\n            }\n            if (config.reviewCategory) {\n                reviewCategory = config.reviewCategory;\n            }\n            return {\n                name: config.packageName,\n                version: config.packageJson.version,\n                path: config.projectRelativeFolder,\n                fullPath: config.projectFolder,\n                versionPolicy,\n                versionPolicyName,\n                shouldPublish,\n                reviewCategory,\n                tags: Array.from(config.tags)\n            };\n        });\n        const output = {\n            projects\n        };\n        // eslint-disable-next-line no-console\n        console.log(JSON.stringify(output, undefined, 2));\n    }\n    _printList(selection) {\n        for (const project of selection) {\n            // eslint-disable-next-line no-console\n            console.log(project.packageName);\n        }\n    }\n    async _printListTableAsync(selection) {\n        const tableHeader = ['Project'];\n        if (this._version.value || this._detailedFlag.value) {\n            tableHeader.push('Version');\n        }\n        if (this._path.value || this._detailedFlag.value) {\n            tableHeader.push('Path');\n        }\n        if (this._fullPath.value) {\n            tableHeader.push('Full Path');\n        }\n        if (this._detailedFlag.value) {\n            tableHeader.push('Version policy');\n            tableHeader.push('Version policy name');\n            tableHeader.push('Should publish');\n            tableHeader.push('Review category');\n            tableHeader.push('Tags');\n        }\n        const { default: CliTable } = await import('cli-table');\n        const table = new CliTable({\n            head: tableHeader\n        });\n        for (const project of selection) {\n            const packageRow = [];\n            function appendToPackageRow(value) {\n                packageRow.push(value === undefined ? 'UNDEFINED' : value);\n            }\n            appendToPackageRow(project.packageName);\n            if (this._version.value || this._detailedFlag.value) {\n                appendToPackageRow(project.packageJson.version);\n            }\n            if (this._path.value || this._detailedFlag.value) {\n                appendToPackageRow(project.projectRelativeFolder);\n            }\n            if (this._fullPath.value) {\n                appendToPackageRow(project.projectFolder);\n            }\n            if (this._detailedFlag.value) {\n                // When we HAVE a version policy\n                let versionPolicyDefinitionName = '';\n                let versionPolicyName = '';\n                // When we DO NOT have version policy, fallback to shouldPublish boolean\n                let shouldPublish = '';\n                let reviewCategory = '';\n                if (project.versionPolicy !== undefined) {\n                    const definitionName = VersionPolicyDefinitionName[project.versionPolicy.definitionName];\n                    versionPolicyDefinitionName = definitionName;\n                    versionPolicyName = project.versionPolicy.policyName;\n                }\n                else {\n                    shouldPublish = `${project.shouldPublish}`;\n                }\n                if (project.reviewCategory) {\n                    reviewCategory = project.reviewCategory;\n                }\n                appendToPackageRow(versionPolicyDefinitionName);\n                appendToPackageRow(versionPolicyName);\n                appendToPackageRow(shouldPublish);\n                appendToPackageRow(reviewCategory);\n                appendToPackageRow(Array.from(project.tags).join(', '));\n            }\n            table.push(packageRow);\n        }\n        // eslint-disable-next-line no-console\n        console.log(table.toString());\n    }\n}\n//# sourceMappingURL=ListAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { FileSystem } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { ChangeType } from '../../api/ChangeManagement';\nimport { Npm } from '../../utilities/Npm';\nimport { PublishUtilities } from '../../logic/PublishUtilities';\nimport { ChangelogGenerator } from '../../logic/ChangelogGenerator';\nimport { PrereleaseToken } from '../../logic/PrereleaseToken';\nimport { ChangeManager } from '../../logic/ChangeManager';\nimport { BaseRushAction } from './BaseRushAction';\nimport { PublishGit } from '../../logic/PublishGit';\nimport * as PolicyValidator from '../../logic/policy/PolicyValidator';\nimport { DEFAULT_PACKAGE_UPDATE_MESSAGE } from './VersionAction';\nimport { Utilities } from '../../utilities/Utilities';\nimport { Git } from '../../logic/Git';\nimport { RushConstants } from '../../logic/RushConstants';\nexport class PublishAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'publish',\n            summary: 'Reads and processes package publishing change requests generated by \"rush change\".',\n            documentation: 'Reads and processes package publishing change requests generated by \"rush change\". This will perform a ' +\n                // eslint-disable-next-line no-console\n                'read-only operation by default, printing operations executed to the console. To commit ' +\n                'changes and publish packages, you must use the --commit flag and/or the --publish flag.',\n            parser\n        });\n        this._apply = this.defineFlagParameter({\n            parameterLongName: '--apply',\n            parameterShortName: '-a',\n            description: 'If this flag is specified, the change requests will be applied to package.json files.'\n        });\n        this._targetBranch = this.defineStringParameter({\n            parameterLongName: '--target-branch',\n            parameterShortName: '-b',\n            argumentName: 'BRANCH',\n            description: 'If this flag is specified, applied changes and deleted change requests will be ' +\n                'committed and merged into the target branch.'\n        });\n        this._publish = this.defineFlagParameter({\n            parameterLongName: '--publish',\n            parameterShortName: '-p',\n            description: 'If this flag is specified, applied changes will be published to the NPM registry.'\n        });\n        this._addCommitDetails = this.defineFlagParameter({\n            parameterLongName: '--add-commit-details',\n            parameterShortName: undefined,\n            description: 'Adds commit author and hash to the changelog.json files for each change.'\n        });\n        this._regenerateChangelogs = this.defineFlagParameter({\n            parameterLongName: '--regenerate-changelogs',\n            parameterShortName: undefined,\n            description: 'Regenerates all changelog files based on the current JSON content.'\n        });\n        // NPM registry related parameters\n        this._registryUrl = this.defineStringParameter({\n            parameterLongName: '--registry',\n            parameterShortName: '-r',\n            argumentName: 'REGISTRY',\n            description: `Publishes to a specified NPM registry. If this is specified, it will prevent the current commit will not be ` +\n                'tagged.'\n        });\n        this._npmAuthToken = this.defineStringParameter({\n            parameterLongName: '--npm-auth-token',\n            parameterShortName: '-n',\n            argumentName: 'TOKEN',\n            description: '(DEPRECATED) Specifies the authentication token to use during publishing. This parameter is deprecated' +\n                ' because command line parameters may be readable by unrelated processes on a lab machine. Instead, a' +\n                ' safer practice is to pass the token via an environment variable and reference it from your ' +\n                ' common/config/rush/.npmrc-publish file.'\n        });\n        this._npmTag = this.defineStringParameter({\n            parameterLongName: '--tag',\n            parameterShortName: '-t',\n            argumentName: 'TAG',\n            description: `The tag option to pass to npm publish. By default NPM will publish using the 'latest' tag, even if ` +\n                `the package is older than the current latest, so in publishing workflows for older releases, providing ` +\n                `a tag is important. When hotfix changes are made, this parameter defaults to 'hotfix'.`\n        });\n        this._npmAccessLevel = this.defineChoiceParameter({\n            alternatives: ['public', 'restricted'],\n            parameterLongName: '--set-access-level',\n            parameterShortName: undefined,\n            description: `By default, when Rush invokes \"npm publish\" it will publish scoped packages with an access level ` +\n                `of \"restricted\". Scoped packages can be published with an access level of \"public\" by specifying ` +\n                `that value for this flag with the initial publication. NPM always publishes unscoped packages with ` +\n                `an access level of \"public\". For more information, see the NPM documentation for the \"--access\" ` +\n                `option of \"npm publish\".`\n        });\n        // NPM pack tarball related parameters\n        this._pack = this.defineFlagParameter({\n            parameterLongName: '--pack',\n            description: `Packs projects into tarballs instead of publishing to npm repository. It can only be used when ` +\n                `--include-all is specified. If this flag is specified, NPM registry related parameters will be ignored.`\n        });\n        this._releaseFolder = this.defineStringParameter({\n            parameterLongName: '--release-folder',\n            argumentName: 'FOLDER',\n            description: `This parameter is used with --pack parameter to provide customized location for the tarballs instead of ` +\n                `the default value. `\n        });\n        // End of NPM pack tarball related parameters\n        this._includeAll = this.defineFlagParameter({\n            parameterLongName: '--include-all',\n            parameterShortName: undefined,\n            description: `If this flag is specified, all packages with shouldPublish=true in ${RushConstants.rushJsonFilename} ` +\n                'or with a specified version policy ' +\n                'will be published if their version is newer than published version.'\n        });\n        this._versionPolicy = this.defineStringParameter({\n            parameterLongName: '--version-policy',\n            argumentName: 'POLICY',\n            description: 'Version policy name. Only projects with this version policy will be published if used ' +\n                'with --include-all.'\n        });\n        this._prereleaseName = this.defineStringParameter({\n            parameterLongName: '--prerelease-name',\n            argumentName: 'NAME',\n            description: 'Bump up to a prerelease version with the provided prerelease name. Cannot be used with --suffix'\n        });\n        this._partialPrerelease = this.defineFlagParameter({\n            parameterLongName: '--partial-prerelease',\n            parameterShortName: undefined,\n            description: 'Used with --prerelease-name. Only bump packages to a prerelease version if they have changes.'\n        });\n        this._suffix = this.defineStringParameter({\n            parameterLongName: '--suffix',\n            argumentName: 'SUFFIX',\n            description: 'Append a suffix to all changed versions. Cannot be used with --prerelease-name.'\n        });\n        this._force = this.defineFlagParameter({\n            parameterLongName: '--force',\n            parameterShortName: undefined,\n            description: 'If this flag is specified with --publish, packages will be published with --force on npm'\n        });\n        this._applyGitTagsOnPack = this.defineFlagParameter({\n            parameterLongName: '--apply-git-tags-on-pack',\n            description: `If specified with --publish and --pack, git tags will be applied for packages` +\n                ` as if a publish was being run without --pack.`\n        });\n        this._commitId = this.defineStringParameter({\n            parameterLongName: '--commit',\n            parameterShortName: '-c',\n            argumentName: 'COMMIT_ID',\n            description: `Used in conjunction with git tagging -- apply git tags at the commit hash` +\n                ` specified. If not provided, the current HEAD will be tagged.`\n        });\n        this._ignoreGitHooksParameter = this.defineFlagParameter({\n            parameterLongName: '--ignore-git-hooks',\n            description: `Skips execution of all git hooks. Make sure you know what you are skipping.`\n        });\n    }\n    /**\n     * Executes the publish action, which will read change request files, apply changes to package.jsons,\n     */\n    async runAsync() {\n        const currentlyInstalledVariant = await this.rushConfiguration.getCurrentlyInstalledVariantAsync();\n        await PolicyValidator.validatePolicyAsync(this.rushConfiguration, this.rushConfiguration.defaultSubspace, currentlyInstalledVariant, { bypassPolicy: false });\n        // Example: \"common\\temp\\publish-home\"\n        this._targetNpmrcPublishFolder = path.join(this.rushConfiguration.commonTempFolder, 'publish-home');\n        // Example: \"common\\temp\\publish-home\\.npmrc\"\n        this._targetNpmrcPublishPath = path.join(this._targetNpmrcPublishFolder, '.npmrc');\n        const allPackages = this.rushConfiguration.projectsByName;\n        if (this._regenerateChangelogs.value) {\n            // eslint-disable-next-line no-console\n            console.log('Regenerating changelogs');\n            ChangelogGenerator.regenerateChangelogs(allPackages, this.rushConfiguration);\n            return;\n        }\n        this._validate();\n        this._addNpmPublishHome(this.rushConfiguration.isPnpm);\n        const git = new Git(this.rushConfiguration);\n        const publishGit = new PublishGit(git, this._targetBranch.value);\n        if (this._includeAll.value) {\n            await this._publishAllAsync(publishGit, allPackages);\n        }\n        else {\n            this._prereleaseToken = new PrereleaseToken(this._prereleaseName.value, this._suffix.value, this._partialPrerelease.value);\n            await this._publishChangesAsync(git, publishGit, allPackages);\n        }\n        // eslint-disable-next-line no-console\n        console.log('\\n' + Colorize.green('Rush publish finished successfully.'));\n    }\n    /**\n     * Validate some input parameters\n     */\n    _validate() {\n        if (this._pack.value && !this._includeAll.value) {\n            throw new Error('--pack can only be used with --include-all');\n        }\n        if (this._releaseFolder.value && !this._pack.value) {\n            throw new Error(`--release-folder can only be used with --pack`);\n        }\n        if (this._applyGitTagsOnPack.value && !this._pack.value) {\n            throw new Error(`${this._applyGitTagsOnPack.longName} must be used with ${this._pack.longName}`);\n        }\n    }\n    async _publishChangesAsync(git, publishGit, allPackages) {\n        const changeManager = new ChangeManager(this.rushConfiguration);\n        await changeManager.loadAsync(this.rushConfiguration.changesFolder, this._prereleaseToken, this._addCommitDetails.value);\n        if (changeManager.hasChanges()) {\n            const orderedChanges = changeManager.packageChanges;\n            const tempBranchName = `publish-${Date.now()}`;\n            // Make changes in temp branch.\n            await publishGit.checkoutAsync(tempBranchName, true);\n            this._setDependenciesBeforePublish();\n            // Make changes to package.json and change logs.\n            changeManager.apply(this._apply.value);\n            await changeManager.updateChangelogAsync(this._apply.value);\n            this._setDependenciesBeforeCommit();\n            if (await git.hasUncommittedChangesAsync()) {\n                // Stage, commit, and push the changes to remote temp branch.\n                await publishGit.addChangesAsync(':/*');\n                await publishGit.commitAsync(this.rushConfiguration.gitVersionBumpCommitMessage || DEFAULT_PACKAGE_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);\n                await publishGit.pushAsync(tempBranchName, !this._ignoreGitHooksParameter.value);\n                this._setDependenciesBeforePublish();\n                // Override tag parameter if there is a hotfix change.\n                for (const change of orderedChanges) {\n                    if (change.changeType === ChangeType.hotfix) {\n                        this._hotfixTagOverride = 'hotfix';\n                        break;\n                    }\n                }\n                // npm publish the things that need publishing.\n                for (const change of orderedChanges) {\n                    if (change.changeType && change.changeType > ChangeType.dependency) {\n                        const project = allPackages.get(change.packageName);\n                        if (project) {\n                            if (!(await this._packageExistsAsync(project))) {\n                                await this._npmPublishAsync(change.packageName, project.publishFolder);\n                            }\n                            else {\n                                // eslint-disable-next-line no-console\n                                console.log(`Skip ${change.packageName}. Package exists.`);\n                            }\n                        }\n                        else {\n                            // eslint-disable-next-line no-console\n                            console.log(`Skip ${change.packageName}. Failed to find its project.`);\n                        }\n                    }\n                }\n                this._setDependenciesBeforeCommit();\n                // Create and push appropriate Git tags.\n                await this._gitAddTagsAsync(publishGit, orderedChanges);\n                await publishGit.pushAsync(tempBranchName, !this._ignoreGitHooksParameter.value);\n                // Now merge to target branch.\n                await publishGit.checkoutAsync(this._targetBranch.value);\n                await publishGit.pullAsync(!this._ignoreGitHooksParameter.value);\n                await publishGit.mergeAsync(tempBranchName, !this._ignoreGitHooksParameter.value);\n                await publishGit.pushAsync(this._targetBranch.value, !this._ignoreGitHooksParameter.value);\n                await publishGit.deleteBranchAsync(tempBranchName, true, !this._ignoreGitHooksParameter.value);\n            }\n            else {\n                await publishGit.checkoutAsync(this._targetBranch.value);\n                await publishGit.deleteBranchAsync(tempBranchName, false, !this._ignoreGitHooksParameter.value);\n            }\n        }\n    }\n    async _publishAllAsync(git, allPackages) {\n        // eslint-disable-next-line no-console\n        console.log(`Rush publish starts with includeAll and version policy ${this._versionPolicy.value}`);\n        let updated = false;\n        for (const [packageName, packageConfig] of allPackages) {\n            if (packageConfig.shouldPublish &&\n                (!this._versionPolicy.value || this._versionPolicy.value === packageConfig.versionPolicyName)) {\n                const applyTagAsync = async (apply) => {\n                    if (!apply) {\n                        return;\n                    }\n                    const packageVersion = packageConfig.packageJson.version;\n                    // Do not create a new tag if one already exists, this will result in a fatal error\n                    if (await git.hasTagAsync(packageConfig)) {\n                        // eslint-disable-next-line no-console\n                        console.log(`Not tagging ${packageName}@${packageVersion}. A tag already exists for this version.`);\n                        return;\n                    }\n                    await git.addTagAsync(!!this._publish.value, packageName, packageVersion, this._commitId.value, this._prereleaseName.value);\n                    updated = true;\n                };\n                if (this._pack.value) {\n                    // packs to tarball instead of publishing to NPM repository\n                    await this._npmPackAsync(packageName, packageConfig);\n                    await applyTagAsync(this._applyGitTagsOnPack.value);\n                }\n                else if (this._force.value || !(await this._packageExistsAsync(packageConfig))) {\n                    // Publish to npm repository\n                    await this._npmPublishAsync(packageName, packageConfig.publishFolder);\n                    await applyTagAsync(true);\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.log(`Skip ${packageName}. Not updated.`);\n                }\n            }\n        }\n        if (updated) {\n            await git.pushAsync(this._targetBranch.value, !this._ignoreGitHooksParameter.value);\n        }\n    }\n    async _gitAddTagsAsync(git, orderedChanges) {\n        for (const change of orderedChanges) {\n            if (change.changeType &&\n                change.changeType > ChangeType.dependency &&\n                this.rushConfiguration.projectsByName.get(change.packageName).shouldPublish) {\n                await git.addTagAsync(!!this._publish.value && !this._registryUrl.value, change.packageName, change.newVersion, this._commitId.value, this._prereleaseName.value);\n            }\n        }\n    }\n    async _npmPublishAsync(packageName, packagePath) {\n        const env = PublishUtilities.getEnvArgs();\n        const args = ['publish'];\n        if (this.rushConfiguration.projectsByName.get(packageName).shouldPublish) {\n            this._addSharedNpmConfig(env, args);\n            if (this._npmTag.value) {\n                args.push(`--tag`, this._npmTag.value);\n            }\n            else if (this._hotfixTagOverride) {\n                args.push(`--tag`, this._hotfixTagOverride);\n            }\n            if (this._force.value) {\n                args.push(`--force`);\n            }\n            if (this._npmAccessLevel.value) {\n                args.push(`--access`, this._npmAccessLevel.value);\n            }\n            if (this.rushConfiguration.isPnpm) {\n                // PNPM 4.11.0 introduced a feature that may interrupt publishing and prompt the user for input.\n                // See this issue for details: https://github.com/microsoft/rushstack/issues/1940\n                args.push('--no-git-checks');\n            }\n            // TODO: Yarn's \"publish\" command line is fairly different from NPM and PNPM.  The right thing to do here\n            // would be to remap our options to the Yarn equivalents.  But until we get around to that, we'll simply invoke\n            // whatever NPM binary happens to be installed in the global path.\n            const packageManagerToolFilename = this.rushConfiguration.packageManager === 'yarn'\n                ? 'npm'\n                : this.rushConfiguration.packageManagerToolFilename;\n            // If the auth token was specified via the command line, avoid printing it on the console\n            const secretSubstring = this._npmAuthToken.value;\n            await PublishUtilities.execCommandAsync(!!this._publish.value, packageManagerToolFilename, args, packagePath, env, secretSubstring);\n        }\n    }\n    async _packageExistsAsync(packageConfig) {\n        const env = PublishUtilities.getEnvArgs();\n        const args = [];\n        this._addSharedNpmConfig(env, args);\n        const publishedVersions = await Npm.getPublishedVersionsAsync(packageConfig.packageName, packageConfig.publishFolder, env, args);\n        const packageVersion = packageConfig.packageJsonEditor.version;\n        // SemVer supports an obscure (and generally deprecated) feature where \"build metadata\" can be\n        // appended to a version.  For example if our version is \"1.2.3-beta.4+extra567\", then \"+extra567\" is the\n        // build metadata part.  The suffix has no effect on version comparisons and is mostly ignored by\n        // the NPM registry.  Importantly, the queried version number will not include it, so we need to discard\n        // it before comparing against the list of already published versions.\n        const parsedVersion = semver.parse(packageVersion);\n        if (!parsedVersion) {\n            throw new Error(`The package \"${packageConfig.packageName}\" has an invalid \"version\" value`);\n        }\n        // For example, normalize \"1.2.3-beta.4+extra567\" -->\"1.2.3-beta.4\".\n        //\n        // This is redundant in the current API, but might change in the future:\n        // https://github.com/npm/node-semver/issues/264\n        parsedVersion.build = [];\n        const normalizedVersion = parsedVersion.format();\n        return publishedVersions.indexOf(normalizedVersion) >= 0;\n    }\n    async _npmPackAsync(packageName, project) {\n        const args = ['pack'];\n        const env = PublishUtilities.getEnvArgs();\n        await PublishUtilities.execCommandAsync(!!this._publish.value, this.rushConfiguration.packageManagerToolFilename, args, project.publishFolder, env);\n        if (this._publish.value) {\n            // Copy the tarball the release folder\n            const tarballName = this._calculateTarballName(project);\n            const tarballPath = path.join(project.publishFolder, tarballName);\n            const destFolder = this._releaseFolder.value\n                ? this._releaseFolder.value\n                : path.join(this.rushConfiguration.commonTempFolder, 'artifacts', 'packages');\n            FileSystem.move({\n                sourcePath: tarballPath,\n                destinationPath: path.join(destFolder, tarballName),\n                overwrite: true\n            });\n        }\n    }\n    _calculateTarballName(project) {\n        // Same logic as how npm forms the tarball name\n        const packageName = project.packageName;\n        const name = packageName[0] === '@' ? packageName.substr(1).replace(/\\//g, '-') : packageName;\n        if (this.rushConfiguration.packageManager === 'yarn') {\n            // yarn tarballs have a \"v\" before the version number\n            return `${name}-v${project.packageJson.version}.tgz`;\n        }\n        else {\n            return `${name}-${project.packageJson.version}.tgz`;\n        }\n    }\n    _setDependenciesBeforePublish() {\n        for (const project of this.rushConfiguration.projects) {\n            if (!this._versionPolicy.value || this._versionPolicy.value === project.versionPolicyName) {\n                const versionPolicy = project.versionPolicy;\n                if (versionPolicy) {\n                    versionPolicy.setDependenciesBeforePublish(project.packageName, this.rushConfiguration);\n                }\n            }\n        }\n    }\n    _setDependenciesBeforeCommit() {\n        for (const project of this.rushConfiguration.projects) {\n            if (!this._versionPolicy.value || this._versionPolicy.value === project.versionPolicyName) {\n                const versionPolicy = project.versionPolicy;\n                if (versionPolicy) {\n                    versionPolicy.setDependenciesBeforePublish(project.packageName, this.rushConfiguration);\n                }\n            }\n        }\n    }\n    _addNpmPublishHome(supportEnvVarFallbackSyntax) {\n        // Create \"common\\temp\\publish-home\" folder, if it doesn't exist\n        Utilities.createFolderWithRetry(this._targetNpmrcPublishFolder);\n        // Copy down the committed \"common\\config\\rush\\.npmrc-publish\" file, if there is one\n        Utilities.syncNpmrc({\n            sourceNpmrcFolder: this.rushConfiguration.commonRushConfigFolder,\n            targetNpmrcFolder: this._targetNpmrcPublishFolder,\n            useNpmrcPublish: true,\n            supportEnvVarFallbackSyntax\n        });\n    }\n    _addSharedNpmConfig(env, args) {\n        const userHomeEnvVariable = process.platform === 'win32' ? 'USERPROFILE' : 'HOME';\n        let registry = '//registry.npmjs.org/';\n        // Check if .npmrc file exists in \"common\\temp\\publish-home\"\n        if (FileSystem.exists(this._targetNpmrcPublishPath)) {\n            // Redirect userHomeEnvVariable, NPM will use config in \"common\\temp\\publish-home\\.npmrc\"\n            env[userHomeEnvVariable] = this._targetNpmrcPublishFolder;\n        }\n        // Check if registryUrl and token are specified via command-line\n        if (this._registryUrl.value) {\n            const registryUrl = this._registryUrl.value;\n            env['npm_config_registry'] = registryUrl; // eslint-disable-line dot-notation\n            registry = registryUrl.substring(registryUrl.indexOf('//'));\n        }\n        if (this._npmAuthToken.value) {\n            args.push(`--${registry}:_authToken=${this._npmAuthToken.value}`);\n        }\n    }\n}\n//# sourceMappingURL=PublishAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Colorize } from '@rushstack/terminal';\nimport { BaseRushAction } from './BaseRushAction';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { PurgeManager } from '../../logic/PurgeManager';\nimport { UnlinkManager } from '../../logic/UnlinkManager';\nexport class PurgeAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'purge',\n            summary: 'For diagnostic purposes, use this command to delete caches and other temporary files used by Rush',\n            documentation: 'The \"rush purge\" command is used to delete temporary files created by Rush.  This is' +\n                ' useful if you are having problems and suspect that cache files may be corrupt.',\n            parser\n        });\n        this._unsafeParameter = this.defineFlagParameter({\n            parameterLongName: '--unsafe',\n            description: '(UNSAFE!) Also delete shared files such as the package manager instances stored in' +\n                ' the \".rush\" folder in the user\\'s home directory.  This is a more aggressive fix that is' +\n                ' NOT SAFE to run in a live environment because it will cause other concurrent Rush processes to fail.'\n        });\n    }\n    async runAsync() {\n        const stopwatch = Stopwatch.start();\n        const unlinkManager = new UnlinkManager(this.rushConfiguration);\n        const purgeManager = new PurgeManager(this.rushConfiguration, this.rushGlobalFolder);\n        await unlinkManager.unlinkAsync(/*force:*/ true);\n        if (this._unsafeParameter.value) {\n            purgeManager.purgeUnsafe();\n        }\n        else {\n            purgeManager.purgeNormal();\n        }\n        await purgeManager.startDeleteAllAsync();\n        // eslint-disable-next-line no-console\n        console.log('\\n' +\n            Colorize.green(`Rush purge started successfully and will complete asynchronously. (${stopwatch.toString()})`));\n    }\n}\n//# sourceMappingURL=PurgeAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseAddAndRemoveAction } from './BaseAddAndRemoveAction';\nimport { getVariantAsync, VARIANT_PARAMETER } from '../../api/Variants';\nexport class RemoveAction extends BaseAddAndRemoveAction {\n    constructor(parser) {\n        const documentation = [\n            'Removes specified package(s) from the dependencies of the current project (as determined by the current working directory)' +\n                ' and then runs \"rush update\".'\n        ].join('\\n');\n        super({\n            actionName: 'remove',\n            summary: 'Removes one or more dependencies from the package.json and runs rush update.',\n            documentation,\n            safeForSimultaneousRushProcesses: false,\n            parser\n        });\n        this._terminal = parser.terminal;\n        this._packageNameList = this.defineStringListParameter({\n            parameterLongName: '--package',\n            parameterShortName: '-p',\n            required: true,\n            argumentName: 'PACKAGE',\n            description: 'The name of the package which should be removed.' +\n                ' To remove multiple packages, run \"rush remove --package foo --package bar\".'\n        });\n        this._allFlag = this.defineFlagParameter({\n            parameterLongName: '--all',\n            description: 'If specified, the dependency will be removed from all projects that declare it.'\n        });\n        this._variantParameter = this.defineStringParameter(VARIANT_PARAMETER);\n    }\n    async getUpdateOptionsAsync() {\n        const projects = super.getProjects();\n        const packagesToRemove = [];\n        for (const specifiedPackageName of this.specifiedPackageNameList) {\n            /**\n             * Name\n             */\n            const packageName = specifiedPackageName;\n            if (!this.rushConfiguration.packageNameParser.isValidName(packageName)) {\n                throw new Error(`The package name \"${packageName}\" is not valid.`);\n            }\n            for (const project of projects) {\n                if (!project.packageJsonEditor.tryGetDependency(packageName) &&\n                    !project.packageJsonEditor.tryGetDevDependency(packageName)) {\n                    this._terminal.writeLine(`The project \"${project.packageName}\" does not have \"${packageName}\" in package.json.`);\n                }\n            }\n            packagesToRemove.push({ packageName });\n        }\n        const variant = await getVariantAsync(this._variantParameter, this.rushConfiguration, true);\n        return {\n            projects: projects,\n            packagesToUpdate: packagesToRemove,\n            skipUpdate: this._skipUpdateFlag.value,\n            debugInstall: this.parser.isDebug,\n            actionName: this.actionName,\n            variant\n        };\n    }\n}\n//# sourceMappingURL=RemoveAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport builtinPackageNames from 'builtin-modules';\nimport { Colorize } from '@rushstack/terminal';\nimport { FileSystem } from '@rushstack/node-core-library';\nimport { BaseConfiglessRushAction } from './BaseRushAction';\nexport class ScanAction extends BaseConfiglessRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'scan',\n            summary: 'When migrating projects into a Rush repo, this command is helpful for detecting' +\n                ' undeclared dependencies.',\n            documentation: `The Node.js module system allows a project to import NPM packages without explicitly` +\n                ` declaring them as dependencies in the package.json file.  Such \"phantom dependencies\"` +\n                ` can cause problems.  Rush and PNPM use symlinks specifically to protect against phantom dependencies.` +\n                ` These protections may cause runtime errors for existing projects when they are first migrated into` +\n                ` a Rush monorepo.  The \"rush scan\" command is a handy tool for fixing these errors. It scans the \"./src\"` +\n                ` and \"./lib\" folders for import syntaxes such as \"import __ from '__'\", \"require('__')\",` +\n                ` and \"System.import('__').  It prints a report of the referenced packages.  This heuristic is` +\n                ` not perfect, but it can save a lot of time when migrating projects.`,\n            safeForSimultaneousRushProcesses: true,\n            parser\n        });\n        this._jsonFlag = this.defineFlagParameter({\n            parameterLongName: '--json',\n            description: 'If this flag is specified, output will be in JSON format.'\n        });\n        this._allFlag = this.defineFlagParameter({\n            parameterLongName: '--all',\n            description: 'If this flag is specified, output will list all detected dependencies.'\n        });\n    }\n    async runAsync() {\n        const packageJsonFilename = path.resolve('./package.json');\n        if (!FileSystem.exists(packageJsonFilename)) {\n            throw new Error('You must run \"rush scan\" in a project folder containing a package.json file.');\n        }\n        const requireRegExps = [\n            // Example: require('something')\n            /\\brequire\\s*\\(\\s*[']([^']+\\s*)[']\\s*\\)/,\n            /\\brequire\\s*\\(\\s*[\"]([^\"]+\\s*)[\"]\\s*\\)/,\n            // Example: require.ensure('something')\n            /\\brequire\\.ensure\\s*\\(\\s*[']([^']+\\s*)[']\\s*\\)/,\n            /\\brequire\\.ensure\\s*\\(\\s*[\"]([^\"]+\\s*)[\"]\\s*\\)/,\n            // Example: require.resolve('something')\n            /\\brequire\\.resolve\\s*\\(\\s*[']([^']+\\s*)[']\\s*\\)/,\n            /\\brequire\\.resolve\\s*\\(\\s*[\"]([^\"]+\\s*)[\"]\\s*\\)/,\n            // Example: System.import('something')\n            /\\bSystem\\.import\\s*\\(\\s*[']([^']+\\s*)[']\\s*\\)/,\n            /\\bSystem\\.import\\s*\\(\\s*[\"]([^\"]+\\s*)[\"]\\s*\\)/,\n            // Example: Import.lazy('something', require);\n            /\\bImport\\.lazy\\s*\\(\\s*[']([^']+\\s*)[']/,\n            /\\bImport\\.lazy\\s*\\(\\s*[\"]([^\"]+\\s*)[\"]/,\n            // Example:\n            //\n            // import {\n            //   A, B\n            // } from 'something';\n            /\\bfrom\\s*[']([^']+)[']/,\n            /\\bfrom\\s*[\"]([^\"]+)[\"]/,\n            // Example:  import 'something';\n            /\\bimport\\s*[']([^']+)[']\\s*\\;/,\n            /\\bimport\\s*[\"]([^\"]+)[\"]\\s*\\;/,\n            // Example: await import('fast-glob')\n            /\\bimport\\s*\\(\\s*[']([^']+)[']\\s*\\)/,\n            /\\bimport\\s*\\(\\s*[\"]([^\"]+)[\"]\\s*\\)/,\n            // Example:\n            // /// <reference types=\"something\" />\n            /\\/\\/\\/\\s*<\\s*reference\\s+types\\s*=\\s*[\"]([^\"]+)[\"]\\s*\\/>/\n        ];\n        // Example: \"my-package/lad/dee/dah\" --> \"my-package\"\n        // Example: \"@ms/my-package\" --> \"@ms/my-package\"\n        // Example: \"lodash.get\" --> \"lodash.get\"\n        const packageRegExp = /^((@[a-z\\-0-9!_]+\\/)?[a-z\\-0-9!_][a-z\\-0-9!_.]*)\\/?/;\n        const requireMatches = new Set();\n        const { default: glob } = await import('fast-glob');\n        const scanResults = await glob(['./*.{ts,js,tsx,jsx}', './{src,lib}/**/*.{ts,js,tsx,jsx}']);\n        for (const filename of scanResults) {\n            try {\n                const contents = FileSystem.readFile(filename);\n                const lines = contents.split('\\n');\n                for (const line of lines) {\n                    for (const requireRegExp of requireRegExps) {\n                        const requireRegExpResult = requireRegExp.exec(line);\n                        if (requireRegExpResult) {\n                            requireMatches.add(requireRegExpResult[1]);\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.bold('Skipping file due to error: ' + filename));\n            }\n        }\n        const packageMatches = new Set();\n        requireMatches.forEach((requireMatch) => {\n            const packageRegExpResult = packageRegExp.exec(requireMatch);\n            if (packageRegExpResult) {\n                packageMatches.add(packageRegExpResult[1]);\n            }\n        });\n        const detectedPackageNames = [];\n        packageMatches.forEach((packageName) => {\n            if (builtinPackageNames.indexOf(packageName) < 0) {\n                detectedPackageNames.push(packageName);\n            }\n        });\n        detectedPackageNames.sort();\n        const declaredDependencies = new Set();\n        const declaredDevDependencies = new Set();\n        const missingDependencies = [];\n        const unusedDependencies = [];\n        const packageJsonContent = FileSystem.readFile(packageJsonFilename);\n        try {\n            const manifest = JSON.parse(packageJsonContent);\n            if (manifest.dependencies) {\n                for (const depName of Object.keys(manifest.dependencies)) {\n                    declaredDependencies.add(depName);\n                }\n            }\n            if (manifest.devDependencies) {\n                for (const depName of Object.keys(manifest.devDependencies)) {\n                    declaredDevDependencies.add(depName);\n                }\n            }\n        }\n        catch (e) {\n            // eslint-disable-next-line no-console\n            console.error(`JSON.parse ${packageJsonFilename} error`);\n        }\n        for (const detectedPkgName of detectedPackageNames) {\n            /**\n             * Missing(phantom) dependencies are\n             * - used in source code\n             * - not decalred in dependencies and devDependencies in package.json\n             */\n            if (!declaredDependencies.has(detectedPkgName) && !declaredDevDependencies.has(detectedPkgName)) {\n                missingDependencies.push(detectedPkgName);\n            }\n        }\n        for (const declaredPkgName of declaredDependencies) {\n            /**\n             * Unused dependencies are\n             * - declared in dependencies in package.json (devDependencies not included)\n             * - not used in source code\n             */\n            if (!detectedPackageNames.includes(declaredPkgName) && !declaredPkgName.startsWith('@types/')) {\n                unusedDependencies.push(declaredPkgName);\n            }\n        }\n        const output = {\n            detectedDependencies: detectedPackageNames,\n            missingDependencies: missingDependencies,\n            unusedDependencies: unusedDependencies\n        };\n        if (this._jsonFlag.value) {\n            // eslint-disable-next-line no-console\n            console.log(JSON.stringify(output, undefined, 2));\n        }\n        else if (this._allFlag.value) {\n            if (detectedPackageNames.length !== 0) {\n                // eslint-disable-next-line no-console\n                console.log('Dependencies that seem to be imported by this project:');\n                for (const packageName of detectedPackageNames) {\n                    // eslint-disable-next-line no-console\n                    console.log('  ' + packageName);\n                }\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.log('This project does not seem to import any NPM packages.');\n            }\n        }\n        else {\n            let wroteAnything = false;\n            if (missingDependencies.length > 0) {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.yellow('Possible phantom dependencies') +\n                    \" - these seem to be imported but aren't listed in package.json:\");\n                for (const packageName of missingDependencies) {\n                    // eslint-disable-next-line no-console\n                    console.log('  ' + packageName);\n                }\n                wroteAnything = true;\n            }\n            if (unusedDependencies.length > 0) {\n                if (wroteAnything) {\n                    // eslint-disable-next-line no-console\n                    console.log('');\n                }\n                // eslint-disable-next-line no-console\n                console.log(Colorize.yellow('Possible unused dependencies') +\n                    \" - these are listed in package.json but don't seem to be imported:\");\n                for (const packageName of unusedDependencies) {\n                    // eslint-disable-next-line no-console\n                    console.log('  ' + packageName);\n                }\n                wroteAnything = true;\n            }\n            if (!wroteAnything) {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.green('Everything looks good.') + '  No missing or unused dependencies were found.');\n            }\n        }\n    }\n}\n//# sourceMappingURL=ScanAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { SetupPackageRegistry } from '../../logic/setup/SetupPackageRegistry';\nimport { BaseRushAction } from './BaseRushAction';\nexport class SetupAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'setup',\n            summary: '(EXPERIMENTAL) Invoke this command before working in a new repo to ensure that any required' +\n                ' prerequisites are installed and permissions are configured.',\n            documentation: '(EXPERIMENTAL) Invoke this command before working in a new repo to ensure that any required' +\n                ' prerequisites are installed and permissions are configured.  The initial implementation' +\n                ' configures the NPM registry credentials.  More features will be added later.',\n            parser\n        });\n    }\n    async runAsync() {\n        const setupPackageRegistry = new SetupPackageRegistry({\n            rushConfiguration: this.rushConfiguration,\n            isDebug: this.parser.isDebug,\n            syncNpmrcAlreadyCalled: false\n        });\n        await setupPackageRegistry.checkAndSetupAsync();\n    }\n}\n//# sourceMappingURL=SetupAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from './BaseRushAction';\nimport { UnlinkManager } from '../../logic/UnlinkManager';\nexport class UnlinkAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'unlink',\n            summary: 'Delete node_modules symlinks for all projects in the repo',\n            documentation: 'This removes the symlinks created by the \"rush link\" command. This is useful for' +\n                ' cleaning a repo using \"git clean\" without accidentally deleting source files, or for using standard NPM' +\n                ' commands on a project.',\n            parser\n        });\n    }\n    async runAsync() {\n        const unlinkManager = new UnlinkManager(this.rushConfiguration);\n        if (!(await unlinkManager.unlinkAsync())) {\n            // eslint-disable-next-line no-console\n            console.log('Nothing to do.');\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log('\\nDone.');\n        }\n    }\n}\n//# sourceMappingURL=UnlinkAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseInstallAction } from './BaseInstallAction';\nimport { SelectionParameterSet } from '../parsing/SelectionParameterSet';\nimport { getVariantAsync } from '../../api/Variants';\nexport class UpdateAction extends BaseInstallAction {\n    constructor(parser) {\n        var _a;\n        super({\n            actionName: 'update',\n            summary: 'Install package dependencies for all projects in the repo,' +\n                ' and create or update the shrinkwrap file as needed',\n            documentation: 'The \"rush update\" command installs the dependencies described in your' +\n                ' package.json files, and updates the shrinkwrap file as needed.' +\n                ' (This \"shrinkwrap\" file stores a central inventory of all dependencies and versions' +\n                ' for projects in your repo. It is found in the \"common/config/rush\" folder.)' +\n                ' Note that Rush always performs a single install for all projects in your repo.' +\n                ' You should run \"rush update\" whenever you start working in a Rush repo,' +\n                ' after you pull from Git, and after you modify a package.json file.' +\n                ' If there is nothing to do, \"rush update\" is instantaneous.' +\n                ' NOTE: In certain cases \"rush install\" should be used instead of \"rush update\"' +\n                ' -- for details, see the command help for \"rush install\".',\n            parser\n        });\n        if ((_a = this.rushConfiguration) === null || _a === void 0 ? void 0 : _a.subspacesFeatureEnabled) {\n            // Partial update is supported only when subspaces is enabled.\n            this._selectionParameters = new SelectionParameterSet(this.rushConfiguration, this, {\n                gitOptions: {\n                    // Include lockfile processing since this expands the selection, and we need to select\n                    // at least the same projects selected with the same query to \"rush build\"\n                    includeExternalDependencies: true,\n                    // Disable filtering because rush-project.json is riggable and therefore may not be available\n                    enableFiltering: false\n                },\n                includeSubspaceSelector: true\n            });\n        }\n        this._fullParameter = this.defineFlagParameter({\n            parameterLongName: '--full',\n            description: 'Normally \"rush update\" tries to preserve your existing installed versions' +\n                ' and only makes the minimum updates needed to satisfy the package.json files.' +\n                ' This conservative approach prevents your PR from getting involved with package updates that' +\n                ' are unrelated to your work. Use \"--full\" when you really want to update all dependencies' +\n                ' to the latest SemVer-compatible version.  This should be done periodically by a person' +\n                ' or robot whose role is to deal with potential upgrade regressions.'\n        });\n        this._recheckParameter = this.defineFlagParameter({\n            parameterLongName: '--recheck',\n            description: 'If the shrinkwrap file appears to already satisfy the package.json files,' +\n                ' then \"rush update\" will skip invoking the package manager at all.  In certain situations' +\n                ' this heuristic may be inaccurate.  Use the \"--recheck\" flag to force the package manager' +\n                \" to process the shrinkwrap file.  This will also update your shrinkwrap file with Rush's fixups.\" +\n                ' (To minimize shrinkwrap churn, these fixups are normally performed only in the temporary folder.)'\n        });\n    }\n    async runAsync() {\n        await this.parser.pluginManager.updateAsync();\n        if (this.parser.pluginManager.error) {\n            await this.parser.pluginManager.reinitializeAllPluginsForCommandAsync(this.actionName);\n        }\n        return super.runAsync();\n    }\n    async buildInstallOptionsAsync() {\n        var _a, _b, _c, _d;\n        const selectedProjects = (_b = (await ((_a = this._selectionParameters) === null || _a === void 0 ? void 0 : _a.getSelectedProjectsAsync(this._terminal)))) !== null && _b !== void 0 ? _b : new Set(this.rushConfiguration.projects);\n        const variant = await getVariantAsync(this._variantParameter, this.rushConfiguration, false);\n        return {\n            debug: this.parser.isDebug,\n            allowShrinkwrapUpdates: true,\n            bypassPolicyAllowed: true,\n            bypassPolicy: this._bypassPolicyParameter.value,\n            noLink: this._noLinkParameter.value,\n            fullUpgrade: this._fullParameter.value,\n            recheckShrinkwrap: this._recheckParameter.value,\n            offline: this._offlineParameter.value,\n            networkConcurrency: this._networkConcurrencyParameter.value,\n            collectLogFile: this._debugPackageManagerParameter.value,\n            variant,\n            // Because the 'defaultValue' option on the _maxInstallAttempts parameter is set,\n            // it is safe to assume that the value is not null\n            maxInstallAttempts: this._maxInstallAttempts.value,\n            // These are derived independently of the selection for command line brevity\n            selectedProjects,\n            pnpmFilterArgumentValues: (_d = (await ((_c = this._selectionParameters) === null || _c === void 0 ? void 0 : _c.getPnpmFilterArgumentValuesAsync(this._terminal)))) !== null && _d !== void 0 ? _d : [],\n            checkOnly: false,\n            beforeInstallAsync: (subspace) => this.rushSession.hooks.beforeInstall.promise(this, subspace, variant),\n            afterInstallAsync: (subspace) => this.rushSession.hooks.afterInstall.promise(this, subspace, variant),\n            terminal: this._terminal\n        };\n    }\n}\n//# sourceMappingURL=UpdateAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseAutoinstallerAction } from './BaseAutoinstallerAction';\nexport class UpdateAutoinstallerAction extends BaseAutoinstallerAction {\n    constructor(parser) {\n        super({\n            actionName: 'update-autoinstaller',\n            summary: 'Updates autoinstaller package dependencies',\n            documentation: 'Use this command to regenerate the shrinkwrap file for an autoinstaller folder.',\n            parser\n        });\n    }\n    async prepareAsync(autoinstaller) {\n        // Do not run `autoinstaller.prepareAsync` here. It tries to install the autoinstaller with\n        // --frozen-lockfile or equivalent, which will fail if the autoinstaller's dependencies\n        // have been changed.\n        await autoinstaller.updateAsync();\n    }\n}\n//# sourceMappingURL=UpdateAutoinstallerAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nimport { ConsoleTerminalProvider, Terminal } from '@rushstack/terminal';\nimport { BaseRushAction } from './BaseRushAction';\nimport { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\nimport { RushConstants } from '../../logic/RushConstants';\nexport class UpdateCloudCredentialsAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: RushConstants.updateCloudCredentialsCommandName,\n            summary: '(EXPERIMENTAL) Update the credentials used by the build cache provider.',\n            documentation: '(EXPERIMENTAL) If the build caching feature is configured, this command facilitates ' +\n                'updating the credentials used by a cloud-based provider.',\n            safeForSimultaneousRushProcesses: false,\n            parser\n        });\n        this._interactiveModeFlag = this.defineFlagParameter({\n            parameterLongName: '--interactive',\n            parameterShortName: '-i',\n            description: 'Run the credential update operation in interactive mode, if supported by the provider.'\n        });\n        this._credentialParameter = this.defineStringParameter({\n            parameterLongName: '--credential',\n            argumentName: 'CREDENTIAL_STRING',\n            description: 'A static credential, to be cached.'\n        });\n        this._deleteFlag = this.defineFlagParameter({\n            parameterLongName: '--delete',\n            parameterShortName: '-d',\n            description: 'If specified, delete stored credentials.'\n        });\n    }\n    async runAsync() {\n        const terminal = new Terminal(new ConsoleTerminalProvider());\n        const buildCacheConfiguration = await BuildCacheConfiguration.loadAndRequireEnabledAsync(terminal, this.rushConfiguration, this.rushSession);\n        if (this._deleteFlag.value) {\n            if (this._interactiveModeFlag.value || this._credentialParameter.value !== undefined) {\n                terminal.writeErrorLine(`If the ${this._deleteFlag.longName} is provided, no other parameters may be provided.`);\n                throw new AlreadyReportedError();\n            }\n            else if (buildCacheConfiguration.cloudCacheProvider) {\n                await buildCacheConfiguration.cloudCacheProvider.deleteCachedCredentialsAsync(terminal);\n            }\n            else {\n                terminal.writeLine('A cloud build cache is not configured; there is nothing to delete.');\n            }\n        }\n        else if (this._interactiveModeFlag.value && this._credentialParameter.value !== undefined) {\n            terminal.writeErrorLine(`Both the ${this._interactiveModeFlag.longName} and the ` +\n                `${this._credentialParameter.longName} parameters were provided. Only one ` +\n                'or the other may be used at a time.');\n            throw new AlreadyReportedError();\n        }\n        else if (this._interactiveModeFlag.value) {\n            if (buildCacheConfiguration.cloudCacheProvider) {\n                await buildCacheConfiguration.cloudCacheProvider.updateCachedCredentialInteractiveAsync(terminal);\n            }\n            else {\n                terminal.writeLine('A cloud build cache is not configured. Credentials are not required.');\n            }\n        }\n        else if (this._credentialParameter.value !== undefined) {\n            if (buildCacheConfiguration.cloudCacheProvider) {\n                await buildCacheConfiguration.cloudCacheProvider.updateCachedCredentialAsync(terminal, this._credentialParameter.value);\n            }\n            else {\n                terminal.writeErrorLine('A cloud build cache is not configured. Credentials are not supported.');\n                throw new AlreadyReportedError();\n            }\n        }\n        else {\n            terminal.writeErrorLine(`One of the ${this._interactiveModeFlag.longName} parameter, the ` +\n                `${this._credentialParameter.longName} parameter, or the ` +\n                `${this._deleteFlag.longName} parameter must be provided.`);\n            throw new AlreadyReportedError();\n        }\n    }\n}\n//# sourceMappingURL=UpdateCloudCredentialsAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from './BaseRushAction';\nimport { getVariantAsync, VARIANT_PARAMETER } from '../../api/Variants';\nexport class UpgradeInteractiveAction extends BaseRushAction {\n    constructor(parser) {\n        const documentation = [\n            'Provide an interactive way to upgrade your dependencies. Running the command will open an interactive prompt' +\n                ' that will ask you which projects and which dependencies you would like to upgrade.' +\n                ' It will then update your package.json files, and run \"rush update\" for you.' +\n                ' If you are using ensureConsistentVersions policy, upgrade-interactive will update all packages which use the' +\n                ' dependencies that you are upgrading and match their SemVer range if provided. If ensureConsistentVersions' +\n                ' is not enabled, upgrade-interactive will only update the dependency in the package you specify.' +\n                ' This can be overriden by using the --make-consistent flag.'\n        ];\n        super({\n            actionName: 'upgrade-interactive',\n            summary: 'Provides interactive prompt for upgrading package dependencies per project',\n            safeForSimultaneousRushProcesses: false,\n            documentation: documentation.join(''),\n            parser\n        });\n        this._makeConsistentFlag = this.defineFlagParameter({\n            parameterLongName: '--make-consistent',\n            description: 'When upgrading dependencies from a single project, also upgrade dependencies from other projects.'\n        });\n        this._skipUpdateFlag = this.defineFlagParameter({\n            parameterLongName: '--skip-update',\n            parameterShortName: '-s',\n            description: 'If specified, the \"rush update\" command will not be run after updating the package.json files.'\n        });\n        this._variantParameter = this.defineStringParameter(VARIANT_PARAMETER);\n    }\n    async runAsync() {\n        const [{ PackageJsonUpdater }, { InteractiveUpgrader }] = await Promise.all([\n            import(/* webpackChunkName: 'PackageJsonUpdater' */ '../../logic/PackageJsonUpdater'),\n            import(/* webpackChunkName: 'InteractiveUpgrader' */ '../../logic/InteractiveUpgrader')\n        ]);\n        const packageJsonUpdater = new PackageJsonUpdater(this.rushConfiguration, this.rushGlobalFolder);\n        const interactiveUpgrader = new InteractiveUpgrader(this.rushConfiguration);\n        const variant = await getVariantAsync(this._variantParameter, this.rushConfiguration, true);\n        const shouldMakeConsistent = this.rushConfiguration.defaultSubspace.shouldEnsureConsistentVersions(variant) ||\n            this._makeConsistentFlag.value;\n        const { projects, depsToUpgrade } = await interactiveUpgrader.upgradeAsync();\n        await packageJsonUpdater.doRushUpgradeAsync({\n            projects,\n            packagesToAdd: depsToUpgrade.packages,\n            updateOtherPackages: shouldMakeConsistent,\n            skipUpdate: this._skipUpdateFlag.value,\n            debugInstall: this.parser.isDebug,\n            variant\n        });\n    }\n}\n//# sourceMappingURL=UpgradeInteractiveAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { FileConstants, Enum } from '@rushstack/node-core-library';\nimport { BumpType } from '../../api/VersionPolicy';\nimport { RushConfiguration } from '../../api/RushConfiguration';\nimport { VersionMismatchFinder } from '../../logic/versionMismatch/VersionMismatchFinder';\nimport * as PolicyValidator from '../../logic/policy/PolicyValidator';\nimport { BaseRushAction } from './BaseRushAction';\nimport { PublishGit } from '../../logic/PublishGit';\nimport { Git } from '../../logic/Git';\nimport { RushConstants } from '../../logic/RushConstants';\nexport const DEFAULT_PACKAGE_UPDATE_MESSAGE = 'Bump versions [skip ci]';\nexport const DEFAULT_CHANGELOG_UPDATE_MESSAGE = 'Update changelogs [skip ci]';\nexport class VersionAction extends BaseRushAction {\n    constructor(parser) {\n        super({\n            actionName: 'version',\n            summary: 'Manage package versions in the repo.',\n            documentation: 'use this \"rush version\" command to ensure version policies and bump versions.',\n            parser\n        });\n        this._targetBranch = this.defineStringParameter({\n            parameterLongName: '--target-branch',\n            parameterShortName: '-b',\n            argumentName: 'BRANCH',\n            description: 'If this flag is specified, changes will be committed and merged into the target branch.'\n        });\n        this._ensureVersionPolicy = this.defineFlagParameter({\n            parameterLongName: '--ensure-version-policy',\n            description: 'Updates package versions if needed to satisfy version policies.'\n        });\n        this._overrideVersion = this.defineStringParameter({\n            parameterLongName: '--override-version',\n            argumentName: 'NEW_VERSION',\n            description: 'Override the version in the specified --version-policy. ' +\n                'This setting only works for lock-step version policy and when --ensure-version-policy is specified.'\n        });\n        this._bumpVersion = this.defineFlagParameter({\n            parameterLongName: '--bump',\n            description: 'Bumps package version based on version policies.'\n        });\n        this._bypassPolicy = this.defineFlagParameter({\n            parameterLongName: RushConstants.bypassPolicyFlagLongName,\n            description: 'Overrides \"gitPolicy\" enforcement (use honorably!)'\n        });\n        this._versionPolicy = this.defineStringParameter({\n            parameterLongName: '--version-policy',\n            argumentName: 'POLICY',\n            description: 'The name of the version policy'\n        });\n        this._overwriteBump = this.defineStringParameter({\n            parameterLongName: '--override-bump',\n            argumentName: 'BUMPTYPE',\n            description: 'Overrides the bump type in the version-policy.json for the specified version policy. ' +\n                'Valid BUMPTYPE values include: prerelease, patch, preminor, minor, major. ' +\n                'This setting only works for lock-step version policy in bump action.'\n        });\n        this._prereleaseIdentifier = this.defineStringParameter({\n            parameterLongName: '--override-prerelease-id',\n            argumentName: 'ID',\n            description: 'Overrides the prerelease identifier in the version value of version-policy.json ' +\n                'for the specified version policy. ' +\n                'This setting only works for lock-step version policy. ' +\n                'This setting increases to new prerelease id when \"--bump\" is provided but only replaces the ' +\n                'prerelease name when \"--ensure-version-policy\" is provided.'\n        });\n        this._ignoreGitHooksParameter = this.defineFlagParameter({\n            parameterLongName: '--ignore-git-hooks',\n            description: `Skips execution of all git hooks. Make sure you know what you are skipping.`\n        });\n    }\n    async runAsync() {\n        const currentlyInstalledVariant = await this.rushConfiguration.getCurrentlyInstalledVariantAsync();\n        for (const subspace of this.rushConfiguration.subspaces) {\n            await PolicyValidator.validatePolicyAsync(this.rushConfiguration, subspace, currentlyInstalledVariant, {\n                bypassPolicyAllowed: true,\n                bypassPolicy: this._bypassPolicy.value\n            });\n        }\n        const git = new Git(this.rushConfiguration);\n        const userEmail = await git.getGitEmailAsync();\n        this._validateInput();\n        const versionManagerModule = await import(\n        /* webpackChunkName: 'VersionManager' */\n        '../../logic/VersionManager');\n        const versionManager = new versionManagerModule.VersionManager(this.rushConfiguration, userEmail, this.rushConfiguration.versionPolicyConfiguration);\n        if (this._ensureVersionPolicy.value) {\n            this._overwritePolicyVersionIfNeeded();\n            const tempBranch = 'version/ensure-' + new Date().getTime();\n            versionManager.ensure(this._versionPolicy.value, true, !!this._overrideVersion.value || !!this._prereleaseIdentifier.value);\n            const updatedPackages = versionManager.updatedProjects;\n            if (updatedPackages.size > 0) {\n                // eslint-disable-next-line no-console\n                console.log(`${updatedPackages.size} packages are getting updated.`);\n                await this._gitProcessAsync(tempBranch, this._targetBranch.value, currentlyInstalledVariant);\n            }\n        }\n        else if (this._bumpVersion.value) {\n            const tempBranch = 'version/bump-' + new Date().getTime();\n            await versionManager.bumpAsync(this._versionPolicy.value, this._overwriteBump.value ? Enum.getValueByKey(BumpType, this._overwriteBump.value) : undefined, this._prereleaseIdentifier.value, true);\n            await this._gitProcessAsync(tempBranch, this._targetBranch.value, currentlyInstalledVariant);\n        }\n    }\n    _overwritePolicyVersionIfNeeded() {\n        if (!this._overrideVersion.value && !this._prereleaseIdentifier.value) {\n            // No need to overwrite policy version\n            return;\n        }\n        if (this._overrideVersion.value && this._prereleaseIdentifier.value) {\n            throw new Error(`The parameters \"--override-version\" and \"--override-prerelease-id\" cannot be used together.`);\n        }\n        if (this._versionPolicy.value) {\n            const versionConfig = this.rushConfiguration.versionPolicyConfiguration;\n            const policy = versionConfig.getVersionPolicy(this._versionPolicy.value);\n            if (!policy || !policy.isLockstepped) {\n                throw new Error(`The lockstep version policy \"${policy.policyName}\" is not found.`);\n            }\n            let newVersion = undefined;\n            if (this._overrideVersion.value) {\n                newVersion = this._overrideVersion.value;\n            }\n            else if (this._prereleaseIdentifier.value) {\n                const newPolicyVersion = new semver.SemVer(policy.version);\n                if (newPolicyVersion.prerelease.length) {\n                    // Update 1.5.0-alpha.10 to 1.5.0-beta.10\n                    // For example, if we are parsing \"1.5.0-alpha.10\" then the newPolicyVersion.prerelease array\n                    // would contain [ \"alpha\", 10 ], so we would replace \"alpha\" with \"beta\"\n                    newPolicyVersion.prerelease = [\n                        this._prereleaseIdentifier.value,\n                        ...newPolicyVersion.prerelease.slice(1)\n                    ];\n                }\n                else {\n                    // Update 1.5.0 to 1.5.0-beta\n                    // Since there is no length, we can just set to a new array\n                    newPolicyVersion.prerelease = [this._prereleaseIdentifier.value];\n                }\n                newVersion = newPolicyVersion.format();\n            }\n            if (newVersion) {\n                versionConfig.update(this._versionPolicy.value, newVersion, true);\n            }\n        }\n        else {\n            throw new Error('Missing --version-policy parameter to specify which version policy should be overwritten.');\n        }\n    }\n    _validateInput() {\n        if (this._bumpVersion.value && this._ensureVersionPolicy.value) {\n            throw new Error('Please choose --bump or --ensure-version-policy but not together.');\n        }\n        if (this._overwriteBump.value && !Enum.tryGetValueByKey(BumpType, this._overwriteBump.value)) {\n            throw new Error('The value of override-bump is not valid.  ' +\n                'Valid values include prerelease, patch, preminor, minor, and major');\n        }\n    }\n    _validateResult(variant) {\n        // Load the config from file to avoid using inconsistent in-memory data.\n        const rushConfig = RushConfiguration.loadFromConfigurationFile(this.rushConfiguration.rushJsonFile);\n        // Validate result of all subspaces\n        for (const subspace of rushConfig.subspaces) {\n            // Respect the `ensureConsistentVersions` field in rush.json\n            if (!subspace.shouldEnsureConsistentVersions(variant)) {\n                continue;\n            }\n            const mismatchFinder = VersionMismatchFinder.getMismatches(rushConfig, {\n                subspace,\n                variant\n            });\n            if (mismatchFinder.numberOfMismatches) {\n                throw new Error('Unable to finish version bump because inconsistencies were encountered. ' +\n                    'Run \"rush check\" to find more details.');\n            }\n        }\n    }\n    async _gitProcessAsync(tempBranch, targetBranch, variant) {\n        // Validate the result before commit.\n        this._validateResult(variant);\n        const git = new Git(this.rushConfiguration);\n        const publishGit = new PublishGit(git, targetBranch);\n        // Make changes in temp branch.\n        await publishGit.checkoutAsync(tempBranch, true);\n        const uncommittedChanges = await git.getUncommittedChangesAsync();\n        // Stage, commit, and push the changes to remote temp branch.\n        // Need to commit the change log updates in its own commit\n        const changeLogUpdated = uncommittedChanges.some((changePath) => {\n            return changePath.indexOf('CHANGELOG.json') > 0;\n        });\n        if (changeLogUpdated) {\n            await publishGit.addChangesAsync('.', this.rushConfiguration.changesFolder);\n            await publishGit.addChangesAsync(':/**/CHANGELOG.json');\n            await publishGit.addChangesAsync(':/**/CHANGELOG.md');\n            await publishGit.commitAsync(this.rushConfiguration.gitChangeLogUpdateCommitMessage || DEFAULT_CHANGELOG_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);\n        }\n        // Commit the package.json and change files updates.\n        const packageJsonUpdated = uncommittedChanges.some((changePath) => {\n            return changePath.indexOf(FileConstants.PackageJson) > 0;\n        });\n        if (packageJsonUpdated) {\n            await publishGit.addChangesAsync(this.rushConfiguration.versionPolicyConfigurationFilePath);\n            await publishGit.addChangesAsync(':/**/package.json');\n            await publishGit.commitAsync(this.rushConfiguration.gitVersionBumpCommitMessage || DEFAULT_PACKAGE_UPDATE_MESSAGE, !this._ignoreGitHooksParameter.value);\n        }\n        if (changeLogUpdated || packageJsonUpdated) {\n            await publishGit.pushAsync(tempBranch, !this._ignoreGitHooksParameter.value);\n            // Now merge to target branch.\n            await publishGit.fetchAsync();\n            await publishGit.checkoutAsync(targetBranch);\n            await publishGit.pullAsync(!this._ignoreGitHooksParameter.value);\n            await publishGit.mergeAsync(tempBranch, !this._ignoreGitHooksParameter.value);\n            await publishGit.pushAsync(targetBranch, !this._ignoreGitHooksParameter.value);\n            await publishGit.deleteBranchAsync(tempBranch, true, !this._ignoreGitHooksParameter.value);\n        }\n        else {\n            // skip commits\n            await publishGit.fetchAsync();\n            await publishGit.checkoutAsync(targetBranch);\n            await publishGit.deleteBranchAsync(tempBranch, false, !this._ignoreGitHooksParameter.value);\n        }\n    }\n}\n//# sourceMappingURL=VersionAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as os from 'os';\n/**\n * Parses a command line specification for desired parallelism.\n * Factored out to enable unit tests\n */\nexport function parseParallelism(rawParallelism, numberOfCores) {\n    var _a, _b;\n    if (numberOfCores === void 0) { numberOfCores = (_b = (_a = os.availableParallelism) === null || _a === void 0 ? void 0 : _a.call(os)) !== null && _b !== void 0 ? _b : os.cpus().length; }\n    if (rawParallelism) {\n        if (rawParallelism === 'max') {\n            return numberOfCores;\n        }\n        else {\n            const parallelismAsNumber = Number(rawParallelism);\n            if (typeof rawParallelism === 'string' && rawParallelism.trim().endsWith('%')) {\n                const parsedPercentage = Number(rawParallelism.trim().replace(/\\%$/, ''));\n                if (parsedPercentage <= 0 || parsedPercentage > 100) {\n                    throw new Error(`Invalid percentage value of '${rawParallelism}', value cannot be less than '0%' or more than '100%'`);\n                }\n                const workers = Math.floor((parsedPercentage / 100) * numberOfCores);\n                return Math.max(workers, 1);\n            }\n            else if (!isNaN(parallelismAsNumber)) {\n                return Math.max(parallelismAsNumber, 1);\n            }\n            else {\n                throw new Error(`Invalid parallelism value of '${rawParallelism}', expected a number, a percentage, or 'max'`);\n            }\n        }\n    }\n    else {\n        // If an explicit parallelism number wasn't provided, then choose a sensible\n        // default.\n        if (os.platform() === 'win32') {\n            // On desktop Windows, some people have complained that their system becomes\n            // sluggish if Rush is using all the CPU cores.  Leave one thread for\n            // other operations. For CI environments, you can use the \"max\" argument to use all available cores.\n            return Math.max(numberOfCores - 1, 1);\n        }\n        else {\n            // Unix-like operating systems have more balanced scheduling, so default\n            // to the number of CPU cores\n            return numberOfCores;\n        }\n    }\n}\n//# sourceMappingURL=ParseParallelism.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError, PackageJsonLookup } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { Selection } from '../../logic/Selection';\nimport { GitChangedProjectSelectorParser } from '../../logic/selectors/GitChangedProjectSelectorParser';\nimport { NamedProjectSelectorParser } from '../../logic/selectors/NamedProjectSelectorParser';\nimport { TagProjectSelectorParser } from '../../logic/selectors/TagProjectSelectorParser';\nimport { VersionPolicyProjectSelectorParser } from '../../logic/selectors/VersionPolicyProjectSelectorParser';\nimport { SubspaceSelectorParser } from '../../logic/selectors/SubspaceSelectorParser';\nimport { RushConstants } from '../../logic/RushConstants';\nexport const SUBSPACE_LONG_ARG_NAME = '--subspace';\n/**\n * This class is provides the set of command line parameters used to select projects\n * based on dependencies.\n *\n * It is a separate component such that unrelated actions can share the same parameters.\n */\nexport class SelectionParameterSet {\n    constructor(rushConfiguration, action, options) {\n        const { gitOptions, includeSubspaceSelector } = options;\n        this._rushConfiguration = rushConfiguration;\n        const selectorParsers = new Map();\n        const nameSelectorParser = new NamedProjectSelectorParser(rushConfiguration);\n        selectorParsers.set('name', nameSelectorParser);\n        selectorParsers.set('git', new GitChangedProjectSelectorParser(rushConfiguration, gitOptions));\n        selectorParsers.set('tag', new TagProjectSelectorParser(rushConfiguration));\n        selectorParsers.set('version-policy', new VersionPolicyProjectSelectorParser(rushConfiguration));\n        selectorParsers.set('subspace', new SubspaceSelectorParser(rushConfiguration));\n        this._selectorParserByScope = selectorParsers;\n        const getSpecifierCompletions = async () => {\n            const completions = ['.'];\n            for (const [prefix, selector] of selectorParsers) {\n                for (const completion of selector.getCompletions()) {\n                    completions.push(`${prefix}:${completion}`);\n                }\n            }\n            // Include completions from the name parser without a scope\n            for (const completion of nameSelectorParser.getCompletions()) {\n                completions.push(completion);\n            }\n            return completions;\n        };\n        this._toProject = action.defineStringListParameter({\n            parameterLongName: '--to',\n            parameterShortName: '-t',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--to\" parameter expands this selection to include PROJECT and all its dependencies.' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._toExceptProject = action.defineStringListParameter({\n            parameterLongName: '--to-except',\n            parameterShortName: '-T',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--to-except\" parameter expands this selection to include all dependencies of PROJECT,' +\n                ' but not PROJECT itself.' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._fromProject = action.defineStringListParameter({\n            parameterLongName: '--from',\n            parameterShortName: '-f',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--from\" parameter expands this selection to include PROJECT and all projects that depend on it,' +\n                ' plus all dependencies of this set.' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._onlyProject = action.defineStringListParameter({\n            parameterLongName: '--only',\n            parameterShortName: '-o',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--only\" parameter expands this selection to include PROJECT; its dependencies are not added.' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' Note that this parameter is \"unsafe\" as it may produce a selection that excludes some dependencies.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._impactedByProject = action.defineStringListParameter({\n            parameterLongName: '--impacted-by',\n            parameterShortName: '-i',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--impacted-by\" parameter expands this selection to include PROJECT and any projects that' +\n                ' depend on PROJECT (and thus might be broken by changes to PROJECT).' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' Note that this parameter is \"unsafe\" as it may produce a selection that excludes some dependencies.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._impactedByExceptProject = action.defineStringListParameter({\n            parameterLongName: '--impacted-by-except',\n            parameterShortName: '-I',\n            argumentName: 'PROJECT',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' Each \"--impacted-by-except\" parameter works the same as \"--impacted-by\" except that PROJECT itself' +\n                ' is not added to the selection.' +\n                ' \".\" can be used as shorthand for the project in the current working directory.' +\n                ' Note that this parameter is \"unsafe\" as it may produce a selection that excludes some dependencies.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".',\n            completions: getSpecifierCompletions\n        });\n        this._toVersionPolicy = action.defineStringListParameter({\n            parameterLongName: '--to-version-policy',\n            argumentName: 'VERSION_POLICY_NAME',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' The \"--to-version-policy\" parameter is equivalent to specifying \"--to\" for each of the projects' +\n                ' belonging to VERSION_POLICY_NAME.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".'\n        });\n        this._fromVersionPolicy = action.defineStringListParameter({\n            parameterLongName: '--from-version-policy',\n            argumentName: 'VERSION_POLICY_NAME',\n            description: 'Normally all projects in the monorepo will be processed;' +\n                ' adding this parameter will instead select a subset of projects.' +\n                ' The \"--from-version-policy\" parameter is equivalent to specifying \"--from\" for each of the projects' +\n                ' belonging to VERSION_POLICY_NAME.' +\n                ' For details, refer to the website article \"Selecting subsets of projects\".'\n        });\n        if (includeSubspaceSelector) {\n            this._subspaceParameter = action.defineStringParameter({\n                parameterLongName: SUBSPACE_LONG_ARG_NAME,\n                argumentName: 'SUBSPACE_NAME',\n                description: '(EXPERIMENTAL) Specifies a Rush subspace to be installed. Requires the \"subspacesEnabled\" feature to be enabled in subspaces.json.'\n            });\n        }\n    }\n    /**\n     * Used to implement the `preventSelectingAllSubspaces` policy which checks for commands that accidentally\n     * select everything.   Return `true` if the CLI was invoked with selection parameters.\n     *\n     * @remarks\n     * It is still possible for a user to select everything, but they must do so using an explicit selection\n     * such as `rush install --from thing-that-everything-depends-on`.\n     */\n    didUserSelectAnything() {\n        var _a;\n        if ((_a = this._subspaceParameter) === null || _a === void 0 ? void 0 : _a.value) {\n            return true;\n        }\n        return [\n            this._impactedByProject,\n            this._impactedByExceptProject,\n            this._onlyProject,\n            this._toProject,\n            this._fromProject,\n            this._toExceptProject,\n            this._fromVersionPolicy,\n            this._toVersionPolicy\n        ].some((x) => x.values.length > 0);\n    }\n    /**\n     * Computes the set of selected projects based on all parameter values.\n     *\n     * If no parameters are specified, returns all projects in the Rush config file.\n     */\n    async getSelectedProjectsAsync(terminal) {\n        var _a, _b;\n        // Hack out the old version-policy parameters\n        for (const value of this._fromVersionPolicy.values) {\n            this._fromProject.values.push(`version-policy:${value}`);\n        }\n        for (const value of this._toVersionPolicy.values) {\n            this._toProject.values.push(`version-policy:${value}`);\n        }\n        const selectors = [\n            this._onlyProject,\n            this._fromProject,\n            this._toProject,\n            this._toExceptProject,\n            this._impactedByProject,\n            this._impactedByExceptProject\n        ];\n        // Check if any of the selection parameters have a value specified on the command line\n        const isSelectionSpecified = selectors.some((param) => param.values.length > 0) ||\n            !!((_a = this._subspaceParameter) === null || _a === void 0 ? void 0 : _a.value);\n        // If no selection parameters are specified, return everything\n        if (!isSelectionSpecified) {\n            return new Set(this._rushConfiguration.projects);\n        }\n        const [\n        // Include exactly these projects (--only)\n        onlyProjects, \n        // Include all projects that depend on these projects, and all dependencies thereof\n        fromProjects, \n        // --to\n        toRaw, \n        // --to-except\n        toExceptProjects, \n        // --impacted-by\n        impactedByProjects, \n        // --impacted-by-except\n        impactedByExceptProjects] = await Promise.all(selectors.map((param) => {\n            return this._evaluateProjectParameterAsync(param, terminal);\n        }));\n        let subspaceProjects = [];\n        if ((_b = this._subspaceParameter) === null || _b === void 0 ? void 0 : _b.value) {\n            if (!this._rushConfiguration.subspacesFeatureEnabled) {\n                // eslint-disable-next-line no-console\n                console.log();\n                // eslint-disable-next-line no-console\n                console.log(Colorize.red(`The \"${SUBSPACE_LONG_ARG_NAME}\" parameter can only be passed if \"subspacesEnabled\" ` +\n                    'is set to true in subspaces.json.'));\n                throw new AlreadyReportedError();\n            }\n            const subspace = this._rushConfiguration.getSubspace(this._subspaceParameter.value);\n            subspaceProjects = subspace.getProjects();\n        }\n        const selection = Selection.union(\n        // Safe command line options\n        Selection.expandAllDependencies(Selection.union(toRaw, Selection.directDependenciesOf(toExceptProjects), \n        // --from / --from-version-policy\n        Selection.expandAllConsumers(fromProjects))), subspaceProjects, \n        // Unsafe command line option: --only\n        onlyProjects, \n        // Unsafe command line options: --impacted-by, --impacted-by-except\n        Selection.expandAllConsumers(Selection.union(impactedByProjects, Selection.directConsumersOf(impactedByExceptProjects))));\n        return selection;\n    }\n    /**\n     * Represents the selection as `--filter` parameters to pnpm.\n     *\n     * @remarks\n     *\n     * IMPORTANT: This function produces PNPM CLI operators that select projects from PNPM's temp workspace.\n     * If Rush subspaces are enabled, PNPM cannot see the complete Rush workspace, and therefore these operators\n     * would malfunction. In the current implementation, we calculate them anyway, then `BaseInstallAction.runAsync()`\n     * will overwrite `pnpmFilterArgumentValues` with a flat list of project names.  In the future, these\n     * two code paths will be combined into a single general solution.\n     *\n     * @see https://pnpm.io/filtering\n     */\n    async getPnpmFilterArgumentValuesAsync(terminal) {\n        const args = [];\n        // Include exactly these projects (--only)\n        for (const project of await this._evaluateProjectParameterAsync(this._onlyProject, terminal)) {\n            args.push(project.packageName);\n        }\n        // Include all projects that depend on these projects, and all dependencies thereof\n        const fromProjects = Selection.union(\n        // --from\n        await this._evaluateProjectParameterAsync(this._fromProject, terminal));\n        // All specified projects and all projects that they depend on\n        for (const project of Selection.union(\n        // --to\n        await this._evaluateProjectParameterAsync(this._toProject, terminal), \n        // --from / --from-version-policy\n        Selection.expandAllConsumers(fromProjects))) {\n            args.push(`${project.packageName}...`);\n        }\n        // --to-except\n        // All projects that the project directly or indirectly declares as a dependency\n        for (const project of await this._evaluateProjectParameterAsync(this._toExceptProject, terminal)) {\n            args.push(`${project.packageName}^...`);\n        }\n        // --impacted-by\n        // The project and all projects directly or indirectly declare it as a dependency\n        for (const project of await this._evaluateProjectParameterAsync(this._impactedByProject, terminal)) {\n            args.push(`...${project.packageName}`);\n        }\n        // --impacted-by-except\n        // All projects that directly or indirectly declare the specified project as a dependency\n        for (const project of await this._evaluateProjectParameterAsync(this._impactedByExceptProject, terminal)) {\n            args.push(`...^${project.packageName}`);\n        }\n        return args;\n    }\n    /**\n     * Usage telemetry for selection parameters. Only saved locally, and if requested in the config.\n     */\n    getTelemetry() {\n        return {\n            command_from: `${this._fromProject.values.length > 0}`,\n            command_impactedBy: `${this._impactedByProject.values.length > 0}`,\n            command_impactedByExcept: `${this._impactedByExceptProject.values.length > 0}`,\n            command_only: `${this._onlyProject.values.length > 0}`,\n            command_to: `${this._toProject.values.length > 0}`,\n            command_toExcept: `${this._toExceptProject.values.length > 0}`,\n            command_fromVersionPolicy: `${this._fromVersionPolicy.values.length > 0}`,\n            command_toVersionPolicy: `${this._toVersionPolicy.values.length > 0}`\n        };\n    }\n    /**\n     * Computes the referents of parameters that accept a project identifier.\n     * Handles '.', unscoped names, and scoped names.\n     */\n    async _evaluateProjectParameterAsync(listParameter, terminal) {\n        const parameterName = listParameter.longName;\n        const selection = new Set();\n        for (const rawSelector of listParameter.values) {\n            // Handle the special case of \"current project\" without a scope\n            if (rawSelector === '.') {\n                const packageJsonLookup = PackageJsonLookup.instance;\n                const packageJson = packageJsonLookup.tryLoadPackageJsonFor(process.cwd());\n                if (packageJson) {\n                    const project = this._rushConfiguration.getProjectByName(packageJson.name);\n                    if (project) {\n                        selection.add(project);\n                    }\n                    else {\n                        terminal.writeErrorLine(`Rush is not currently running in a project directory specified in ${RushConstants.rushJsonFilename}. ` +\n                            `The \".\" value for the ${parameterName} parameter is not allowed.`);\n                        throw new AlreadyReportedError();\n                    }\n                }\n                else {\n                    terminal.writeErrorLine('Rush is not currently running in a project directory. ' +\n                        `The \".\" value for the ${parameterName} parameter is not allowed.`);\n                    throw new AlreadyReportedError();\n                }\n                continue;\n            }\n            const scopeIndex = rawSelector.indexOf(':');\n            const scope = scopeIndex < 0 ? 'name' : rawSelector.slice(0, scopeIndex);\n            const unscopedSelector = scopeIndex < 0 ? rawSelector : rawSelector.slice(scopeIndex + 1);\n            const handler = this._selectorParserByScope.get(scope);\n            if (!handler) {\n                terminal.writeErrorLine(`Unsupported selector prefix \"${scope}\" passed to \"${parameterName}\": \"${rawSelector}\".` +\n                    ` Supported prefixes: ${Array.from(this._selectorParserByScope.keys(), (selectorParserScope) => `\"${selectorParserScope}:\"`).join(', ')}`);\n                throw new AlreadyReportedError();\n            }\n            for (const project of await handler.evaluateSelectorAsync({\n                unscopedSelector,\n                terminal,\n                parameterName\n            })) {\n                selection.add(project);\n            }\n        }\n        return selection;\n    }\n}\n//# sourceMappingURL=SelectionParameterSet.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseRushAction } from '../actions/BaseRushAction';\nimport { RushConstants } from '../../logic/RushConstants';\n/**\n * Base class for command-line actions that are implemented using user-defined scripts.\n *\n * @remarks\n * Compared to the normal built-in actions, these actions are special because (1) they\n * can be discovered dynamically via common/config/command-line.json, and (2)\n * user-defined command-line parameters can be passed through to the script.\n *\n * The two subclasses are BulkScriptAction and GlobalScriptAction.\n */\nexport class BaseScriptAction extends BaseRushAction {\n    constructor(options) {\n        super(options);\n        this.customParameters = new Map();\n        this.commandLineConfiguration = options.commandLineConfiguration;\n        this.command = options.command;\n    }\n    defineScriptParameters() {\n        if (!this.commandLineConfiguration) {\n            return;\n        }\n        // Find any parameters that are associated with this command\n        for (const parameter of this.command.associatedParameters) {\n            let tsCommandLineParameter;\n            switch (parameter.parameterKind) {\n                case 'flag':\n                    tsCommandLineParameter = this.defineFlagParameter({\n                        parameterShortName: parameter.shortName,\n                        parameterLongName: parameter.longName,\n                        description: parameter.description,\n                        required: parameter.required\n                    });\n                    break;\n                case 'choice':\n                    tsCommandLineParameter = this.defineChoiceParameter({\n                        parameterShortName: parameter.shortName,\n                        parameterLongName: parameter.longName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        alternatives: parameter.alternatives.map((x) => x.name),\n                        defaultValue: parameter.defaultValue\n                    });\n                    break;\n                case 'string':\n                    tsCommandLineParameter = this.defineStringParameter({\n                        parameterLongName: parameter.longName,\n                        parameterShortName: parameter.shortName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        argumentName: parameter.argumentName\n                    });\n                    break;\n                case 'integer':\n                    tsCommandLineParameter = this.defineIntegerParameter({\n                        parameterLongName: parameter.longName,\n                        parameterShortName: parameter.shortName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        argumentName: parameter.argumentName\n                    });\n                    break;\n                case 'stringList':\n                    tsCommandLineParameter = this.defineStringListParameter({\n                        parameterLongName: parameter.longName,\n                        parameterShortName: parameter.shortName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        argumentName: parameter.argumentName\n                    });\n                    break;\n                case 'integerList':\n                    tsCommandLineParameter = this.defineIntegerListParameter({\n                        parameterLongName: parameter.longName,\n                        parameterShortName: parameter.shortName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        argumentName: parameter.argumentName\n                    });\n                    break;\n                case 'choiceList':\n                    tsCommandLineParameter = this.defineChoiceListParameter({\n                        parameterShortName: parameter.shortName,\n                        parameterLongName: parameter.longName,\n                        description: parameter.description,\n                        required: parameter.required,\n                        alternatives: parameter.alternatives.map((x) => x.name)\n                    });\n                    break;\n                default:\n                    throw new Error(`${RushConstants.commandLineFilename} defines a parameter \"${parameter.longName}\" using an unsupported parameter kind \"${parameter.parameterKind}\"`);\n            }\n            this.customParameters.set(parameter, tsCommandLineParameter);\n        }\n    }\n}\n//# sourceMappingURL=BaseScriptAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, JsonFile, AlreadyReportedError, Text } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { BaseScriptAction } from './BaseScriptAction';\nimport { Utilities } from '../../utilities/Utilities';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { Autoinstaller } from '../../logic/Autoinstaller';\n/**\n * This class implements custom commands that are run once globally for the entire repo\n * (versus bulk commands, which run separately for each project).  The action executes\n * a user-defined script file.\n *\n * @remarks\n * Bulk commands can be defined via common/config/command-line.json.  Rush's predefined \"build\"\n * and \"rebuild\" commands are also modeled as bulk commands, because they essentially just\n * invoke scripts from package.json in the same way as a custom command.\n */\nexport class GlobalScriptAction extends BaseScriptAction {\n    constructor(options) {\n        super(options);\n        this._shellCommand = options.shellCommand;\n        this._autoinstallerName = options.autoinstallerName || '';\n        if (this._autoinstallerName) {\n            Autoinstaller.validateName(this._autoinstallerName);\n            // Example: .../common/autoinstallers/my-task\n            this._autoinstallerFullPath = path.join(this.rushConfiguration.commonAutoinstallersFolder, this._autoinstallerName);\n            if (!FileSystem.exists(this._autoinstallerFullPath)) {\n                throw new Error(`The custom command \"${this.actionName}\" specifies an \"autoinstallerName\" setting` +\n                    ' but the path does not exist: ' +\n                    this._autoinstallerFullPath);\n            }\n            // Example: .../common/autoinstallers/my-task/package.json\n            const packageJsonPath = path.join(this._autoinstallerFullPath, 'package.json');\n            if (!FileSystem.exists(packageJsonPath)) {\n                throw new Error(`The custom command \"${this.actionName}\" specifies an \"autoinstallerName\" setting` +\n                    ` whose package.json file was not found: ` +\n                    packageJsonPath);\n            }\n            const packageJson = JsonFile.load(packageJsonPath);\n            if (packageJson.name !== this._autoinstallerName) {\n                throw new Error(`The custom command \"${this.actionName}\" specifies an \"autoinstallerName\" setting,` +\n                    ` but the package.json file's \"name\" field is not \"${this._autoinstallerName}\": ` +\n                    packageJsonPath);\n            }\n        }\n        else {\n            this._autoinstallerFullPath = '';\n        }\n        this.defineScriptParameters();\n    }\n    async _prepareAutoinstallerNameAsync() {\n        const autoInstaller = new Autoinstaller({\n            autoinstallerName: this._autoinstallerName,\n            rushConfiguration: this.rushConfiguration,\n            rushGlobalFolder: this.rushGlobalFolder\n        });\n        await autoInstaller.prepareAsync();\n    }\n    async runAsync() {\n        var _a, _b;\n        const { hooks: sessionHooks } = this.rushSession;\n        if (sessionHooks.runAnyGlobalCustomCommand.isUsed()) {\n            // Avoid the cost of compiling the hook if it wasn't tapped.\n            await sessionHooks.runAnyGlobalCustomCommand.promise(this);\n        }\n        const hookForAction = sessionHooks.runGlobalCustomCommand.get(this.actionName);\n        if (hookForAction) {\n            // Run the more specific hook for a command with this name after the general hook\n            await hookForAction.promise(this);\n        }\n        const additionalPathFolders = ((_a = this.commandLineConfiguration) === null || _a === void 0 ? void 0 : _a.additionalPathFolders.slice()) || [];\n        if (this._autoinstallerName) {\n            await this._prepareAutoinstallerNameAsync();\n            const autoinstallerNameBinPath = path.join(this._autoinstallerFullPath, 'node_modules', '.bin');\n            additionalPathFolders.push(autoinstallerNameBinPath);\n        }\n        // Collect all custom parameter values\n        const customParameterValues = [];\n        for (const tsCommandLineParameter of this.customParameters.values()) {\n            tsCommandLineParameter.appendToArgList(customParameterValues);\n        }\n        for (let i = 0; i < customParameterValues.length; i++) {\n            let customParameterValue = customParameterValues[i];\n            customParameterValue = customParameterValue.replace(/\"/g, '\\\\\"');\n            if (customParameterValue.indexOf(' ') >= 0) {\n                customParameterValue = `\"${customParameterValue}\"`;\n            }\n            customParameterValues[i] = customParameterValue;\n        }\n        let shellCommand = this._shellCommand;\n        if (customParameterValues.length > 0) {\n            shellCommand += ' ' + customParameterValues.join(' ');\n        }\n        const shellCommandTokenContext = (_b = this.commandLineConfiguration) === null || _b === void 0 ? void 0 : _b.shellCommandTokenContext;\n        if (shellCommandTokenContext) {\n            shellCommand = this._expandShellCommandWithTokens(shellCommand, shellCommandTokenContext);\n        }\n        this._rejectAnyTokensInShellCommand(shellCommand, shellCommandTokenContext);\n        const stopwatch = Stopwatch.start();\n        const exitCode = Utilities.executeLifecycleCommand(shellCommand, {\n            rushConfiguration: this.rushConfiguration,\n            workingDirectory: this.rushConfiguration.rushJsonFolder,\n            initCwd: this.rushConfiguration.commonTempFolder,\n            handleOutput: false,\n            environmentPathOptions: {\n                includeRepoBin: true,\n                additionalPathFolders: additionalPathFolders\n            }\n        });\n        process.exitCode = exitCode;\n        stopwatch.stop();\n        if (this.parser.telemetry) {\n            this.parser.telemetry.log({\n                name: this.actionName,\n                durationInSeconds: stopwatch.duration,\n                result: exitCode > 0 ? 'Failed' : 'Succeeded',\n                extraData: {\n                    customParameterValue: customParameterValues.join(' ')\n                }\n            });\n            this.parser.flushTelemetry();\n        }\n        if (exitCode > 0) {\n            // eslint-disable-next-line no-console\n            console.log('\\n' + Colorize.red(`The script failed with exit code ${exitCode}`));\n            throw new AlreadyReportedError();\n        }\n    }\n    _expandShellCommandWithTokens(shellCommand, tokenContext) {\n        let expandedShellCommand = shellCommand;\n        for (const [token, tokenReplacement] of Object.entries(tokenContext)) {\n            expandedShellCommand = Text.replaceAll(expandedShellCommand, `<${token}>`, tokenReplacement);\n        }\n        return expandedShellCommand;\n    }\n    _rejectAnyTokensInShellCommand(shellCommand, tokenContext) {\n        if (shellCommand.indexOf('<') < 0 && shellCommand.indexOf('>') < 0) {\n            return;\n        }\n        const tokenRegExp = /(\\<[^<]*?\\>)/;\n        const match = tokenRegExp.exec(shellCommand);\n        if (match) {\n            throw new Error(`The \"shellCommand\" value contains an unrecognized token \"${match[1]}\".${tokenContext ? ` Available tokens are ${Object.keys(tokenContext).join(', ')}.` : ''}`);\n        }\n        throw new Error(`The \"shellCommand\" value contains extra token characters (\"<\" or \">\"): ${shellCommand}`);\n    }\n}\n//# sourceMappingURL=GlobalScriptAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError, InternalError } from '@rushstack/node-core-library';\nimport { Terminal, Colorize } from '@rushstack/terminal';\nimport { PhasedCommandHooks } from '../../pluginFramework/PhasedCommandHooks';\nimport { SetupChecks } from '../../logic/SetupChecks';\nimport { Stopwatch, StopwatchState } from '../../utilities/Stopwatch';\nimport { BaseScriptAction } from './BaseScriptAction';\nimport { OperationExecutionManager } from '../../logic/operations/OperationExecutionManager';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { EnvironmentVariableNames } from '../../api/EnvironmentConfiguration';\nimport { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\nimport { SelectionParameterSet } from '../parsing/SelectionParameterSet';\nimport { PhasedOperationPlugin } from '../../logic/operations/PhasedOperationPlugin';\nimport { ShellOperationRunnerPlugin } from '../../logic/operations/ShellOperationRunnerPlugin';\nimport { Event } from '../../api/EventHooks';\nimport { ProjectChangeAnalyzer } from '../../logic/ProjectChangeAnalyzer';\nimport { OperationStatus } from '../../logic/operations/OperationStatus';\nimport { OperationResultSummarizerPlugin } from '../../logic/operations/OperationResultSummarizerPlugin';\nimport { parseParallelism } from '../parsing/ParseParallelism';\nimport { CobuildConfiguration } from '../../api/CobuildConfiguration';\nimport { CacheableOperationPlugin } from '../../logic/operations/CacheableOperationPlugin';\nimport { RushProjectConfiguration } from '../../api/RushProjectConfiguration';\nimport { LegacySkipPlugin } from '../../logic/operations/LegacySkipPlugin';\nimport { ValidateOperationsPlugin } from '../../logic/operations/ValidateOperationsPlugin';\nimport { ShardedPhasedOperationPlugin } from '../../logic/operations/ShardedPhaseOperationPlugin';\nimport { FlagFile } from '../../api/FlagFile';\nimport { WeightedOperationPlugin } from '../../logic/operations/WeightedOperationPlugin';\nimport { getVariantAsync, VARIANT_PARAMETER } from '../../api/Variants';\nimport { Selection } from '../../logic/Selection';\nimport { NodeDiagnosticDirPlugin } from '../../logic/operations/NodeDiagnosticDirPlugin';\n/**\n * This class implements phased commands which are run individually for each project in the repo,\n * possibly in parallel, and which may define multiple phases.\n *\n * @remarks\n * Phased commands can be defined via common/config/command-line.json.  Rush's predefined \"build\"\n * and \"rebuild\" commands are also modeled as phased commands with a single phase that invokes the npm\n * \"build\" script for each project.\n */\nexport class PhasedScriptAction extends BaseScriptAction {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._enableParallelism = options.enableParallelism;\n        this._isIncrementalBuildAllowed = options.incremental;\n        this._disableBuildCache = options.disableBuildCache;\n        this._originalPhases = options.originalPhases;\n        this._initialPhases = options.initialPhases;\n        this._watchPhases = options.watchPhases;\n        this._watchDebounceMs = (_a = options.watchDebounceMs) !== null && _a !== void 0 ? _a : RushConstants.defaultWatchDebounceMs;\n        this._alwaysWatch = options.alwaysWatch;\n        this._alwaysInstall = options.alwaysInstall;\n        this._runsBeforeInstall = false;\n        this._knownPhases = options.phases;\n        this.hooks = new PhasedCommandHooks();\n        const terminal = new Terminal(this.rushSession.terminalProvider);\n        this._terminal = terminal;\n        // Generates the default operation graph\n        new PhasedOperationPlugin().apply(this.hooks);\n        // Splices in sharded phases to the operation graph.\n        new ShardedPhasedOperationPlugin().apply(this.hooks);\n        // Applies the Shell Operation Runner to selected operations\n        new ShellOperationRunnerPlugin().apply(this.hooks);\n        new WeightedOperationPlugin().apply(this.hooks);\n        new ValidateOperationsPlugin(terminal).apply(this.hooks);\n        if (this._enableParallelism) {\n            this._parallelismParameter = this.defineStringParameter({\n                parameterLongName: '--parallelism',\n                parameterShortName: '-p',\n                argumentName: 'COUNT',\n                environmentVariable: EnvironmentVariableNames.RUSH_PARALLELISM,\n                description: 'Specifies the maximum number of concurrent processes to launch during a build.' +\n                    ' The COUNT should be a positive integer, a percentage value (eg. \"50%%\") or the word \"max\"' +\n                    ' to specify a count that is equal to the number of CPU cores. If this parameter is omitted,' +\n                    ' then the default value depends on the operating system and number of CPU cores.'\n            });\n        }\n        this._timelineParameter = this.defineFlagParameter({\n            parameterLongName: '--timeline',\n            description: 'After the build is complete, print additional statistics and CPU usage information,' +\n                ' including an ASCII chart of the start and stop times for each operation.'\n        });\n        this._cobuildPlanParameter = this.defineFlagParameter({\n            parameterLongName: '--log-cobuild-plan',\n            description: '(EXPERIMENTAL) Before the build starts, log information about the cobuild state. This will include information about ' +\n                'clusters and the projects that are part of each cluster.'\n        });\n        this._selectionParameters = new SelectionParameterSet(this.rushConfiguration, this, {\n            gitOptions: {\n                // Include lockfile processing since this expands the selection, and we need to select\n                // at least the same projects selected with the same query to \"rush build\"\n                includeExternalDependencies: true,\n                // Enable filtering to reduce evaluation cost\n                enableFiltering: true\n            },\n            includeSubspaceSelector: false\n        });\n        this._verboseParameter = this.defineFlagParameter({\n            parameterLongName: '--verbose',\n            parameterShortName: '-v',\n            description: 'Display the logs during the build, rather than just displaying the build status summary'\n        });\n        this._includePhaseDeps = this.defineFlagParameter({\n            parameterLongName: '--include-phase-deps',\n            description: 'If the selected projects are \"unsafe\" (missing some dependencies), add the minimal set of phase dependencies. For example, ' +\n                `\"--from A\" normally might include the \"_phase:test\" phase for A's dependencies, even though changes to A can't break those tests. ` +\n                `Using \"--impacted-by A --include-phase-deps\" avoids that work by performing \"_phase:test\" only for downstream projects.`\n        });\n        if (this._isIncrementalBuildAllowed) {\n            this._changedProjectsOnly = this.defineFlagParameter({\n                parameterLongName: '--changed-projects-only',\n                parameterShortName: '-c',\n                description: 'Normally the incremental build logic will rebuild changed projects as well as' +\n                    ' any projects that directly or indirectly depend on a changed project. Specify \"--changed-projects-only\"' +\n                    ' to ignore dependent projects, only rebuilding those projects whose files were changed.' +\n                    ' Note that this parameter is \"unsafe\"; it is up to the developer to ensure that the ignored projects' +\n                    ' are okay to ignore.'\n            });\n        }\n        this._ignoreHooksParameter = this.defineFlagParameter({\n            parameterLongName: '--ignore-hooks',\n            description: `Skips execution of the \"eventHooks\" scripts defined in ${RushConstants.rushJsonFilename}. ` +\n                'Make sure you know what you are skipping.'\n        });\n        if (this._watchPhases.size > 0 && !this._alwaysWatch) {\n            // Only define the parameter if it has an effect.\n            this._watchParameter = this.defineFlagParameter({\n                parameterLongName: '--watch',\n                description: `Starts a file watcher after initial execution finishes. Will run the following phases on affected projects: ${Array.from(this._watchPhases, (phase) => phase.name).join(', ')}`\n            });\n        }\n        // If `this._alwaysInstall === undefined`, Rush does not define the parameter\n        // but a repository may still define a custom parameter with the same name.\n        if (this._alwaysInstall === false) {\n            this._installParameter = this.defineFlagParameter({\n                parameterLongName: '--install',\n                description: 'Normally a phased command expects \"rush install\" to have been manually run first. If this flag is specified, ' +\n                    'Rush will automatically perform an install before processing the current command.'\n            });\n        }\n        if (this._alwaysInstall !== undefined) {\n            this._variantParameter = this.defineStringParameter(VARIANT_PARAMETER);\n        }\n        if (this._watchPhases.size > 0 &&\n            this.rushConfiguration.experimentsConfiguration.configuration.useIPCScriptsInWatchMode) {\n            this._noIPCParameter = this.defineFlagParameter({\n                parameterLongName: '--no-ipc',\n                description: 'Disables the IPC feature for the current command (if applicable to selected operations). Operations will not look for a \":ipc\" suffixed script.' +\n                    'This feature only applies in watch mode and is enabled by default.'\n            });\n        }\n        this._nodeDiagnosticDirParameter = this.defineStringParameter({\n            parameterLongName: '--node-diagnostic-dir',\n            argumentName: 'DIRECTORY',\n            description: 'Specifies the directory where Node.js diagnostic reports will be written. ' +\n                'This directory will contain a subdirectory for each project and phase.'\n        });\n        this.defineScriptParameters();\n        for (const [{ associatedPhases }, tsCommandLineParameter] of this.customParameters) {\n            if (associatedPhases) {\n                for (const phaseName of associatedPhases) {\n                    const phase = this._knownPhases.get(phaseName);\n                    if (!phase) {\n                        throw new InternalError(`Could not find a phase matching ${phaseName}.`);\n                    }\n                    phase.associatedParameters.add(tsCommandLineParameter);\n                }\n            }\n        }\n    }\n    async runAsync() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        if (this._alwaysInstall || ((_a = this._installParameter) === null || _a === void 0 ? void 0 : _a.value)) {\n            const { doBasicInstallAsync } = await import(\n            /* webpackChunkName: 'doBasicInstallAsync' */\n            '../../logic/installManager/doBasicInstallAsync');\n            const variant = await getVariantAsync(this._variantParameter, this.rushConfiguration, true);\n            await doBasicInstallAsync({\n                terminal: this._terminal,\n                rushConfiguration: this.rushConfiguration,\n                rushGlobalFolder: this.rushGlobalFolder,\n                isDebug: this.parser.isDebug,\n                variant,\n                beforeInstallAsync: (subspace) => this.rushSession.hooks.beforeInstall.promise(this, subspace, variant),\n                afterInstallAsync: (subspace) => this.rushSession.hooks.afterInstall.promise(this, subspace, variant),\n                // Eventually we may want to allow a subspace to be selected here\n                subspace: this.rushConfiguration.defaultSubspace\n            });\n        }\n        if (!this._runsBeforeInstall) {\n            // TODO: Replace with last-install.flag when \"rush link\" and \"rush unlink\" are removed\n            const lastLinkFlag = new FlagFile(this.rushConfiguration.defaultSubspace.getSubspaceTempFolderPath(), RushConstants.lastLinkFlagFilename, {});\n            // Only check for a valid link flag when subspaces is not enabled\n            if (!(await lastLinkFlag.isValidAsync()) && !this.rushConfiguration.subspacesFeatureEnabled) {\n                const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;\n                if (useWorkspaces) {\n                    throw new Error('Link flag invalid.\\nDid you run \"rush install\" or \"rush update\"?');\n                }\n                else {\n                    throw new Error('Link flag invalid.\\nDid you run \"rush link\"?');\n                }\n            }\n        }\n        this._doBeforeTask();\n        // if this is parallelizable, then use the value from the flag (undefined or a number),\n        // if parallelism is not enabled, then restrict to 1 core\n        const parallelism = this._enableParallelism\n            ? parseParallelism((_b = this._parallelismParameter) === null || _b === void 0 ? void 0 : _b.value)\n            : 1;\n        const terminal = this._terminal;\n        const stopwatch = Stopwatch.start();\n        const showTimeline = this._timelineParameter ? this._timelineParameter.value : false;\n        if (showTimeline) {\n            const { ConsoleTimelinePlugin } = await import(\n            /* webpackChunkName: 'ConsoleTimelinePlugin' */\n            '../../logic/operations/ConsoleTimelinePlugin');\n            new ConsoleTimelinePlugin(terminal).apply(this.hooks);\n        }\n        const includePhaseDeps = (_d = (_c = this._includePhaseDeps) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : false;\n        const diagnosticDir = this._nodeDiagnosticDirParameter.value;\n        if (diagnosticDir) {\n            new NodeDiagnosticDirPlugin({\n                diagnosticDir\n            }).apply(this.hooks);\n        }\n        // Enable the standard summary\n        new OperationResultSummarizerPlugin(terminal).apply(this.hooks);\n        const { hooks: sessionHooks } = this.rushSession;\n        if (sessionHooks.runAnyPhasedCommand.isUsed()) {\n            // Avoid the cost of compiling the hook if it wasn't tapped.\n            await sessionHooks.runAnyPhasedCommand.promise(this);\n        }\n        const hookForAction = sessionHooks.runPhasedCommand.get(this.actionName);\n        if (hookForAction) {\n            // Run the more specific hook for a command with this name after the general hook\n            await hookForAction.promise(this);\n        }\n        const isQuietMode = !this._verboseParameter.value;\n        const changedProjectsOnly = !!((_e = this._changedProjectsOnly) === null || _e === void 0 ? void 0 : _e.value);\n        let buildCacheConfiguration;\n        let cobuildConfiguration;\n        if (!this._disableBuildCache) {\n            buildCacheConfiguration = await BuildCacheConfiguration.tryLoadAsync(terminal, this.rushConfiguration, this.rushSession);\n            cobuildConfiguration = await CobuildConfiguration.tryLoadAsync(terminal, this.rushConfiguration, this.rushSession);\n            await (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.createLockProviderAsync(terminal));\n        }\n        try {\n            const projectSelection = await this._selectionParameters.getSelectedProjectsAsync(terminal);\n            if (!projectSelection.size) {\n                terminal.writeLine(Colorize.yellow(`The command line selection parameters did not match any projects.`));\n                return;\n            }\n            const isWatch = ((_f = this._watchParameter) === null || _f === void 0 ? void 0 : _f.value) || this._alwaysWatch;\n            if (isWatch && ((_g = this._noIPCParameter) === null || _g === void 0 ? void 0 : _g.value) === false) {\n                new (await import(\n                /* webpackChunkName: 'IPCOperationRunnerPlugin' */ '../../logic/operations/IPCOperationRunnerPlugin')).IPCOperationRunnerPlugin().apply(this.hooks);\n            }\n            const customParametersByName = new Map();\n            for (const [configParameter, parserParameter] of this.customParameters) {\n                customParametersByName.set(configParameter.longName, parserParameter);\n            }\n            if (buildCacheConfiguration === null || buildCacheConfiguration === void 0 ? void 0 : buildCacheConfiguration.buildCacheEnabled) {\n                terminal.writeVerboseLine(`Incremental strategy: cache restoration`);\n                new CacheableOperationPlugin({\n                    allowWarningsInSuccessfulBuild: !!this.rushConfiguration.experimentsConfiguration.configuration\n                        .buildCacheWithAllowWarningsInSuccessfulBuild,\n                    buildCacheConfiguration,\n                    cobuildConfiguration,\n                    terminal\n                }).apply(this.hooks);\n            }\n            else if (!this._disableBuildCache) {\n                terminal.writeVerboseLine(`Incremental strategy: output preservation`);\n                // Explicitly disabling the build cache also disables legacy skip detection.\n                new LegacySkipPlugin({\n                    allowWarningsInSuccessfulBuild: this.rushConfiguration.experimentsConfiguration.configuration\n                        .buildSkipWithAllowWarningsInSuccessfulBuild,\n                    terminal,\n                    changedProjectsOnly,\n                    isIncrementalBuildAllowed: this._isIncrementalBuildAllowed\n                }).apply(this.hooks);\n            }\n            else {\n                terminal.writeVerboseLine(`Incremental strategy: none (full rebuild)`);\n            }\n            const showBuildPlan = (_j = (_h = this._cobuildPlanParameter) === null || _h === void 0 ? void 0 : _h.value) !== null && _j !== void 0 ? _j : false;\n            if (showBuildPlan) {\n                if (!(buildCacheConfiguration === null || buildCacheConfiguration === void 0 ? void 0 : buildCacheConfiguration.buildCacheEnabled)) {\n                    throw new Error('You must have build cache enabled to use this option.');\n                }\n                const { BuildPlanPlugin } = await import('../../logic/operations/BuildPlanPlugin');\n                new BuildPlanPlugin(terminal).apply(this.hooks);\n            }\n            const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;\n            if (((_k = this.rushConfiguration) === null || _k === void 0 ? void 0 : _k.isPnpm) && (experiments === null || experiments === void 0 ? void 0 : experiments.usePnpmSyncForInjectedDependencies)) {\n                const { PnpmSyncCopyOperationPlugin } = await import('../../logic/operations/PnpmSyncCopyOperationPlugin');\n                new PnpmSyncCopyOperationPlugin(terminal).apply(this.hooks);\n            }\n            const relevantProjects = Selection.expandAllDependencies(projectSelection);\n            const projectConfigurations = this\n                ._runsBeforeInstall\n                ? new Map()\n                : await RushProjectConfiguration.tryLoadForProjectsAsync(relevantProjects, terminal);\n            const initialCreateOperationsContext = {\n                buildCacheConfiguration,\n                cobuildConfiguration,\n                customParameters: customParametersByName,\n                isIncrementalBuildAllowed: this._isIncrementalBuildAllowed,\n                isInitial: true,\n                isWatch,\n                rushConfiguration: this.rushConfiguration,\n                phaseOriginal: new Set(this._originalPhases),\n                phaseSelection: new Set(this._initialPhases),\n                includePhaseDeps,\n                projectSelection,\n                projectConfigurations,\n                projectsInUnknownState: projectSelection\n            };\n            const executionManagerOptions = {\n                quietMode: isQuietMode,\n                debugMode: this.parser.isDebug,\n                parallelism,\n                changedProjectsOnly,\n                beforeExecuteOperationAsync: async (record) => {\n                    return await this.hooks.beforeExecuteOperation.promise(record);\n                },\n                afterExecuteOperationAsync: async (record) => {\n                    await this.hooks.afterExecuteOperation.promise(record);\n                },\n                createEnvironmentForOperation: this.hooks.createEnvironmentForOperation.isUsed()\n                    ? (record) => {\n                        return this.hooks.createEnvironmentForOperation.call(Object.assign({}, process.env), record);\n                    }\n                    : undefined,\n                onOperationStatusChangedAsync: (record) => {\n                    this.hooks.onOperationStatusChanged.call(record);\n                }\n            };\n            const initialInternalOptions = {\n                initialCreateOperationsContext,\n                executionManagerOptions,\n                stopwatch,\n                terminal\n            };\n            const internalOptions = await this._runInitialPhasesAsync(initialInternalOptions);\n            if (isWatch) {\n                if (buildCacheConfiguration) {\n                    // Cache writes are not supported during watch mode, only reads.\n                    buildCacheConfiguration.cacheWriteEnabled = false;\n                }\n                await this._runWatchPhasesAsync(internalOptions);\n            }\n        }\n        finally {\n            await (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.destroyLockProviderAsync());\n        }\n    }\n    async _runInitialPhasesAsync(options) {\n        const { initialCreateOperationsContext, executionManagerOptions: partialExecutionManagerOptions, stopwatch, terminal } = options;\n        const { projectConfigurations } = initialCreateOperationsContext;\n        const { projectSelection } = initialCreateOperationsContext;\n        const operations = await this.hooks.createOperations.promise(new Set(), initialCreateOperationsContext);\n        terminal.write('Analyzing repo state... ');\n        const repoStateStopwatch = new Stopwatch();\n        repoStateStopwatch.start();\n        const analyzer = new ProjectChangeAnalyzer(this.rushConfiguration);\n        const getInputsSnapshotAsync = await analyzer._tryGetSnapshotProviderAsync(projectConfigurations, terminal, \n        // We need to include all dependencies, otherwise build cache id calculation will be incorrect\n        Selection.expandAllDependencies(projectSelection));\n        const initialSnapshot = await (getInputsSnapshotAsync === null || getInputsSnapshotAsync === void 0 ? void 0 : getInputsSnapshotAsync());\n        repoStateStopwatch.stop();\n        terminal.writeLine(`DONE (${repoStateStopwatch.toString()})`);\n        terminal.writeLine();\n        const initialExecuteOperationsContext = Object.assign(Object.assign({}, initialCreateOperationsContext), { inputsSnapshot: initialSnapshot });\n        const executionManagerOptions = Object.assign(Object.assign({}, partialExecutionManagerOptions), { beforeExecuteOperationsAsync: async (records) => {\n                await this.hooks.beforeExecuteOperations.promise(records, initialExecuteOperationsContext);\n            } });\n        const initialOptions = {\n            executeOperationsContext: initialExecuteOperationsContext,\n            ignoreHooks: false,\n            operations,\n            stopwatch,\n            executionManagerOptions,\n            terminal\n        };\n        await this._executeOperationsAsync(initialOptions);\n        return Object.assign(Object.assign({}, options), { executionManagerOptions,\n            getInputsSnapshotAsync,\n            initialSnapshot });\n    }\n    _registerWatchModeInterface(projectWatcher) {\n        const toggleWatcherKey = 'w';\n        const buildOnceKey = 'b';\n        const invalidateKey = 'i';\n        const shutdownKey = 'x';\n        const terminal = this._terminal;\n        projectWatcher.setPromptGenerator((isPaused) => {\n            var _a;\n            const promptLines = [\n                `  Press <${toggleWatcherKey}> to ${isPaused ? 'resume' : 'pause'}.`,\n                `  Press <${invalidateKey}> to invalidate all projects.`\n            ];\n            if (isPaused) {\n                promptLines.push(`  Press <${buildOnceKey}> to build once.`);\n            }\n            if (((_a = this._noIPCParameter) === null || _a === void 0 ? void 0 : _a.value) === false) {\n                promptLines.push(`  Press <${shutdownKey}> to reset child processes.`);\n            }\n            return promptLines;\n        });\n        process.stdin.setRawMode(true);\n        process.stdin.resume();\n        process.stdin.setEncoding('utf8');\n        process.stdin.on('data', (key) => {\n            switch (key) {\n                case toggleWatcherKey:\n                    if (projectWatcher.isPaused) {\n                        projectWatcher.resume();\n                    }\n                    else {\n                        projectWatcher.pause();\n                    }\n                    break;\n                case buildOnceKey:\n                    if (projectWatcher.isPaused) {\n                        projectWatcher.clearStatus();\n                        terminal.writeLine(`Building once...`);\n                        projectWatcher.resume();\n                        projectWatcher.pause();\n                    }\n                    break;\n                case invalidateKey:\n                    projectWatcher.clearStatus();\n                    terminal.writeLine(`Invalidating all operations...`);\n                    projectWatcher.invalidateAll('manual trigger');\n                    if (!projectWatcher.isPaused) {\n                        projectWatcher.resume();\n                    }\n                    break;\n                case shutdownKey:\n                    projectWatcher.clearStatus();\n                    terminal.writeLine(`Shutting down long-lived child processes...`);\n                    // TODO: Inject this promise into the execution queue somewhere so that it gets waited on between runs\n                    void this.hooks.shutdownAsync.promise();\n                    break;\n                case '\\u0003':\n                    process.kill(process.pid, 'SIGINT');\n                    break;\n            }\n        });\n    }\n    /**\n     * Runs the command in watch mode. Fundamentally is a simple loop:\n     * 1) Wait for a change to one or more projects in the selection\n     * 2) Invoke the command on the changed projects, and, if applicable, impacted projects\n     *    Uses the same algorithm as --impacted-by\n     * 3) Goto (1)\n     */\n    async _runWatchPhasesAsync(options) {\n        const { getInputsSnapshotAsync, initialSnapshot, initialCreateOperationsContext, executionManagerOptions, stopwatch, terminal } = options;\n        const phaseOriginal = new Set(this._watchPhases);\n        const phaseSelection = new Set(this._watchPhases);\n        const { projectSelection: projectsToWatch } = initialCreateOperationsContext;\n        if (!getInputsSnapshotAsync || !initialSnapshot) {\n            terminal.writeErrorLine(`Cannot watch for changes if the Rush repo is not in a Git repository, exiting.`);\n            throw new AlreadyReportedError();\n        }\n        // Use async import so that we don't pay the cost for sync builds\n        const { ProjectWatcher } = await import(\n        /* webpackChunkName: 'ProjectWatcher' */\n        '../../logic/ProjectWatcher');\n        const projectWatcher = new ProjectWatcher({\n            getInputsSnapshotAsync,\n            initialSnapshot,\n            debounceMs: this._watchDebounceMs,\n            rushConfiguration: this.rushConfiguration,\n            projectsToWatch,\n            terminal\n        });\n        // Ensure process.stdin allows interactivity before using TTY-only APIs\n        if (process.stdin.isTTY) {\n            this._registerWatchModeInterface(projectWatcher);\n        }\n        const onWaitingForChanges = () => {\n            // Allow plugins to display their own messages when waiting for changes.\n            this.hooks.waitingForChanges.call();\n            // Report so that the developer can always see that it is in watch mode as the latest console line.\n            terminal.writeLine(`Watching for changes to ${projectsToWatch.size} ${projectsToWatch.size === 1 ? 'project' : 'projects'}. Press Ctrl+C to exit.`);\n        };\n        function invalidateOperation(operation, reason) {\n            const { associatedProject } = operation;\n            if (associatedProject) {\n                // Since ProjectWatcher only tracks entire projects, widen the operation to its project\n                // Revisit when migrating to @rushstack/operation-graph and we have a long-lived operation graph\n                projectWatcher.invalidateProject(associatedProject, `${operation.name} (${reason})`);\n            }\n        }\n        // Loop until Ctrl+C\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // On the initial invocation, this promise will return immediately with the full set of projects\n            const { changedProjects, inputsSnapshot: state } = await projectWatcher.waitForChangeAsync(onWaitingForChanges);\n            if (stopwatch.state === StopwatchState.Stopped) {\n                // Clear and reset the stopwatch so that we only report time from a single execution at a time\n                stopwatch.reset();\n                stopwatch.start();\n            }\n            terminal.writeLine(`Detected changes in ${changedProjects.size} project${changedProjects.size === 1 ? '' : 's'}:`);\n            const names = [...changedProjects].map((x) => x.packageName).sort();\n            for (const name of names) {\n                terminal.writeLine(`    ${Colorize.cyan(name)}`);\n            }\n            // Account for consumer relationships\n            const executeOperationsContext = Object.assign(Object.assign({}, initialCreateOperationsContext), { isInitial: false, inputsSnapshot: state, projectsInUnknownState: changedProjects, phaseOriginal,\n                phaseSelection,\n                invalidateOperation });\n            const operations = await this.hooks.createOperations.promise(new Set(), executeOperationsContext);\n            const executeOptions = {\n                executeOperationsContext,\n                // For now, don't run pre-build or post-build in watch mode\n                ignoreHooks: true,\n                operations,\n                stopwatch,\n                executionManagerOptions: Object.assign(Object.assign({}, executionManagerOptions), { beforeExecuteOperationsAsync: async (records) => {\n                        await this.hooks.beforeExecuteOperations.promise(records, executeOperationsContext);\n                    } }),\n                terminal\n            };\n            try {\n                // Delegate the the underlying command, for only the projects that need reprocessing\n                await this._executeOperationsAsync(executeOptions);\n            }\n            catch (err) {\n                // In watch mode, we want to rebuild even if the original build failed.\n                if (!(err instanceof AlreadyReportedError)) {\n                    throw err;\n                }\n            }\n        }\n    }\n    /**\n     * Runs a set of operations and reports the results.\n     */\n    async _executeOperationsAsync(options) {\n        const { executionManagerOptions, ignoreHooks, operations, stopwatch, terminal } = options;\n        const executionManager = new OperationExecutionManager(operations, executionManagerOptions);\n        const { isInitial, isWatch, cobuildConfiguration } = options.executeOperationsContext;\n        let success = false;\n        let result;\n        try {\n            result = await executionManager.executeAsync();\n            success = result.status === OperationStatus.Success;\n            await this.hooks.afterExecuteOperations.promise(result, options.executeOperationsContext);\n            stopwatch.stop();\n            const message = `rush ${this.actionName} (${stopwatch.toString()})`;\n            if (result.status === OperationStatus.Success) {\n                terminal.writeLine(Colorize.green(message));\n            }\n            else {\n                terminal.writeLine(message);\n            }\n        }\n        catch (error) {\n            success = false;\n            stopwatch.stop();\n            if (error instanceof AlreadyReportedError) {\n                terminal.writeLine(`rush ${this.actionName} (${stopwatch.toString()})`);\n            }\n            else {\n                if (error && error.message) {\n                    if (this.parser.isDebug) {\n                        terminal.writeErrorLine('Error: ' + error.stack);\n                    }\n                    else {\n                        terminal.writeErrorLine('Error: ' + error.message);\n                    }\n                }\n                terminal.writeErrorLine(Colorize.red(`rush ${this.actionName} - Errors! (${stopwatch.toString()})`));\n            }\n        }\n        if (!ignoreHooks) {\n            this._doAfterTask();\n        }\n        if (this.parser.telemetry) {\n            const jsonOperationResults = {};\n            const extraData = Object.assign(Object.assign(Object.assign({}, this._selectionParameters.getTelemetry()), this.getParameterStringMap()), { isWatch,\n                // Fields specific to the current operation set\n                isInitial, countAll: 0, countSuccess: 0, countSuccessWithWarnings: 0, countFailure: 0, countBlocked: 0, countFromCache: 0, countSkipped: 0, countNoOp: 0 });\n            if (result) {\n                const { operationResults } = result;\n                const nonSilentDependenciesByOperation = new Map();\n                function getNonSilentDependencies(operation) {\n                    let realDependencies = nonSilentDependenciesByOperation.get(operation);\n                    if (!realDependencies) {\n                        realDependencies = new Set();\n                        nonSilentDependenciesByOperation.set(operation, realDependencies);\n                        for (const dependency of operation.dependencies) {\n                            const dependencyRecord = operationResults.get(dependency);\n                            if (dependencyRecord === null || dependencyRecord === void 0 ? void 0 : dependencyRecord.silent) {\n                                for (const deepDependency of getNonSilentDependencies(dependency)) {\n                                    realDependencies.add(deepDependency);\n                                }\n                            }\n                            else {\n                                realDependencies.add(dependency.name);\n                            }\n                        }\n                    }\n                    return realDependencies;\n                }\n                for (const [operation, operationResult] of operationResults) {\n                    if (operationResult.silent) {\n                        // Architectural operation. Ignore.\n                        continue;\n                    }\n                    const { startTime, endTime } = operationResult.stopwatch;\n                    jsonOperationResults[operation.name] = {\n                        startTimestampMs: startTime,\n                        endTimestampMs: endTime,\n                        nonCachedDurationMs: operationResult.nonCachedDurationMs,\n                        wasExecutedOnThisMachine: !operationResult.cobuildRunnerId ||\n                            operationResult.cobuildRunnerId === (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildRunnerId),\n                        result: operationResult.status,\n                        dependencies: Array.from(getNonSilentDependencies(operation)).sort()\n                    };\n                    extraData.countAll++;\n                    switch (operationResult.status) {\n                        case OperationStatus.Success:\n                            extraData.countSuccess++;\n                            break;\n                        case OperationStatus.SuccessWithWarning:\n                            extraData.countSuccessWithWarnings++;\n                            break;\n                        case OperationStatus.Failure:\n                            extraData.countFailure++;\n                            break;\n                        case OperationStatus.Blocked:\n                            extraData.countBlocked++;\n                            break;\n                        case OperationStatus.FromCache:\n                            extraData.countFromCache++;\n                            break;\n                        case OperationStatus.Skipped:\n                            extraData.countSkipped++;\n                            break;\n                        case OperationStatus.NoOp:\n                            extraData.countNoOp++;\n                            break;\n                        default:\n                            // Do nothing.\n                            break;\n                    }\n                }\n            }\n            const logEntry = {\n                name: this.actionName,\n                durationInSeconds: stopwatch.duration,\n                result: success ? 'Succeeded' : 'Failed',\n                extraData,\n                operationResults: jsonOperationResults\n            };\n            this.hooks.beforeLog.call(logEntry);\n            this.parser.telemetry.log(logEntry);\n            this.parser.flushTelemetry();\n        }\n        if (!success && !isWatch) {\n            throw new AlreadyReportedError();\n        }\n    }\n    _doBeforeTask() {\n        if (this.actionName !== RushConstants.buildCommandName &&\n            this.actionName !== RushConstants.rebuildCommandName) {\n            // Only collects information for built-in commands like build or rebuild.\n            return;\n        }\n        SetupChecks.validate(this.rushConfiguration);\n        this.eventHooksManager.handle(Event.preRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);\n    }\n    _doAfterTask() {\n        if (this.actionName !== RushConstants.buildCommandName &&\n            this.actionName !== RushConstants.rebuildCommandName) {\n            // Only collects information for built-in commands like build or rebuild.\n            return;\n        }\n        this.eventHooksManager.handle(Event.postRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);\n    }\n}\n//# sourceMappingURL=PhasedScriptAction.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * A library for writing scripts that interact with the {@link https://rushjs.io/ | Rush} tool.\n * @packageDocumentation\n */\n// For backwards compatibility\nexport { LookupByPath as LookupByPath } from '@rushstack/lookup-by-path';\nexport { ApprovedPackagesPolicy } from './api/ApprovedPackagesPolicy';\nexport { RushConfiguration } from './api/RushConfiguration';\nexport { Subspace } from './api/Subspace';\nexport { SubspacesConfiguration } from './api/SubspacesConfiguration';\nexport { PackageManagerOptionsConfigurationBase } from './logic/base/BasePackageManagerOptionsConfiguration';\nexport { NpmOptionsConfiguration } from './logic/npm/NpmOptionsConfiguration';\nexport { YarnOptionsConfiguration } from './logic/yarn/YarnOptionsConfiguration';\nexport { PnpmOptionsConfiguration } from './logic/pnpm/PnpmOptionsConfiguration';\nexport { BuildCacheConfiguration } from './api/BuildCacheConfiguration';\nexport { CobuildConfiguration } from './api/CobuildConfiguration';\nexport { FileSystemBuildCacheProvider } from './logic/buildCache/FileSystemBuildCacheProvider';\nexport { EnvironmentConfiguration, EnvironmentVariableNames } from './api/EnvironmentConfiguration';\nexport { RushConstants } from './logic/RushConstants';\nexport { PackageManager } from './api/packageManager/PackageManager';\nexport { RushConfigurationProject } from './api/RushConfigurationProject';\nexport { RushProjectConfiguration } from './api/RushProjectConfiguration';\nexport { RushUserConfiguration } from './api/RushUserConfiguration';\nexport { RushGlobalFolder as _RushGlobalFolder } from './api/RushGlobalFolder';\nexport { ApprovedPackagesItem, ApprovedPackagesConfiguration } from './api/ApprovedPackagesConfiguration';\nexport { CommonVersionsConfiguration } from './api/CommonVersionsConfiguration';\nexport { PackageJsonEditor, PackageJsonDependency, DependencyType, PackageJsonDependencyMeta } from './api/PackageJsonEditor';\nexport { RepoStateFile } from './logic/RepoStateFile';\nexport { EventHooks, Event } from './api/EventHooks';\nexport { ChangeManager } from './api/ChangeManager';\nexport { FlagFile as _FlagFile } from './api/FlagFile';\nexport { VersionPolicyDefinitionName, BumpType, LockStepVersionPolicy, IndividualVersionPolicy, VersionPolicy } from './api/VersionPolicy';\nexport { VersionPolicyConfiguration } from './api/VersionPolicyConfiguration';\nexport { Rush } from './api/Rush';\nexport { RushInternals as _RushInternals } from './api/RushInternals';\nexport { ExperimentsConfiguration } from './api/ExperimentsConfiguration';\nexport { CustomTipsConfiguration, CustomTipId, CustomTipSeverity, CustomTipType } from './api/CustomTipsConfiguration';\nexport { ProjectChangeAnalyzer } from './logic/ProjectChangeAnalyzer';\nexport { Operation } from './logic/operations/Operation';\nexport { OperationStatus } from './logic/operations/OperationStatus';\nexport { RushSession } from './pluginFramework/RushSession';\nexport { RushLifecycleHooks } from './pluginFramework/RushLifeCycle';\nexport { PhasedCommandHooks } from './pluginFramework/PhasedCommandHooks';\nexport { CredentialCache } from './logic/CredentialCache';\nexport { OperationStateFile as _OperationStateFile } from './logic/operations/OperationStateFile';\nexport { OperationMetadataManager as _OperationMetadataManager } from './logic/operations/OperationMetadataManager';\nexport { RushCommandLine } from './api/RushCommandLine';\n//# sourceMappingURL=index.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, JsonFile, LockFile, NewlineKind, PackageName } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { Utilities } from '../utilities/Utilities';\nimport { PackageJsonEditor } from '../api/PackageJsonEditor';\nimport { InstallHelpers } from './installManager/InstallHelpers';\nimport { RushConstants } from './RushConstants';\nimport { LastInstallFlag } from '../api/LastInstallFlag';\nimport { RushCommandLineParser } from '../cli/RushCommandLineParser';\nexport class Autoinstaller {\n    constructor(options) {\n        var _a;\n        this.name = options.autoinstallerName;\n        this._rushConfiguration = options.rushConfiguration;\n        this._rushGlobalFolder = options.rushGlobalFolder;\n        this._restrictConsoleOutput =\n            (_a = options.restrictConsoleOutput) !== null && _a !== void 0 ? _a : RushCommandLineParser.shouldRestrictConsoleOutput();\n        Autoinstaller.validateName(this.name);\n    }\n    // Example: .../common/autoinstallers/my-task\n    get folderFullPath() {\n        return path.join(this._rushConfiguration.commonAutoinstallersFolder, this.name);\n    }\n    // Example: .../common/autoinstallers/my-task/package-lock.yaml\n    get shrinkwrapFilePath() {\n        return path.join(this._rushConfiguration.commonAutoinstallersFolder, this.name, this._rushConfiguration.shrinkwrapFilename);\n    }\n    // Example: .../common/autoinstallers/my-task/package.json\n    get packageJsonPath() {\n        return path.join(this._rushConfiguration.commonAutoinstallersFolder, this.name, 'package.json');\n    }\n    static validateName(autoinstallerName) {\n        const nameOrError = PackageName.tryParse(autoinstallerName);\n        if (nameOrError.error) {\n            throw new Error(`The specified name \"${autoinstallerName}\" is invalid: ` + nameOrError.error);\n        }\n        if (nameOrError.scope) {\n            throw new Error(`The specified name \"${autoinstallerName}\" must not contain an NPM scope`);\n        }\n    }\n    async prepareAsync() {\n        const autoinstallerFullPath = this.folderFullPath;\n        if (!FileSystem.exists(autoinstallerFullPath)) {\n            throw new Error(`The autoinstaller ${this.name} does not exist, Please run\\nrush init-autoinstaller --name ${this.name}\\n`);\n        }\n        await InstallHelpers.ensureLocalPackageManagerAsync(this._rushConfiguration, this._rushGlobalFolder, RushConstants.defaultMaxInstallAttempts, this._restrictConsoleOutput);\n        // Example: common/autoinstallers/my-task/package.json\n        const relativePathForLogs = path.relative(this._rushConfiguration.rushJsonFolder, autoinstallerFullPath);\n        this._logIfConsoleOutputIsNotRestricted(`Acquiring lock for \"${relativePathForLogs}\" folder...`);\n        const lock = await LockFile.acquireAsync(autoinstallerFullPath, 'autoinstaller');\n        try {\n            // Example: .../common/autoinstallers/my-task/.rush/temp\n            const lastInstallFlagPath = path.join(autoinstallerFullPath, RushConstants.projectRushFolderName, 'temp');\n            const packageJsonPath = path.join(autoinstallerFullPath, 'package.json');\n            const packageJson = JsonFile.load(packageJsonPath);\n            const lastInstallFlag = new LastInstallFlag(lastInstallFlagPath, {\n                node: process.versions.node,\n                packageManager: this._rushConfiguration.packageManager,\n                packageManagerVersion: this._rushConfiguration.packageManagerToolVersion,\n                packageJson: packageJson,\n                rushJsonFolder: this._rushConfiguration.rushJsonFolder\n            });\n            // Example: ../common/autoinstallers/my-task/node_modules\n            const nodeModulesFolder = `${autoinstallerFullPath}/${RushConstants.nodeModulesFolderName}`;\n            const flagPath = `${nodeModulesFolder}/rush-autoinstaller.flag`;\n            const isLastInstallFlagDirty = !(await lastInstallFlag.isValidAsync()) || !FileSystem.exists(flagPath);\n            if (isLastInstallFlagDirty || lock.dirtyWhenAcquired) {\n                if (FileSystem.exists(nodeModulesFolder)) {\n                    this._logIfConsoleOutputIsNotRestricted('Deleting old files from ' + nodeModulesFolder);\n                    FileSystem.ensureEmptyFolder(nodeModulesFolder);\n                }\n                // Copy: .../common/autoinstallers/my-task/.npmrc\n                Utilities.syncNpmrc({\n                    sourceNpmrcFolder: this._rushConfiguration.commonRushConfigFolder,\n                    targetNpmrcFolder: autoinstallerFullPath,\n                    supportEnvVarFallbackSyntax: this._rushConfiguration.isPnpm\n                });\n                this._logIfConsoleOutputIsNotRestricted(`Installing dependencies under ${autoinstallerFullPath}...\\n`);\n                await Utilities.executeCommandAsync({\n                    command: this._rushConfiguration.packageManagerToolFilename,\n                    args: ['install', '--frozen-lockfile'],\n                    workingDirectory: autoinstallerFullPath,\n                    keepEnvironment: true\n                });\n                // Create file: ../common/autoinstallers/my-task/.rush/temp/last-install.flag\n                await lastInstallFlag.createAsync();\n                FileSystem.writeFile(flagPath, 'If this file is deleted, Rush will assume that the node_modules folder has been cleaned and will reinstall it.');\n                this._logIfConsoleOutputIsNotRestricted('Auto install completed successfully\\n');\n            }\n            else {\n                this._logIfConsoleOutputIsNotRestricted('Autoinstaller folder is already up to date\\n');\n            }\n        }\n        finally {\n            // Ensure the lockfile is released when we are finished.\n            lock.release();\n        }\n    }\n    async updateAsync() {\n        await InstallHelpers.ensureLocalPackageManagerAsync(this._rushConfiguration, this._rushGlobalFolder, RushConstants.defaultMaxInstallAttempts, this._restrictConsoleOutput);\n        const autoinstallerPackageJsonPath = path.join(this.folderFullPath, 'package.json');\n        if (!(await FileSystem.existsAsync(autoinstallerPackageJsonPath))) {\n            throw new Error(`The specified autoinstaller path does not exist: ` + autoinstallerPackageJsonPath);\n        }\n        this._logIfConsoleOutputIsNotRestricted(`Updating autoinstaller package: ${autoinstallerPackageJsonPath}`);\n        let oldFileContents = '';\n        if (await FileSystem.existsAsync(this.shrinkwrapFilePath)) {\n            oldFileContents = FileSystem.readFile(this.shrinkwrapFilePath, { convertLineEndings: NewlineKind.Lf });\n            this._logIfConsoleOutputIsNotRestricted('Deleting ' + this.shrinkwrapFilePath);\n            await FileSystem.deleteFileAsync(this.shrinkwrapFilePath);\n            if (this._rushConfiguration.isPnpm) {\n                // Workaround for https://github.com/pnpm/pnpm/issues/1890\n                //\n                // When \"rush update-autoinstaller\" is run, Rush deletes \"common/autoinstallers/my-task/pnpm-lock.yaml\"\n                // so that a new lockfile will be generated. However \"pnpm install\" by design will try to recover\n                // \"pnpm-lock.yaml\" from \"my-task/node_modules/.pnpm/lock.yaml\", which may prevent a full upgrade.\n                // Deleting both files ensures that a new lockfile will always be generated.\n                const pnpmPackageManager = this._rushConfiguration\n                    .packageManagerWrapper;\n                await FileSystem.deleteFileAsync(path.join(this.folderFullPath, pnpmPackageManager.internalShrinkwrapRelativePath));\n            }\n        }\n        // Detect a common mistake where PNPM prints \"Already up-to-date\" without creating a shrinkwrap file\n        const packageJsonEditor = PackageJsonEditor.load(this.packageJsonPath);\n        if (packageJsonEditor.dependencyList.length === 0) {\n            throw new Error('You must add at least one dependency to the autoinstaller package' +\n                ' before invoking this command:\\n' +\n                this.packageJsonPath);\n        }\n        this._logIfConsoleOutputIsNotRestricted();\n        Utilities.syncNpmrc({\n            sourceNpmrcFolder: this._rushConfiguration.commonRushConfigFolder,\n            targetNpmrcFolder: this.folderFullPath,\n            supportEnvVarFallbackSyntax: this._rushConfiguration.isPnpm\n        });\n        await Utilities.executeCommandAsync({\n            command: this._rushConfiguration.packageManagerToolFilename,\n            args: ['install'],\n            workingDirectory: this.folderFullPath,\n            keepEnvironment: true\n        });\n        this._logIfConsoleOutputIsNotRestricted();\n        if (this._rushConfiguration.packageManager === 'npm') {\n            this._logIfConsoleOutputIsNotRestricted(Colorize.bold('Running \"npm shrinkwrap\"...'));\n            await Utilities.executeCommandAsync({\n                command: this._rushConfiguration.packageManagerToolFilename,\n                args: ['shrinkwrap'],\n                workingDirectory: this.folderFullPath,\n                keepEnvironment: true\n            });\n            this._logIfConsoleOutputIsNotRestricted('\"npm shrinkwrap\" completed');\n            this._logIfConsoleOutputIsNotRestricted();\n        }\n        if (!(await FileSystem.existsAsync(this.shrinkwrapFilePath))) {\n            throw new Error('The package manager did not create the expected shrinkwrap file: ' + this.shrinkwrapFilePath);\n        }\n        const newFileContents = await FileSystem.readFileAsync(this.shrinkwrapFilePath, {\n            convertLineEndings: NewlineKind.Lf\n        });\n        if (oldFileContents !== newFileContents) {\n            this._logIfConsoleOutputIsNotRestricted(Colorize.green('The shrinkwrap file has been updated.') + '  Please commit the updated file:');\n            this._logIfConsoleOutputIsNotRestricted(`\\n  ${this.shrinkwrapFilePath}`);\n        }\n        else {\n            this._logIfConsoleOutputIsNotRestricted(Colorize.green('Already up to date.'));\n        }\n    }\n    _logIfConsoleOutputIsNotRestricted(message) {\n        if (!this._restrictConsoleOutput) {\n            // eslint-disable-next-line no-console\n            console.log(message !== null && message !== void 0 ? message : '');\n        }\n    }\n}\n//# sourceMappingURL=Autoinstaller.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Async, FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport schemaJson from '../schemas/change-file.schema.json';\n/**\n * This class represents the collection of change files existing in the repo and provides operations\n * for those change files.\n */\nexport class ChangeFiles {\n    constructor(changesPath) {\n        this._changesPath = changesPath;\n    }\n    /**\n     * Validate if the newly added change files match the changed packages.\n     */\n    static validate(newChangeFilePaths, changedPackages, rushConfiguration) {\n        const schema = JsonSchema.fromLoadedObject(schemaJson);\n        const projectsWithChangeDescriptions = new Set();\n        newChangeFilePaths.forEach((filePath) => {\n            // eslint-disable-next-line no-console\n            console.log(`Found change file: ${filePath}`);\n            const changeFile = JsonFile.loadAndValidate(filePath, schema);\n            if (rushConfiguration.hotfixChangeEnabled) {\n                if (changeFile && changeFile.changes) {\n                    for (const change of changeFile.changes) {\n                        if (change.type !== 'none' && change.type !== 'hotfix') {\n                            throw new Error(`Change file ${filePath} specifies a type of '${change.type}' ` +\n                                `but only 'hotfix' and 'none' change types may be used in a branch with 'hotfixChangeEnabled'.`);\n                        }\n                    }\n                }\n            }\n            if (changeFile && changeFile.changes) {\n                changeFile.changes.forEach((change) => projectsWithChangeDescriptions.add(change.packageName));\n            }\n            else {\n                throw new Error(`Invalid change file: ${filePath}`);\n            }\n        });\n        const projectsMissingChangeDescriptions = new Set(changedPackages);\n        projectsWithChangeDescriptions.forEach((name) => projectsMissingChangeDescriptions.delete(name));\n        if (projectsMissingChangeDescriptions.size > 0) {\n            const projectsMissingChangeDescriptionsArray = [];\n            projectsMissingChangeDescriptions.forEach((name) => projectsMissingChangeDescriptionsArray.push(name));\n            throw new Error([\n                'The following projects have been changed and require change descriptions, but change descriptions were not ' +\n                    'detected for them:',\n                ...projectsMissingChangeDescriptionsArray.map((projectName) => `- ${projectName}`),\n                'To resolve this error, run \"rush change\". This will generate change description files that must be ' +\n                    'committed to source control.'\n            ].join('\\n'));\n        }\n    }\n    static getChangeComments(newChangeFilePaths) {\n        const changes = new Map();\n        newChangeFilePaths.forEach((filePath) => {\n            // eslint-disable-next-line no-console\n            console.log(`Found change file: ${filePath}`);\n            const changeRequest = JsonFile.load(filePath);\n            if (changeRequest && changeRequest.changes) {\n                changeRequest.changes.forEach((change) => {\n                    if (!changes.get(change.packageName)) {\n                        changes.set(change.packageName, []);\n                    }\n                    if (change.comment && change.comment.length) {\n                        changes.get(change.packageName).push(change.comment);\n                    }\n                });\n            }\n            else {\n                throw new Error(`Invalid change file: ${filePath}`);\n            }\n        });\n        return changes;\n    }\n    /**\n     * Get the array of absolute paths of change files.\n     */\n    async getFilesAsync() {\n        if (!this._files) {\n            const { default: glob } = await import('fast-glob');\n            this._files = (await glob('**/*.json', { cwd: this._changesPath, absolute: true })) || [];\n        }\n        return this._files;\n    }\n    /**\n     * Get the path of changes folder.\n     */\n    getChangesPath() {\n        return this._changesPath;\n    }\n    /**\n     * Delete all change files\n     */\n    async deleteAllAsync(shouldDelete, updatedChangelogs) {\n        if (updatedChangelogs) {\n            // Skip changes files if the package's change log is not updated.\n            const packagesToInclude = new Set();\n            updatedChangelogs.forEach((changelog) => {\n                packagesToInclude.add(changelog.name);\n            });\n            const files = await this.getFilesAsync();\n            const filesToDelete = [];\n            await Async.forEachAsync(files, async (filePath) => {\n                const changeRequest = await JsonFile.loadAsync(filePath);\n                let shouldDeleteFile = true;\n                for (const changeInfo of changeRequest.changes) {\n                    if (!packagesToInclude.has(changeInfo.packageName)) {\n                        shouldDeleteFile = false;\n                        break;\n                    }\n                }\n                if (shouldDeleteFile) {\n                    filesToDelete.push(filePath);\n                }\n            }, { concurrency: 5 });\n            return await this._deleteFilesAsync(filesToDelete, shouldDelete);\n        }\n        else {\n            // Delete all change files.\n            const files = await this.getFilesAsync();\n            return await this._deleteFilesAsync(files, shouldDelete);\n        }\n    }\n    async _deleteFilesAsync(files, shouldDelete) {\n        if (files.length) {\n            // eslint-disable-next-line no-console\n            console.log(`\\n* ${shouldDelete ? 'DELETING:' : 'DRYRUN: Deleting'} ${files.length} change file(s).`);\n            await Async.forEachAsync(files, async (filePath) => {\n                // eslint-disable-next-line no-console\n                console.log(` - ${filePath}`);\n                if (shouldDelete) {\n                    await FileSystem.deleteFileAsync(filePath);\n                }\n            }, { concurrency: 5 });\n        }\n        return files.length;\n    }\n}\n//# sourceMappingURL=ChangeFiles.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PublishUtilities } from './PublishUtilities';\nimport { ChangeFiles } from './ChangeFiles';\nimport { PrereleaseToken } from './PrereleaseToken';\nimport { ChangelogGenerator } from './ChangelogGenerator';\n/**\n * The class manages change files and controls how changes logged by change files\n * can be applied to package.json and change logs.\n */\nexport class ChangeManager {\n    constructor(rushConfiguration, projectsToExclude) {\n        this._rushConfiguration = rushConfiguration;\n        this._projectsToExclude = projectsToExclude;\n    }\n    /**\n     * Load changes from change files\n     * @param changesPath - location of change files\n     * @param prereleaseToken - prerelease token\n     * @param includeCommitDetails - whether commit details need to be included in changes\n     */\n    async loadAsync(changesPath, prereleaseToken = new PrereleaseToken(), includeCommitDetails = false) {\n        this._allPackages = this._rushConfiguration.projectsByName;\n        this._prereleaseToken = prereleaseToken;\n        this._changeFiles = new ChangeFiles(changesPath);\n        this._allChanges = await PublishUtilities.findChangeRequestsAsync(this._allPackages, this._rushConfiguration, this._changeFiles, includeCommitDetails, this._prereleaseToken, this._projectsToExclude);\n        this._orderedChanges = PublishUtilities.sortChangeRequests(this._allChanges.packageChanges);\n    }\n    hasChanges() {\n        return ((this._orderedChanges && this._orderedChanges.length > 0) ||\n            (this._allChanges && this._allChanges.versionPolicyChanges.size > 0));\n    }\n    get packageChanges() {\n        return this._orderedChanges;\n    }\n    get allPackages() {\n        return this._allPackages;\n    }\n    validateChanges(versionConfig) {\n        this._allChanges.packageChanges.forEach((change, projectName) => {\n            const projectInfo = this._rushConfiguration.getProjectByName(projectName);\n            if (projectInfo) {\n                if (projectInfo.versionPolicy) {\n                    projectInfo.versionPolicy.validate(change.newVersion, projectName);\n                }\n            }\n        });\n    }\n    /**\n     * Apply changes to package.json\n     * @param shouldCommit - If the value is true, package.json will be updated.\n     * If the value is false, package.json and change logs will not be updated. It will only do a dry-run.\n     */\n    apply(shouldCommit) {\n        if (!this.hasChanges()) {\n            return;\n        }\n        // Update all the changed version policies\n        this._allChanges.versionPolicyChanges.forEach((versionPolicyChange, versionPolicyName) => {\n            this._rushConfiguration.versionPolicyConfiguration.update(versionPolicyName, versionPolicyChange.newVersion, shouldCommit);\n        });\n        // Apply all changes to package.json files.\n        const updatedPackages = PublishUtilities.updatePackages(this._allChanges, this._allPackages, this._rushConfiguration, shouldCommit, this._prereleaseToken, this._projectsToExclude);\n        return updatedPackages;\n    }\n    async updateChangelogAsync(shouldCommit) {\n        // Do not update changelog or delete the change files for prerelease.\n        // Save them for the official release.\n        if (!this._prereleaseToken.hasValue) {\n            // Update changelogs.\n            const updatedChangelogs = ChangelogGenerator.updateChangelogs(this._allChanges, this._allPackages, this._rushConfiguration, shouldCommit);\n            // Remove the change request files only if \"-a\" was provided.\n            await this._changeFiles.deleteAllAsync(shouldCommit, updatedChangelogs);\n        }\n    }\n}\n//# sourceMappingURL=ChangeManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport { PublishUtilities } from './PublishUtilities';\nimport { ChangeType } from '../api/ChangeManagement';\nimport schemaJson from '../schemas/changelog.schema.json';\nconst CHANGELOG_JSON = 'CHANGELOG.json';\nconst CHANGELOG_MD = 'CHANGELOG.md';\nconst EOL = '\\n';\nexport class ChangelogGenerator {\n    /**\n     * Updates the appropriate changelogs with the given changes.\n     */\n    static updateChangelogs(allChanges, allProjects, rushConfiguration, shouldCommit) {\n        const updatedChangeLogs = [];\n        allChanges.packageChanges.forEach((change, packageName) => {\n            const project = allProjects.get(packageName);\n            if (project && ChangelogGenerator._shouldUpdateChangeLog(project, allChanges)) {\n                const changeLog = ChangelogGenerator.updateIndividualChangelog(change, project.projectFolder, shouldCommit, rushConfiguration, project.versionPolicy && project.versionPolicy.isLockstepped, project.isMainProject);\n                if (changeLog) {\n                    updatedChangeLogs.push(changeLog);\n                }\n            }\n        });\n        return updatedChangeLogs;\n    }\n    /**\n     * Fully regenerate the markdown files based on the current json files.\n     */\n    static regenerateChangelogs(allProjects, rushConfiguration) {\n        allProjects.forEach((project) => {\n            const markdownPath = path.resolve(project.projectFolder, CHANGELOG_MD);\n            const markdownJSONPath = path.resolve(project.projectFolder, CHANGELOG_JSON);\n            if (FileSystem.exists(markdownPath)) {\n                // eslint-disable-next-line no-console\n                console.log('Found: ' + markdownPath);\n                if (!FileSystem.exists(markdownJSONPath)) {\n                    throw new Error('A CHANGELOG.md without json: ' + markdownPath);\n                }\n                const changelog = ChangelogGenerator._getChangelog(project.packageName, project.projectFolder);\n                const isLockstepped = !!project.versionPolicy && project.versionPolicy.isLockstepped;\n                FileSystem.writeFile(path.join(project.projectFolder, CHANGELOG_MD), ChangelogGenerator._translateToMarkdown(changelog, rushConfiguration, isLockstepped));\n            }\n        });\n    }\n    /**\n     * Updates an individual changelog for a single project.\n     */\n    static updateIndividualChangelog(change, projectFolder, shouldCommit, rushConfiguration, isLockstepped = false, isMain = true) {\n        if (isLockstepped && !isMain) {\n            // Early return if the project is lockstepped and does not host change logs\n            return undefined;\n        }\n        const changelog = ChangelogGenerator._getChangelog(change.packageName, projectFolder);\n        if (!changelog.entries.some((entry) => entry.version === change.newVersion)) {\n            const changelogEntry = {\n                version: change.newVersion,\n                tag: PublishUtilities.createTagname(change.packageName, change.newVersion, rushConfiguration.gitTagSeparator),\n                date: new Date().toUTCString(),\n                comments: {}\n            };\n            change.changes.forEach((individualChange) => {\n                if (individualChange.comment) {\n                    // Initialize the comments array only as necessary.\n                    const changeTypeString = ChangeType[individualChange.changeType];\n                    changelogEntry.comments[changeTypeString] = changelogEntry.comments[changeTypeString] || [];\n                    const comments = changelogEntry.comments[changeTypeString];\n                    const changeLogComment = {\n                        comment: individualChange.comment\n                    };\n                    if (individualChange.author) {\n                        changeLogComment.author = individualChange.author;\n                    }\n                    if (individualChange.commit) {\n                        changeLogComment.commit = individualChange.commit;\n                    }\n                    if (individualChange.customFields) {\n                        changeLogComment.customFields = individualChange.customFields;\n                    }\n                    comments.push(changeLogComment);\n                }\n            });\n            // Add the changelog entry to the start of the list.\n            changelog.entries.unshift(changelogEntry);\n            const changelogFilename = path.join(projectFolder, CHANGELOG_JSON);\n            // eslint-disable-next-line no-console\n            console.log(`${EOL}* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ` +\n                `Changelog update for \"${change.packageName}@${change.newVersion}\".`);\n            if (shouldCommit) {\n                // Write markdown transform.\n                JsonFile.save(changelog, changelogFilename);\n                FileSystem.writeFile(path.join(projectFolder, CHANGELOG_MD), ChangelogGenerator._translateToMarkdown(changelog, rushConfiguration, isLockstepped));\n            }\n            return changelog;\n        }\n        // change log not updated.\n        return undefined;\n    }\n    /**\n     * Loads the changelog json from disk, or creates a new one if there isn't one.\n     */\n    static _getChangelog(packageName, projectFolder) {\n        const changelogFilename = path.join(projectFolder, CHANGELOG_JSON);\n        let changelog = undefined;\n        // Try to read the existing changelog.\n        if (FileSystem.exists(changelogFilename)) {\n            changelog = JsonFile.loadAndValidate(changelogFilename, ChangelogGenerator.jsonSchema);\n        }\n        if (!changelog) {\n            changelog = {\n                name: packageName,\n                entries: []\n            };\n        }\n        else {\n            // Force the changelog name to be same as package name.\n            // In case the package has been renamed but change log name is not updated.\n            changelog.name = packageName;\n        }\n        return changelog;\n    }\n    /**\n     * Translates the given changelog json object into a markdown string.\n     */\n    static _translateToMarkdown(changelog, rushConfiguration, isLockstepped = false) {\n        let markdown = [\n            `# Change Log - ${changelog.name}`,\n            '',\n            `This log was last generated on ${new Date().toUTCString()} and should not be manually modified.`,\n            '',\n            ''\n        ].join(EOL);\n        changelog.entries.forEach((entry, index) => {\n            markdown += `## ${entry.version}${EOL}`;\n            if (entry.date) {\n                markdown += `${entry.date}${EOL}`;\n            }\n            markdown += EOL;\n            let comments = '';\n            comments += ChangelogGenerator._getChangeComments('Breaking changes', entry.comments.major);\n            comments += ChangelogGenerator._getChangeComments('Minor changes', entry.comments.minor);\n            comments += ChangelogGenerator._getChangeComments('Patches', entry.comments.patch);\n            if (isLockstepped) {\n                // In lockstepped projects, all changes are of type ChangeType.none.\n                comments += ChangelogGenerator._getChangeComments('Updates', entry.comments.none);\n            }\n            if (rushConfiguration.hotfixChangeEnabled) {\n                comments += ChangelogGenerator._getChangeComments('Hotfixes', entry.comments.hotfix);\n            }\n            if (!comments) {\n                markdown +=\n                    (changelog.entries.length === index + 1 ? '_Initial release_' : '_Version update only_') +\n                        EOL +\n                        EOL;\n            }\n            else {\n                markdown += comments;\n            }\n        });\n        return markdown;\n    }\n    /**\n     * Helper to return the comments string to be appends to the markdown content.\n     */\n    static _getChangeComments(title, commentsArray) {\n        let comments = '';\n        if (commentsArray) {\n            comments = `### ${title}${EOL + EOL}`;\n            commentsArray.forEach((comment) => {\n                comments += `- ${comment.comment}${EOL}`;\n            });\n            comments += EOL;\n        }\n        return comments;\n    }\n    /**\n     * Changelogs should only be generated for publishable projects.\n     * Do not update changelog or delete the change files for prerelease. Save them for the official release.\n     * Unless the package is a hotfix, in which case do delete the change files.\n     *\n     * @param project\n     * @param allChanges\n     */\n    static _shouldUpdateChangeLog(project, allChanges) {\n        var _a;\n        return (project.shouldPublish &&\n            (!semver.prerelease(project.packageJson.version) ||\n                ((_a = allChanges.packageChanges.get(project.packageName)) === null || _a === void 0 ? void 0 : _a.changeType) === ChangeType.hotfix));\n    }\n}\n/**\n * The JSON Schema for Changelog file (changelog.schema.json).\n */\nChangelogGenerator.jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=ChangelogGenerator.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema, LockFile } from '@rushstack/node-core-library';\nimport { Utilities } from '../utilities/Utilities';\nimport { RushUserConfiguration } from '../api/RushUserConfiguration';\nimport schemaJson from '../schemas/credentials.schema.json';\nimport { objectsAreDeepEqual } from '../utilities/objectUtilities';\nconst CACHE_FILENAME = 'credentials.json';\nconst LATEST_CREDENTIALS_JSON_VERSION = '0.1.0';\n/**\n * @beta\n */\nexport class CredentialCache /* implements IDisposable */ {\n    constructor(cacheFilePath, loadedJson, lockfile) {\n        this._modified = false;\n        this._disposed = false;\n        if (loadedJson && loadedJson.version !== LATEST_CREDENTIALS_JSON_VERSION) {\n            throw new Error(`Unexpected credentials.json file version: ${loadedJson.version}`);\n        }\n        this._cacheFilePath = cacheFilePath;\n        this._cacheEntries = new Map(Object.entries((loadedJson === null || loadedJson === void 0 ? void 0 : loadedJson.cacheEntries) || {}));\n        this._supportsEditing = !!lockfile;\n        this._lockfile = lockfile;\n    }\n    static async initializeAsync(options) {\n        const rushUserFolderPath = RushUserConfiguration.getRushUserFolderPath();\n        const cacheFilePath = `${rushUserFolderPath}/${CACHE_FILENAME}`;\n        const jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n        let loadedJson;\n        try {\n            loadedJson = await JsonFile.loadAndValidateAsync(cacheFilePath, jsonSchema);\n        }\n        catch (e) {\n            if (!FileSystem.isErrnoException(e)) {\n                throw e;\n            }\n        }\n        let lockfile;\n        if (options.supportEditing) {\n            lockfile = await LockFile.acquireAsync(rushUserFolderPath, `${CACHE_FILENAME}.lock`);\n        }\n        const credentialCache = new CredentialCache(cacheFilePath, loadedJson, lockfile);\n        return credentialCache;\n    }\n    static async usingAsync(options, doActionAsync) {\n        await Utilities.usingAsync(async () => await CredentialCache.initializeAsync(options), doActionAsync);\n    }\n    setCacheEntry(cacheId, entry) {\n        this._validate(true);\n        const { expires, credential, credentialMetadata } = entry;\n        const expiresMilliseconds = (expires === null || expires === void 0 ? void 0 : expires.getTime()) || 0;\n        const existingCacheEntry = this._cacheEntries.get(cacheId);\n        if ((existingCacheEntry === null || existingCacheEntry === void 0 ? void 0 : existingCacheEntry.credential) !== credential ||\n            (existingCacheEntry === null || existingCacheEntry === void 0 ? void 0 : existingCacheEntry.expires) !== expiresMilliseconds ||\n            !objectsAreDeepEqual(existingCacheEntry === null || existingCacheEntry === void 0 ? void 0 : existingCacheEntry.credentialMetadata, credentialMetadata)) {\n            this._modified = true;\n            this._cacheEntries.set(cacheId, {\n                expires: expiresMilliseconds,\n                credential,\n                credentialMetadata\n            });\n        }\n    }\n    tryGetCacheEntry(cacheId) {\n        this._validate(false);\n        const cacheEntry = this._cacheEntries.get(cacheId);\n        if (cacheEntry) {\n            const result = {\n                expires: cacheEntry.expires ? new Date(cacheEntry.expires) : undefined,\n                credential: cacheEntry.credential,\n                credentialMetadata: cacheEntry.credentialMetadata\n            };\n            return result;\n        }\n        else {\n            return undefined;\n        }\n    }\n    deleteCacheEntry(cacheId) {\n        this._validate(true);\n        if (this._cacheEntries.has(cacheId)) {\n            this._modified = true;\n            this._cacheEntries.delete(cacheId);\n        }\n    }\n    trimExpiredEntries() {\n        this._validate(true);\n        const now = Date.now();\n        for (const [cacheId, cacheEntry] of this._cacheEntries.entries()) {\n            if (cacheEntry.expires < now) {\n                this._cacheEntries.delete(cacheId);\n                this._modified = true;\n            }\n        }\n    }\n    async saveIfModifiedAsync() {\n        this._validate(true);\n        if (this._modified) {\n            const cacheEntriesJson = {};\n            for (const [cacheId, cacheEntry] of this._cacheEntries.entries()) {\n                cacheEntriesJson[cacheId] = cacheEntry;\n            }\n            const newJson = {\n                version: LATEST_CREDENTIALS_JSON_VERSION,\n                cacheEntries: cacheEntriesJson\n            };\n            await JsonFile.saveAsync(newJson, this._cacheFilePath, {\n                ensureFolderExists: true,\n                updateExistingFile: true,\n                ignoreUndefinedValues: true\n            });\n            this._modified = false;\n        }\n    }\n    dispose() {\n        var _a;\n        (_a = this._lockfile) === null || _a === void 0 ? void 0 : _a.release();\n        this._disposed = true;\n    }\n    _validate(requiresEditing) {\n        if (!this._supportsEditing && requiresEditing) {\n            throw new Error(`This instance of ${CredentialCache.name} does not support editing.`);\n        }\n        if (this._disposed) {\n            throw new Error(`This instance of ${CredentialCache.name} has been disposed.`);\n        }\n    }\n}\n//# sourceMappingURL=CredentialCache.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { DependencyType } from '../api/PackageJsonEditor';\nexport class DependencyAnalyzer {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    static forRushConfiguration(rushConfiguration) {\n        if (!DependencyAnalyzer._dependencyAnalyzerByRushConfiguration) {\n            DependencyAnalyzer._dependencyAnalyzerByRushConfiguration = new WeakMap();\n        }\n        let analyzer = DependencyAnalyzer._dependencyAnalyzerByRushConfiguration.get(rushConfiguration);\n        if (!analyzer) {\n            analyzer = new DependencyAnalyzer(rushConfiguration);\n            DependencyAnalyzer._dependencyAnalyzerByRushConfiguration.set(rushConfiguration, analyzer);\n        }\n        return analyzer;\n    }\n    getAnalysis(subspace, variant, addAction) {\n        // Use an empty string as the key when no variant provided. Anything else would possibly conflict\n        // with a variant created by the user\n        const variantKey = variant || '';\n        if (!this._analysisByVariantBySubspace) {\n            this._analysisByVariantBySubspace = new Map();\n        }\n        const subspaceToAnalyze = subspace || this._rushConfiguration.defaultSubspace;\n        let analysisForVariant = this._analysisByVariantBySubspace.get(variantKey);\n        if (!analysisForVariant) {\n            analysisForVariant = new WeakMap();\n            this._analysisByVariantBySubspace.set(variantKey, analysisForVariant);\n        }\n        let analysisForSubspace = analysisForVariant.get(subspaceToAnalyze);\n        if (!analysisForSubspace) {\n            analysisForSubspace = this._getAnalysisInternal(subspaceToAnalyze, variant, addAction);\n            analysisForVariant.set(subspaceToAnalyze, analysisForSubspace);\n        }\n        return analysisForSubspace;\n    }\n    /**\n     * Generates the {@link IDependencyAnalysis}.\n     *\n     * @remarks\n     * The result of this function is not cached.\n     */\n    _getAnalysisInternal(subspace, variant, addAction) {\n        var _a;\n        const commonVersionsConfiguration = subspace.getCommonVersions(variant);\n        const allVersionsByPackageName = new Map();\n        const allowedAlternativeVersions = commonVersionsConfiguration.allowedAlternativeVersions;\n        let projectsToProcess = this._rushConfiguration.projects;\n        if (addAction && this._rushConfiguration.subspacesFeatureEnabled) {\n            projectsToProcess = subspace.getProjects();\n        }\n        for (const project of projectsToProcess) {\n            const dependencies = [\n                ...project.packageJsonEditor.dependencyList,\n                ...project.packageJsonEditor.devDependencyList\n            ];\n            for (const { name: dependencyName, version: dependencyVersion, dependencyType } of dependencies) {\n                if (dependencyType === DependencyType.Peer) {\n                    // If this is a peer dependency, it isn't a real dependency in this context, so it shouldn't\n                    // be included in the list of dependency versions.\n                    continue;\n                }\n                // Is it a local project?\n                const localProject = this._rushConfiguration.getProjectByName(dependencyName);\n                if (localProject) {\n                    if (!project.decoupledLocalDependencies.has(dependencyName) &&\n                        semver.satisfies(localProject.packageJson.version, dependencyVersion)) {\n                        // For now, ignore local dependencies (that aren't cyclic dependencies).\n                        continue;\n                    }\n                }\n                let allVersionForDependency = allVersionsByPackageName.get(dependencyName);\n                if (!allVersionForDependency) {\n                    allVersionForDependency = new Set();\n                    allVersionsByPackageName.set(dependencyName, allVersionForDependency);\n                }\n                allVersionForDependency.add(dependencyVersion);\n            }\n        }\n        const implicitlyPreferredVersionByPackageName = new Map();\n        // Only generate implicitly preferred versions when requested\n        const useImplicitlyPreferredVersions = (_a = commonVersionsConfiguration.implicitlyPreferredVersions) !== null && _a !== void 0 ? _a : true;\n        if (useImplicitlyPreferredVersions) {\n            for (const [dependencyName, versions] of allVersionsByPackageName) {\n                // For each dependency, we're collecting the set of all version specifiers that appear across the repo.\n                // If there is only one version specifier, then that's the \"preferred\" one.\n                const alternativesForThisDependency = new Set(allowedAlternativeVersions.get(dependencyName));\n                let implicitlyPreferredVersion = undefined;\n                for (const version of versions) {\n                    // Versions listed in the common-versions.json's \"allowedAlternativeVersions\" property\n                    // can be safely ignored in determining the set of implicitly preferred versions.\n                    // (Even if it's the only version specifier anywhere in the repo, we still ignore it, because\n                    // otherwise the rule would be difficult to explain.)\n                    if (!alternativesForThisDependency.has(version)) {\n                        if (implicitlyPreferredVersion === undefined) {\n                            // There isn't a candidate for an implicitly preferred version yet. Set this value as a candidate.\n                            implicitlyPreferredVersion = version;\n                        }\n                        else {\n                            // There was already another version that was a candidate. Clear that out and break.\n                            // This dependency does not have an implicitly preferred version because there are at least\n                            // two candidates.\n                            implicitlyPreferredVersion = undefined;\n                            break;\n                        }\n                    }\n                }\n                if (implicitlyPreferredVersion !== undefined) {\n                    implicitlyPreferredVersionByPackageName.set(dependencyName, implicitlyPreferredVersion);\n                }\n            }\n        }\n        return {\n            commonVersionsConfiguration,\n            implicitlyPreferredVersionByPackageName,\n            allVersionsByPackageName\n        };\n    }\n}\n//# sourceMappingURL=DependencyAnalyzer.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport npmPackageArg from 'npm-package-arg';\nimport { InternalError } from '@rushstack/node-core-library';\n/**\n * match workspace protocol in dependencies value declaration in `package.json`\n * example:\n * `\"workspace:*\"`\n * `\"workspace:alias@1.2.3\"`\n */\nconst WORKSPACE_PREFIX_REGEX = /^workspace:((?<alias>[^._/][^@]*)@)?(?<version>.*)$/;\n/**\n * resolve workspace protocol(from `@pnpm/workspace.spec-parser`).\n * used by pnpm. see [pkgs-graph](https://github.com/pnpm/pnpm/blob/27c33f0319f86c45c1645d064cd9c28aada80780/workspace/pkgs-graph/src/index.ts#L49)\n */\nclass WorkspaceSpec {\n    constructor(version, alias) {\n        this.version = version;\n        this.alias = alias;\n        this.versionSpecifier = alias ? `${alias}@${version}` : version;\n    }\n    static tryParse(pref) {\n        const parts = WORKSPACE_PREFIX_REGEX.exec(pref);\n        if (parts === null || parts === void 0 ? void 0 : parts.groups) {\n            return new WorkspaceSpec(parts.groups.version, parts.groups.alias);\n        }\n    }\n    toString() {\n        return `workspace:${this.versionSpecifier}`;\n    }\n}\n/**\n * The parsed format of a provided version specifier.\n */\nexport var DependencySpecifierType;\n(function (DependencySpecifierType) {\n    /**\n     * A git repository\n     */\n    DependencySpecifierType[\"Git\"] = \"Git\";\n    /**\n     * A tagged version, e.g. \"example@latest\"\n     */\n    DependencySpecifierType[\"Tag\"] = \"Tag\";\n    /**\n     * A specific version number, e.g. \"example@1.2.3\"\n     */\n    DependencySpecifierType[\"Version\"] = \"Version\";\n    /**\n     * A version range, e.g. \"example@2.x\"\n     */\n    DependencySpecifierType[\"Range\"] = \"Range\";\n    /**\n     * A local .tar.gz, .tar or .tgz file\n     */\n    DependencySpecifierType[\"File\"] = \"File\";\n    /**\n     * A local directory\n     */\n    DependencySpecifierType[\"Directory\"] = \"Directory\";\n    /**\n     * An HTTP url to a .tar.gz, .tar or .tgz file\n     */\n    DependencySpecifierType[\"Remote\"] = \"Remote\";\n    /**\n     * A package alias, e.g. \"npm:other-package@^1.2.3\"\n     */\n    DependencySpecifierType[\"Alias\"] = \"Alias\";\n    /**\n     * A package specified using workspace protocol, e.g. \"workspace:^1.2.3\"\n     */\n    DependencySpecifierType[\"Workspace\"] = \"Workspace\";\n})(DependencySpecifierType || (DependencySpecifierType = {}));\n/**\n * An NPM \"version specifier\" is a string that can appear as a package.json \"dependencies\" value.\n * Example version specifiers: `^1.2.3`, `file:./blah.tgz`, `npm:other-package@~1.2.3`, and so forth.\n * A \"dependency specifier\" is the version specifier information, combined with the dependency package name.\n */\nexport class DependencySpecifier {\n    constructor(packageName, versionSpecifier) {\n        this.packageName = packageName;\n        this.versionSpecifier = versionSpecifier;\n        // Workspace ranges are a feature from PNPM and Yarn. Set the version specifier\n        // to the trimmed version range.\n        const workspaceSpecResult = WorkspaceSpec.tryParse(versionSpecifier);\n        if (workspaceSpecResult) {\n            this.specifierType = DependencySpecifierType.Workspace;\n            this.versionSpecifier = workspaceSpecResult.versionSpecifier;\n            if (workspaceSpecResult.alias) {\n                // \"workspace:some-package@^1.2.3\" should be resolved as alias\n                this.aliasTarget = new DependencySpecifier(workspaceSpecResult.alias, workspaceSpecResult.version);\n            }\n            else {\n                this.aliasTarget = undefined;\n            }\n            return;\n        }\n        const result = npmPackageArg.resolve(packageName, versionSpecifier);\n        this.specifierType = DependencySpecifier.getDependencySpecifierType(result.type);\n        if (this.specifierType === DependencySpecifierType.Alias) {\n            const aliasResult = result;\n            if (!aliasResult.subSpec || !aliasResult.subSpec.name) {\n                throw new InternalError('Unexpected result from npm-package-arg');\n            }\n            this.aliasTarget = new DependencySpecifier(aliasResult.subSpec.name, aliasResult.subSpec.rawSpec);\n        }\n        else {\n            this.aliasTarget = undefined;\n        }\n    }\n    static getDependencySpecifierType(specifierType) {\n        switch (specifierType) {\n            case 'git':\n                return DependencySpecifierType.Git;\n            case 'tag':\n                return DependencySpecifierType.Tag;\n            case 'version':\n                return DependencySpecifierType.Version;\n            case 'range':\n                return DependencySpecifierType.Range;\n            case 'file':\n                return DependencySpecifierType.File;\n            case 'directory':\n                return DependencySpecifierType.Directory;\n            case 'remote':\n                return DependencySpecifierType.Remote;\n            case 'alias':\n                return DependencySpecifierType.Alias;\n            default:\n                throw new InternalError(`Unexpected npm-package-arg result type \"${specifierType}\"`);\n        }\n    }\n}\n//# sourceMappingURL=DependencySpecifier.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Colorize } from '@rushstack/terminal';\nimport { Utilities } from '../utilities/Utilities';\nimport { Event } from '../api/EventHooks';\nimport { Stopwatch } from '../utilities/Stopwatch';\nimport { EnvironmentVariableNames } from '../api/EnvironmentConfiguration';\nexport class EventHooksManager {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n        this._eventHooks = rushConfiguration.eventHooks;\n        this._commonTempFolder = rushConfiguration.commonTempFolder;\n    }\n    handle(event, isDebug, ignoreHooks) {\n        if (!this._eventHooks) {\n            return;\n        }\n        const scripts = this._eventHooks.get(event);\n        if (scripts.length > 0) {\n            if (ignoreHooks) {\n                // eslint-disable-next-line no-console\n                console.log(`Skipping event hooks for ${Event[event]} since --ignore-hooks was specified`);\n                return;\n            }\n            const stopwatch = Stopwatch.start();\n            // eslint-disable-next-line no-console\n            console.log('\\n' + Colorize.green(`Executing event hooks for ${Event[event]}`));\n            const printEventHooksOutputToConsole = isDebug ||\n                this._rushConfiguration.experimentsConfiguration.configuration.printEventHooksOutputToConsole;\n            scripts.forEach((script) => {\n                try {\n                    const environment = Object.assign({}, process.env);\n                    // NOTE: Do NOT expose this variable to other subprocesses besides telemetry hooks.  We do NOT want\n                    // child processes to inspect Rush's raw command line and magically change their behavior in a way\n                    // that might be confusing to end users, or rely on CLI parameters that the build cache is unaware of.\n                    environment[EnvironmentVariableNames.RUSH_INVOKED_ARGS] = JSON.stringify(process.argv);\n                    Utilities.executeLifecycleCommand(script, {\n                        rushConfiguration: this._rushConfiguration,\n                        workingDirectory: this._rushConfiguration.rushJsonFolder,\n                        initCwd: this._commonTempFolder,\n                        handleOutput: !printEventHooksOutputToConsole,\n                        initialEnvironment: environment,\n                        environmentPathOptions: {\n                            includeRepoBin: true\n                        }\n                    });\n                }\n                catch (error) {\n                    // eslint-disable-next-line no-console\n                    console.error('\\n' +\n                        Colorize.yellow(`Event hook \"${script}\" failed: ${error}\\nRun \"rush\" with --debug` +\n                            ` to see detailed error information.`));\n                    if (isDebug) {\n                        // eslint-disable-next-line no-console\n                        console.error('\\n' + error.message);\n                    }\n                }\n            });\n            stopwatch.stop();\n            // eslint-disable-next-line no-console\n            console.log('\\n' + Colorize.green(`Event hooks finished. (${stopwatch.toString()})`));\n        }\n    }\n}\n//# sourceMappingURL=EventHooksManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport gitInfo from 'git-repo-info';\nimport * as path from 'path';\nimport * as url from 'url';\nimport { trueCasePathSync } from 'true-case-path';\nimport { Executable, AlreadyReportedError, Path, Async } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { ensureGitMinimumVersion } from '@rushstack/package-deps-hash';\nimport { Utilities } from '../utilities/Utilities';\nimport * as GitEmailPolicy from './policy/GitEmailPolicy';\nimport { EnvironmentConfiguration } from '../api/EnvironmentConfiguration';\nimport { parseGitStatus } from './GitStatusParser';\nimport { RushConstants } from './RushConstants';\nexport const DEFAULT_GIT_TAG_SEPARATOR = '_';\nexport class Git {\n    constructor(rushConfiguration) {\n        this._checkedGitPath = false;\n        this._checkedGitInfo = false;\n        this._gitEmailResult = undefined;\n        this._gitHooksPath = undefined;\n        this._rushConfiguration = rushConfiguration;\n    }\n    /**\n     * Returns the path to the Git binary if found. Otherwise, return undefined.\n     */\n    get gitPath() {\n        if (!this._checkedGitPath) {\n            this._gitPath = EnvironmentConfiguration.gitBinaryPath || Executable.tryResolve('git');\n            this._checkedGitPath = true;\n        }\n        return this._gitPath;\n    }\n    getGitPathOrThrow() {\n        const gitPath = this.gitPath;\n        if (!gitPath) {\n            throw new Error('Git is not present');\n        }\n        else {\n            return gitPath;\n        }\n    }\n    /**\n     * Returns true if the Git binary can be found.\n     */\n    isGitPresent() {\n        return !!this.gitPath;\n    }\n    /**\n     * Returns true if the Git binary was found and the current path is under a Git working tree.\n     * @param repoInfo - If provided, do the check based on this Git repo info. If not provided,\n     * the result of `this.getGitInfo()` is used.\n     */\n    isPathUnderGitWorkingTree(repoInfo) {\n        if (this.isGitPresent()) {\n            // Do we even have a Git binary?\n            if (!repoInfo) {\n                repoInfo = this.getGitInfo();\n            }\n            return !!(repoInfo && repoInfo.sha);\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * If a Git email address is configured and is nonempty, this returns it.\n     * Otherwise, configuration instructions are printed to the console,\n     * and AlreadyReportedError is thrown.\n     */\n    async getGitEmailAsync() {\n        // Determine the user's account\n        // Ex: \"bob@example.com\"\n        const { error, result } = await this._tryGetGitEmailAsync();\n        if (error) {\n            // eslint-disable-next-line no-console\n            console.log([\n                `Error: ${error.message}`,\n                'Unable to determine your Git configuration using this command:',\n                '',\n                '    git config user.email',\n                ''\n            ].join('\\n'));\n            throw new AlreadyReportedError();\n        }\n        return this.validateGitEmail(result);\n    }\n    /**\n     * If the Git email address is configured and non-empty, this returns it. Otherwise\n     * it prints an error message and throws.\n     */\n    validateGitEmail(userEmail) {\n        if (userEmail === undefined || userEmail.length === 0) {\n            // eslint-disable-next-line no-console\n            console.log([\n                'This operation requires that a Git email be specified.',\n                '',\n                `If you didn't configure your email yet, try something like this:`,\n                '',\n                ...GitEmailPolicy.getEmailExampleLines(this._rushConfiguration),\n                ''\n            ].join('\\n'));\n            throw new AlreadyReportedError();\n        }\n        return userEmail;\n    }\n    /**\n     * Get the folder where Git hooks should go for the current working tree.\n     * Returns undefined if the current path is not under a Git working tree.\n     */\n    getHooksFolder() {\n        const repoInfo = this.getGitInfo();\n        if (repoInfo && repoInfo.worktreeGitDir) {\n            return path.join(repoInfo.worktreeGitDir, 'hooks');\n        }\n        return undefined;\n    }\n    async getIsHooksPathDefaultAsync() {\n        const repoInfo = this.getGitInfo();\n        if (!(repoInfo === null || repoInfo === void 0 ? void 0 : repoInfo.commonGitDir)) {\n            // This should have never been called in a non-Git environment\n            return true;\n        }\n        let commonGitDir = repoInfo.commonGitDir;\n        try {\n            commonGitDir = trueCasePathSync(commonGitDir);\n        }\n        catch (error) {\n            /* ignore errors from true-case-path */\n        }\n        const defaultHooksPath = path.resolve(commonGitDir, 'hooks');\n        const hooksResult = await this._tryGetGitHooksPathAsync();\n        if (hooksResult.error) {\n            // eslint-disable-next-line no-console\n            console.log([\n                `Error: ${hooksResult.error.message}`,\n                'Unable to determine your Git configuration using this command:',\n                '',\n                '    git rev-parse --git-path hooks',\n                '',\n                'Assuming hooks can still be installed in the default location'\n            ].join('\\n'));\n            return true;\n        }\n        if (hooksResult.result) {\n            const absoluteHooksPath = path.resolve(this._rushConfiguration.rushJsonFolder, hooksResult.result);\n            return absoluteHooksPath === defaultHooksPath;\n        }\n        // No error, but also empty result? Not sure it's possible.\n        return true;\n    }\n    async getConfigHooksPathAsync() {\n        let configHooksPath = '';\n        const gitPath = this.getGitPathOrThrow();\n        try {\n            configHooksPath = (await this._executeGitCommandAndCaptureOutputAsync(gitPath, ['config', 'core.hooksPath'])).trim();\n        }\n        catch (e) {\n            // git config returns error code 1 if core.hooksPath is not set.\n        }\n        return configHooksPath;\n    }\n    /**\n     * Get information about the current Git working tree.\n     * Returns undefined if rush.json is not under a Git working tree.\n     */\n    getGitInfo() {\n        if (!this._checkedGitInfo) {\n            let repoInfo;\n            try {\n                // gitInfo() shouldn't usually throw, but wrapping in a try/catch just in case\n                repoInfo = gitInfo(this._rushConfiguration.rushJsonFolder);\n            }\n            catch (ex) {\n                // if there's an error, assume we're not in a Git working tree\n            }\n            if (repoInfo && this.isPathUnderGitWorkingTree(repoInfo)) {\n                this._gitInfo = repoInfo;\n            }\n            this._checkedGitInfo = true;\n        }\n        return this._gitInfo;\n    }\n    async getMergeBaseAsync(targetBranch, terminal, shouldFetch = false) {\n        if (shouldFetch) {\n            this._fetchRemoteBranch(targetBranch, terminal);\n        }\n        const gitPath = this.getGitPathOrThrow();\n        try {\n            const output = await this._executeGitCommandAndCaptureOutputAsync(gitPath, [\n                '--no-optional-locks',\n                'merge-base',\n                '--',\n                'HEAD',\n                targetBranch\n            ]);\n            const result = output.trim();\n            return result;\n        }\n        catch (e) {\n            terminal.writeErrorLine(`Unable to determine merge base for branch \"${targetBranch}\". ` +\n                'This can occur if the current clone is a shallow clone. If this clone is running in a CI ' +\n                'pipeline, check your pipeline settings to ensure that the clone depth includes ' +\n                'the expected merge base. If this clone is running locally, consider running \"git fetch --deepen=<depth>\".');\n            throw new AlreadyReportedError();\n        }\n    }\n    async getBlobContentAsync({ blobSpec, repositoryRoot }) {\n        const gitPath = this.getGitPathOrThrow();\n        const output = await this._executeGitCommandAndCaptureOutputAsync(gitPath, ['cat-file', 'blob', blobSpec, '--'], repositoryRoot);\n        return output;\n    }\n    /**\n     * @param pathPrefix - An optional path prefix \"git diff\"s should be filtered by.\n     * @returns\n     * An array of paths of repo-root-relative paths of files that are different from\n     * those in the provided {@param targetBranch}. If a {@param pathPrefix} is provided,\n     * this function only returns results under the that path.\n     */\n    async getChangedFilesAsync(targetBranch, terminal, skipFetch = false, pathPrefix) {\n        if (!skipFetch) {\n            this._fetchRemoteBranch(targetBranch, terminal);\n        }\n        const gitPath = this.getGitPathOrThrow();\n        const output = await this._executeGitCommandAndCaptureOutputAsync(gitPath, [\n            'diff',\n            `${targetBranch}...`,\n            '--name-only',\n            '--no-renames',\n            '--diff-filter=A'\n        ]);\n        return output\n            .split('\\n')\n            .map((line) => {\n            if (line) {\n                const trimmedLine = line.trim();\n                if (!pathPrefix || Path.isUnderOrEqual(trimmedLine, pathPrefix)) {\n                    return trimmedLine;\n                }\n            }\n            else {\n                return undefined;\n            }\n        })\n            .filter((line) => {\n            return line && line.length > 0;\n        });\n    }\n    /**\n     * Gets the remote default branch that maps to the provided repository url.\n     * This method is used by 'Rush change' to find the default remote branch to compare against.\n     * If repository url is not provided or if there is no match, returns the default remote's\n     * default branch 'origin/main'.\n     * If there are more than one matches, returns the first remote's default branch.\n     *\n     * @param rushConfiguration - rush configuration\n     */\n    async getRemoteDefaultBranchAsync() {\n        const repositoryUrls = this._rushConfiguration.repositoryUrls;\n        if (repositoryUrls.length > 0) {\n            const gitPath = this.getGitPathOrThrow();\n            const output = (await this._executeGitCommandAndCaptureOutputAsync(gitPath, ['remote'])).trim();\n            const normalizedRepositoryUrls = new Set();\n            for (const repositoryUrl of repositoryUrls) {\n                // Apply toUpperCase() for a case-insensitive comparison\n                normalizedRepositoryUrls.add(Git.normalizeGitUrlForComparison(repositoryUrl).toUpperCase());\n            }\n            const matchingRemotes = [];\n            await Async.forEachAsync(output.split('\\n'), async (remoteName) => {\n                if (remoteName) {\n                    const remoteUrl = (await this._executeGitCommandAndCaptureOutputAsync(gitPath, [\n                        'remote',\n                        'get-url',\n                        '--',\n                        remoteName\n                    ])).trim();\n                    if (remoteUrl) {\n                        // Also apply toUpperCase() for a case-insensitive comparison\n                        const normalizedRemoteUrl = Git.normalizeGitUrlForComparison(remoteUrl).toUpperCase();\n                        if (normalizedRepositoryUrls.has(normalizedRemoteUrl)) {\n                            matchingRemotes.push(remoteName);\n                        }\n                    }\n                }\n            }, { concurrency: 10 });\n            if (matchingRemotes.length > 0) {\n                if (matchingRemotes.length > 1) {\n                    // eslint-disable-next-line no-console\n                    console.log(`More than one git remote matches the repository URL. Using the first remote (${matchingRemotes[0]}).`);\n                }\n                return `${matchingRemotes[0]}/${this._rushConfiguration.repositoryDefaultBranch}`;\n            }\n            else {\n                const errorMessage = repositoryUrls.length > 1\n                    ? `Unable to find a git remote matching one of the repository URLs (${repositoryUrls.join(', ')}). `\n                    : `Unable to find a git remote matching the repository URL (${repositoryUrls[0]}). `;\n                // eslint-disable-next-line no-console\n                console.log(Colorize.yellow(errorMessage + 'Detected changes are likely to be incorrect.'));\n                return this._rushConfiguration.repositoryDefaultFullyQualifiedRemoteBranch;\n            }\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(Colorize.yellow(`A git remote URL has not been specified in ${RushConstants.rushJsonFilename}. Setting the baseline remote URL is recommended.`));\n            return this._rushConfiguration.repositoryDefaultFullyQualifiedRemoteBranch;\n        }\n    }\n    async hasUncommittedChangesAsync() {\n        const gitStatusEntries = await this.getGitStatusAsync();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for (const gitStatusEntry of gitStatusEntries) {\n            // If there are any changes, return true. We only need to evaluate the first iterator entry\n            return true;\n        }\n        return false;\n    }\n    async hasUnstagedChangesAsync() {\n        const gitStatusEntries = await this.getGitStatusAsync();\n        for (const gitStatusEntry of gitStatusEntries) {\n            if (gitStatusEntry.kind === 'untracked' ||\n                gitStatusEntry.unstagedChangeType !== undefined) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * The list of files changed but not committed\n     */\n    async getUncommittedChangesAsync() {\n        const result = [];\n        const gitStatusEntries = await this.getGitStatusAsync();\n        for (const gitStatusEntry of gitStatusEntries) {\n            result.push(gitStatusEntry.path);\n        }\n        return result;\n    }\n    getTagSeparator() {\n        return this._rushConfiguration.gitTagSeparator || DEFAULT_GIT_TAG_SEPARATOR;\n    }\n    async getGitStatusAsync() {\n        const gitPath = this.getGitPathOrThrow();\n        // See Git.test.ts for example output\n        const output = await this._executeGitCommandAndCaptureOutputAsync(gitPath, [\n            'status',\n            '--porcelain=2',\n            '--null',\n            '--ignored=no'\n        ]);\n        return parseGitStatus(output);\n    }\n    /**\n     * Git remotes can use different URL syntaxes; this converts them all to a normalized HTTPS\n     * representation for matching purposes.  IF THE INPUT IS NOT ALREADY HTTPS, THE OUTPUT IS\n     * NOT NECESSARILY A VALID GIT URL.\n     *\n     * @example\n     * `git@github.com:ExampleOrg/ExampleProject.git` --> `https://github.com/ExampleOrg/ExampleProject`\n     */\n    static normalizeGitUrlForComparison(gitUrl) {\n        // Git URL formats are documented here: https://www.git-scm.com/docs/git-clone#_git_urls\n        let result = gitUrl.trim();\n        // [user@]host.xz:path/to/repo.git/\n        // \"This syntax is only recognized if there are no slashes before the first colon. This helps\n        // differentiate a local path that contains a colon.\"\n        //\n        // Match patterns like this:\n        //   user@host.ext:path/to/repo\n        //   host.ext:path/to/repo\n        //   localhost:/~user/path/to/repo\n        //\n        // But not:\n        //   http://blah\n        //   c:/windows/path.txt\n        //\n        const scpLikeSyntaxRegExp = /^(?:[^@:\\/]+\\@)?([^:\\/]{2,})\\:((?!\\/\\/).+)$/;\n        // Example: \"user@host.ext:path/to/repo\"\n        const scpLikeSyntaxMatch = scpLikeSyntaxRegExp.exec(gitUrl);\n        if (scpLikeSyntaxMatch) {\n            // Example: \"host.ext\"\n            const host = scpLikeSyntaxMatch[1];\n            // Example: \"path/to/repo\"\n            const urlPath = scpLikeSyntaxMatch[2];\n            if (urlPath.startsWith('/')) {\n                result = `https://${host}${urlPath}`;\n            }\n            else {\n                result = `https://${host}/${urlPath}`;\n            }\n        }\n        const parsedUrl = url.parse(result);\n        // Only convert recognized schemes\n        switch (parsedUrl.protocol) {\n            case 'http:':\n            case 'https:':\n            case 'ssh:':\n            case 'ftp:':\n            case 'ftps:':\n            case 'git:':\n            case 'git+http:':\n            case 'git+https:':\n            case 'git+ssh:':\n            case 'git+ftp:':\n            case 'git+ftps:':\n                // Assemble the parts we want:\n                result = `https://${parsedUrl.host}${parsedUrl.pathname}`;\n                break;\n        }\n        // Trim \".git\" or \".git/\" from the end\n        result = result.replace(/.git\\/?$/, '');\n        return result;\n    }\n    /**\n     * This will throw errors only if we cannot find Git commandline.\n     * If git email didn't configure, this will return undefined; otherwise,\n     * returns user.email config\n     */\n    async tryGetGitEmailAsync() {\n        const { result } = await this._tryGetGitEmailAsync();\n        return result;\n    }\n    /**\n     * Returns an object containing either the result of the `git config user.email`\n     * command or an error.\n     */\n    async _tryGetGitEmailAsync() {\n        if (this._gitEmailResult === undefined) {\n            const gitPath = this.getGitPathOrThrow();\n            try {\n                this._gitEmailResult = {\n                    result: (await this._executeGitCommandAndCaptureOutputAsync(gitPath, ['config', 'user.email'])).trim()\n                };\n            }\n            catch (e) {\n                this._gitEmailResult = {\n                    error: e\n                };\n            }\n        }\n        return this._gitEmailResult;\n    }\n    async _tryGetGitHooksPathAsync() {\n        if (this._gitHooksPath === undefined) {\n            const gitPath = this.getGitPathOrThrow();\n            try {\n                this._gitHooksPath = {\n                    result: (await this._executeGitCommandAndCaptureOutputAsync(gitPath, ['rev-parse', '--git-path', 'hooks'])).trim()\n                };\n            }\n            catch (e) {\n                this._gitHooksPath = {\n                    error: e\n                };\n            }\n        }\n        return this._gitHooksPath;\n    }\n    _tryFetchRemoteBranch(remoteBranchName) {\n        const firstSlashIndex = remoteBranchName.indexOf('/');\n        if (firstSlashIndex === -1) {\n            throw new Error(`Unexpected git remote branch format: ${remoteBranchName}. ` +\n                'Expected branch to be in the <remote>/<branch name> format.');\n        }\n        const remoteName = remoteBranchName.substr(0, firstSlashIndex);\n        const branchName = remoteBranchName.substr(firstSlashIndex + 1);\n        const gitPath = this.getGitPathOrThrow();\n        const spawnResult = Executable.spawnSync(gitPath, ['fetch', '--', remoteName, branchName], {\n            stdio: 'ignore'\n        });\n        return spawnResult.status === 0;\n    }\n    _fetchRemoteBranch(remoteBranchName, terminal) {\n        // eslint-disable-next-line no-console\n        console.log(`Checking for updates to ${remoteBranchName}...`);\n        const fetchResult = this._tryFetchRemoteBranch(remoteBranchName);\n        if (!fetchResult) {\n            terminal.writeWarningLine(`Error fetching git remote branch ${remoteBranchName}. Detected changed files may be incorrect.`);\n        }\n    }\n    /**\n     * @internal\n     */\n    async _executeGitCommandAndCaptureOutputAsync(gitPath, args, repositoryRoot = this._rushConfiguration.rushJsonFolder) {\n        try {\n            return await Utilities.executeCommandAndCaptureOutputAsync(gitPath, args, repositoryRoot);\n        }\n        catch (e) {\n            ensureGitMinimumVersion(gitPath);\n            throw e;\n        }\n    }\n    /**\n     *\n     * @param ref Given a ref which can be branch name, commit hash, tag name, etc, check if it is a commit hash\n     */\n    async determineIfRefIsACommitAsync(ref) {\n        const gitPath = this.getGitPathOrThrow();\n        try {\n            const output = await this._executeGitCommandAndCaptureOutputAsync(gitPath, [\n                'rev-parse',\n                '--verify',\n                ref\n            ]);\n            const result = output.trim();\n            return result === ref;\n        }\n        catch (e) {\n            // assume not a commit\n            return false;\n        }\n    }\n}\n//# sourceMappingURL=Git.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nfunction _parseGitStatusChangeType(str) {\n    switch (str) {\n        case 'M': {\n            return 'modified';\n        }\n        case 'T': {\n            return 'type-changed';\n        }\n        case 'A': {\n            return 'added';\n        }\n        case 'D': {\n            return 'deleted';\n        }\n        case 'R': {\n            return 'renamed';\n        }\n        case 'C': {\n            return 'copied';\n        }\n        case '.': {\n            return undefined;\n        }\n        default: {\n            throw new Error(`Unexpected git status change type: ${str}`);\n        }\n    }\n}\nfunction _parseIsInSubmodule(submoduleState) {\n    // This field is actually four characters long, but this parser only handles if the entry is in a\n    // submodule or not. That is represented by a \"N\" or an \"S\" in the first character.\n    const submoduleMode = submoduleState.charAt(0);\n    if (submoduleMode === 'N') {\n        return false;\n    }\n    else if (submoduleMode === 'S') {\n        return true;\n    }\n    else {\n        throw new Error(`Unexpected submodule state: ${submoduleState}`);\n    }\n}\nexport function* parseGitStatus(gitStatusOutput) {\n    // See reference https://git-scm.com/docs/git-status?msclkid=1cff552bcdce11ecadf77a086eded66c#_porcelain_format_version_2\n    let pos = 0;\n    function getFieldAndAdvancePos(delimiter) {\n        const newPos = gitStatusOutput.indexOf(delimiter, pos);\n        if (newPos === -1) {\n            throw new Error(`Unexpected end of git status output after position ${pos}`);\n        }\n        const field = gitStatusOutput.substring(pos, newPos);\n        pos = newPos + delimiter.length;\n        return field;\n    }\n    /**\n     * @example\n     * ```\n     * ? path/g.ts\n     * ```\n     */\n    function parseUntrackedEntry() {\n        const path = getFieldAndAdvancePos('\\0');\n        const entry = {\n            kind: 'untracked',\n            path\n        };\n        return entry;\n    }\n    /**\n     * @example\n     * ```\n     * 1 A. N... 000000 100644 100644 0000000000000000000000000000000000000000 a171a25d2c978ba071959f39dbeaa339fe84f768 path/a.ts\\0\n     * 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n     * 1 .D N... 100644 100644 000000 3fcb58810c113c90c366dd81d16443425c7b95fa 3fcb58810c113c90c366dd81d16443425c7b95fa path/c.ts\\0\n     * 1 D. N... 100644 000000 000000 91b0203b85a7bb605e35f842d1d05d66a6275e10 0000000000000000000000000000000000000000 path/d.ts\\0\n     * 1 A. N... 000000 100644 100644 0000000000000000000000000000000000000000 451de43c5cb012af55a79cc3463849ab3cfa0457 path/f.ts\\0\n     * 1 AM N... 000000 100644 100644 0000000000000000000000000000000000000000 9d9ab4adc79c591c0aa72f7fd29a008c80893e3e path/h.ts\\0\n     * ```\n     */\n    function parseAddModifyOrDeleteEntry() {\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //   ^\n        const changeTypeField = getFieldAndAdvancePos(' ');\n        const rawStagedChangeType = changeTypeField.charAt(0);\n        const stagedChangeType = _parseGitStatusChangeType(rawStagedChangeType);\n        const rawUnstagedChangeType = changeTypeField.charAt(1);\n        const unstagedChangeType = _parseGitStatusChangeType(rawUnstagedChangeType);\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //      ^\n        const submoduleState = getFieldAndAdvancePos(' ');\n        const isInSubmodule = _parseIsInSubmodule(submoduleState);\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //           ^\n        const headFileMode = getFieldAndAdvancePos(' ');\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //                  ^\n        const indexFileMode = getFieldAndAdvancePos(' ');\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //                         ^\n        const worktreeFileMode = getFieldAndAdvancePos(' ');\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //                                ^\n        const headObjectName = getFieldAndAdvancePos(' ');\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //                                                                         ^\n        const indexObjectName = getFieldAndAdvancePos(' ');\n        // 1 MM N... 100644 100644 100644 d20c7e41acf4295db610f395f50a554145b4ece7 8299b2a7d657ec1211649f14c85737d68a920d9e path/b.ts\\0\n        //                                                                                                                  ^\n        const path = getFieldAndAdvancePos('\\0');\n        const entry = {\n            kind: 'changed',\n            stagedChangeType,\n            unstagedChangeType,\n            isInSubmodule,\n            headFileMode,\n            indexFileMode,\n            worktreeFileMode,\n            headObjectName,\n            indexObjectName,\n            path\n        };\n        return entry;\n    }\n    /**\n     * @example\n     * ```\n     * 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n     * ```\n     */\n    function parseRenamedOrCopiedEntry() {\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //   ^\n        const changeTypeField = getFieldAndAdvancePos(' ');\n        const rawStagedChangeType = changeTypeField.charAt(0);\n        const stagedChangeType = _parseGitStatusChangeType(rawStagedChangeType);\n        const rawUnstagedChangeType = changeTypeField.charAt(1);\n        const unstagedChangeType = _parseGitStatusChangeType(rawUnstagedChangeType);\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //      ^\n        const submoduleState = getFieldAndAdvancePos(' ');\n        const isInSubmodule = _parseIsInSubmodule(submoduleState);\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //           ^\n        const headFileMode = getFieldAndAdvancePos(' ');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                  ^\n        const indexFileMode = getFieldAndAdvancePos(' ');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                         ^\n        const worktreeFileMode = getFieldAndAdvancePos(' ');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                                ^\n        const headObjectName = getFieldAndAdvancePos(' ');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                                                                         ^\n        const indexObjectName = getFieldAndAdvancePos(' ');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                                                                                                                  ^\n        const renameOrCopyScoreField = getFieldAndAdvancePos(' ');\n        const renameOrCopyMode = renameOrCopyScoreField.charAt(0);\n        const rawRenameOrCopyScore = renameOrCopyScoreField.substring(1);\n        const renameOrCopyScore = parseInt(rawRenameOrCopyScore, 10);\n        let kind;\n        if (renameOrCopyMode === 'R') {\n            kind = 'renamed';\n        }\n        else if (renameOrCopyMode === 'C') {\n            kind = 'copied';\n        }\n        else {\n            throw new Error(`Unexpected rename or copy mode: ${renameOrCopyMode}`);\n        }\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                                                                                                                       ^\n        const path = getFieldAndAdvancePos('\\0');\n        // 2 R. N... 100644 100644 100644 451de43c5cb012af55a79cc3463849ab3cfa0457 451de43c5cb012af55a79cc3463849ab3cfa0457 R100 path/e.ts\\0e2.ts\\0\n        //                                                                                                                                  ^\n        const originalPath = getFieldAndAdvancePos('\\0');\n        const entry = {\n            kind,\n            stagedChangeType,\n            unstagedChangeType,\n            isInSubmodule,\n            headFileMode,\n            indexFileMode,\n            worktreeFileMode,\n            headObjectName,\n            indexObjectName,\n            renameOrCopyScore,\n            path,\n            originalPath\n        };\n        return entry;\n    }\n    /**\n     * @example\n     * ```\n     * u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n     * ```\n     */\n    function parseUnmergedEntry() {\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //   ^\n        const changeTypeField = getFieldAndAdvancePos(' ');\n        const rawStagedChangeType = changeTypeField.charAt(0);\n        const stagedChangeType = _parseGitStatusChangeType(rawStagedChangeType);\n        const rawUnstagedChangeType = changeTypeField.charAt(1);\n        const unstagedChangeType = _parseGitStatusChangeType(rawUnstagedChangeType);\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //      ^\n        const submoduleState = getFieldAndAdvancePos(' ');\n        const isInSubmodule = _parseIsInSubmodule(submoduleState);\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //           ^\n        const stage1FileMode = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                  ^\n        const stage2FileMode = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                         ^\n        const stage3FileMode = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                                ^\n        const worktreeFileMode = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                                       ^\n        const stage1ObjectName = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                                                                                ^\n        const stage2ObjectName = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                                                                                                                         ^\n        const stage3ObjectName = getFieldAndAdvancePos(' ');\n        // u .M N... 100644 100644 100644 100644 07b1571a387db3072be485e6cc5591fef35bf666 63f37aa0393e142e2c8329593eb0f78e4cc77032 ebac91ffe8227e6e9b99d9816ce0a6d166b4a524 path/unmerged.ts\\0\n        //                                                                                                                                                                  ^\n        const path = getFieldAndAdvancePos('\\0');\n        const entry = {\n            kind: 'unmerged',\n            stagedChangeType,\n            unstagedChangeType,\n            isInSubmodule,\n            stage1FileMode,\n            stage2FileMode,\n            stage3FileMode,\n            worktreeFileMode,\n            stage1ObjectName,\n            stage2ObjectName,\n            stage3ObjectName,\n            path\n        };\n        return entry;\n    }\n    while (pos < gitStatusOutput.length) {\n        const modeField = getFieldAndAdvancePos(' ');\n        switch (modeField) {\n            case '?': {\n                // Untracked\n                yield parseUntrackedEntry();\n                break;\n            }\n            case '1': {\n                // Simple change\n                yield parseAddModifyOrDeleteEntry();\n                break;\n            }\n            case '2': {\n                // Renamed or copied\n                yield parseRenamedOrCopiedEntry();\n                break;\n            }\n            case 'u': {\n                // Unmerged\n                yield parseUnmergedEntry();\n                break;\n            }\n            default: {\n                throw new Error(`Unexpected git status mode: ${modeField}`);\n            }\n        }\n    }\n}\n//# sourceMappingURL=GitStatusParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * JSON schema URLs that Rush writes into config files.\n */\nexport class JsonSchemaUrls {\n}\nJsonSchemaUrls.approvedPackages = 'https://developer.microsoft.com/json-schemas/rush/v5/approved-packages.schema.json';\nJsonSchemaUrls.commonVersions = 'https://developer.microsoft.com/json-schemas/rush/v5/common-versions.schema.json';\n//# sourceMappingURL=JsonSchemaUrls.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { Colorize } from '@rushstack/terminal';\nimport { RushConstants } from './RushConstants';\n/**\n * This constant is the major version of the next LTS node Node.js release. This constant should be updated when\n * a new LTS version is added to Rush's support matrix.\n *\n * LTS schedule: https://nodejs.org/en/about/releases/\n * LTS versions: https://nodejs.org/en/download/releases/\n */\nconst UPCOMING_NODE_LTS_VERSION = 22;\nconst nodeVersion = process.versions.node;\nconst nodeMajorVersion = semver.major(nodeVersion);\n/**\n * This class provides useful functions for warning if the current Node.js runtime isn't supported.\n *\n * @internal\n */\nexport class NodeJsCompatibility {\n    /**\n     * This reports if the Node.js version is known to have serious incompatibilities.  In that situation, the user\n     * should downgrade Rush to an older release that supported their Node.js version.\n     */\n    static reportAncientIncompatibleVersion() {\n        // IMPORTANT: If this test fails, the Rush CLI front-end process will terminate with an error.\n        // Only increment it when our code base is known to use newer features (e.g. \"async\"/\"await\") that\n        // have no hope of working with older Node.js.\n        if (semver.satisfies(nodeVersion, '<14.18.0')) {\n            // eslint-disable-next-line no-console\n            console.error(Colorize.red(`Your version of Node.js (${nodeVersion}) is very old and incompatible with Rush. ` +\n                `Please upgrade to the latest Long-Term Support (LTS) version.\\n`));\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Detect whether the Node.js version is \"supported\" by the Rush maintainers.  We generally\n     * only support versions that were \"Long Term Support\" (LTS) at the time when Rush was published.\n     *\n     * This is a warning only -- the user is free to ignore it and use Rush anyway.\n     */\n    static warnAboutCompatibilityIssues(options) {\n        // Only show the first warning\n        return (NodeJsCompatibility.reportAncientIncompatibleVersion() ||\n            NodeJsCompatibility.warnAboutVersionTooNew(options) ||\n            NodeJsCompatibility._warnAboutOddNumberedVersion() ||\n            NodeJsCompatibility._warnAboutNonLtsVersion(options.rushConfiguration));\n    }\n    /**\n     * Warn about a Node.js version that has not been tested yet with Rush.\n     */\n    static warnAboutVersionTooNew(options) {\n        if (nodeMajorVersion >= UPCOMING_NODE_LTS_VERSION + 1) {\n            if (!options.alreadyReportedNodeTooNewError) {\n                // We are on a much newer release than we have tested and support\n                if (options.isRushLib) {\n                    // eslint-disable-next-line no-console\n                    console.warn(Colorize.yellow(`Your version of Node.js (${nodeVersion}) has not been tested with this release ` +\n                        `of the Rush engine. Please consider upgrading the \"rushVersion\" setting in ${RushConstants.rushJsonFilename}, ` +\n                        `or downgrading Node.js.\\n`));\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.warn(Colorize.yellow(`Your version of Node.js (${nodeVersion}) has not been tested with this release ` +\n                        `of Rush. Please consider installing a newer version of the \"@microsoft/rush\" ` +\n                        `package, or downgrading Node.js.\\n`));\n                }\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    static _warnAboutNonLtsVersion(rushConfiguration) {\n        if (rushConfiguration && !rushConfiguration.suppressNodeLtsWarning && !NodeJsCompatibility.isLtsVersion) {\n            // eslint-disable-next-line no-console\n            console.warn(Colorize.yellow(`Your version of Node.js (${nodeVersion}) is not a Long-Term Support (LTS) release. ` +\n                'These versions frequently have bugs. Please consider installing a stable release.\\n'));\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    static _warnAboutOddNumberedVersion() {\n        if (NodeJsCompatibility.isOddNumberedVersion) {\n            // eslint-disable-next-line no-console\n            console.warn(Colorize.yellow(`Your version of Node.js (${nodeVersion}) is an odd-numbered release. ` +\n                `These releases frequently have bugs. Please consider installing a Long Term Support (LTS) ` +\n                `version instead.\\n`));\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    static get isLtsVersion() {\n        return !!process.release.lts;\n    }\n    static get isOddNumberedVersion() {\n        return nodeMajorVersion % 2 !== 0;\n    }\n}\n//# sourceMappingURL=NodeJsCompatibility.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * The type of SemVer range specifier that is prepended to the version\n */\nexport var SemVerStyle;\n(function (SemVerStyle) {\n    SemVerStyle[\"Exact\"] = \"exact\";\n    SemVerStyle[\"Caret\"] = \"caret\";\n    SemVerStyle[\"Tilde\"] = \"tilde\";\n    SemVerStyle[\"Passthrough\"] = \"passthrough\";\n})(SemVerStyle || (SemVerStyle = {}));\n//# sourceMappingURL=PackageJsonUpdaterTypes.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nexport class PrereleaseToken {\n    constructor(prereleaseName, suffixName, partialPrerelease = false) {\n        if (prereleaseName && suffixName) {\n            throw new Error('Pre-release name and suffix cannot be provided at the same time.');\n        }\n        this.name = prereleaseName || suffixName;\n        this._prereleaseName = prereleaseName;\n        this._suffixName = suffixName;\n        this._partialPrerelease = partialPrerelease;\n    }\n    get hasValue() {\n        return !!this._prereleaseName || !!this._suffixName;\n    }\n    get isPrerelease() {\n        return !!this._prereleaseName;\n    }\n    get isSuffix() {\n        return !!this._suffixName;\n    }\n    get isPartialPrerelease() {\n        return this.isPrerelease && this._partialPrerelease;\n    }\n}\n//# sourceMappingURL=PrereleaseToken.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport ignore from 'ignore';\nimport { Path, FileSystem, Async, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { getRepoChanges, getRepoRoot, getRepoStateAsync, hashFilesAsync } from '@rushstack/package-deps-hash';\nimport { RushProjectConfiguration } from '../api/RushProjectConfiguration';\nimport { BaseProjectShrinkwrapFile } from './base/BaseProjectShrinkwrapFile';\nimport { PnpmShrinkwrapFile } from './pnpm/PnpmShrinkwrapFile';\nimport { Git } from './Git';\nimport { InputsSnapshot } from './incremental/InputsSnapshot';\n/**\n * @beta\n */\nexport class ProjectChangeAnalyzer {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n        this._git = new Git(this._rushConfiguration);\n    }\n    /**\n     * Gets a list of projects that have changed in the current state of the repo\n     * when compared to the specified branch, optionally taking the shrinkwrap and settings in\n     * the rush-project.json file into consideration.\n     */\n    async getChangedProjectsAsync(options) {\n        const { _rushConfiguration: rushConfiguration } = this;\n        const { targetBranchName, terminal, includeExternalDependencies, enableFiltering, shouldFetch, variant } = options;\n        const gitPath = this._git.getGitPathOrThrow();\n        const repoRoot = getRepoRoot(rushConfiguration.rushJsonFolder);\n        // if the given targetBranchName is a commit, we assume it is the merge base\n        const isTargetBranchACommit = await this._git.determineIfRefIsACommitAsync(targetBranchName);\n        const mergeCommit = isTargetBranchACommit\n            ? targetBranchName\n            : await this._git.getMergeBaseAsync(targetBranchName, terminal, shouldFetch);\n        const changedFiles = getRepoChanges(repoRoot, mergeCommit, gitPath);\n        const lookup = rushConfiguration.getProjectLookupForRoot(repoRoot);\n        const changesByProject = this.getChangesByProject(lookup, changedFiles);\n        const changedProjects = new Set();\n        if (enableFiltering) {\n            // Reading rush-project.json may be problematic if, e.g. rush install has not yet occurred and rigs are in use\n            await Async.forEachAsync(changesByProject, async ([project, projectChanges]) => {\n                const filteredChanges = await this._filterProjectDataAsync(project, projectChanges, repoRoot, terminal);\n                if (filteredChanges.size > 0) {\n                    changedProjects.add(project);\n                }\n            }, { concurrency: 10 });\n        }\n        else {\n            for (const [project, projectChanges] of changesByProject) {\n                if (projectChanges.size > 0) {\n                    changedProjects.add(project);\n                }\n            }\n        }\n        // External dependency changes are not allowed to be filtered, so add these after filtering\n        if (includeExternalDependencies) {\n            // Even though changing the installed version of a nested dependency merits a change file,\n            // ignore lockfile changes for `rush change` for the moment\n            const variantToUse = variant !== null && variant !== void 0 ? variant : (await this._rushConfiguration.getCurrentlyInstalledVariantAsync());\n            const fullShrinkwrapPath = rushConfiguration.defaultSubspace.getCommittedShrinkwrapFilePath(variantToUse);\n            const relativeShrinkwrapFilePath = Path.convertToSlashes(path.relative(repoRoot, fullShrinkwrapPath));\n            const shrinkwrapStatus = changedFiles.get(relativeShrinkwrapFilePath);\n            if (shrinkwrapStatus) {\n                if (shrinkwrapStatus.status !== 'M') {\n                    terminal.writeLine(`Lockfile was created or deleted. Assuming all projects are affected.`);\n                    return new Set(rushConfiguration.projects);\n                }\n                if (rushConfiguration.isPnpm) {\n                    const currentShrinkwrap = PnpmShrinkwrapFile.loadFromFile(fullShrinkwrapPath);\n                    if (!currentShrinkwrap) {\n                        throw new Error(`Unable to obtain current shrinkwrap file.`);\n                    }\n                    const oldShrinkwrapText = await this._git.getBlobContentAsync({\n                        // <ref>:<path> syntax: https://git-scm.com/docs/gitrevisions\n                        blobSpec: `${mergeCommit}:${relativeShrinkwrapFilePath}`,\n                        repositoryRoot: repoRoot\n                    });\n                    const oldShrinkWrap = PnpmShrinkwrapFile.loadFromString(oldShrinkwrapText);\n                    for (const project of rushConfiguration.projects) {\n                        if (currentShrinkwrap\n                            .getProjectShrinkwrap(project)\n                            .hasChanges(oldShrinkWrap.getProjectShrinkwrap(project))) {\n                            changedProjects.add(project);\n                        }\n                    }\n                }\n                else {\n                    terminal.writeLine(`Lockfile has changed and lockfile content comparison is only supported for pnpm. Assuming all projects are affected.`);\n                    return new Set(rushConfiguration.projects);\n                }\n            }\n        }\n        return changedProjects;\n    }\n    getChangesByProject(lookup, changedFiles) {\n        return lookup.groupByChild(changedFiles);\n    }\n    /**\n     * Gets a snapshot of the input state of the Rush workspace that can be queried for incremental\n     * build operations and use by the build cache.\n     * @internal\n     */\n    async _tryGetSnapshotProviderAsync(projectConfigurations, terminal, projectSelection) {\n        var _a, _b;\n        try {\n            const gitPath = this._git.getGitPathOrThrow();\n            if (!this._git.isPathUnderGitWorkingTree()) {\n                terminal.writeLine(`The Rush monorepo is not in a Git repository. Rush will proceed without incremental build support.`);\n                return;\n            }\n            const rushConfiguration = this._rushConfiguration;\n            // Do not use getGitInfo().root; it is the root of the *primary* worktree, not the *current* one.\n            const rootDirectory = getRepoRoot(rushConfiguration.rushJsonFolder, gitPath);\n            // Load the rush-project.json files for the whole repository\n            const additionalGlobs = [];\n            const projectMap = new Map();\n            for (const project of rushConfiguration.projects) {\n                const projectConfig = projectConfigurations.get(project);\n                const additionalFilesByOperationName = new Map();\n                const projectMetadata = {\n                    projectConfig,\n                    additionalFilesByOperationName\n                };\n                projectMap.set(project, projectMetadata);\n                if (projectConfig) {\n                    const { operationSettingsByOperationName } = projectConfig;\n                    for (const [operationName, { dependsOnAdditionalFiles }] of operationSettingsByOperationName) {\n                        if (dependsOnAdditionalFiles) {\n                            const additionalFilesForOperation = new Set();\n                            additionalFilesByOperationName.set(operationName, additionalFilesForOperation);\n                            for (const pattern of dependsOnAdditionalFiles) {\n                                additionalGlobs.push({\n                                    project,\n                                    operationName,\n                                    additionalFilesForOperation,\n                                    pattern\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            // Include project shrinkwrap files as part of the computation\n            const additionalRelativePathsToHash = [];\n            const globalAdditionalFiles = [];\n            if (rushConfiguration.isPnpm) {\n                await Async.forEachAsync(rushConfiguration.projects, async (project) => {\n                    const projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(project);\n                    if (!(await FileSystem.existsAsync(projectShrinkwrapFilePath))) {\n                        if (rushConfiguration.subspacesFeatureEnabled) {\n                            return;\n                        }\n                        throw new Error(`A project dependency file (${projectShrinkwrapFilePath}) is missing. You may need to run ` +\n                            '\"rush install\" or \"rush update\".');\n                    }\n                    const relativeProjectShrinkwrapFilePath = Path.convertToSlashes(path.relative(rootDirectory, projectShrinkwrapFilePath));\n                    additionalRelativePathsToHash.push(relativeProjectShrinkwrapFilePath);\n                });\n            }\n            else {\n                // Add the shrinkwrap file to every project's dependencies\n                const currentVariant = await this._rushConfiguration.getCurrentlyInstalledVariantAsync();\n                const shrinkwrapFile = Path.convertToSlashes(path.relative(rootDirectory, rushConfiguration.defaultSubspace.getCommittedShrinkwrapFilePath(currentVariant)));\n                globalAdditionalFiles.push(shrinkwrapFile);\n            }\n            const lookupByPath = this._rushConfiguration.getProjectLookupForRoot(rootDirectory);\n            let filterPath = [];\n            if (projectSelection &&\n                projectSelection.size > 0 &&\n                this._rushConfiguration.experimentsConfiguration.configuration.enableSubpathScan) {\n                filterPath = Array.from(projectSelection, ({ projectFolder }) => projectFolder);\n            }\n            return async function tryGetSnapshotAsync() {\n                var _a, _b;\n                try {\n                    const [hashes, additionalFiles] = await Promise.all([\n                        getRepoStateAsync(rootDirectory, additionalRelativePathsToHash, gitPath, filterPath),\n                        getAdditionalFilesFromRushProjectConfigurationAsync(additionalGlobs, lookupByPath, rootDirectory, terminal)\n                    ]);\n                    for (const file of additionalFiles) {\n                        if (hashes.has(file)) {\n                            additionalFiles.delete(file);\n                        }\n                    }\n                    const additionalHashes = new Map(await hashFilesAsync(rootDirectory, additionalFiles, gitPath));\n                    return new InputsSnapshot({\n                        additionalHashes,\n                        globalAdditionalFiles,\n                        hashes,\n                        lookupByPath,\n                        projectMap: projectMap,\n                        rootDir: rootDirectory\n                    });\n                }\n                catch (e) {\n                    // If getRepoState fails, don't fail the whole build. Treat this case as if we don't know anything about\n                    // the state of the files in the repo. This can happen if the environment doesn't have Git.\n                    terminal.writeWarningLine(`Error calculating the state of the repo. (inner error: ${(_b = (_a = e.stack) !== null && _a !== void 0 ? _a : e.message) !== null && _b !== void 0 ? _b : e}). Continuing without diffing files.`);\n                    return;\n                }\n            };\n        }\n        catch (e) {\n            // If getRepoState fails, don't fail the whole build. Treat this case as if we don't know anything about\n            // the state of the files in the repo. This can happen if the environment doesn't have Git.\n            terminal.writeWarningLine(`Error calculating the state of the repo. (inner error: ${(_b = (_a = e.stack) !== null && _a !== void 0 ? _a : e.message) !== null && _b !== void 0 ? _b : e}). Continuing without diffing files.`);\n            return;\n        }\n    }\n    /**\n     * @internal\n     */\n    async _filterProjectDataAsync(project, unfilteredProjectData, rootDir, terminal) {\n        const ignoreMatcher = await this._getIgnoreMatcherForProjectAsync(project, terminal);\n        if (!ignoreMatcher) {\n            return unfilteredProjectData;\n        }\n        const projectKey = path.relative(rootDir, project.projectFolder);\n        const projectKeyLength = projectKey.length + 1;\n        // At this point, `filePath` is guaranteed to start with `projectKey`, so\n        // we can safely slice off the first N characters to get the file path relative to the\n        // root of the project.\n        const filteredProjectData = new Map();\n        for (const [filePath, value] of unfilteredProjectData) {\n            const relativePath = filePath.slice(projectKeyLength);\n            if (!ignoreMatcher.ignores(relativePath)) {\n                // Add the file path to the filtered data if it is not ignored\n                filteredProjectData.set(filePath, value);\n            }\n        }\n        return filteredProjectData;\n    }\n    async _getIgnoreMatcherForProjectAsync(project, terminal) {\n        const incrementalBuildIgnoredGlobs = await RushProjectConfiguration.tryLoadIgnoreGlobsForProjectAsync(project, terminal);\n        if (incrementalBuildIgnoredGlobs && incrementalBuildIgnoredGlobs.length) {\n            const ignoreMatcher = ignore();\n            ignoreMatcher.add(incrementalBuildIgnoredGlobs);\n            return ignoreMatcher;\n        }\n    }\n}\nasync function getAdditionalFilesFromRushProjectConfigurationAsync(additionalGlobs, rootRelativeLookupByPath, rootDirectory, terminal) {\n    const additionalFilesFromRushProjectConfiguration = new Set();\n    if (!additionalGlobs.length) {\n        return additionalFilesFromRushProjectConfiguration;\n    }\n    const { default: glob } = await import('fast-glob');\n    await Async.forEachAsync(additionalGlobs, async (item) => {\n        const { project, operationName, additionalFilesForOperation, pattern } = item;\n        const matches = await glob(pattern, {\n            cwd: project.projectFolder,\n            onlyFiles: true,\n            // We want to keep path's type unchanged,\n            // i.e. if the pattern was a  relative path, then matched paths should also be relative paths\n            //      if the pattern was an absolute path, then matched paths should also be absolute paths\n            //\n            // We are doing this because these paths are going to be used to calculate operation state hashes and some users\n            // might choose to depend on global files (e.g. `/etc/os-release`) and some might choose to depend on local non-project files\n            // (e.g. `../path/to/workspace/file`)\n            //\n            // In both cases we want that path to the resource to be the same on all machines,\n            // regardless of what is the current working directory.\n            //\n            // That being said, we want to keep `absolute` options here as false:\n            absolute: false\n        });\n        for (const match of matches) {\n            // The glob result is relative to the project folder, but we want it to be relative to the repo root\n            const rootRelativeFilePath = Path.convertToSlashes(path.relative(rootDirectory, path.resolve(project.projectFolder, match)));\n            if (rootRelativeFilePath.startsWith('../')) {\n                // The target file is outside of the Git tree, use the original result of the match.\n                additionalFilesFromRushProjectConfiguration.add(match);\n                additionalFilesForOperation.add(match);\n            }\n            else {\n                // The target file is inside of the Git tree, find out if it is in a Rush project.\n                const projectMatch = rootRelativeLookupByPath.findChildPath(rootRelativeFilePath);\n                if (projectMatch && projectMatch !== project) {\n                    terminal.writeErrorLine(`In project \"${project.packageName}\" (\"${project.projectRelativeFolder}\"), ` +\n                        `config for operation \"${operationName}\" specifies a glob \"${pattern}\" that selects a file \"${rootRelativeFilePath}\" in a different workspace project ` +\n                        `\"${projectMatch.packageName}\" (\"${projectMatch.projectRelativeFolder}\"). ` +\n                        `This is forbidden. The \"dependsOnAdditionalFiles\" property of \"rush-project.json\" may only be used to refer to non-workspace files, non-project files, ` +\n                        `or untracked files in the current project. To depend on files in another workspace project, use \"devDependencies\" in \"package.json\".`);\n                    throw new AlreadyReportedError();\n                }\n                additionalFilesForOperation.add(rootRelativeFilePath);\n                additionalFilesFromRushProjectConfiguration.add(rootRelativeFilePath);\n            }\n        }\n    });\n    return additionalFilesFromRushProjectConfiguration;\n}\n//# sourceMappingURL=ProjectChangeAnalyzer.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Parses the \"scripts\" section from package.json and provides support for executing scripts.\n */\nexport class ProjectCommandSet {\n    constructor(packageJson) {\n        this.malformedScriptNames = [];\n        this.commandNames = [];\n        this._scriptsByName = new Map();\n        const scripts = packageJson.scripts || {};\n        for (const scriptName of Object.keys(scripts)) {\n            if (scriptName[0] === '-' || scriptName.length === 0) {\n                this.malformedScriptNames.push(scriptName);\n            }\n            else {\n                this.commandNames.push(scriptName);\n                this._scriptsByName.set(scriptName, scripts[scriptName]);\n            }\n        }\n        this.commandNames.sort();\n    }\n    tryGetScriptBody(commandName) {\n        return this._scriptsByName.get(commandName);\n    }\n    getScriptBody(commandName) {\n        const result = this.tryGetScriptBody(commandName);\n        if (result === undefined) {\n            throw new Error(`The command \"${commandName}\" was not found`);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=ProjectCommandSet.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PublishUtilities } from './PublishUtilities';\nimport { Utilities } from '../utilities/Utilities';\nconst DUMMY_BRANCH_NAME = '-branch-name-';\nexport class PublishGit {\n    constructor(git, targetBranch) {\n        this._targetBranch = targetBranch;\n        this._gitPath = git.getGitPathOrThrow();\n        this._gitTagSeparator = git.getTagSeparator();\n    }\n    async checkoutAsync(branchName, createBranch = false) {\n        const params = ['checkout'];\n        if (createBranch) {\n            params.push('-b');\n        }\n        params.push(branchName || DUMMY_BRANCH_NAME);\n        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, params);\n    }\n    async mergeAsync(branchName, verify = false) {\n        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, [\n            'merge',\n            branchName,\n            '--no-edit',\n            ...(verify ? [] : ['--no-verify'])\n        ]);\n    }\n    async deleteBranchAsync(branchName, hasRemote = true, verify = false) {\n        if (!branchName) {\n            branchName = DUMMY_BRANCH_NAME;\n        }\n        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, [\n            'branch',\n            '-d',\n            branchName\n        ]);\n        if (hasRemote) {\n            await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, [\n                'push',\n                'origin',\n                '--delete',\n                branchName,\n                ...(verify ? [] : ['--no-verify'])\n            ]);\n        }\n    }\n    async pullAsync(verify = false) {\n        const params = ['pull', 'origin'];\n        if (this._targetBranch) {\n            params.push(this._targetBranch);\n        }\n        if (!verify) {\n            params.push('--no-verify');\n        }\n        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, params);\n    }\n    async fetchAsync() {\n        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, ['fetch', 'origin']);\n    }\n    async addChangesAsync(pathspec, workingDirectory) {\n        const files = pathspec ? pathspec : '.';\n        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, ['add', files], workingDirectory ? workingDirectory : process.cwd());\n    }\n    async addTagAsync(shouldExecute, packageName, packageVersion, commitId, preReleaseName) {\n        // Tagging only happens if we're publishing to real NPM and committing to git.\n        const tagName = PublishUtilities.createTagname(packageName, packageVersion, this._gitTagSeparator);\n        await PublishUtilities.execCommandAsync(!!this._targetBranch && shouldExecute, this._gitPath, [\n            'tag',\n            '-a',\n            preReleaseName ? `${tagName}-${preReleaseName}` : tagName,\n            '-m',\n            preReleaseName\n                ? `${packageName} v${packageVersion}-${preReleaseName}`\n                : `${packageName} v${packageVersion}`,\n            ...(commitId ? [commitId] : [])\n        ]);\n    }\n    async hasTagAsync(packageConfig) {\n        const tagName = PublishUtilities.createTagname(packageConfig.packageName, packageConfig.packageJson.version, this._gitTagSeparator);\n        const tagOutput = (await Utilities.executeCommandAndCaptureOutputAsync(this._gitPath, ['tag', '-l', tagName], packageConfig.projectFolder, PublishUtilities.getEnvArgs(), true)).replace(/(\\r\\n|\\n|\\r)/gm, '');\n        return tagOutput === tagName;\n    }\n    async commitAsync(commitMessage, verify = false) {\n        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, [\n            'commit',\n            '-m',\n            commitMessage,\n            ...(verify ? [] : ['--no-verify'])\n        ]);\n    }\n    async pushAsync(branchName, verify = false) {\n        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, \n        // We append \"--no-verify\" to prevent Git hooks from running.  For example, people may\n        // want to invoke \"rush change -v\" as a pre-push hook.\n        [\n            'push',\n            'origin',\n            `HEAD:${branchName || DUMMY_BRANCH_NAME}`,\n            '--follow-tags',\n            '--verbose',\n            ...(verify ? [] : ['--no-verify'])\n        ]);\n    }\n}\n//# sourceMappingURL=PublishGit.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * This file contains a set of helper functions that are unit tested and used with the PublishAction,\n * which itself is a thin wrapper around these helpers.\n */\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { execSync } from 'child_process';\nimport { JsonFile, FileConstants, Text, Enum, InternalError } from '@rushstack/node-core-library';\nimport { ChangeType } from '../api/ChangeManagement';\nimport { Utilities } from '../utilities/Utilities';\nimport { DependencySpecifier, DependencySpecifierType } from './DependencySpecifier';\nimport { Git, DEFAULT_GIT_TAG_SEPARATOR } from './Git';\nconst MAGIC_SPECIFIERS = new Set(['*', '^', '~']);\nexport class PublishUtilities {\n    /**\n     * Finds change requests in the given folder.\n     * @param changesPath Path to the changes folder.\n     * @returns Dictionary of all change requests, keyed by package name.\n     */\n    static async findChangeRequestsAsync(allPackages, rushConfiguration, changeFiles, includeCommitDetails, prereleaseToken, projectsToExclude) {\n        const allChanges = {\n            packageChanges: new Map(),\n            versionPolicyChanges: new Map()\n        };\n        // eslint-disable-next-line no-console\n        console.log(`Finding changes in: ${changeFiles.getChangesPath()}`);\n        const files = await changeFiles.getFilesAsync();\n        // Add the minimum changes defined by the change descriptions.\n        for (const changeFilePath of files) {\n            const changeRequest = JsonFile.load(changeFilePath);\n            if (includeCommitDetails) {\n                const git = new Git(rushConfiguration);\n                PublishUtilities._updateCommitDetails(git, changeFilePath, changeRequest.changes);\n            }\n            for (const change of changeRequest.changes) {\n                PublishUtilities._addChange({\n                    change,\n                    changeFilePath,\n                    allChanges,\n                    allPackages,\n                    rushConfiguration,\n                    prereleaseToken,\n                    projectsToExclude\n                });\n            }\n        }\n        // keep resolving downstream dependency changes and version policy changes\n        // until no more changes are detected\n        let hasChanges;\n        do {\n            hasChanges = false;\n            // For each requested package change, ensure downstream dependencies are also updated.\n            allChanges.packageChanges.forEach((change, packageName) => {\n                hasChanges =\n                    PublishUtilities._updateDownstreamDependencies(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;\n            });\n            // Bump projects affected by the version policy changes.\n            allPackages.forEach((project) => {\n                const versionPolicyChange = project.versionPolicyName !== undefined\n                    ? allChanges.versionPolicyChanges.get(project.versionPolicyName)\n                    : undefined;\n                if (versionPolicyChange === undefined) {\n                    return;\n                }\n                const projectHasChanged = this._addChange({\n                    change: {\n                        packageName: project.packageName,\n                        changeType: versionPolicyChange.changeType,\n                        newVersion: versionPolicyChange.newVersion // enforce the specific policy version\n                    },\n                    allChanges,\n                    allPackages,\n                    rushConfiguration,\n                    prereleaseToken,\n                    projectsToExclude\n                });\n                if (projectHasChanged) {\n                    // eslint-disable-next-line no-console\n                    console.log(`\\n* APPLYING: update ${project.packageName} to version ${versionPolicyChange.newVersion}`);\n                }\n                hasChanges = projectHasChanged || hasChanges;\n            });\n        } while (hasChanges);\n        // Update orders so that downstreams are marked to come after upstreams.\n        allChanges.packageChanges.forEach((change, packageName) => {\n            const project = allPackages.get(packageName);\n            const packageJson = project.packageJson;\n            const deps = project.consumingProjects;\n            // Write the new version expected for the change.\n            const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);\n            if (skipVersionBump) {\n                change.newVersion = packageJson.version;\n            }\n            else {\n                // For hotfix changes, do not re-write new version\n                change.newVersion =\n                    change.changeType >= ChangeType.patch\n                        ? semver.inc(packageJson.version, PublishUtilities._getReleaseType(change.changeType))\n                        : change.changeType === ChangeType.hotfix\n                            ? change.newVersion\n                            : packageJson.version;\n            }\n            if (deps) {\n                for (const dep of deps) {\n                    const depChange = allChanges.packageChanges.get(dep.packageName);\n                    if (depChange) {\n                        depChange.order = Math.max(change.order + 1, depChange.order);\n                    }\n                }\n            }\n        });\n        return allChanges;\n    }\n    /**\n     * Given the changes hash, flattens them into a sorted array based on their dependency order.\n     * @params packageChanges - hash of change requests.\n     * @returns Sorted array of change requests.\n     */\n    static sortChangeRequests(packageChanges) {\n        return [...packageChanges.values()].sort((a, b) => a.order === b.order ? a.packageName.localeCompare(b.packageName) : a.order < b.order ? -1 : 1);\n    }\n    /**\n     * Given a single change request, updates the package json file with updated versions on disk.\n     */\n    static updatePackages(allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude) {\n        const updatedPackages = new Map();\n        allChanges.packageChanges.forEach((change, packageName) => {\n            const updatedPackage = PublishUtilities._writePackageChanges(change, allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude);\n            updatedPackages.set(updatedPackage.name, updatedPackage);\n        });\n        return updatedPackages;\n    }\n    /**\n     * Returns the generated tagname to use for a published commit, given package name and version.\n     */\n    static createTagname(packageName, version, separator = DEFAULT_GIT_TAG_SEPARATOR) {\n        return packageName + `${separator}v` + version;\n    }\n    static isRangeDependency(version) {\n        const LOOSE_PKG_REGEX = />=?(?:\\d+\\.){2}\\d+(\\-[0-9A-Za-z-.]*)?\\s+<(?:\\d+\\.){2}\\d+/;\n        return LOOSE_PKG_REGEX.test(version);\n    }\n    static getEnvArgs() {\n        const env = {};\n        // Copy existing process.env values (for nodist)\n        Object.keys(process.env).forEach((key) => {\n            env[key] = process.env[key];\n        });\n        return env;\n    }\n    /**\n     * @param secretSubstring -- if specified, a substring to be replaced by `<<SECRET>>` to avoid printing secrets\n     * on the console\n     */\n    static async execCommandAsync(shouldExecute, command, args = [], workingDirectory = process.cwd(), environment, secretSubstring) {\n        let relativeDirectory = path.relative(process.cwd(), workingDirectory);\n        if (relativeDirectory) {\n            relativeDirectory = `(${relativeDirectory})`;\n        }\n        let commandArgs = args.join(' ');\n        if (secretSubstring && secretSubstring.length > 0) {\n            // Avoid printing the NPM publish token on the console when displaying the commandArgs\n            commandArgs = Text.replaceAll(commandArgs, secretSubstring, '<<SECRET>>');\n        }\n        // eslint-disable-next-line no-console\n        console.log(`\\n* ${shouldExecute ? 'EXECUTING' : 'DRYRUN'}: ${command} ${commandArgs} ${relativeDirectory}`);\n        if (shouldExecute) {\n            await Utilities.executeCommandAsync({\n                command,\n                args,\n                workingDirectory,\n                environment,\n                suppressOutput: false,\n                keepEnvironment: true\n            });\n        }\n    }\n    static getNewDependencyVersion(dependencies, dependencyName, newProjectVersion) {\n        const currentDependencySpecifier = new DependencySpecifier(dependencyName, dependencies[dependencyName]);\n        const currentDependencyVersion = currentDependencySpecifier.versionSpecifier;\n        let newDependencyVersion;\n        if (MAGIC_SPECIFIERS.has(currentDependencyVersion)) {\n            // pnpm and yarn support `workspace:*', `workspace:~`, and `workspace:^` as valid version specifiers\n            // These translate as `current`, `~current`, and `^current` when published\n            newDependencyVersion = currentDependencyVersion;\n        }\n        else if (PublishUtilities.isRangeDependency(currentDependencyVersion)) {\n            newDependencyVersion = PublishUtilities._getNewRangeDependency(newProjectVersion);\n        }\n        else if (currentDependencyVersion.lastIndexOf('~', 0) === 0) {\n            newDependencyVersion = '~' + newProjectVersion;\n        }\n        else if (currentDependencyVersion.lastIndexOf('^', 0) === 0) {\n            newDependencyVersion = '^' + newProjectVersion;\n        }\n        else {\n            newDependencyVersion = newProjectVersion;\n        }\n        return currentDependencySpecifier.specifierType === DependencySpecifierType.Workspace\n            ? `workspace:${newDependencyVersion}`\n            : newDependencyVersion;\n    }\n    static _getReleaseType(changeType) {\n        switch (changeType) {\n            case ChangeType.major:\n                return 'major';\n            case ChangeType.minor:\n                return 'minor';\n            case ChangeType.patch:\n                return 'patch';\n            case ChangeType.hotfix:\n                return 'prerelease';\n            default:\n                throw new Error(`Wrong change type ${changeType}`);\n        }\n    }\n    static _getNewRangeDependency(newVersion) {\n        let upperLimit = newVersion;\n        if (semver.prerelease(newVersion)) {\n            // Remove the prerelease first, then bump major.\n            upperLimit = semver.inc(newVersion, 'patch');\n        }\n        upperLimit = semver.inc(upperLimit, 'major');\n        return `>=${newVersion} <${upperLimit}`;\n    }\n    static _shouldSkipVersionBump(project, prereleaseToken, projectsToExclude) {\n        // Suffix does not bump up the version.\n        // Excluded projects do not bump up version.\n        return ((prereleaseToken && prereleaseToken.isSuffix) ||\n            (projectsToExclude && projectsToExclude.has(project.packageName)) ||\n            !project.shouldPublish);\n    }\n    static _updateCommitDetails(git, filename, changes) {\n        try {\n            const gitPath = git.getGitPathOrThrow();\n            const fileLog = execSync(`${gitPath} log -n 1 ${filename}`, {\n                cwd: path.dirname(filename)\n            }).toString();\n            const author = fileLog.match(/Author: (.*)/)[1];\n            const commit = fileLog.match(/commit (.*)/)[1];\n            changes.forEach((change) => {\n                change.author = author;\n                change.commit = commit;\n            });\n        }\n        catch (e) {\n            /* no-op, best effort. */\n        }\n    }\n    static _writePackageChanges(change, allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude) {\n        const project = allPackages.get(change.packageName);\n        const packageJson = project.packageJson;\n        const shouldSkipVersionBump = !project.shouldPublish || (!!projectsToExclude && projectsToExclude.has(change.packageName));\n        const newVersion = shouldSkipVersionBump\n            ? packageJson.version\n            : PublishUtilities._getChangeInfoNewVersion(change, prereleaseToken);\n        if (!shouldSkipVersionBump) {\n            // eslint-disable-next-line no-console\n            console.log(`\\n* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ${ChangeType[change.changeType]} update ` +\n                `for ${change.packageName} to ${newVersion}`);\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.log(`\\n* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: update for ${change.packageName} at ${newVersion}`);\n        }\n        const packagePath = path.join(project.projectFolder, FileConstants.PackageJson);\n        packageJson.version = newVersion;\n        // Update the package's dependencies.\n        PublishUtilities._updateDependencies(packageJson.name, packageJson.dependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);\n        // Update the package's dev dependencies.\n        PublishUtilities._updateDependencies(packageJson.name, packageJson.devDependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);\n        // Update the package's peer dependencies.\n        PublishUtilities._updateDependencies(packageJson.name, packageJson.peerDependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);\n        change.changes.forEach((subChange) => {\n            if (subChange.comment) {\n                // eslint-disable-next-line no-console\n                console.log(` - [${ChangeType[subChange.changeType]}] ${subChange.comment}`);\n            }\n        });\n        if (shouldCommit) {\n            JsonFile.save(packageJson, packagePath, { updateExistingFile: true });\n        }\n        return packageJson;\n    }\n    static _isCyclicDependency(allPackages, packageName, dependencyName) {\n        const packageConfig = allPackages.get(packageName);\n        return !!packageConfig && packageConfig.decoupledLocalDependencies.has(dependencyName);\n    }\n    static _updateDependencies(packageName, dependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {\n        if (dependencies) {\n            Object.keys(dependencies).forEach((depName) => {\n                if (!PublishUtilities._isCyclicDependency(allPackages, packageName, depName)) {\n                    const depChange = allChanges.packageChanges.get(depName);\n                    if (!depChange) {\n                        return;\n                    }\n                    const depProject = allPackages.get(depName);\n                    if (!depProject.shouldPublish || (projectsToExclude && projectsToExclude.has(depName))) {\n                        // No version change.\n                        return;\n                    }\n                    else if (prereleaseToken &&\n                        prereleaseToken.hasValue &&\n                        prereleaseToken.isPartialPrerelease &&\n                        depChange.changeType < ChangeType.hotfix) {\n                        // For partial prereleases, do not version bump dependencies with the `prereleaseToken`\n                        // value unless an actual change (hotfix, patch, minor, major) has occurred\n                        return;\n                    }\n                    else if (depChange && prereleaseToken && prereleaseToken.hasValue) {\n                        // TODO: treat prerelease version the same as non-prerelease version.\n                        // For prerelease, the newVersion needs to be appended with prerelease name.\n                        // And dependency should specify the specific prerelease version.\n                        const currentSpecifier = new DependencySpecifier(depName, dependencies[depName]);\n                        const newVersion = PublishUtilities._getChangeInfoNewVersion(depChange, prereleaseToken);\n                        dependencies[depName] =\n                            currentSpecifier.specifierType === DependencySpecifierType.Workspace\n                                ? `workspace:${newVersion}`\n                                : newVersion;\n                    }\n                    else if (depChange && depChange.changeType >= ChangeType.hotfix) {\n                        PublishUtilities._updateDependencyVersion(packageName, dependencies, depName, depChange, allChanges, allPackages, rushConfiguration);\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Gets the new version from the ChangeInfo.\n     * The value of newVersion in ChangeInfo remains unchanged when the change type is dependency,\n     * However, for pre-release build, it won't pick up the updated pre-released dependencies. That is why\n     * this function should return a pre-released patch for that case. The exception to this is when we're\n     * running a partial pre-release build. In this case, only user-changed packages should update.\n     */\n    static _getChangeInfoNewVersion(change, prereleaseToken) {\n        let newVersion = change.newVersion;\n        if (prereleaseToken && prereleaseToken.hasValue) {\n            if (prereleaseToken.isPartialPrerelease && change.changeType <= ChangeType.hotfix) {\n                return newVersion;\n            }\n            if (prereleaseToken.isPrerelease && change.changeType === ChangeType.dependency) {\n                newVersion = semver.inc(newVersion, 'patch');\n            }\n            return `${newVersion}-${prereleaseToken.name}`;\n        }\n        else {\n            return newVersion;\n        }\n    }\n    /**\n     * Adds the given change to the packageChanges map.\n     *\n     * @returns true if the change caused the dependency change type to increase.\n     */\n    static _addChange({ change, changeFilePath, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude }) {\n        var _a, _b, _c;\n        let hasChanged = false;\n        const packageName = change.packageName;\n        const project = allPackages.get(packageName);\n        if (!project) {\n            // eslint-disable-next-line no-console\n            console.log(`The package ${packageName} was requested for publishing but does not exist. Skip this change.`);\n            return false;\n        }\n        const packageJson = project.packageJson;\n        // If the given change does not have a changeType, derive it from the \"type\" string.\n        if (change.changeType === undefined) {\n            change.changeType = Enum.tryGetValueByKey(ChangeType, change.type);\n            if (change.changeType === undefined) {\n                if (changeFilePath) {\n                    throw new Error(`Invalid change type ${JSON.stringify(change.type)} in ${changeFilePath}`);\n                }\n                else {\n                    throw new InternalError(`Invalid change type ${JSON.stringify(change.type)}`);\n                }\n            }\n        }\n        let currentChange = allChanges.packageChanges.get(packageName);\n        if (currentChange === undefined) {\n            hasChanged = true;\n            currentChange = {\n                packageName,\n                changeType: change.changeType,\n                order: 0,\n                changes: [change]\n            };\n            allChanges.packageChanges.set(packageName, currentChange);\n        }\n        else {\n            const oldChangeType = currentChange.changeType;\n            if (oldChangeType === ChangeType.hotfix && change.changeType > oldChangeType) {\n                throw new Error(`Cannot apply ${this._getReleaseType(change.changeType)} change after hotfix on same package`);\n            }\n            if (change.changeType === ChangeType.hotfix && oldChangeType > change.changeType) {\n                throw new Error(`Cannot apply hotfix alongside ${this._getReleaseType(oldChangeType)} change on same package`);\n            }\n            currentChange.changeType = Math.max(currentChange.changeType, change.changeType);\n            currentChange.changes.push(change);\n            hasChanged = hasChanged || oldChangeType !== currentChange.changeType;\n            hasChanged =\n                hasChanged ||\n                    (change.newVersion !== undefined &&\n                        currentChange.newVersion !== undefined &&\n                        semver.gt(change.newVersion, currentChange.newVersion));\n        }\n        const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);\n        if (skipVersionBump) {\n            currentChange.newVersion = (_a = change.newVersion) !== null && _a !== void 0 ? _a : packageJson.version;\n            hasChanged = false;\n            currentChange.changeType = ChangeType.none;\n        }\n        else {\n            if (change.changeType === ChangeType.hotfix) {\n                const prereleaseComponents = semver.prerelease(packageJson.version);\n                if (!rushConfiguration.hotfixChangeEnabled) {\n                    throw new Error(`Cannot add hotfix change; hotfixChangeEnabled is false in configuration.`);\n                }\n                currentChange.newVersion = (_b = change.newVersion) !== null && _b !== void 0 ? _b : packageJson.version;\n                if (!prereleaseComponents) {\n                    currentChange.newVersion += '-hotfix';\n                }\n                currentChange.newVersion = semver.inc(currentChange.newVersion, 'prerelease');\n            }\n            else {\n                // When there are multiple changes of this package, the final value of new version\n                // should not depend on the order of the changes.\n                let packageVersion = (_c = change.newVersion) !== null && _c !== void 0 ? _c : packageJson.version;\n                if (currentChange.newVersion && semver.gt(currentChange.newVersion, packageVersion)) {\n                    packageVersion = currentChange.newVersion;\n                }\n                const shouldBump = change.newVersion === undefined && change.changeType >= ChangeType.hotfix;\n                currentChange.newVersion = shouldBump\n                    ? semver.inc(packageVersion, PublishUtilities._getReleaseType(currentChange.changeType))\n                    : packageVersion;\n                // set versionpolicy version to the current version\n                if (hasChanged &&\n                    project.versionPolicyName !== undefined &&\n                    project.versionPolicy !== undefined &&\n                    project.versionPolicy.isLockstepped) {\n                    const projectVersionPolicy = project.versionPolicy;\n                    const currentVersionPolicyChange = allChanges.versionPolicyChanges.get(project.versionPolicyName);\n                    if (projectVersionPolicy.nextBump === undefined &&\n                        (currentVersionPolicyChange === undefined ||\n                            semver.gt(currentChange.newVersion, currentVersionPolicyChange.newVersion))) {\n                        allChanges.versionPolicyChanges.set(project.versionPolicyName, {\n                            versionPolicyName: project.versionPolicyName,\n                            changeType: currentChange.changeType,\n                            newVersion: currentChange.newVersion\n                        });\n                    }\n                }\n            }\n            // If hotfix change, force new range dependency to be the exact new version\n            currentChange.newRangeDependency =\n                change.changeType === ChangeType.hotfix\n                    ? currentChange.newVersion\n                    : PublishUtilities._getNewRangeDependency(currentChange.newVersion);\n        }\n        return hasChanged;\n    }\n    static _updateDownstreamDependencies(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {\n        let hasChanges = false;\n        const packageName = change.packageName;\n        const downstream = allPackages.get(packageName).consumingProjects;\n        // Iterate through all downstream dependencies for the package.\n        if (downstream) {\n            if (change.changeType >= ChangeType.hotfix || (prereleaseToken && prereleaseToken.hasValue)) {\n                for (const dependency of downstream) {\n                    const packageJson = dependency.packageJson;\n                    hasChanges =\n                        PublishUtilities._updateDownstreamDependency(packageJson.name, packageJson.dependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;\n                    hasChanges =\n                        PublishUtilities._updateDownstreamDependency(packageJson.name, packageJson.devDependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;\n                }\n            }\n        }\n        return hasChanges;\n    }\n    static _updateDownstreamDependency(parentPackageName, dependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {\n        let hasChanges = false;\n        if (dependencies &&\n            dependencies[change.packageName] &&\n            !PublishUtilities._isCyclicDependency(allPackages, parentPackageName, change.packageName)) {\n            const requiredVersion = new DependencySpecifier(change.packageName, dependencies[change.packageName]);\n            const isWorkspaceWildcardVersion = requiredVersion.specifierType === DependencySpecifierType.Workspace &&\n                MAGIC_SPECIFIERS.has(requiredVersion.versionSpecifier);\n            const isPrerelease = !!prereleaseToken && prereleaseToken.hasValue && !allChanges.packageChanges.has(parentPackageName);\n            // If the version range exists and has not yet been updated to this version, update it.\n            if (isPrerelease ||\n                isWorkspaceWildcardVersion ||\n                requiredVersion.versionSpecifier !== change.newRangeDependency) {\n                let changeType;\n                // Propagate hotfix changes to dependencies\n                if (change.changeType === ChangeType.hotfix) {\n                    changeType = ChangeType.hotfix;\n                }\n                else {\n                    // Either it already satisfies the new version, or doesn't.\n                    // If not, the downstream dep needs to be republished.\n                    // The downstream dep will also need to be republished if using `workspace:*` as this will publish\n                    // as the exact version.\n                    changeType =\n                        !isWorkspaceWildcardVersion &&\n                            semver.satisfies(change.newVersion, requiredVersion.versionSpecifier)\n                            ? ChangeType.dependency\n                            : ChangeType.patch;\n                }\n                hasChanges = PublishUtilities._addChange({\n                    change: {\n                        packageName: parentPackageName,\n                        changeType\n                    },\n                    allChanges,\n                    allPackages,\n                    rushConfiguration,\n                    prereleaseToken,\n                    projectsToExclude\n                });\n                if (hasChanges || isPrerelease) {\n                    // Only re-evaluate downstream dependencies if updating the parent package's dependency\n                    // caused a version bump.\n                    hasChanges =\n                        PublishUtilities._updateDownstreamDependencies(allChanges.packageChanges.get(parentPackageName), allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;\n                }\n            }\n        }\n        return hasChanges;\n    }\n    static _getPublishDependencyVersion(specifier, newVersion) {\n        if (specifier.specifierType === DependencySpecifierType.Workspace) {\n            const { versionSpecifier } = specifier;\n            switch (versionSpecifier) {\n                case '*':\n                    return newVersion;\n                case '~':\n                case '^':\n                    return `${versionSpecifier}${newVersion}`;\n            }\n        }\n        return newVersion;\n    }\n    static _updateDependencyVersion(packageName, dependencies, dependencyName, dependencyChange, allChanges, allPackages, rushConfiguration) {\n        let currentDependencyVersion = dependencies[dependencyName];\n        let newDependencyVersion = PublishUtilities.getNewDependencyVersion(dependencies, dependencyName, dependencyChange.newVersion);\n        dependencies[dependencyName] = newDependencyVersion;\n        // \"*\", \"~\", and \"^\" are special cases for workspace ranges, since it will publish using the exact\n        // version of the local dependency, so we need to modify what we write for our change\n        // comment\n        const currentDependencySpecifier = new DependencySpecifier(dependencyName, currentDependencyVersion);\n        currentDependencyVersion =\n            currentDependencySpecifier.specifierType === DependencySpecifierType.Workspace &&\n                MAGIC_SPECIFIERS.has(currentDependencySpecifier.versionSpecifier)\n                ? undefined\n                : currentDependencySpecifier.versionSpecifier;\n        const newDependencySpecifier = new DependencySpecifier(dependencyName, newDependencyVersion);\n        newDependencyVersion = PublishUtilities._getPublishDependencyVersion(newDependencySpecifier, dependencyChange.newVersion);\n        // Add dependency version update comment.\n        PublishUtilities._addChange({\n            change: {\n                packageName: packageName,\n                changeType: ChangeType.dependency,\n                comment: `Updating dependency \"${dependencyName}\" ` +\n                    (currentDependencyVersion ? `from \\`${currentDependencyVersion}\\` ` : '') +\n                    `to \\`${newDependencyVersion}\\``\n            },\n            allChanges,\n            allPackages,\n            rushConfiguration\n        });\n    }\n}\n//# sourceMappingURL=PublishUtilities.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { Colorize } from '@rushstack/terminal';\nimport { AsyncRecycler } from '../utilities/AsyncRecycler';\nimport { RushConstants } from './RushConstants';\n/**\n * This class implements the logic for \"rush purge\"\n */\nexport class PurgeManager {\n    constructor(rushConfiguration, rushGlobalFolder) {\n        this._rushConfiguration = rushConfiguration;\n        this._rushGlobalFolder = rushGlobalFolder;\n        const commonAsyncRecyclerPath = path.join(this._rushConfiguration.commonTempFolder, RushConstants.rushRecyclerFolderName);\n        this.commonTempFolderRecycler = new AsyncRecycler(commonAsyncRecyclerPath);\n        const rushUserAsyncRecyclerPath = path.join(this._rushGlobalFolder.path, RushConstants.rushRecyclerFolderName);\n        this._rushUserFolderRecycler = new AsyncRecycler(rushUserAsyncRecyclerPath);\n    }\n    /**\n     * Performs the AsyncRecycler.deleteAll() operation.  This should be called before\n     * the PurgeManager instance is disposed.\n     */\n    async startDeleteAllAsync() {\n        await Promise.all([\n            this.commonTempFolderRecycler.startDeleteAllAsync(),\n            this._rushUserFolderRecycler.startDeleteAllAsync()\n        ]);\n    }\n    /**\n     * Delete everything from the common/temp folder\n     */\n    purgeNormal() {\n        // Delete everything under common\\temp except for the recycler folder itself\n        // eslint-disable-next-line no-console\n        console.log('Purging ' + this._rushConfiguration.commonTempFolder);\n        this.commonTempFolderRecycler.moveAllItemsInFolder(this._rushConfiguration.commonTempFolder, this._getMembersToExclude(this._rushConfiguration.commonTempFolder, true));\n    }\n    /**\n     * In addition to performing the purgeNormal() operation, this method also cleans the\n     * .rush folder in the user's home directory.\n     */\n    purgeUnsafe() {\n        this.purgeNormal();\n        // We will delete everything under ~/.rush/ except for the recycler folder itself\n        // eslint-disable-next-line no-console\n        console.log('Purging ' + this._rushGlobalFolder.path);\n        // If Rush itself is running under a folder such as  ~/.rush/node-v4.5.6/rush-1.2.3,\n        // we cannot delete that folder.\n        // First purge the node-specific folder, e.g. ~/.rush/node-v4.5.6/* except for rush-1.2.3:\n        this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushGlobalFolder.nodeSpecificPath, this._getMembersToExclude(this._rushGlobalFolder.nodeSpecificPath, true));\n        // Then purge the the global folder, e.g. ~/.rush/* except for node-v4.5.6\n        this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushGlobalFolder.path, this._getMembersToExclude(this._rushGlobalFolder.path, false));\n        if (this._rushConfiguration.isPnpm &&\n            this._rushConfiguration.pnpmOptions.pnpmStore === 'global' &&\n            this._rushConfiguration.pnpmOptions.pnpmStorePath) {\n            // eslint-disable-next-line no-console\n            console.warn(Colorize.yellow(`Purging the global pnpm-store`));\n            this._rushUserFolderRecycler.moveAllItemsInFolder(this._rushConfiguration.pnpmOptions.pnpmStorePath);\n        }\n    }\n    _getMembersToExclude(folderToRecycle, showWarning) {\n        // Don't recycle the recycler\n        const membersToExclude = [RushConstants.rushRecyclerFolderName];\n        // If the current process is running inside one of the folders, don't recycle that either\n        // Example: \"/home/user/.rush/rush-1.2.3/lib/example.js\"\n        const currentFolderPath = path.resolve(__dirname);\n        // Example:\n        // folderToRecycle = \"/home/user/.rush/node-v4.5.6\"\n        // relative =  \"rush-1.2.3/lib/example.js\"\n        const relative = path.relative(folderToRecycle, currentFolderPath);\n        // (The result can be an absolute path if the two folders are on different drive letters)\n        if (!path.isAbsolute(relative)) {\n            // Get the first path segment:\n            const firstPart = relative.split(/[\\\\\\/]/)[0];\n            if (firstPart.length > 0 && firstPart !== '..') {\n                membersToExclude.push(firstPart);\n                if (showWarning) {\n                    // Warn that we won't dispose this folder\n                    // eslint-disable-next-line no-console\n                    console.log(Colorize.yellow(\"The active process's folder will not be deleted: \" + path.join(folderToRecycle, firstPart)));\n                }\n            }\n        }\n        return membersToExclude;\n    }\n}\n//# sourceMappingURL=PurgeManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile, JsonSchema, NewlineKind } from '@rushstack/node-core-library';\nimport { PnpmShrinkwrapFile } from './pnpm/PnpmShrinkwrapFile';\nimport schemaJson from '../schemas/repo-state.schema.json';\n/**\n * This file is used to track the state of various Rush-related features. It is generated\n * and updated by Rush.\n *\n * @public\n */\nexport class RepoStateFile {\n    constructor(repoStateJson, isValid, filePath) {\n        this._modified = false;\n        this.filePath = filePath;\n        this._isValid = isValid;\n        if (repoStateJson) {\n            this._pnpmShrinkwrapHash = repoStateJson.pnpmShrinkwrapHash;\n            this._preferredVersionsHash = repoStateJson.preferredVersionsHash;\n            this._packageJsonInjectedDependenciesHash = repoStateJson.packageJsonInjectedDependenciesHash;\n        }\n    }\n    /**\n     * The hash of the pnpm shrinkwrap file at the end of the last update.\n     */\n    get pnpmShrinkwrapHash() {\n        return this._pnpmShrinkwrapHash;\n    }\n    /**\n     * The hash of all preferred versions at the end of the last update.\n     */\n    get preferredVersionsHash() {\n        return this._preferredVersionsHash;\n    }\n    /**\n     * The hash of all preferred versions at the end of the last update.\n     */\n    get packageJsonInjectedDependenciesHash() {\n        return this._packageJsonInjectedDependenciesHash;\n    }\n    /**\n     * If false, the repo-state.json file is not valid and its values cannot be relied upon\n     */\n    get isValid() {\n        return this._isValid;\n    }\n    /**\n     * Loads the repo-state.json data from the specified file path.\n     * If the file has not been created yet, then an empty object is returned.\n     *\n     * @param jsonFilename - The path to the repo-state.json file.\n     */\n    static loadFromFile(jsonFilename) {\n        let fileContents;\n        try {\n            fileContents = FileSystem.readFile(jsonFilename);\n        }\n        catch (error) {\n            if (!FileSystem.isNotExistError(error)) {\n                throw error;\n            }\n        }\n        let foundMergeConflictMarker = false;\n        let repoStateJson = undefined;\n        if (fileContents) {\n            try {\n                repoStateJson = JsonFile.parseString(fileContents);\n            }\n            catch (error) {\n                // Look for a Git merge conflict marker. PNPM gracefully handles merge conflicts in pnpm-lock.yaml,\n                // so a user should be able to just run \"rush update\" if they get conflicts in pnpm-lock.yaml\n                // and repo-state.json and have Rush update both.\n                for (let nextNewlineIndex = 0; nextNewlineIndex > -1; nextNewlineIndex = fileContents.indexOf('\\n', nextNewlineIndex + 1)) {\n                    if (fileContents.substr(nextNewlineIndex + 1, 7) === '<<<<<<<') {\n                        foundMergeConflictMarker = true;\n                        repoStateJson = {\n                            preferredVersionsHash: 'INVALID',\n                            pnpmShrinkwrapHash: 'INVALID'\n                        };\n                        break;\n                    }\n                }\n            }\n            if (repoStateJson) {\n                this._jsonSchema.validateObject(repoStateJson, jsonFilename);\n            }\n        }\n        return new RepoStateFile(repoStateJson, !foundMergeConflictMarker, jsonFilename);\n    }\n    /**\n     * Refresh the data contained in repo-state.json using the current state\n     * of the Rush repo, and save the file if changes were made.\n     *\n     * @param rushConfiguration - The Rush configuration for the repo.\n     * @param subspace - The subspace that repo-state.json was loaded from,\n     * or `undefined` for the default subspace.\n     *\n     * @returns true if the file was modified, otherwise false.\n     */\n    refreshState(rushConfiguration, subspace, variant) {\n        if (subspace === undefined) {\n            subspace = rushConfiguration.defaultSubspace;\n        }\n        // Only support saving the pnpm shrinkwrap hash if it was enabled\n        const preventShrinkwrapChanges = rushConfiguration.isPnpm &&\n            rushConfiguration.pnpmOptions &&\n            rushConfiguration.pnpmOptions.preventManualShrinkwrapChanges;\n        if (preventShrinkwrapChanges) {\n            const pnpmShrinkwrapFile = PnpmShrinkwrapFile.loadFromFile(subspace.getCommittedShrinkwrapFilePath(variant));\n            if (pnpmShrinkwrapFile) {\n                const shrinkwrapFileHash = pnpmShrinkwrapFile.getShrinkwrapHash(rushConfiguration.experimentsConfiguration.configuration);\n                if (this._pnpmShrinkwrapHash !== shrinkwrapFileHash) {\n                    this._pnpmShrinkwrapHash = shrinkwrapFileHash;\n                    this._modified = true;\n                }\n            }\n        }\n        else if (this._pnpmShrinkwrapHash !== undefined) {\n            this._pnpmShrinkwrapHash = undefined;\n            this._modified = true;\n        }\n        // Currently, only support saving the preferred versions hash if using workspaces\n        const useWorkspaces = rushConfiguration.pnpmOptions && rushConfiguration.pnpmOptions.useWorkspaces;\n        if (useWorkspaces) {\n            const commonVersions = subspace.getCommonVersions(variant);\n            const preferredVersionsHash = commonVersions.getPreferredVersionsHash();\n            if (this._preferredVersionsHash !== preferredVersionsHash) {\n                this._preferredVersionsHash = preferredVersionsHash;\n                this._modified = true;\n            }\n        }\n        else if (this._preferredVersionsHash !== undefined) {\n            this._preferredVersionsHash = undefined;\n            this._modified = true;\n        }\n        if (rushConfiguration.isPnpm) {\n            const packageJsonInjectedDependenciesHash = subspace.getPackageJsonInjectedDependenciesHash(variant);\n            // packageJsonInjectedDependenciesHash is undefined, means there is no injected dependencies for that subspace\n            // so we don't need to track the hash value for that subspace\n            if (packageJsonInjectedDependenciesHash &&\n                packageJsonInjectedDependenciesHash !== this._packageJsonInjectedDependenciesHash) {\n                this._packageJsonInjectedDependenciesHash = packageJsonInjectedDependenciesHash;\n                this._modified = true;\n            }\n            else if (!packageJsonInjectedDependenciesHash && this._packageJsonInjectedDependenciesHash) {\n                // if packageJsonInjectedDependenciesHash is undefined, but this._packageJsonInjectedDependenciesHash is not\n                // means users may turn off the injected installation\n                // so we will need to remove unused fields in repo-state.json as well\n                this._packageJsonInjectedDependenciesHash = undefined;\n                this._modified = true;\n            }\n        }\n        // Now that the file has been refreshed, we know its contents are valid\n        this._isValid = true;\n        return this._saveIfModified();\n    }\n    /**\n     * Writes the \"repo-state.json\" file to disk, using the filename that was passed to loadFromFile().\n     */\n    _saveIfModified() {\n        if (this._modified) {\n            const content = '// DO NOT MODIFY THIS FILE MANUALLY BUT DO COMMIT IT. It is generated and used by Rush.' +\n                `${NewlineKind.Lf}${this._serialize()}`;\n            FileSystem.writeFile(this.filePath, content);\n            this._modified = false;\n            return true;\n        }\n        return false;\n    }\n    _serialize() {\n        // We need to set these one-by-one, since JsonFile.stringify does not like undefined values\n        const repoStateJson = {};\n        if (this._pnpmShrinkwrapHash) {\n            repoStateJson.pnpmShrinkwrapHash = this._pnpmShrinkwrapHash;\n        }\n        if (this._preferredVersionsHash) {\n            repoStateJson.preferredVersionsHash = this._preferredVersionsHash;\n        }\n        if (this._packageJsonInjectedDependenciesHash) {\n            repoStateJson.packageJsonInjectedDependenciesHash = this._packageJsonInjectedDependenciesHash;\n        }\n        return JsonFile.stringify(repoStateJson, { newlineConversion: NewlineKind.Lf });\n    }\n}\nRepoStateFile._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=RepoStateFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Constants used by the Rush tool.\n * @beta\n *\n * @remarks\n *\n * These are NOT part of the public API surface for rush-lib.\n * The rationale is that we don't want people implementing custom parsers for\n * the Rush config files; instead, they should rely on the official APIs from rush-lib.\n */\nexport class RushConstants {\n}\n/**\n * The filename (\"rush.json\") for the root-level configuration file.\n */\nRushConstants.rushJsonFilename = 'rush.json';\n/**\n * The filename (\"browser-approved-packages.json\") for an optional policy configuration file\n * that stores a list of NPM packages that have been approved for usage by Rush projects.\n * This is part of a pair of config files, one for projects that run in a web browser\n * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else\n * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).\n */\nRushConstants.browserApprovedPackagesFilename = 'browser-approved-packages.json';\n/**\n * The folder name (\"changes\") where change files will be stored.\n */\nRushConstants.changeFilesFolderName = 'changes';\n/**\n * The filename (\"nonbrowser-approved-packages.json\") for an optional policy configuration file\n * that stores a list of NPM packages that have been approved for usage by Rush projects.\n * This is part of a pair of config files, one for projects that run in a web browser\n * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else\n * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).\n */\nRushConstants.nonbrowserApprovedPackagesFilename = 'nonbrowser-approved-packages.json';\n/**\n * The folder name (\"common\") where Rush's common data will be stored.\n */\nRushConstants.commonFolderName = 'common';\n/**\n * The NPM scope (\"\\@rush-temp\") that is used for Rush's temporary projects.\n */\nRushConstants.rushTempNpmScope = '@rush-temp';\n/**\n * The folder name (\"variants\") under which named variant configurations for\n * alternate dependency sets may be found.\n * Example: `C:\\MyRepo\\common\\config\\rush\\variants`\n */\nRushConstants.rushVariantsFolderName = 'variants';\n/**\n * The folder name (\"temp\") under the common folder, or under the .rush folder in each project's directory where\n * temporary files will be stored.\n * Example: `C:\\MyRepo\\common\\temp`\n */\nRushConstants.rushTempFolderName = 'temp';\n/**\n * The folder name (\"projects\") where temporary projects will be stored.\n * Example: `C:\\MyRepo\\common\\temp\\projects`\n */\nRushConstants.rushTempProjectsFolderName = 'projects';\n/**\n * The filename (\"npm-shrinkwrap.json\") used to store an installation plan for the NPM package manger.\n */\nRushConstants.npmShrinkwrapFilename = 'npm-shrinkwrap.json';\n/**\n * Number of installation attempts\n */\nRushConstants.defaultMaxInstallAttempts = 1;\n/**\n * The filename (\"pnpm-lock.yaml\") used to store an installation plan for the PNPM package manger\n * (PNPM version 3.x and later).\n */\nRushConstants.pnpmV3ShrinkwrapFilename = 'pnpm-lock.yaml';\n/**\n * The filename (\"pnpmfile.js\") used to add custom configuration to PNPM (PNPM version 1.x and later).\n */\nRushConstants.pnpmfileV1Filename = 'pnpmfile.js';\n/**\n * The filename (\".pnpmfile.cjs\") used to add custom configuration to PNPM (PNPM version 6.x and later).\n */\nRushConstants.pnpmfileV6Filename = '.pnpmfile.cjs';\n/**\n * The filename (\".modules.yaml\") used by pnpm to specify configurations in the node_modules directory\n */\nRushConstants.pnpmModulesFilename = '.modules.yaml';\n/**\n * The filename (\"global-pnpmfile.cjs\") used to add custom configuration to subspaces\n */\nRushConstants.pnpmfileGlobalFilename = 'global-pnpmfile.cjs';\n/**\n * The folder name used to store patch files for pnpm\n * Example: `C:\\MyRepo\\common\\config\\pnpm-patches`\n * Example: `C:\\MyRepo\\common\\temp\\patches`\n */\nRushConstants.pnpmPatchesFolderName = 'patches';\n/**\n * The folder name under `/common/temp` used to store checked-in patches.\n * Example: `C:\\MyRepo\\common\\pnpm-patches`\n */\nRushConstants.pnpmPatchesCommonFolderName = `pnpm-${RushConstants.pnpmPatchesFolderName}`;\n/**\n * The filename (\"shrinkwrap.yaml\") used to store state for pnpm\n */\nRushConstants.yarnShrinkwrapFilename = 'yarn.lock';\n/**\n * The folder name (\"node_modules\") where NPM installs its packages.\n */\nRushConstants.nodeModulesFolderName = 'node_modules';\n/**\n * The filename (\"pinned-versions.json\") for an old configuration file that\n * that is no longer supported.\n *\n * @deprecated This feature has been superseded by the \"preferredVersions\" setting\n * in common-versions.json\n */\n// NOTE: Although this is marked as \"deprecated\", we will probably never retire it,\n// since we always want to report the warning when someone upgrades an old repo.\nRushConstants.pinnedVersionsFilename = 'pinned-versions.json';\n/**\n * The filename (\"common-versions.json\") for an optional configuration file\n * that stores dependency version information that affects all projects in the repo.\n * This configuration file should go in the \"common/config/rush\" folder.\n */\nRushConstants.commonVersionsFilename = 'common-versions.json';\n/**\n * The filename (\"repo-state.json\") for a file used by Rush to\n * store the state of various features as they stand in the repo.\n */\nRushConstants.repoStateFilename = 'repo-state.json';\n/**\n * The filename (\"custom-tips.json\") for the file used by Rush to\n * print user-customized messages.\n * This configuration file should go in the \"common/config/rush\" folder.\n */\nRushConstants.customTipsFilename = 'custom-tips.json';\n/**\n * The name of the per-project folder where project-specific Rush files are stored. For example,\n * the package-deps files, which are used by commands to determine if a particular project needs to be rebuilt.\n */\nRushConstants.projectRushFolderName = '.rush';\n/**\n * Custom command line configuration file, which is used by rush for implementing\n * custom command and options.\n */\nRushConstants.commandLineFilename = 'command-line.json';\nRushConstants.versionPoliciesFilename = 'version-policies.json';\n/**\n * Experiments configuration file.\n */\nRushConstants.experimentsFilename = 'experiments.json';\n/**\n * Pnpm configuration file\n */\nRushConstants.pnpmConfigFilename = 'pnpm-config.json';\n/**\n * Rush plugins configuration file name.\n */\nRushConstants.rushPluginsConfigFilename = 'rush-plugins.json';\n/**\n * Rush plugin manifest file name.\n */\nRushConstants.rushPluginManifestFilename = 'rush-plugin-manifest.json';\n/**\n * The artifactory.json configuration file name.\n */\nRushConstants.artifactoryFilename = 'artifactory.json';\n/**\n * The subspaces.json configuration file name\n */\nRushConstants.subspacesConfigFilename = 'subspaces.json';\n/**\n * The name of the default subspace if one isn't specified but subspaces is enabled.\n */\nRushConstants.defaultSubspaceName = 'default';\n/**\n * Build cache configuration file.\n */\nRushConstants.buildCacheFilename = 'build-cache.json';\n/**\n * Build cache version number, incremented when the logic to create cache entries changes.\n * Changing this ensures that cache entries generated by an old version will no longer register as a cache hit.\n */\nRushConstants.buildCacheVersion = 1;\n/**\n * Cobuild configuration file.\n */\nRushConstants.cobuildFilename = 'cobuild.json';\n/**\n * Per-project configuration filename.\n */\nRushConstants.rushProjectConfigFilename = 'rush-project.json';\n/**\n * The URL (\"http://rushjs.io\") for the Rush web site.\n */\nRushConstants.rushWebSiteUrl = 'https://rushjs.io';\n/**\n * The name of the NPM package for the Rush tool (\"\\@microsoft/rush\").\n */\nRushConstants.rushPackageName = '@microsoft/rush';\n/**\n * The folder name (\"rush-recycler\") where Rush moves large folder trees\n * before asynchronously deleting them.\n */\nRushConstants.rushRecyclerFolderName = 'rush-recycler';\n/**\n * The name of the file to drop in project-folder/.rush/temp/ containing a listing of the project's direct\n * and indirect dependencies. This is used to detect if a project's dependencies have changed since the last build.\n */\nRushConstants.projectShrinkwrapFilename = 'shrinkwrap-deps.json';\n/**\n * The value of the \"commandKind\" property for a bulk command in command-line.json\n */\nRushConstants.bulkCommandKind = 'bulk';\n/**\n * The value of the \"commandKind\" property for a global command in command-line.json\n */\nRushConstants.globalCommandKind = 'global';\n/**\n * The value of the \"commandKind\" property for a phased command in command-line.json\n */\nRushConstants.phasedCommandKind = 'phased';\n/**\n * The name of the incremental build command.\n */\nRushConstants.buildCommandName = 'build';\n/**\n * The name of the non-incremental build command.\n */\nRushConstants.rebuildCommandName = 'rebuild';\nRushConstants.updateCloudCredentialsCommandName = 'update-cloud-credentials';\n/**\n * When a hash generated that contains multiple input segments, this character may be used\n * to separate them to avoid issues like\n * crypto.createHash('sha1').update('a').update('bc').digest('hex') === crypto.createHash('sha1').update('ab').update('c').digest('hex')\n */\nRushConstants.hashDelimiter = '|';\n/**\n * The name of the per-user Rush configuration data folder.\n */\nRushConstants.rushUserConfigurationFolderName = '.rush-user';\n/**\n * The name of the project `rush-logs` folder.\n */\nRushConstants.rushLogsFolderName = 'rush-logs';\n/**\n * The expected prefix for phase names in \"common/config/rush/command-line.json\"\n */\nRushConstants.phaseNamePrefix = '_phase:';\n/**\n * The default debounce value for Rush multi-project watch mode. When watching, controls\n * how long to wait after the last encountered file system event before execution. If another\n * file system event occurs in this interval, the timeout will reset.\n */\nRushConstants.defaultWatchDebounceMs = 1000;\n/**\n * The name of the parameter that can be used to bypass policies.\n */\nRushConstants.bypassPolicyFlagLongName = '--bypass-policy';\n/**\n * Merge Queue ignore configuration file.\n */\nRushConstants.mergeQueueIgnoreFileName = '.mergequeueignore';\n/**\n * The filename (\"project-impact-graph.yaml\") for the project impact graph file.\n */\nRushConstants.projectImpactGraphFilename = 'project-impact-graph.yaml';\n/**\n * The filename for the last link flag\n */\nRushConstants.lastLinkFlagFilename = 'last-link';\n/**\n * The filename for the Rush alerts config file.\n */\nRushConstants.rushAlertsConfigFilename = 'rush-alerts.json';\n/**\n * The filename for the file that tracks which variant is currently installed.\n */\nRushConstants.currentVariantsFilename = 'current-variants.json';\n//# sourceMappingURL=RushConstants.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * This namespace contains functions for manipulating sets of projects\n */\nexport class Selection {\n    /**\n     * Computes the intersection of two or more sets.\n     */\n    static intersection(first, ...rest) {\n        return new Set(generateIntersection(first, ...rest));\n    }\n    /**\n     * Computes the union of two or more sets.\n     */\n    static union(...sets) {\n        return new Set(generateConcatenation(...sets));\n    }\n    /**\n     * Computes a set that contains the input projects and all the direct and indirect dependencies thereof.\n     */\n    static expandAllDependencies(input) {\n        return expandAll(input, expandDependenciesStep);\n    }\n    /**\n     * Computes a set that contains the input projects and all projects that directly or indirectly depend on them.\n     */\n    static expandAllConsumers(input) {\n        return expandAll(input, expandConsumers);\n    }\n    /**\n     * Iterates the direct dependencies of the listed projects. May contain duplicates.\n     */\n    static *directDependenciesOf(input) {\n        for (const item of input) {\n            yield* item.dependencyProjects;\n        }\n    }\n    /**\n     * Iterates the projects that declare any of the listed projects as a dependency. May contain duplicates.\n     */\n    static *directConsumersOf(input) {\n        for (const item of input) {\n            yield* item.consumingProjects;\n        }\n    }\n}\nfunction* generateIntersection(first, ...rest) {\n    for (const item of first) {\n        if (rest.every((set) => set.has(item))) {\n            yield item;\n        }\n    }\n}\nfunction* generateConcatenation(...sets) {\n    for (const set of sets) {\n        yield* set;\n    }\n}\n/**\n * Adds all dependencies of the specified project to the target set.\n */\nfunction expandDependenciesStep(project, targetSet) {\n    for (const dep of project.dependencyProjects) {\n        targetSet.add(dep);\n    }\n}\n/**\n * Adds all projects that declare the specified project as a dependency to the target set.\n */\nfunction expandConsumers(project, targetSet) {\n    for (const dep of project.consumingProjects) {\n        targetSet.add(dep);\n    }\n}\n/**\n * Computes a set derived from the input by cloning it, then iterating over every member of the new set and\n * calling a step function that may add more elements to the set.\n */\nfunction expandAll(input, expandStep) {\n    const result = new Set(input);\n    for (const item of result) {\n        expandStep(item, result);\n    }\n    return result;\n}\n//# sourceMappingURL=Selection.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { FileSystem, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Colorize, PrintUtilities } from '@rushstack/terminal';\nimport { RushConstants } from './RushConstants';\n// Refuses to run at all if the PNPM version is older than this, because there\n// are known bugs or missing features in earlier releases.\nconst MINIMUM_SUPPORTED_NPM_VERSION = '4.5.0';\n// Refuses to run at all if the PNPM version is older than this, because there\n// are known bugs or missing features in earlier releases.\nconst MINIMUM_SUPPORTED_PNPM_VERSION = '5.0.0';\n/**\n * Validate that the developer's setup is good.\n *\n * These checks are invoked prior to the following commands:\n * - rush install\n * - rush update\n * - rush build\n * - rush rebuild\n */\nexport class SetupChecks {\n    static validate(rushConfiguration) {\n        // NOTE: The Node.js version is also checked in rush/src/start.ts\n        const errorMessage = SetupChecks._validate(rushConfiguration);\n        if (errorMessage) {\n            // eslint-disable-next-line no-console\n            console.error(Colorize.red(PrintUtilities.wrapWords(errorMessage)));\n            throw new AlreadyReportedError();\n        }\n    }\n    static _validate(rushConfiguration) {\n        // Check for outdated tools\n        if (rushConfiguration.isPnpm) {\n            if (semver.lt(rushConfiguration.packageManagerToolVersion, MINIMUM_SUPPORTED_PNPM_VERSION)) {\n                return (`The ${RushConstants.rushJsonFilename} file requests PNPM version ` +\n                    rushConfiguration.packageManagerToolVersion +\n                    `, but PNPM ${MINIMUM_SUPPORTED_PNPM_VERSION} is the minimum supported by Rush.`);\n            }\n        }\n        else if (rushConfiguration.packageManager === 'npm') {\n            if (semver.lt(rushConfiguration.packageManagerToolVersion, MINIMUM_SUPPORTED_NPM_VERSION)) {\n                return (`The ${RushConstants.rushJsonFilename} file requests NPM version ` +\n                    rushConfiguration.packageManagerToolVersion +\n                    `, but NPM ${MINIMUM_SUPPORTED_NPM_VERSION} is the minimum supported by Rush.`);\n            }\n        }\n        SetupChecks._checkForPhantomFolders(rushConfiguration);\n    }\n    static _checkForPhantomFolders(rushConfiguration) {\n        const phantomFolders = [];\n        const seenFolders = new Set();\n        // Check from the real parent of the common/temp folder\n        const commonTempParent = path.dirname(FileSystem.getRealPath(rushConfiguration.commonTempFolder));\n        SetupChecks._collectPhantomFoldersUpwards(commonTempParent, phantomFolders, seenFolders);\n        // Check from the real folder containing rush.json\n        const realRushJsonFolder = FileSystem.getRealPath(rushConfiguration.rushJsonFolder);\n        SetupChecks._collectPhantomFoldersUpwards(realRushJsonFolder, phantomFolders, seenFolders);\n        if (phantomFolders.length > 0) {\n            if (phantomFolders.length === 1) {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.yellow(PrintUtilities.wrapWords('Warning: A phantom \"node_modules\" folder was found. This defeats Rush\\'s protection against' +\n                    ' NPM phantom dependencies and may cause confusing build errors. It is recommended to' +\n                    ' delete this folder:')));\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.yellow(PrintUtilities.wrapWords('Warning: Phantom \"node_modules\" folders were found. This defeats Rush\\'s protection against' +\n                    ' NPM phantom dependencies and may cause confusing build errors. It is recommended to' +\n                    ' delete these folders:')));\n            }\n            for (const folder of phantomFolders) {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.yellow(`\"${folder}\"`));\n            }\n            // eslint-disable-next-line no-console\n            console.log(); // add a newline\n        }\n    }\n    /**\n     * Checks \"folder\" and each of its parents to see if it contains a node_modules folder.\n     * The bad folders will be added to phantomFolders.\n     * The seenFolders set is used to avoid duplicates.\n     */\n    static _collectPhantomFoldersUpwards(folder, phantomFolders, seenFolders) {\n        // Stop if we reached a folder that we already analyzed\n        while (!seenFolders.has(folder)) {\n            seenFolders.add(folder);\n            // If there is a node_modules folder under this folder, add it to the list of bad folders\n            const nodeModulesFolder = path.join(folder, RushConstants.nodeModulesFolderName);\n            if (FileSystem.exists(nodeModulesFolder)) {\n                // Collect the names of files/folders in that node_modules folder\n                const filenames = FileSystem.readFolderItemNames(nodeModulesFolder).filter((x) => !x.startsWith('.'));\n                let ignore = false;\n                if (filenames.length === 0) {\n                    // If the node_modules folder is completely empty, then it's not a concern\n                    ignore = true;\n                }\n                else if (filenames.length === 1 && filenames[0] === 'vso-task-lib') {\n                    // Special case:  The Azure DevOps build agent installs the \"vso-task-lib\" NPM package\n                    // in a top-level path such as:\n                    //\n                    //   /home/vsts/work/node_modules/vso-task-lib\n                    //\n                    // It is always the only package in that node_modules folder.  The \"vso-task-lib\" package\n                    // is now deprecated, so it is unlikely to be a real dependency of any modern project.\n                    // To avoid false alarms, we ignore this specific case.\n                    ignore = true;\n                }\n                if (!ignore) {\n                    phantomFolders.push(nodeModulesFolder);\n                }\n            }\n            // Walk upwards\n            const parentFolder = path.dirname(folder);\n            if (!parentFolder || parentFolder === folder) {\n                // If path.dirname() returns its own input, then means we reached the root\n                break;\n            }\n            folder = parentFolder;\n        }\n    }\n}\n//# sourceMappingURL=SetupChecks.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { NpmShrinkwrapFile } from './npm/NpmShrinkwrapFile';\nimport { PnpmShrinkwrapFile } from './pnpm/PnpmShrinkwrapFile';\nimport { YarnShrinkwrapFile } from './yarn/YarnShrinkwrapFile';\nexport class ShrinkwrapFileFactory {\n    static getShrinkwrapFile(packageManager, shrinkwrapFilename) {\n        switch (packageManager) {\n            case 'npm':\n                return NpmShrinkwrapFile.loadFromFile(shrinkwrapFilename);\n            case 'pnpm':\n                return PnpmShrinkwrapFile.loadFromFile(shrinkwrapFilename);\n            case 'yarn':\n                return YarnShrinkwrapFile.loadFromFile(shrinkwrapFilename);\n            default:\n                throw new Error(`Invalid package manager: ${packageManager}`);\n        }\n    }\n    static parseShrinkwrapFile(packageManager, shrinkwrapContent) {\n        switch (packageManager) {\n            case 'npm':\n                return NpmShrinkwrapFile.loadFromString(shrinkwrapContent);\n            case 'pnpm':\n                return PnpmShrinkwrapFile.loadFromString(shrinkwrapContent);\n            case 'yarn':\n                return YarnShrinkwrapFile.loadFromString(shrinkwrapContent);\n            default:\n                throw new Error(`Invalid package manager: ${packageManager}`);\n        }\n    }\n}\n//# sourceMappingURL=ShrinkwrapFileFactory.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, Async } from '@rushstack/node-core-library';\nimport { installRunRushScriptFilename, installRunRushxScriptFilename, installRunRushPnpmScriptFilename, installRunScriptFilename, scriptsFolderPath } from '../utilities/PathConstants';\nimport { RushConstants } from './RushConstants';\nconst HEADER_LINES_PREFIX = [\n    '// THIS FILE WAS GENERATED BY A TOOL. ANY MANUAL MODIFICATIONS WILL GET OVERWRITTEN WHENEVER RUSH IS UPGRADED.',\n    '//'\n];\nconst HEADER_LINES_SUFFIX = [\n    '//',\n    '// For more information, see: https://rushjs.io/pages/maintainer/setup_new_repo/',\n    '//',\n    '// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.',\n    \"// See the @microsoft/rush package's LICENSE file for details.\",\n    ''\n];\nconst _scripts = [\n    {\n        scriptName: installRunScriptFilename,\n        headerLines: [\n            '// This script is intended for usage in an automated build environment where a Node tool may not have',\n            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the specified',\n            '// version of the specified tool (if not already installed), and then pass a command-line to it.',\n            '// An example usage would be:',\n            '//',\n            `//    node common/scripts/${installRunScriptFilename} qrcode@1.2.2 qrcode https://rushjs.io`\n        ]\n    },\n    {\n        scriptName: installRunRushScriptFilename,\n        headerLines: [\n            '// This script is intended for usage in an automated build environment where the Rush command may not have',\n            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the version of Rush',\n            `// specified in the ${RushConstants.rushJsonFilename} configuration file (if not already installed), and then pass a command-line to it.`,\n            '// An example usage would be:',\n            '//',\n            `//    node common/scripts/${installRunRushScriptFilename} install`\n        ]\n    },\n    {\n        scriptName: installRunRushxScriptFilename,\n        headerLines: [\n            '// This script is intended for usage in an automated build environment where the Rush command may not have',\n            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the version of Rush',\n            `// specified in the ${RushConstants.rushJsonFilename} configuration file (if not already installed), and then pass a command-line to the`,\n            '// rushx command.',\n            '//',\n            '// An example usage would be:',\n            '//',\n            `//    node common/scripts/${installRunRushxScriptFilename} custom-command`\n        ]\n    }\n];\nconst _pnpmOnlyScripts = [\n    {\n        scriptName: installRunRushPnpmScriptFilename,\n        headerLines: [\n            '// This script is intended for usage in an automated build environment where the Rush command may not have',\n            '// been preinstalled, or may have an unpredictable version.  This script will automatically install the version of Rush',\n            `// specified in the ${RushConstants.rushJsonFilename} configuration file (if not already installed), and then pass a command-line to the`,\n            '// rush-pnpm command.',\n            '//',\n            '// An example usage would be:',\n            '//',\n            `//    node common/scripts/${installRunRushPnpmScriptFilename} pnpm-command`\n        ]\n    }\n];\nconst getScripts = (rushConfiguration) => {\n    if (rushConfiguration.isPnpm) {\n        return _scripts.concat(_pnpmOnlyScripts);\n    }\n    return _scripts;\n};\n/**\n * Checks whether the common/scripts files are up to date, and recopies them if needed.\n * This is used by the \"rush install\" and \"rush update\" commands.\n */\nexport class StandardScriptUpdater {\n    /**\n     * Recopy the scripts if the scripts are out of date.\n     * Used by \"rush update\".\n     */\n    static async updateAsync(rushConfiguration) {\n        await FileSystem.ensureFolderAsync(rushConfiguration.commonScriptsFolder);\n        let anyChanges = false;\n        await Async.forEachAsync(getScripts(rushConfiguration), async (script) => {\n            const changed = await StandardScriptUpdater._updateScriptOrThrowAsync(script, rushConfiguration, false);\n            anyChanges || (anyChanges = changed);\n        }, { concurrency: 10 });\n        if (anyChanges) {\n            // eslint-disable-next-line no-console\n            console.log(); // print a newline after the notices\n        }\n        return anyChanges;\n    }\n    /**\n     * Throw an exception if the scripts are out of date.\n     * Used by \"rush install\".\n     */\n    static async validateAsync(rushConfiguration) {\n        await Async.forEachAsync(getScripts(rushConfiguration), async (script) => {\n            await StandardScriptUpdater._updateScriptOrThrowAsync(script, rushConfiguration, true);\n        }, { concurrency: 10 });\n    }\n    /**\n     * Compares a single script in the common/script folder to see if it needs to be updated.\n     * If throwInsteadOfCopy=false, then an outdated or missing script will be recopied;\n     * otherwise, an exception is thrown.\n     */\n    static async _updateScriptOrThrowAsync(script, rushConfiguration, throwInsteadOfCopy) {\n        const targetFilePath = `${rushConfiguration.commonScriptsFolder}/${script.scriptName}`;\n        // Are the files the same?\n        let filesAreSame = false;\n        let targetContent;\n        try {\n            targetContent = await FileSystem.readFileAsync(targetFilePath);\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n        const targetNormalized = targetContent\n            ? StandardScriptUpdater._normalize(targetContent)\n            : undefined;\n        let sourceNormalized;\n        if (targetNormalized) {\n            sourceNormalized = await StandardScriptUpdater._getExpectedFileDataAsync(script);\n            if (sourceNormalized === targetNormalized) {\n                filesAreSame = true;\n            }\n        }\n        if (!filesAreSame) {\n            if (throwInsteadOfCopy) {\n                throw new Error('The standard files in the \"common/scripts\" folders need to be updated' +\n                    ' for this Rush version.  Please run \"rush update\" and commit the changes.');\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.log(`Script is out of date; updating \"${targetFilePath}\"`);\n                sourceNormalized || (sourceNormalized = await StandardScriptUpdater._getExpectedFileDataAsync(script));\n                await FileSystem.writeFileAsync(targetFilePath, sourceNormalized);\n            }\n        }\n        return !filesAreSame;\n    }\n    static _normalize(content) {\n        // Ignore newline differences from .gitattributes\n        return (content\n            .split('\\n')\n            // Ignore trailing whitespace\n            .map((x) => x.trimRight())\n            .join('\\n'));\n    }\n    static async _getExpectedFileDataAsync({ scriptName, headerLines }) {\n        const sourceFilePath = `${scriptsFolderPath}/${scriptName}`;\n        let sourceContent = await FileSystem.readFileAsync(sourceFilePath);\n        sourceContent = [...HEADER_LINES_PREFIX, ...headerLines, ...HEADER_LINES_SUFFIX, sourceContent].join('\\n');\n        const sourceNormalized = StandardScriptUpdater._normalize(sourceContent);\n        return sourceNormalized;\n    }\n}\n//# sourceMappingURL=StandardScriptUpdater.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as os from 'os';\nimport * as path from 'path';\nimport { FileSystem, JsonFile } from '@rushstack/node-core-library';\nimport { Rush } from '../api/Rush';\nconst MAX_FILE_COUNT = 100;\nconst ONE_MEGABYTE_IN_BYTES = 1048576;\nexport class Telemetry {\n    constructor(rushConfiguration, rushSession) {\n        this._flushAsyncTasks = new Set();\n        this._rushConfiguration = rushConfiguration;\n        this._rushSession = rushSession;\n        this._enabled = this._rushConfiguration.telemetryEnabled;\n        this._store = [];\n        const folderName = 'telemetry';\n        this._dataFolder = path.join(this._rushConfiguration.commonTempFolder, folderName);\n    }\n    log(telemetryData) {\n        if (!this._enabled) {\n            return;\n        }\n        const cpus = os.cpus();\n        const data = Object.assign(Object.assign({}, telemetryData), { machineInfo: telemetryData.machineInfo || {\n                machineArchitecture: os.arch(),\n                // The Node.js model is sometimes padded, for example:\n                // \"AMD Ryzen 7 3700X 8-Core Processor             \"\n                machineCpu: cpus[0].model.trim(),\n                machineCores: cpus.length,\n                machineTotalMemoryMiB: Math.round(os.totalmem() / ONE_MEGABYTE_IN_BYTES),\n                machineFreeMemoryMiB: Math.round(os.freemem() / ONE_MEGABYTE_IN_BYTES)\n            }, timestampMs: telemetryData.timestampMs || new Date().getTime(), platform: telemetryData.platform || process.platform, rushVersion: telemetryData.rushVersion || Rush.version });\n        this._store.push(data);\n    }\n    flush() {\n        if (!this._enabled || this._store.length === 0) {\n            return;\n        }\n        const fullPath = this._getFilePath();\n        JsonFile.save(this._store, fullPath, { ensureFolderExists: true, ignoreUndefinedValues: true });\n        if (this._rushSession.hooks.flushTelemetry.isUsed()) {\n            /**\n             * User defined flushTelemetry should not block anything, so we don't await here,\n             * and store the promise into a list so that we can await it later.\n             */\n            const asyncTaskPromise = this._rushSession.hooks.flushTelemetry.promise(this._store);\n            this._flushAsyncTasks.add(asyncTaskPromise);\n            asyncTaskPromise.then(() => {\n                this._flushAsyncTasks.delete(asyncTaskPromise);\n            }, () => {\n                this._flushAsyncTasks.delete(asyncTaskPromise);\n            });\n        }\n        this._store = [];\n        this._cleanUp();\n    }\n    /**\n     * There are some async tasks that are not finished when the process is exiting.\n     */\n    async ensureFlushedAsync() {\n        await Promise.all(this._flushAsyncTasks);\n    }\n    get store() {\n        return this._store;\n    }\n    /**\n     * When there are too many log files, delete the old ones.\n     */\n    _cleanUp() {\n        if (FileSystem.exists(this._dataFolder)) {\n            const files = FileSystem.readFolderItemNames(this._dataFolder);\n            if (files.length > MAX_FILE_COUNT) {\n                const sortedFiles = files\n                    .map((fileName) => {\n                    const filePath = path.join(this._dataFolder, fileName);\n                    const stats = FileSystem.getStatistics(filePath);\n                    return {\n                        filePath: filePath,\n                        modifiedTime: stats.mtime.getTime(),\n                        isFile: stats.isFile()\n                    };\n                })\n                    .filter((value) => {\n                    // Only delete files\n                    return value.isFile;\n                })\n                    .sort((a, b) => {\n                    return a.modifiedTime - b.modifiedTime;\n                })\n                    .map((s) => {\n                    return s.filePath;\n                });\n                const filesToDelete = sortedFiles.length - MAX_FILE_COUNT;\n                for (let i = 0; i < filesToDelete; i++) {\n                    FileSystem.deleteFile(sortedFiles[i]);\n                }\n            }\n        }\n    }\n    _getFilePath() {\n        let fileName = `telemetry_${new Date().toISOString()}`;\n        fileName = fileName.replace(/[\\-\\:\\.]/g, '_') + '.json';\n        return path.join(this._dataFolder, fileName);\n    }\n}\n//# sourceMappingURL=Telemetry.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { Utilities } from '../utilities/Utilities';\nimport { BaseProjectShrinkwrapFile } from './base/BaseProjectShrinkwrapFile';\nimport { FlagFile } from '../api/FlagFile';\nimport { RushConstants } from './RushConstants';\n/**\n * This class implements the logic for \"rush unlink\"\n */\nexport class UnlinkManager {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    /**\n     * Delete flag file and all the existing node_modules symlinks and all\n     * project/.rush/temp/shrinkwrap-deps.json files\n     *\n     * Returns true if anything was deleted.\n     */\n    async unlinkAsync(force = false) {\n        const useWorkspaces = this._rushConfiguration.pnpmOptions && this._rushConfiguration.pnpmOptions.useWorkspaces;\n        if (!force && useWorkspaces) {\n            // eslint-disable-next-line no-console\n            console.log(Colorize.red('Unlinking is not supported when using workspaces. Run \"rush purge\" to remove ' +\n                'project node_modules folders.'));\n            throw new AlreadyReportedError();\n        }\n        await new FlagFile(this._rushConfiguration.defaultSubspace.getSubspaceTempFolderPath(), RushConstants.lastLinkFlagFilename, {}).clearAsync();\n        return this._deleteProjectFiles();\n    }\n    /**\n     * Delete:\n     *  - all the node_modules symlinks of configured Rush projects\n     *  - all of the project/.rush/temp/shrinkwrap-deps.json files of configured Rush projects\n     *\n     * Returns true if anything was deleted\n     * */\n    _deleteProjectFiles() {\n        let didDeleteAnything = false;\n        for (const rushProject of this._rushConfiguration.projects) {\n            const localModuleFolder = path.join(rushProject.projectFolder, 'node_modules');\n            if (FileSystem.exists(localModuleFolder)) {\n                // eslint-disable-next-line no-console\n                console.log(`Purging ${localModuleFolder}`);\n                Utilities.dangerouslyDeletePath(localModuleFolder);\n                didDeleteAnything = true;\n            }\n            const projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(rushProject);\n            if (FileSystem.exists(projectShrinkwrapFilePath)) {\n                // eslint-disable-next-line no-console\n                console.log(`Deleting ${projectShrinkwrapFilePath}`);\n                FileSystem.deleteFile(projectShrinkwrapFilePath);\n                didDeleteAnything = true;\n            }\n        }\n        return didDeleteAnything;\n    }\n}\n//# sourceMappingURL=UnlinkManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Options that all package managers share.\n *\n * @public\n */\nexport class PackageManagerOptionsConfigurationBase {\n    /** @internal */\n    constructor(json) {\n        this.environmentVariables = json.environmentVariables;\n    }\n}\n//# sourceMappingURL=BasePackageManagerOptionsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, JsonFile } from '@rushstack/node-core-library';\nimport { RushConstants } from '../RushConstants';\n/**\n * This class handles creating the project/.rush/temp/shrinkwrap-deps.json file\n * which tracks the direct and indirect dependencies that a project consumes. This is used\n * to better determine which projects should be rebuilt when dependencies are updated.\n */\nexport class BaseProjectShrinkwrapFile {\n    constructor(shrinkwrapFile, project) {\n        this.project = project;\n        this.projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(this.project);\n        this.shrinkwrapFile = shrinkwrapFile;\n    }\n    /**\n     * Save an empty project shrinkwrap file. This is used in repos with no dependencies.\n     */\n    static async saveEmptyProjectShrinkwrapFileAsync(project) {\n        const projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(project);\n        await JsonFile.saveAsync({}, projectShrinkwrapFilePath, { ensureFolderExists: true });\n    }\n    /**\n     * Get the fully-qualified path to the <project>/.rush/temp/shrinkwrap-deps.json\n     * for the specified project.\n     */\n    static getFilePathForProject(project) {\n        return `${project.projectRushTempFolder}/${RushConstants.projectShrinkwrapFilename}`;\n    }\n    /**\n     * If the <project>/.rush/temp/shrinkwrap-deps.json file exists, delete it. Otherwise, do nothing.\n     */\n    async deleteIfExistsAsync() {\n        await FileSystem.deleteFileAsync(this.projectShrinkwrapFilePath, { throwIfNotExists: false });\n    }\n}\n//# sourceMappingURL=BaseProjectShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as semver from 'semver';\nimport { Colorize } from '@rushstack/terminal';\nimport { RushConstants } from '../RushConstants';\nimport { DependencySpecifierType } from '../DependencySpecifier';\nimport { PackageNameParsers } from '../../api/PackageNameParsers';\n/**\n * This class is a parser for both npm's npm-shrinkwrap.json and pnpm's pnpm-lock.yaml file formats.\n */\nexport class BaseShrinkwrapFile {\n    constructor() {\n        this._alreadyWarnedSpecs = new Set();\n    }\n    static tryGetValue(dictionary, key) {\n        if (dictionary.hasOwnProperty(key)) {\n            return dictionary[key];\n        }\n        return undefined;\n    }\n    /**\n     * Determine whether `pnpm-lock.yaml` complies with the rules specified in `common/config/rush/pnpm-config.schema.json`.\n     *\n     * @virtual\n     */\n    validateShrinkwrapAfterUpdate(rushConfiguration, subspace, terminal) { }\n    /**\n     * Validate the shrinkwrap using the provided policy options.\n     *\n     * @virtual\n     */\n    validate(packageManagerOptionsConfig, policyOptions, experimentsConfig) { }\n    /**\n     * Returns true if the shrinkwrap file includes a top-level package that would satisfy the specified\n     * package name and SemVer version range\n     *\n     * @virtual\n     */\n    hasCompatibleTopLevelDependency(dependencySpecifier) {\n        const shrinkwrapDependency = this.getTopLevelDependencyVersion(dependencySpecifier.packageName);\n        if (!shrinkwrapDependency) {\n            return false;\n        }\n        return this._checkDependencyVersion(dependencySpecifier, shrinkwrapDependency);\n    }\n    /**\n     * Returns true if the shrinkwrap file includes a package that would satisfying the specified\n     * package name and SemVer version range.  By default, the dependencies are resolved by looking\n     * at the root of the node_modules folder described by the shrinkwrap file.  However, if\n     * tempProjectName is specified, then the resolution will start in that subfolder.\n     *\n     * Consider this example:\n     *\n     * - node_modules\\\n     *   - temp-project\\\n     *     - lib-a@1.2.3\n     *     - lib-b@1.0.0\n     *   - lib-b@2.0.0\n     *\n     * In this example, hasCompatibleDependency(\"lib-b\", \">= 1.1.0\", \"temp-project\") would fail\n     * because it finds lib-b@1.0.0 which does not satisfy the pattern \">= 1.1.0\".\n     *\n     * @virtual\n     */\n    tryEnsureCompatibleDependency(dependencySpecifier, tempProjectName) {\n        const shrinkwrapDependency = this.tryEnsureDependencyVersion(dependencySpecifier, tempProjectName);\n        if (!shrinkwrapDependency) {\n            return false;\n        }\n        return this._checkDependencyVersion(dependencySpecifier, shrinkwrapDependency);\n    }\n    /**\n     * Check for projects that exist in the shrinkwrap file, but don't exist\n     * in rush.json.  This might occur, e.g. if a project was recently deleted or renamed.\n     *\n     * @returns a list of orphaned projects.\n     */\n    findOrphanedProjects(rushConfiguration, subspace) {\n        const orphanedProjectNames = [];\n        // We can recognize temp projects because they are under the \"@rush-temp\" NPM scope.\n        for (const tempProjectName of this.getTempProjectNames()) {\n            if (!rushConfiguration.findProjectByTempName(tempProjectName)) {\n                orphanedProjectNames.push(tempProjectName);\n            }\n        }\n        return orphanedProjectNames;\n    }\n    _getTempProjectNames(dependencies) {\n        const result = [];\n        for (const key of Object.keys(dependencies)) {\n            // If it starts with @rush-temp, then include it:\n            if (PackageNameParsers.permissive.getScope(key) === RushConstants.rushTempNpmScope) {\n                result.push(key);\n            }\n        }\n        result.sort(); // make the result deterministic\n        return result;\n    }\n    _checkDependencyVersion(projectDependency, shrinkwrapDependency) {\n        let normalizedProjectDependency = projectDependency;\n        let normalizedShrinkwrapDependency = shrinkwrapDependency;\n        // Special handling for NPM package aliases such as this:\n        //\n        // \"dependencies\": {\n        //   \"alias-name\": \"npm:target-name@^1.2.3\"\n        // }\n        //\n        // In this case, the shrinkwrap file will have a key equivalent to \"npm:target-name@1.2.5\",\n        // and so we need to unwrap the target and compare \"1.2.5\" with \"^1.2.3\".\n        if (projectDependency.specifierType === DependencySpecifierType.Alias) {\n            // Does the shrinkwrap install it as an alias?\n            if (shrinkwrapDependency.specifierType === DependencySpecifierType.Alias) {\n                // Does the shrinkwrap have the right package name?\n                if (projectDependency.packageName === shrinkwrapDependency.packageName) {\n                    // Yes, the aliases match, so let's compare their targets in the logic below\n                    normalizedProjectDependency = projectDependency.aliasTarget;\n                    normalizedShrinkwrapDependency = shrinkwrapDependency.aliasTarget;\n                }\n                else {\n                    // If the names are different, then it's a mismatch\n                    return false;\n                }\n            }\n            else {\n                // A non-alias cannot satisfy an alias dependency; at least, let's avoid that idea\n                return false;\n            }\n        }\n        switch (normalizedProjectDependency.specifierType) {\n            case DependencySpecifierType.Version:\n            case DependencySpecifierType.Range:\n                return semver.satisfies(normalizedShrinkwrapDependency.versionSpecifier, normalizedProjectDependency.versionSpecifier);\n            default:\n                // For other version specifier types like \"file:./blah.tgz\" or \"git://github.com/npm/cli.git#v1.0.27\"\n                // we allow the installation to continue but issue a warning.  The \"rush install\" checks will not work\n                // correctly.\n                // Only warn once for each versionSpecifier\n                if (!this._alreadyWarnedSpecs.has(projectDependency.versionSpecifier)) {\n                    this._alreadyWarnedSpecs.add(projectDependency.versionSpecifier);\n                    // eslint-disable-next-line no-console\n                    console.log(Colorize.yellow(`WARNING: Not validating ${projectDependency.specifierType}-based` +\n                        ` specifier: \"${projectDependency.versionSpecifier}\"`));\n                }\n                return true;\n        }\n    }\n}\n//# sourceMappingURL=BaseShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport process from 'node:process';\nconst OPTIONS_ARGUMENT_NAME = 'options';\n// NOTE: When adding new tokens, make sure to document the syntax in the \"rush init\"\n// template for build-cache.json\nconst HASH_TOKEN_NAME = 'hash';\nconst PROJECT_NAME_TOKEN_NAME = 'projectName';\nconst PHASE_NAME_TOKEN_NAME = 'phaseName';\nconst OS_TOKEN_NAME = 'os';\nconst ARCH_TOKEN_NAME = 'arch';\n// This regex matches substrings that look like [token]\nconst TOKEN_REGEX = /\\[[^\\]]*\\]/g;\nexport class CacheEntryId {\n    constructor() { }\n    static parsePattern(pattern) {\n        if (!pattern) {\n            return ({ projectStateHash }) => projectStateHash;\n        }\n        else {\n            pattern = pattern.trim();\n            if (pattern.startsWith('/')) {\n                throw new Error('Cache entry name patterns may not start with a slash.');\n            }\n            const patternWithoutTokens = pattern.replace(TOKEN_REGEX, '');\n            if (patternWithoutTokens.match(/\\]/)) {\n                throw new Error(`Unexpected \"]\" character in cache entry name pattern.`);\n            }\n            if (patternWithoutTokens.match(/\\[/)) {\n                throw new Error('Unclosed token in cache entry name pattern.');\n            }\n            if (!patternWithoutTokens.match(/^[A-z0-9-_\\/]*$/)) {\n                throw new Error('Cache entry name pattern contains an invalid character. ' +\n                    'Only alphanumeric characters, slashes, underscores, and hyphens are allowed.');\n            }\n            let foundHashToken = false;\n            const templateString = pattern.trim().replace(TOKEN_REGEX, (token) => {\n                token = token.substring(1, token.length - 1);\n                let tokenName;\n                let tokenAttribute;\n                const tokenSplitIndex = token.indexOf(':');\n                if (tokenSplitIndex === -1) {\n                    tokenName = token;\n                }\n                else {\n                    tokenName = token.substr(0, tokenSplitIndex);\n                    tokenAttribute = token.substr(tokenSplitIndex + 1);\n                }\n                switch (tokenName) {\n                    case HASH_TOKEN_NAME: {\n                        if (tokenAttribute !== undefined) {\n                            throw new Error(`An attribute isn\\'t supported for the \"${tokenName}\" token.`);\n                        }\n                        foundHashToken = true;\n                        return `\\${${OPTIONS_ARGUMENT_NAME}.projectStateHash}`;\n                    }\n                    case PROJECT_NAME_TOKEN_NAME: {\n                        switch (tokenAttribute) {\n                            case undefined: {\n                                return `\\${${OPTIONS_ARGUMENT_NAME}.projectName}`;\n                            }\n                            case 'normalize': {\n                                return `\\${${OPTIONS_ARGUMENT_NAME}.projectName.replace('@','').replace(/\\\\+/g, '++').replace(/\\\\/\\/g, '+')}`;\n                            }\n                            default: {\n                                throw new Error(`Unexpected attribute \"${tokenAttribute}\" for the \"${tokenName}\" token.`);\n                            }\n                        }\n                    }\n                    case PHASE_NAME_TOKEN_NAME: {\n                        switch (tokenAttribute) {\n                            case undefined: {\n                                throw new Error('Either the \"normalize\" or the \"trimPrefix\" attribute is required ' +\n                                    `for the \"${tokenName}\" token.`);\n                            }\n                            case 'normalize': {\n                                // Replace colons with underscores.\n                                return `\\${${OPTIONS_ARGUMENT_NAME}.phaseName.replace(/:/g, '_')}`;\n                            }\n                            case 'trimPrefix': {\n                                // Trim the \"_phase:\" prefix from the phase name.\n                                return `\\${${OPTIONS_ARGUMENT_NAME}.phaseName.replace(/^_phase:/, '')}`;\n                            }\n                            default: {\n                                throw new Error(`Unexpected attribute \"${tokenAttribute}\" for the \"${tokenName}\" token.`);\n                            }\n                        }\n                    }\n                    case OS_TOKEN_NAME: {\n                        if (tokenAttribute !== undefined) {\n                            throw new Error(`An attribute isn\\'t supported for the \"${tokenName}\" token.`);\n                        }\n                        return process.platform;\n                    }\n                    case ARCH_TOKEN_NAME: {\n                        if (tokenAttribute !== undefined) {\n                            throw new Error(`An attribute isn\\'t supported for the \"${tokenName}\" token.`);\n                        }\n                        return process.arch;\n                    }\n                    default: {\n                        throw new Error(`Unexpected token name \"${tokenName}\".`);\n                    }\n                }\n            });\n            if (!foundHashToken) {\n                throw new Error(`Cache entry name pattern is missing a [${HASH_TOKEN_NAME}] token.`);\n            }\n            // eslint-disable-next-line no-new-func\n            return new Function(OPTIONS_ARGUMENT_NAME, `\"use strict\"\\nreturn \\`${templateString}\\`;`);\n        }\n    }\n}\n//# sourceMappingURL=CacheEntryId.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem } from '@rushstack/node-core-library';\nconst DEFAULT_BUILD_CACHE_FOLDER_NAME = 'build-cache';\n/**\n * A build cache provider using the local file system.\n * Required by all cloud cache providers.\n * @beta\n */\nexport class FileSystemBuildCacheProvider {\n    constructor(options) {\n        this._cacheFolderPath =\n            options.rushUserConfiguration.buildCacheFolder ||\n                path.join(options.rushConfiguration.commonTempFolder, DEFAULT_BUILD_CACHE_FOLDER_NAME);\n    }\n    /**\n     * Returns the absolute disk path for the specified cache id.\n     */\n    getCacheEntryPath(cacheId) {\n        return path.join(this._cacheFolderPath, cacheId);\n    }\n    /**\n     * Validates that the specified cache id exists on disk, and returns the path if it does.\n     */\n    async tryGetCacheEntryPathByIdAsync(terminal, cacheId) {\n        const cacheEntryFilePath = this.getCacheEntryPath(cacheId);\n        if (await FileSystem.existsAsync(cacheEntryFilePath)) {\n            return cacheEntryFilePath;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Writes the specified buffer to the corresponding file system path for the cache id.\n     */\n    async trySetCacheEntryBufferAsync(terminal, cacheId, entryBuffer) {\n        const cacheEntryFilePath = this.getCacheEntryPath(cacheId);\n        await FileSystem.writeFileAsync(cacheEntryFilePath, entryBuffer, { ensureFolderExists: true });\n        terminal.writeVerboseLine(`Wrote cache entry to \"${cacheEntryFilePath}\".`);\n        return cacheEntryFilePath;\n    }\n}\n//# sourceMappingURL=FileSystemBuildCacheProvider.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport { FileSystem, InternalError, Async } from '@rushstack/node-core-library';\nimport { TarExecutable } from '../../utilities/TarExecutable';\nimport { EnvironmentVariableNames } from '../../api/EnvironmentConfiguration';\nexport class ProjectBuildCache {\n    constructor(cacheId, options) {\n        const { buildCacheConfiguration: { localCacheProvider, cloudCacheProvider, buildCacheEnabled, cacheWriteEnabled }, project, projectOutputFolderNames } = options;\n        this._project = project;\n        this._localBuildCacheProvider = localCacheProvider;\n        this._cloudBuildCacheProvider = cloudCacheProvider;\n        this._buildCacheEnabled = buildCacheEnabled;\n        this._cacheWriteEnabled = cacheWriteEnabled;\n        this._projectOutputFolderNames = projectOutputFolderNames || [];\n        this._cacheId = cacheId;\n    }\n    static _tryGetTarUtility(terminal) {\n        if (!ProjectBuildCache._tarUtilityPromise) {\n            ProjectBuildCache._tarUtilityPromise = TarExecutable.tryInitializeAsync(terminal);\n        }\n        return ProjectBuildCache._tarUtilityPromise;\n    }\n    get cacheId() {\n        return this._cacheId;\n    }\n    static getProjectBuildCache(options) {\n        const cacheId = ProjectBuildCache._getCacheId(options);\n        return new ProjectBuildCache(cacheId, options);\n    }\n    static forOperation(operation, options) {\n        var _a, _b;\n        if (!operation.associatedProject) {\n            throw new InternalError('Operation must have an associated project');\n        }\n        if (!operation.associatedPhase) {\n            throw new InternalError('Operation must have an associated phase');\n        }\n        const outputFolders = [...((_b = (_a = operation.operation.settings) === null || _a === void 0 ? void 0 : _a.outputFolderNames) !== null && _b !== void 0 ? _b : [])];\n        if (operation.metadataFolderPath) {\n            outputFolders.push(operation.metadataFolderPath);\n        }\n        const buildCacheOptions = Object.assign(Object.assign({}, options), { project: operation.associatedProject, phaseName: operation.associatedPhase.name, projectOutputFolderNames: outputFolders, operationStateHash: operation.stateHash });\n        const cacheId = ProjectBuildCache._getCacheId(buildCacheOptions);\n        return new ProjectBuildCache(cacheId, buildCacheOptions);\n    }\n    async tryRestoreFromCacheAsync(terminal, specifiedCacheId) {\n        const cacheId = specifiedCacheId || this._cacheId;\n        if (!cacheId) {\n            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\n            return false;\n        }\n        if (!this._buildCacheEnabled) {\n            // Skip reading local and cloud build caches, without any noise\n            return false;\n        }\n        let localCacheEntryPath = await this._localBuildCacheProvider.tryGetCacheEntryPathByIdAsync(terminal, cacheId);\n        let cacheEntryBuffer;\n        let updateLocalCacheSuccess;\n        if (!localCacheEntryPath && this._cloudBuildCacheProvider) {\n            terminal.writeVerboseLine('This project was not found in the local build cache. Querying the cloud build cache.');\n            cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(terminal, cacheId);\n            if (cacheEntryBuffer) {\n                try {\n                    localCacheEntryPath = await this._localBuildCacheProvider.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);\n                    updateLocalCacheSuccess = true;\n                }\n                catch (e) {\n                    updateLocalCacheSuccess = false;\n                }\n            }\n        }\n        if (!localCacheEntryPath && !cacheEntryBuffer) {\n            terminal.writeVerboseLine('This project was not found in the build cache.');\n            return false;\n        }\n        terminal.writeLine('Build cache hit.');\n        terminal.writeVerboseLine(`Cache key: ${cacheId}`);\n        const projectFolderPath = this._project.projectFolder;\n        // Purge output folders\n        terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);\n        await Promise.all(this._projectOutputFolderNames.map((outputFolderName) => FileSystem.deleteFolderAsync(`${projectFolderPath}/${outputFolderName}`)));\n        const tarUtility = await ProjectBuildCache._tryGetTarUtility(terminal);\n        let restoreSuccess = false;\n        if (tarUtility && localCacheEntryPath) {\n            const logFilePath = this._getTarLogFilePath(cacheId, 'untar');\n            const tarExitCode = await tarUtility.tryUntarAsync({\n                archivePath: localCacheEntryPath,\n                outputFolderPath: projectFolderPath,\n                logFilePath\n            });\n            if (tarExitCode === 0) {\n                restoreSuccess = true;\n                terminal.writeLine('Successfully restored output from the build cache.');\n            }\n            else {\n                terminal.writeWarningLine('Unable to restore output from the build cache. ' +\n                    `See \"${logFilePath}\" for logs from the tar process.`);\n            }\n        }\n        if (updateLocalCacheSuccess === false) {\n            terminal.writeWarningLine('Unable to update the local build cache with data from the cloud cache.');\n        }\n        return restoreSuccess;\n    }\n    async trySetCacheEntryAsync(terminal, specifiedCacheId) {\n        var _a, _b, _c;\n        if (!this._cacheWriteEnabled) {\n            // Skip writing local and cloud build caches, without any noise\n            return true;\n        }\n        const cacheId = specifiedCacheId || this._cacheId;\n        if (!cacheId) {\n            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\n            return false;\n        }\n        const filesToCache = await this._tryCollectPathsToCacheAsync(terminal);\n        if (!filesToCache) {\n            return false;\n        }\n        terminal.writeVerboseLine(`Caching build output folders: ${filesToCache.filteredOutputFolderNames.join(', ')}`);\n        let localCacheEntryPath;\n        const tarUtility = await ProjectBuildCache._tryGetTarUtility(terminal);\n        if (tarUtility) {\n            const finalLocalCacheEntryPath = this._localBuildCacheProvider.getCacheEntryPath(cacheId);\n            // Derive the temp file from the destination path to ensure they are on the same volume\n            // In the case of a shared network drive containing the build cache, we also need to make\n            // sure the the temp path won't be shared by two parallel rush builds.\n            const randomSuffix = crypto.randomBytes(8).toString('hex');\n            const tempLocalCacheEntryPath = `${finalLocalCacheEntryPath}-${randomSuffix}.temp`;\n            const logFilePath = this._getTarLogFilePath(cacheId, 'tar');\n            const tarExitCode = await tarUtility.tryCreateArchiveFromProjectPathsAsync({\n                archivePath: tempLocalCacheEntryPath,\n                paths: filesToCache.outputFilePaths,\n                project: this._project,\n                logFilePath\n            });\n            if (tarExitCode === 0) {\n                // Move after the archive is finished so that if the process is interrupted we aren't left with an invalid file\n                try {\n                    await Async.runWithRetriesAsync({\n                        action: () => FileSystem.moveAsync({\n                            sourcePath: tempLocalCacheEntryPath,\n                            destinationPath: finalLocalCacheEntryPath,\n                            overwrite: true\n                        }),\n                        maxRetries: 2,\n                        retryDelayMs: 500\n                    });\n                }\n                catch (moveError) {\n                    try {\n                        await FileSystem.deleteFileAsync(tempLocalCacheEntryPath);\n                    }\n                    catch (deleteError) {\n                        // Ignored\n                    }\n                    throw moveError;\n                }\n                localCacheEntryPath = finalLocalCacheEntryPath;\n            }\n            else {\n                terminal.writeWarningLine(`\"tar\" exited with code ${tarExitCode} while attempting to create the cache entry. ` +\n                    `See \"${logFilePath}\" for logs from the tar process.`);\n                return false;\n            }\n        }\n        else {\n            terminal.writeWarningLine(`Unable to locate \"tar\". Please ensure that \"tar\" is on your PATH environment variable, or set the ` +\n                `${EnvironmentVariableNames.RUSH_TAR_BINARY_PATH} environment variable to the full path to the \"tar\" binary.`);\n            return false;\n        }\n        let cacheEntryBuffer;\n        let setCloudCacheEntryPromise;\n        // Note that \"writeAllowed\" settings (whether in config or environment) always apply to\n        // the configured CLOUD cache. If the cache is enabled, rush is always allowed to read from and\n        // write to the local build cache.\n        if ((_a = this._cloudBuildCacheProvider) === null || _a === void 0 ? void 0 : _a.isCacheWriteAllowed) {\n            if (localCacheEntryPath) {\n                cacheEntryBuffer = await FileSystem.readFileToBufferAsync(localCacheEntryPath);\n            }\n            else {\n                throw new InternalError('Expected the local cache entry path to be set.');\n            }\n            setCloudCacheEntryPromise = (_b = this._cloudBuildCacheProvider) === null || _b === void 0 ? void 0 : _b.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);\n        }\n        const updateCloudCacheSuccess = (_c = (await setCloudCacheEntryPromise)) !== null && _c !== void 0 ? _c : true;\n        const success = updateCloudCacheSuccess && !!localCacheEntryPath;\n        if (success) {\n            terminal.writeLine('Successfully set cache entry.');\n            terminal.writeVerboseLine(`Cache key: ${cacheId}`);\n        }\n        else if (!localCacheEntryPath && updateCloudCacheSuccess) {\n            terminal.writeWarningLine('Unable to set local cache entry.');\n        }\n        else if (localCacheEntryPath && !updateCloudCacheSuccess) {\n            terminal.writeWarningLine('Unable to set cloud cache entry.');\n        }\n        else {\n            terminal.writeWarningLine('Unable to set both cloud and local cache entries.');\n        }\n        return success;\n    }\n    /**\n     * Walks the declared output folders of the project and collects a list of files.\n     * @returns The list of output files as project-relative paths, or `undefined` if a\n     *   symbolic link was encountered.\n     */\n    async _tryCollectPathsToCacheAsync(terminal) {\n        const projectFolderPath = this._project.projectFolder;\n        const outputFilePaths = [];\n        const queue = [];\n        const filteredOutputFolderNames = [];\n        let hasSymbolicLinks = false;\n        // Adds child directories to the queue, files to the path list, and bails on symlinks\n        function processChildren(relativePath, diskPath, children) {\n            for (const child of children) {\n                const childRelativePath = `${relativePath}/${child.name}`;\n                if (child.isSymbolicLink()) {\n                    terminal.writeError(`Unable to include \"${childRelativePath}\" in build cache. It is a symbolic link.`);\n                    hasSymbolicLinks = true;\n                }\n                else if (child.isDirectory()) {\n                    queue.push([childRelativePath, `${diskPath}/${child.name}`]);\n                }\n                else {\n                    outputFilePaths.push(childRelativePath);\n                }\n            }\n        }\n        // Handle declared output folders.\n        for (const outputFolder of this._projectOutputFolderNames) {\n            const diskPath = `${projectFolderPath}/${outputFolder}`;\n            try {\n                const children = await FileSystem.readFolderItemsAsync(diskPath);\n                processChildren(outputFolder, diskPath, children);\n                // The folder exists, record it\n                filteredOutputFolderNames.push(outputFolder);\n            }\n            catch (error) {\n                if (!FileSystem.isNotExistError(error)) {\n                    throw error;\n                }\n                // If the folder does not exist, ignore it.\n            }\n        }\n        for (const [relativePath, diskPath] of queue) {\n            const children = await FileSystem.readFolderItemsAsync(diskPath);\n            processChildren(relativePath, diskPath, children);\n        }\n        if (hasSymbolicLinks) {\n            // Symbolic links do not round-trip safely.\n            return undefined;\n        }\n        // Ensure stable output path order.\n        outputFilePaths.sort();\n        return {\n            outputFilePaths,\n            filteredOutputFolderNames\n        };\n    }\n    _getTarLogFilePath(cacheId, mode) {\n        return path.join(this._project.projectRushTempFolder, `${cacheId}.${mode}.log`);\n    }\n    static _getCacheId(options) {\n        const { buildCacheConfiguration, project: { packageName }, operationStateHash, phaseName } = options;\n        return buildCacheConfiguration.getCacheEntryId({\n            projectName: packageName,\n            projectStateHash: operationStateHash,\n            phaseName\n        });\n    }\n}\n//# sourceMappingURL=ProjectBuildCache.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { InternalError } from '@rushstack/node-core-library';\nconst KEY_SEPARATOR = ':';\nexport class CobuildLock {\n    constructor(options) {\n        const { cobuildConfiguration, projectBuildCache, cobuildClusterId: clusterId, lockExpireTimeInSeconds, packageName, phaseName } = options;\n        const { cobuildContextId: contextId, cobuildRunnerId: runnerId } = cobuildConfiguration;\n        const { cacheId } = projectBuildCache;\n        this.cobuildConfiguration = cobuildConfiguration;\n        this.projectBuildCache = projectBuildCache;\n        if (!cacheId) {\n            // This should never happen\n            throw new InternalError(`Cache id is require for cobuild lock`);\n        }\n        if (!contextId) {\n            // This should never happen\n            throw new InternalError(`Cobuild context id is require for cobuild lock`);\n        }\n        // Example: cobuild:lock:<contextId>:<clusterId>\n        const lockKey = ['cobuild', 'lock', contextId, clusterId].join(KEY_SEPARATOR);\n        // Example: cobuild:completed:<contextId>:<cacheId>\n        const completedStateKey = ['cobuild', 'completed', contextId, cacheId].join(KEY_SEPARATOR);\n        this._cobuildContext = {\n            contextId,\n            clusterId,\n            runnerId,\n            lockKey,\n            completedStateKey,\n            packageName,\n            phaseName,\n            lockExpireTimeInSeconds: lockExpireTimeInSeconds,\n            cacheId\n        };\n    }\n    async setCompletedStateAsync(state) {\n        await this.cobuildConfiguration\n            .getCobuildLockProvider()\n            .setCompletedStateAsync(this._cobuildContext, state);\n    }\n    async getCompletedStateAsync() {\n        const state = await this.cobuildConfiguration\n            .getCobuildLockProvider()\n            .getCompletedStateAsync(this._cobuildContext);\n        return state;\n    }\n    async tryAcquireLockAsync() {\n        const acquireLockResult = await this.cobuildConfiguration\n            .getCobuildLockProvider()\n            .acquireLockAsync(this._cobuildContext);\n        if (acquireLockResult) {\n            // renew the lock in a redundant way in case of losing the lock\n            await this.renewLockAsync();\n        }\n        return acquireLockResult;\n    }\n    async renewLockAsync() {\n        await this.cobuildConfiguration.getCobuildLockProvider().renewLockAsync(this._cobuildContext);\n    }\n    get cobuildContext() {\n        return this._cobuildContext;\n    }\n}\n//# sourceMappingURL=CobuildLock.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { InternalError } from '@rushstack/node-core-library';\n/**\n * A disjoint set data structure\n */\nexport class DisjointSet {\n    constructor() {\n        this._forest = new Set();\n        this._parentMap = new Map();\n        this._sizeMap = new Map();\n        this._setByElement = new Map();\n    }\n    destroy() {\n        var _a;\n        this._forest.clear();\n        this._parentMap.clear();\n        this._sizeMap.clear();\n        (_a = this._setByElement) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    /**\n     * Adds a new set containing specific object\n     */\n    add(x) {\n        if (this._forest.has(x)) {\n            return;\n        }\n        this._forest.add(x);\n        this._parentMap.set(x, x);\n        this._sizeMap.set(x, 1);\n        this._setByElement = undefined;\n    }\n    /**\n     * Unions the sets that contain two objects\n     */\n    union(a, b) {\n        let x = this._find(a);\n        let y = this._find(b);\n        if (x === y) {\n            // x and y are already in the same set\n            return;\n        }\n        const xSize = this._getSize(x);\n        const ySize = this._getSize(y);\n        if (xSize < ySize) {\n            const t = x;\n            x = y;\n            y = t;\n        }\n        this._parentMap.set(y, x);\n        this._sizeMap.set(x, xSize + ySize);\n        this._setByElement = undefined;\n    }\n    getAllSets() {\n        if (this._setByElement === undefined) {\n            this._setByElement = new Map();\n            for (const element of this._forest) {\n                const root = this._find(element);\n                let set = this._setByElement.get(root);\n                if (set === undefined) {\n                    set = new Set();\n                    this._setByElement.set(root, set);\n                }\n                set.add(element);\n            }\n        }\n        return this._setByElement.values();\n    }\n    /**\n     * Returns true if x and y are in the same set\n     */\n    isConnected(x, y) {\n        return this._find(x) === this._find(y);\n    }\n    _find(a) {\n        let x = a;\n        let parent = this._getParent(x);\n        while (parent !== x) {\n            parent = this._getParent(parent);\n            this._parentMap.set(x, parent);\n            x = parent;\n            parent = this._getParent(x);\n        }\n        return x;\n    }\n    _getParent(x) {\n        const parent = this._parentMap.get(x);\n        if (parent === undefined) {\n            // This should not happen\n            throw new InternalError(`Can not find parent`);\n        }\n        return parent;\n    }\n    _getSize(x) {\n        const size = this._sizeMap.get(x);\n        if (size === undefined) {\n            // This should not happen\n            throw new InternalError(`Can not get size`);\n        }\n        return size;\n    }\n}\n//# sourceMappingURL=DisjointSet.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport schemaJson from '../../schemas/deploy-scenario.schema.json';\nimport { RushConstants } from '../RushConstants';\nexport class DeployScenarioConfiguration {\n    constructor(json, projectJsonsByName) {\n        this.json = json;\n        this.projectJsonsByName = projectJsonsByName;\n    }\n    /**\n     * Validates that the input string conforms to the naming rules for a \"rush deploy\" scenario name.\n     */\n    static validateScenarioName(scenarioName) {\n        if (!scenarioName) {\n            throw new Error('The scenario name cannot be an empty string');\n        }\n        if (!this._scenarioNameRegExp.test(scenarioName)) {\n            throw new Error(`\"${scenarioName}\" is not a valid scenario name. The name must be comprised of` +\n                ' lowercase letters and numbers, separated by single hyphens. Example: \"my-scenario\"');\n        }\n    }\n    /**\n     * Given the --scenarioName value, return the full path of the filename.\n     *\n     * Example: \"ftp-site\" --> \"...common/config/rush/deploy-ftp-site.json\"\n     * Example: undefined --> \"...common/config/rush/deploy.json\"\n     */\n    static getConfigFilePath(scenarioName, rushConfiguration) {\n        let scenarioFileName;\n        if (scenarioName) {\n            DeployScenarioConfiguration.validateScenarioName(scenarioName);\n            scenarioFileName = `deploy-${scenarioName}.json`;\n        }\n        else {\n            scenarioFileName = `deploy.json`;\n        }\n        return path.join(rushConfiguration.commonRushConfigFolder, scenarioFileName);\n    }\n    static loadFromFile(terminal, scenarioFilePath, rushConfiguration) {\n        if (!FileSystem.exists(scenarioFilePath)) {\n            throw new Error('The scenario config file was not found: ' + scenarioFilePath);\n        }\n        terminal.writeLine(Colorize.cyan(`Loading deployment scenario: ${scenarioFilePath}`));\n        const deployScenarioJson = JsonFile.loadAndValidate(scenarioFilePath, DeployScenarioConfiguration._jsonSchema);\n        // Apply the defaults\n        if (!deployScenarioJson.linkCreation) {\n            deployScenarioJson.linkCreation = 'default';\n        }\n        const deployScenarioProjectJsonsByName = new Map();\n        for (const projectSetting of deployScenarioJson.projectSettings || []) {\n            // Validate projectSetting.projectName\n            if (!rushConfiguration.getProjectByName(projectSetting.projectName)) {\n                throw new Error(`The \"projectSettings\" section refers to the project name \"${projectSetting.projectName}\"` +\n                    ` which was not found in ${RushConstants.rushJsonFilename}`);\n            }\n            for (const additionalProjectsToInclude of projectSetting.additionalProjectsToInclude || []) {\n                if (!rushConfiguration.getProjectByName(projectSetting.projectName)) {\n                    throw new Error(`The \"additionalProjectsToInclude\" setting refers to the` +\n                        ` project name \"${additionalProjectsToInclude}\" which was not found in ${RushConstants.rushJsonFilename}`);\n                }\n            }\n            deployScenarioProjectJsonsByName.set(projectSetting.projectName, projectSetting);\n        }\n        return new DeployScenarioConfiguration(deployScenarioJson, deployScenarioProjectJsonsByName);\n    }\n}\n// Used by validateScenarioName()\n// Matches lowercase words separated by dashes.\n// Example: \"deploy-the-thing123\"\nDeployScenarioConfiguration._scenarioNameRegExp = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nDeployScenarioConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=DeployScenarioConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'node:path';\nimport { createHash } from 'node:crypto';\nimport ignore from 'ignore';\nimport { LookupByPath } from '@rushstack/lookup-by-path';\nimport { InternalError, Path, Sort } from '@rushstack/node-core-library';\nimport { RushConstants } from '../RushConstants';\nconst { hashDelimiter } = RushConstants;\n/**\n * Represents a synchronously-queryable in-memory snapshot of the state of the inputs to a Rush repository.\n * Any asynchronous work needs to be performed by the caller and the results passed to the constructor.\n *\n * @remarks\n * All operations on this class will return the same result regardless of when they are executed.\n *\n * @internal\n */\nexport class InputsSnapshot {\n    /**\n     *\n     * @param params - The parameters for the snapshot\n     * @internal\n     */\n    constructor(params) {\n        const { additionalHashes, environment = Object.assign({}, process.env), globalAdditionalFiles, hashes, lookupByPath, rootDir } = params;\n        const projectMetadataMap = new Map();\n        for (const [project, record] of params.projectMap) {\n            projectMetadataMap.set(project, createInternalRecord(project, record, rootDir));\n        }\n        // Route hashes to individual projects\n        for (const [file, hash] of hashes) {\n            const project = lookupByPath.findChildPath(file);\n            if (!project) {\n                continue;\n            }\n            let record = projectMetadataMap.get(project);\n            if (!record) {\n                projectMetadataMap.set(project, (record = createInternalRecord(project, undefined, rootDir)));\n            }\n            record.hashes.set(file, hash);\n        }\n        let globalAdditionalHashes;\n        if (globalAdditionalFiles) {\n            globalAdditionalHashes = new Map();\n            const sortedAdditionalFiles = Array.from(globalAdditionalFiles).sort();\n            for (const file of sortedAdditionalFiles) {\n                const hash = hashes.get(file);\n                if (!hash) {\n                    throw new Error(`Hash not found for global file: \"${file}\"`);\n                }\n                const owningProject = lookupByPath.findChildPath(file);\n                if (owningProject) {\n                    throw new InternalError(`Requested global additional file \"${file}\" is owned by project in \"${owningProject.projectRelativeFolder}\". Declare a project dependency instead.`);\n                }\n                globalAdditionalHashes.set(file, hash);\n            }\n        }\n        for (const record of projectMetadataMap.values()) {\n            // Ensure stable ordering.\n            Sort.sortMapKeys(record.hashes);\n        }\n        this._projectMetadataMap = projectMetadataMap;\n        this._additionalHashes = additionalHashes;\n        this._globalAdditionalHashes = globalAdditionalHashes;\n        // Snapshot the environment so that queries are not impacted by when they happen\n        this._environment = environment;\n        this.hashes = hashes;\n        this.rootDirectory = rootDir;\n    }\n    /**\n     * {@inheritdoc}\n     */\n    getTrackedFileHashesForOperation(project, operationName) {\n        var _a, _b;\n        const record = this._projectMetadataMap.get(project);\n        if (!record) {\n            throw new InternalError(`No information available for project at ${project.projectFolder}`);\n        }\n        const { fileHashesByOperationName } = record;\n        let hashes = fileHashesByOperationName.get(operationName);\n        if (!hashes) {\n            hashes = new Map();\n            fileHashesByOperationName.set(operationName, hashes);\n            // TODO: Support incrementalBuildIgnoredGlobs per-operation\n            const filter = getOrCreateProjectFilter(record);\n            let outputValidator;\n            if (operationName) {\n                const operationSettings = (_a = record.projectConfig) === null || _a === void 0 ? void 0 : _a.operationSettingsByOperationName.get(operationName);\n                const outputFolderNames = operationSettings === null || operationSettings === void 0 ? void 0 : operationSettings.outputFolderNames;\n                if (outputFolderNames) {\n                    const { relativePrefix } = record;\n                    outputValidator = new LookupByPath();\n                    for (const folderName of outputFolderNames) {\n                        outputValidator.setItem(`${relativePrefix}/${folderName}`, folderName);\n                    }\n                }\n                // Hash any additional files (files outside of a project, untracked project files, or even files outside of the repository)\n                const additionalFilesForOperation = (_b = record.additionalFilesByOperationName) === null || _b === void 0 ? void 0 : _b.get(operationName);\n                if (additionalFilesForOperation) {\n                    for (const [filePath, hash] of this._resolveHashes(additionalFilesForOperation)) {\n                        hashes.set(filePath, hash);\n                    }\n                }\n            }\n            const { _globalAdditionalHashes: globalAdditionalHashes } = this;\n            if (globalAdditionalHashes) {\n                for (const [file, hash] of globalAdditionalHashes) {\n                    record.hashes.set(file, hash);\n                }\n            }\n            // Hash the base project files\n            for (const [filePath, hash] of record.hashes) {\n                if (filter(filePath)) {\n                    hashes.set(filePath, hash);\n                }\n                // Ensure that the configured output folders for this operation do not contain any input files\n                // This should be reworked to operate on a global file origin map to ensure a hashed input\n                // is not a declared output of *any* operation.\n                const outputMatch = outputValidator === null || outputValidator === void 0 ? void 0 : outputValidator.findChildPath(filePath);\n                if (outputMatch) {\n                    throw new Error(`Configured output folder \"${outputMatch}\" for operation \"${operationName}\" in project \"${project.projectRelativeFolder}\" contains tracked input file \"${filePath}\".` +\n                        ` If it is intended that this operation modifies its own input files, modify the build process to emit a warning if the output version differs from the input, and remove the directory from \"outputFolderNames\".` +\n                        ` This will ensure cache correctness. Otherwise, change the build process to output to a disjoint folder.`);\n                }\n            }\n        }\n        return hashes;\n    }\n    /**\n     * {@inheritdoc}\n     */\n    getOperationOwnStateHash(project, operationName) {\n        var _a;\n        const record = this._projectMetadataMap.get(project);\n        if (!record) {\n            throw new Error(`No information available for project at ${project.projectFolder}`);\n        }\n        const { hashByOperationName } = record;\n        let hash = hashByOperationName.get(operationName);\n        if (!hash) {\n            const hashes = this.getTrackedFileHashesForOperation(project, operationName);\n            const hasher = createHash('sha1');\n            // If this is for a specific operation, apply operation-specific options\n            if (operationName) {\n                const operationSettings = (_a = record.projectConfig) === null || _a === void 0 ? void 0 : _a.operationSettingsByOperationName.get(operationName);\n                if (operationSettings) {\n                    const { dependsOnEnvVars, outputFolderNames } = operationSettings;\n                    if (dependsOnEnvVars) {\n                        // As long as we enumerate environment variables in a consistent order, we will get a stable hash.\n                        // Changing the order in rush-project.json will change the hash anyway since the file contents are part of the hash.\n                        for (const envVar of dependsOnEnvVars) {\n                            hasher.update(`${hashDelimiter}$${envVar}=${this._environment[envVar] || ''}`);\n                        }\n                    }\n                    if (outputFolderNames) {\n                        hasher.update(`${hashDelimiter}${JSON.stringify(outputFolderNames)}`);\n                    }\n                }\n            }\n            // Hash the base project files\n            for (const [filePath, fileHash] of hashes) {\n                hasher.update(`${hashDelimiter}${filePath}${hashDelimiter}${fileHash}`);\n            }\n            hash = hasher.digest('hex');\n            hashByOperationName.set(operationName, hash);\n        }\n        return hash;\n    }\n    *_resolveHashes(filePaths) {\n        var _a;\n        const { hashes, _additionalHashes } = this;\n        for (const filePath of filePaths) {\n            const hash = (_a = hashes.get(filePath)) !== null && _a !== void 0 ? _a : _additionalHashes === null || _additionalHashes === void 0 ? void 0 : _additionalHashes.get(filePath);\n            if (!hash) {\n                throw new Error(`Could not find hash for file path \"${filePath}\"`);\n            }\n            yield [filePath, hash];\n        }\n    }\n}\nfunction getOrCreateProjectFilter(record) {\n    var _a;\n    if (!record.projectFilePathFilter) {\n        const ignoredGlobs = (_a = record.projectConfig) === null || _a === void 0 ? void 0 : _a.incrementalBuildIgnoredGlobs;\n        if (!ignoredGlobs || ignoredGlobs.length === 0) {\n            record.projectFilePathFilter = noopFilter;\n        }\n        else {\n            const ignorer = ignore();\n            ignorer.add(ignoredGlobs);\n            const prefixLength = record.relativePrefix.length + 1;\n            record.projectFilePathFilter = function projectFilePathFilter(filePath) {\n                return !ignorer.ignores(filePath.slice(prefixLength));\n            };\n        }\n    }\n    return record.projectFilePathFilter;\n}\nfunction createInternalRecord(project, baseRecord, rootDir) {\n    return {\n        // Data from the caller\n        projectConfig: baseRecord === null || baseRecord === void 0 ? void 0 : baseRecord.projectConfig,\n        additionalFilesByOperationName: baseRecord === null || baseRecord === void 0 ? void 0 : baseRecord.additionalFilesByOperationName,\n        // Caches\n        hashes: new Map(),\n        hashByOperationName: new Map(),\n        fileHashesByOperationName: new Map(),\n        relativePrefix: getRelativePrefix(project, rootDir)\n    };\n}\nfunction getRelativePrefix(project, rootDir) {\n    return Path.convertToSlashes(path.relative(rootDir, project.projectFolder));\n}\nfunction noopFilter(filePath) {\n    return true;\n}\n//# sourceMappingURL=InputsSnapshot.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileConstants, FileSystem, JsonFile, LockFile } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { LastInstallFlag } from '../../api/LastInstallFlag';\nimport { Utilities } from '../../utilities/Utilities';\nimport { merge } from '../../utilities/objectUtilities';\nimport { RushConstants } from '../RushConstants';\nimport * as semver from 'semver';\nexport class InstallHelpers {\n    static generateCommonPackageJson(rushConfiguration, subspace, dependencies = new Map(), terminal) {\n        const commonPackageJson = {\n            dependencies: {},\n            description: 'Temporary file generated by the Rush tool',\n            name: 'rush-common',\n            private: true,\n            version: '0.0.0'\n        };\n        if (rushConfiguration.isPnpm) {\n            const pnpmOptions = subspace.getPnpmOptions() || rushConfiguration.pnpmOptions;\n            if (!commonPackageJson.pnpm) {\n                commonPackageJson.pnpm = {};\n            }\n            if (pnpmOptions.globalOverrides) {\n                commonPackageJson.pnpm.overrides = pnpmOptions.globalOverrides;\n            }\n            if (pnpmOptions.globalPackageExtensions) {\n                commonPackageJson.pnpm.packageExtensions = pnpmOptions.globalPackageExtensions;\n            }\n            if (pnpmOptions.globalPeerDependencyRules) {\n                commonPackageJson.pnpm.peerDependencyRules = pnpmOptions.globalPeerDependencyRules;\n            }\n            if (pnpmOptions.globalNeverBuiltDependencies) {\n                commonPackageJson.pnpm.neverBuiltDependencies = pnpmOptions.globalNeverBuiltDependencies;\n            }\n            if (pnpmOptions.globalIgnoredOptionalDependencies) {\n                if (rushConfiguration.rushConfigurationJson.pnpmVersion !== undefined &&\n                    semver.lt(rushConfiguration.rushConfigurationJson.pnpmVersion, '9.0.0')) {\n                    terminal.writeWarningLine(Colorize.yellow(`Your version of pnpm (${rushConfiguration.rushConfigurationJson.pnpmVersion}) ` +\n                        `doesn't support the \"globalIgnoredOptionalDependencies\" field in ` +\n                        `${rushConfiguration.commonRushConfigFolder}/${RushConstants.pnpmConfigFilename}. ` +\n                        'Remove this field or upgrade to pnpm 9.'));\n                }\n                commonPackageJson.pnpm.ignoredOptionalDependencies = pnpmOptions.globalIgnoredOptionalDependencies;\n            }\n            if (pnpmOptions.globalAllowedDeprecatedVersions) {\n                commonPackageJson.pnpm.allowedDeprecatedVersions = pnpmOptions.globalAllowedDeprecatedVersions;\n            }\n            if (pnpmOptions.globalPatchedDependencies) {\n                commonPackageJson.pnpm.patchedDependencies = pnpmOptions.globalPatchedDependencies;\n            }\n            if (pnpmOptions.unsupportedPackageJsonSettings) {\n                merge(commonPackageJson, pnpmOptions.unsupportedPackageJsonSettings);\n            }\n        }\n        // Add any preferred versions to the top of the commonPackageJson\n        // do this in alphabetical order for simpler debugging\n        for (const dependency of Array.from(dependencies.keys()).sort()) {\n            commonPackageJson.dependencies[dependency] = dependencies.get(dependency);\n        }\n        // Example: \"C:\\MyRepo\\common\\temp\\package.json\"\n        const commonPackageJsonFilename = path.join(subspace.getSubspaceTempFolderPath(), FileConstants.PackageJson);\n        // Don't update the file timestamp unless the content has changed, since \"rush install\"\n        // will consider this timestamp\n        JsonFile.save(commonPackageJson, commonPackageJsonFilename, { onlyIfChanged: true });\n    }\n    static getPackageManagerEnvironment(rushConfiguration, options = {}) {\n        let configurationEnvironment = undefined;\n        if (rushConfiguration.packageManager === 'npm') {\n            if (rushConfiguration.npmOptions && rushConfiguration.npmOptions.environmentVariables) {\n                configurationEnvironment = rushConfiguration.npmOptions.environmentVariables;\n            }\n        }\n        else if (rushConfiguration.isPnpm) {\n            if (rushConfiguration.pnpmOptions && rushConfiguration.pnpmOptions.environmentVariables) {\n                configurationEnvironment = rushConfiguration.pnpmOptions.environmentVariables;\n            }\n        }\n        else if (rushConfiguration.packageManager === 'yarn') {\n            if (rushConfiguration.yarnOptions && rushConfiguration.yarnOptions.environmentVariables) {\n                configurationEnvironment = rushConfiguration.yarnOptions.environmentVariables;\n            }\n        }\n        return InstallHelpers._mergeEnvironmentVariables(process.env, configurationEnvironment, options);\n    }\n    /**\n     * If the \"(p)npm-local\" symlink hasn't been set up yet, this creates it, installing the\n     * specified (P)npm version in the user's home directory if needed.\n     */\n    static async ensureLocalPackageManagerAsync(rushConfiguration, rushGlobalFolder, maxInstallAttempts, restrictConsoleOutput) {\n        let logIfConsoleOutputIsNotRestricted;\n        if (restrictConsoleOutput) {\n            logIfConsoleOutputIsNotRestricted = () => {\n                /* noop */\n            };\n        }\n        else {\n            logIfConsoleOutputIsNotRestricted = (message) => {\n                // eslint-disable-next-line no-console\n                console.log(message);\n            };\n        }\n        // Example: \"C:\\Users\\YourName\\.rush\"\n        const rushUserFolder = rushGlobalFolder.nodeSpecificPath;\n        if (!FileSystem.exists(rushUserFolder)) {\n            logIfConsoleOutputIsNotRestricted('Creating ' + rushUserFolder);\n            FileSystem.ensureFolder(rushUserFolder);\n        }\n        const packageManager = rushConfiguration.packageManager;\n        const packageManagerVersion = rushConfiguration.packageManagerToolVersion;\n        const packageManagerAndVersion = `${packageManager}-${packageManagerVersion}`;\n        // Example: \"C:\\Users\\YourName\\.rush\\pnpm-1.2.3\"\n        const packageManagerToolFolder = path.join(rushUserFolder, packageManagerAndVersion);\n        const packageManagerMarker = new LastInstallFlag(packageManagerToolFolder, {\n            node: process.versions.node\n        });\n        logIfConsoleOutputIsNotRestricted(`Trying to acquire lock for ${packageManagerAndVersion}`);\n        const lock = await LockFile.acquireAsync(rushUserFolder, packageManagerAndVersion);\n        logIfConsoleOutputIsNotRestricted(`Acquired lock for ${packageManagerAndVersion}`);\n        if (!(await packageManagerMarker.isValidAsync()) || lock.dirtyWhenAcquired) {\n            logIfConsoleOutputIsNotRestricted(Colorize.bold(`Installing ${packageManager} version ${packageManagerVersion}\\n`));\n            // note that this will remove the last-install flag from the directory\n            await Utilities.installPackageInDirectoryAsync({\n                directory: packageManagerToolFolder,\n                packageName: packageManager,\n                version: rushConfiguration.packageManagerToolVersion,\n                tempPackageTitle: `${packageManager}-local-install`,\n                maxInstallAttempts: maxInstallAttempts,\n                // This is using a local configuration to install a package in a shared global location.\n                // Generally that's a bad practice, but in this case if we can successfully install\n                // the package at all, we can reasonably assume it's good for all the repositories.\n                // In particular, we'll assume that two different NPM registries cannot have two\n                // different implementations of the same version of the same package.\n                // This was needed for: https://github.com/microsoft/rushstack/issues/691\n                commonRushConfigFolder: rushConfiguration.commonRushConfigFolder\n            });\n            logIfConsoleOutputIsNotRestricted(`Successfully installed ${packageManager} version ${packageManagerVersion}`);\n        }\n        else {\n            logIfConsoleOutputIsNotRestricted(`Found ${packageManager} version ${packageManagerVersion} in ${packageManagerToolFolder}`);\n        }\n        await packageManagerMarker.createAsync();\n        // Example: \"C:\\MyRepo\\common\\temp\"\n        FileSystem.ensureFolder(rushConfiguration.commonTempFolder);\n        // Example: \"C:\\MyRepo\\common\\temp\\pnpm-local\"\n        const localPackageManagerToolFolder = path.join(rushConfiguration.commonTempFolder, `${packageManager}-local`);\n        logIfConsoleOutputIsNotRestricted(`\\nSymlinking \"${localPackageManagerToolFolder}\"`);\n        logIfConsoleOutputIsNotRestricted(`  --> \"${packageManagerToolFolder}\"`);\n        // We cannot use FileSystem.exists() to test the existence of a symlink, because it will\n        // return false for broken symlinks.  There is no way to test without catching an exception.\n        try {\n            FileSystem.deleteFolder(localPackageManagerToolFolder);\n        }\n        catch (error) {\n            if (error.code !== 'ENOENT') {\n                throw error;\n            }\n        }\n        FileSystem.createSymbolicLinkJunction({\n            linkTargetPath: packageManagerToolFolder,\n            newLinkPath: localPackageManagerToolFolder\n        });\n        lock.release();\n    }\n    // Helper for getPackageManagerEnvironment\n    static _mergeEnvironmentVariables(baseEnv, environmentVariables, options = {}) {\n        const packageManagerEnv = baseEnv;\n        if (environmentVariables) {\n            // eslint-disable-next-line guard-for-in\n            for (const envVar in environmentVariables) {\n                let setEnvironmentVariable = true;\n                // eslint-disable-next-line no-console\n                console.log(`\\nProcessing definition for environment variable: ${envVar}`);\n                if (baseEnv.hasOwnProperty(envVar)) {\n                    setEnvironmentVariable = false;\n                    // eslint-disable-next-line no-console\n                    console.log(`Environment variable already defined:`);\n                    // eslint-disable-next-line no-console\n                    console.log(`  Name: ${envVar}`);\n                    // eslint-disable-next-line no-console\n                    console.log(`  Existing value: ${baseEnv[envVar]}`);\n                    // eslint-disable-next-line no-console\n                    console.log(`  Value set in ${RushConstants.rushJsonFilename}: ${environmentVariables[envVar].value}`);\n                    if (environmentVariables[envVar].override) {\n                        setEnvironmentVariable = true;\n                        // eslint-disable-next-line no-console\n                        console.log(`Overriding the environment variable with the value set in ${RushConstants.rushJsonFilename}.`);\n                    }\n                    else {\n                        // eslint-disable-next-line no-console\n                        console.log(Colorize.yellow(`WARNING: Not overriding the value of the environment variable.`));\n                    }\n                }\n                if (setEnvironmentVariable) {\n                    if (options.debug) {\n                        // eslint-disable-next-line no-console\n                        console.log(`Setting environment variable for package manager.`);\n                        // eslint-disable-next-line no-console\n                        console.log(`  Name: ${envVar}`);\n                        // eslint-disable-next-line no-console\n                        console.log(`  Value: ${environmentVariables[envVar].value}`);\n                    }\n                    packageManagerEnv[envVar] = environmentVariables[envVar].value;\n                }\n            }\n        }\n        return packageManagerEnv;\n    }\n}\n//# sourceMappingURL=InstallHelpers.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageManagerOptionsConfigurationBase } from '../base/BasePackageManagerOptionsConfiguration';\n/**\n * Options that are only used when the NPM package manager is selected.\n *\n * @remarks\n * It is valid to define these options in rush.json even if the NPM package manager\n * is not being used.\n *\n * @public\n */\nexport class NpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {\n    /** @internal */\n    constructor(json) {\n        super(json);\n    }\n}\n//# sourceMappingURL=NpmOptionsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, FileSystem, InternalError } from '@rushstack/node-core-library';\nimport { BaseShrinkwrapFile } from '../base/BaseShrinkwrapFile';\nimport { DependencySpecifier } from '../DependencySpecifier';\nexport class NpmShrinkwrapFile extends BaseShrinkwrapFile {\n    constructor(shrinkwrapJson) {\n        super();\n        this._shrinkwrapJson = shrinkwrapJson;\n        // Normalize the data\n        if (!this._shrinkwrapJson.version) {\n            this._shrinkwrapJson.version = '';\n        }\n        if (!this._shrinkwrapJson.name) {\n            this._shrinkwrapJson.name = '';\n        }\n        if (!this._shrinkwrapJson.dependencies) {\n            this._shrinkwrapJson.dependencies = {};\n        }\n        // Workspaces not supported in NPM\n        this.isWorkspaceCompatible = false;\n    }\n    static loadFromFile(shrinkwrapJsonFilename) {\n        try {\n            const shrinkwrapContent = FileSystem.readFile(shrinkwrapJsonFilename);\n            return NpmShrinkwrapFile.loadFromString(shrinkwrapContent);\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                return undefined; // file does not exist\n            }\n            throw new Error(`Error reading \"${shrinkwrapJsonFilename}\":\\n  ${error.message}`);\n        }\n    }\n    static loadFromString(shrinkwrapContent) {\n        // strip BOM\n        const data = shrinkwrapContent.charCodeAt(0) === 0xfeff ? shrinkwrapContent.slice(1) : shrinkwrapContent;\n        // We don't use JsonFile/jju here because shrinkwrap.json is a special NPM file format\n        // and typically very large, so we want to load it the same way that NPM does.\n        return new NpmShrinkwrapFile(JSON.parse(data));\n    }\n    /** @override */\n    getTempProjectNames() {\n        return this._getTempProjectNames(this._shrinkwrapJson.dependencies);\n    }\n    /** @override */\n    serialize() {\n        return JsonFile.stringify(this._shrinkwrapJson);\n    }\n    /** @override */\n    getTopLevelDependencyVersion(dependencyName) {\n        // First, check under tempProjectName, as this is the first place we look during linking.\n        const dependencyJson = NpmShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, dependencyName);\n        if (!dependencyJson) {\n            return undefined;\n        }\n        return new DependencySpecifier(dependencyName, dependencyJson.version);\n    }\n    /**\n     * @param dependencyName the name of the dependency to get a version for\n     * @param tempProjectName the name of the temp project to check for this dependency\n     * @param versionRange Not used, just exists to satisfy abstract API contract\n     * @override\n     */\n    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {\n        // First, check under tempProjectName, as this is the first place we look during linking.\n        let dependencyJson = undefined;\n        const tempDependency = NpmShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, tempProjectName);\n        if (tempDependency && tempDependency.dependencies) {\n            dependencyJson = NpmShrinkwrapFile.tryGetValue(tempDependency.dependencies, dependencySpecifier.packageName);\n        }\n        // Otherwise look at the root of the shrinkwrap file\n        if (!dependencyJson) {\n            return this.getTopLevelDependencyVersion(dependencySpecifier.packageName);\n        }\n        return new DependencySpecifier(dependencySpecifier.packageName, dependencyJson.version);\n    }\n    /** @override */\n    getProjectShrinkwrap(project) {\n        return undefined;\n    }\n    /** @override */\n    async isWorkspaceProjectModifiedAsync(project, subspace, variant) {\n        throw new InternalError('Not implemented');\n    }\n}\n//# sourceMappingURL=NpmShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { OperationStatus } from './OperationStatus';\nimport { RushConstants } from '../RushConstants';\n/**\n * Implementation of the async iteration protocol for a collection of IOperation objects.\n * The async iterator will wait for an operation to be ready for execution, or terminate if there are no more operations.\n *\n * @remarks\n * If the caller does not update dependencies prior to invoking `next()` on the iterator again,\n * it must manually invoke `assignOperations()` after performing the updates, otherwise iterators will\n * stall until another operations completes.\n */\nexport class AsyncOperationQueue {\n    /**\n     * @param operations - The set of operations to be executed\n     * @param sortFn - A function that sorts operations in reverse priority order:\n     *   - Returning a positive value indicates that `a` should execute before `b`.\n     *   - Returning a negative value indicates that `b` should execute before `a`.\n     *   - Returning 0 indicates no preference.\n     */\n    constructor(operations, sortFn) {\n        this._queue = computeTopologyAndSort(operations, sortFn);\n        this._pendingIterators = [];\n        this._totalOperations = this._queue.length;\n        this._isDone = false;\n        this._completedOperations = new Set();\n    }\n    /**\n     * For use with `for await (const operation of taskQueue)`\n     * @see {AsyncIterator}\n     */\n    next() {\n        const { _pendingIterators: waitingIterators } = this;\n        const promise = new Promise((resolve) => {\n            waitingIterators.push(resolve);\n        });\n        this.assignOperations();\n        return promise;\n    }\n    /**\n     * Set a callback to be invoked when one operation is completed.\n     * If all operations are completed, set the queue to done, resolve all pending iterators in next cycle.\n     */\n    complete(record) {\n        this._completedOperations.add(record);\n        // Apply status changes to direct dependents\n        if (record.status !== OperationStatus.Failure && record.status !== OperationStatus.Blocked) {\n            // Only do so if the operation did not fail or get blocked\n            for (const item of record.consumers) {\n                // Remove this operation from the dependencies, to unblock the scheduler\n                if (item.dependencies.delete(record) &&\n                    item.dependencies.size === 0 &&\n                    item.status === OperationStatus.Waiting) {\n                    item.status = OperationStatus.Ready;\n                }\n            }\n        }\n        this.assignOperations();\n        if (this._completedOperations.size === this._totalOperations) {\n            this._isDone = true;\n        }\n    }\n    /**\n     * Routes ready operations with 0 dependencies to waiting iterators. Normally invoked as part of `next()`, but\n     * if the caller does not update operation dependencies prior to calling `next()`, may need to be invoked manually.\n     */\n    assignOperations() {\n        const { _queue: queue, _pendingIterators: waitingIterators } = this;\n        // By iterating in reverse order we do less array shuffling when removing operations\n        for (let i = queue.length - 1; waitingIterators.length > 0 && i >= 0; i--) {\n            const record = queue[i];\n            if (record.status === OperationStatus.Blocked ||\n                record.status === OperationStatus.Skipped ||\n                record.status === OperationStatus.Success ||\n                record.status === OperationStatus.SuccessWithWarning ||\n                record.status === OperationStatus.FromCache ||\n                record.status === OperationStatus.NoOp ||\n                record.status === OperationStatus.Failure) {\n                // It shouldn't be on the queue, remove it\n                queue.splice(i, 1);\n            }\n            else if (record.status === OperationStatus.Queued || record.status === OperationStatus.Executing) {\n                // This operation is currently executing\n                // next one plz :)\n            }\n            else if (record.status === OperationStatus.Waiting) {\n                // This operation is not yet ready to be executed\n                // next one plz :)\n                continue;\n            }\n            else if (record.status !== OperationStatus.Ready) {\n                // Sanity check\n                throw new Error(`Unexpected status \"${record.status}\" for queued operation: ${record.name}`);\n            }\n            else {\n                // This task is ready to process, hand it to the iterator.\n                // Needs to have queue semantics, otherwise tools that iterate it get confused\n                record.status = OperationStatus.Queued;\n                waitingIterators.shift()({\n                    value: record,\n                    done: false\n                });\n            }\n            // Otherwise operation is still waiting\n        }\n        // Since items only get removed from the queue when they have a final status, this should be safe.\n        if (queue.length === 0) {\n            this._isDone = true;\n        }\n        if (this._isDone) {\n            for (const resolveAsyncIterator of waitingIterators.splice(0)) {\n                resolveAsyncIterator({\n                    value: undefined,\n                    done: true\n                });\n            }\n            return;\n        }\n    }\n    /**\n     * Returns this queue as an async iterator, such that multiple functions iterating this object concurrently\n     * receive distinct iteration results.\n     */\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n}\n/**\n * Performs a depth-first search to topologically sort the operations, subject to override via sortFn\n */\nfunction computeTopologyAndSort(operations, sortFn) {\n    // Clone the set of operations as an array, so that we can sort it.\n    const queue = Array.from(operations);\n    // Create a collection for detecting visited nodes\n    const cycleDetectorStack = new Set();\n    for (const operation of queue) {\n        calculateCriticalPathLength(operation, cycleDetectorStack);\n    }\n    return queue.sort(sortFn);\n}\n/**\n * Perform a depth-first search to find critical path length.\n * Cycle detection comes at minimal additional cost.\n */\nfunction calculateCriticalPathLength(operation, dependencyChain) {\n    if (dependencyChain.has(operation)) {\n        throw new Error('A cyclic dependency was encountered:\\n  ' +\n            [...dependencyChain, operation]\n                .map((visitedTask) => visitedTask.name)\n                .reverse()\n                .join('\\n  -> ') +\n            `\\nConsider using the decoupledLocalDependencies option in ${RushConstants.rushJsonFilename}.`);\n    }\n    let { criticalPathLength } = operation;\n    if (criticalPathLength !== undefined) {\n        // This has been visited already\n        return criticalPathLength;\n    }\n    criticalPathLength = 0;\n    if (operation.consumers.size) {\n        dependencyChain.add(operation);\n        for (const consumer of operation.consumers) {\n            criticalPathLength = Math.max(criticalPathLength, calculateCriticalPathLength(consumer, dependencyChain));\n        }\n        dependencyChain.delete(operation);\n    }\n    // Include the contribution from the current operation\n    operation.criticalPathLength = criticalPathLength + operation.weight;\n    // Directly writing operations to an output collection here would yield a topological sorted set\n    // However, we want a bit more fine-tuning of the output than just the raw topology\n    return criticalPathLength;\n}\n//# sourceMappingURL=AsyncOperationQueue.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as crypto from 'crypto';\nimport { InternalError, NewlineKind, Sort } from '@rushstack/node-core-library';\nimport { CollatedTerminal } from '@rushstack/stream-collator';\nimport { DiscardStdoutTransform, TextRewriterTransform } from '@rushstack/terminal';\nimport { SplitterTransform, Terminal } from '@rushstack/terminal';\nimport { CollatedTerminalProvider } from '../../utilities/CollatedTerminalProvider';\nimport { OperationStatus } from './OperationStatus';\nimport { CobuildLock } from '../cobuild/CobuildLock';\nimport { ProjectBuildCache } from '../buildCache/ProjectBuildCache';\nimport { RushConstants } from '../RushConstants';\nimport { initializeProjectLogFilesAsync, getProjectLogFilePaths } from './ProjectLogWritable';\nimport { DisjointSet } from '../cobuild/DisjointSet';\nimport { PeriodicCallback } from './PeriodicCallback';\nimport { NullTerminalProvider } from '../../utilities/NullTerminalProvider';\nconst PLUGIN_NAME = 'CacheablePhasedOperationPlugin';\nconst PERIODIC_CALLBACK_INTERVAL_IN_SECONDS = 10;\nexport class CacheableOperationPlugin {\n    constructor(options) {\n        this._buildCacheContextByOperation = new Map();\n        this._options = options;\n    }\n    apply(hooks) {\n        const { allowWarningsInSuccessfulBuild, buildCacheConfiguration, cobuildConfiguration } = this._options;\n        hooks.beforeExecuteOperations.tap(PLUGIN_NAME, (recordByOperation, context) => {\n            var _a;\n            const { isIncrementalBuildAllowed, inputsSnapshot, projectConfigurations, isInitial } = context;\n            if (!inputsSnapshot) {\n                throw new Error(`Build cache is only supported if running in a Git repository. Either disable the build cache or run Rush in a Git repository.`);\n            }\n            const disjointSet = (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled)\n                ? new DisjointSet()\n                : undefined;\n            for (const [operation, record] of recordByOperation) {\n                const stateHash = record.calculateStateHash({\n                    inputsSnapshot,\n                    buildCacheConfiguration\n                });\n                const { associatedProject, associatedPhase, runner, settings: operationSettings } = operation;\n                if (!associatedProject || !associatedPhase || !runner) {\n                    return;\n                }\n                const { name: phaseName } = associatedPhase;\n                const projectConfiguration = projectConfigurations.get(associatedProject);\n                // This value can *currently* be cached per-project, but in the future the list of files will vary\n                // depending on the selected phase.\n                const fileHashes = inputsSnapshot.getTrackedFileHashesForOperation(associatedProject, phaseName);\n                const cacheDisabledReason = projectConfiguration\n                    ? projectConfiguration.getCacheDisabledReason(fileHashes.keys(), phaseName, operation.isNoOp)\n                    : `Project does not have a ${RushConstants.rushProjectConfigFilename} configuration file, ` +\n                        'or one provided by a rig, so it does not support caching.';\n                const metadataFolderPath = record.metadataFolderPath;\n                const outputFolderNames = metadataFolderPath ? [metadataFolderPath] : [];\n                const configuredOutputFolderNames = operationSettings === null || operationSettings === void 0 ? void 0 : operationSettings.outputFolderNames;\n                if (configuredOutputFolderNames) {\n                    for (const folderName of configuredOutputFolderNames) {\n                        outputFolderNames.push(folderName);\n                    }\n                }\n                disjointSet === null || disjointSet === void 0 ? void 0 : disjointSet.add(operation);\n                const buildCacheContext = {\n                    // Supports cache writes by default for initial operations.\n                    // Don't write during watch runs for performance reasons (and to avoid flooding the cache)\n                    isCacheWriteAllowed: isInitial,\n                    isCacheReadAllowed: isIncrementalBuildAllowed,\n                    operationBuildCache: undefined,\n                    outputFolderNames,\n                    stateHash,\n                    cacheDisabledReason,\n                    cobuildLock: undefined,\n                    cobuildClusterId: undefined,\n                    buildCacheTerminal: undefined,\n                    buildCacheTerminalWritable: undefined,\n                    periodicCallback: new PeriodicCallback({\n                        interval: PERIODIC_CALLBACK_INTERVAL_IN_SECONDS * 1000\n                    }),\n                    cacheRestored: false,\n                    isCacheReadAttempted: false\n                };\n                // Upstream runners may mutate the property of build cache context for downstream runners\n                this._buildCacheContextByOperation.set(operation, buildCacheContext);\n            }\n            if (disjointSet) {\n                clusterOperations(disjointSet, this._buildCacheContextByOperation);\n                for (const operationSet of disjointSet.getAllSets()) {\n                    if ((cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled) && cobuildConfiguration.cobuildContextId) {\n                        // Get a deterministic ordered array of operations, which is important to get a deterministic cluster id.\n                        const groupedOperations = Array.from(operationSet);\n                        Sort.sortBy(groupedOperations, (operation) => {\n                            return operation.name;\n                        });\n                        // Generates cluster id, cluster id comes from the project folder and operation name of all operations in the same cluster.\n                        const hash = crypto.createHash('sha1');\n                        for (const operation of groupedOperations) {\n                            const { associatedPhase: phase, associatedProject: project } = operation;\n                            if (project && phase) {\n                                hash.update(project.projectRelativeFolder);\n                                hash.update(RushConstants.hashDelimiter);\n                                hash.update((_a = operation.name) !== null && _a !== void 0 ? _a : phase.name);\n                                hash.update(RushConstants.hashDelimiter);\n                            }\n                        }\n                        const cobuildClusterId = hash.digest('hex');\n                        // Assign same cluster id to all operations in the same cluster.\n                        for (const record of groupedOperations) {\n                            const buildCacheContext = this._getBuildCacheContextByOperationOrThrow(record);\n                            buildCacheContext.cobuildClusterId = cobuildClusterId;\n                        }\n                    }\n                }\n            }\n        });\n        hooks.beforeExecuteOperation.tapPromise(PLUGIN_NAME, async (runnerContext) => {\n            if (this._buildCacheContextByOperation.size === 0) {\n                return;\n            }\n            const buildCacheContext = this._getBuildCacheContextByOperation(runnerContext.operation);\n            if (!buildCacheContext) {\n                return;\n            }\n            const record = runnerContext;\n            const { associatedProject: project, associatedPhase: phase, runner, _operationMetadataManager: operationMetadataManager, operation } = record;\n            if (!operation.enabled ||\n                !project ||\n                !phase ||\n                !(runner === null || runner === void 0 ? void 0 : runner.cacheable) ||\n                // this check is just to make the types happy, it will always be defined if project + phase are defined.\n                !operationMetadataManager) {\n                return;\n            }\n            const runBeforeExecute = async () => {\n                var _a, _b;\n                if (!buildCacheContext.buildCacheTerminal ||\n                    ((_a = buildCacheContext.buildCacheTerminalWritable) === null || _a === void 0 ? void 0 : _a.isOpen) === false) {\n                    // The writable does not exist or has been closed, re-create one\n                    // eslint-disable-next-line require-atomic-updates\n                    buildCacheContext.buildCacheTerminal = await this._createBuildCacheTerminalAsync({\n                        record,\n                        buildCacheContext,\n                        buildCacheEnabled: buildCacheConfiguration === null || buildCacheConfiguration === void 0 ? void 0 : buildCacheConfiguration.buildCacheEnabled,\n                        rushProject: project,\n                        logFilenameIdentifier: operation.logFilenameIdentifier,\n                        quietMode: record.quietMode,\n                        debugMode: record.debugMode\n                    });\n                }\n                const buildCacheTerminal = buildCacheContext.buildCacheTerminal;\n                let projectBuildCache = this._tryGetProjectBuildCache({\n                    buildCacheContext,\n                    buildCacheConfiguration,\n                    terminal: buildCacheTerminal,\n                    record\n                });\n                // Try to acquire the cobuild lock\n                let cobuildLock;\n                if (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled) {\n                    if ((cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildLeafProjectLogOnlyAllowed) &&\n                        operation.consumers.size === 0 &&\n                        !projectBuildCache) {\n                        // When the leaf project log only is allowed and the leaf project is build cache \"disabled\", try to get\n                        // a log files only project build cache\n                        projectBuildCache = await this._tryGetLogOnlyProjectBuildCacheAsync({\n                            buildCacheConfiguration,\n                            cobuildConfiguration,\n                            buildCacheContext,\n                            rushProject: project,\n                            phase,\n                            terminal: buildCacheTerminal\n                        });\n                        if (projectBuildCache) {\n                            buildCacheTerminal.writeVerboseLine(`Log files only build cache is enabled for the project \"${project.packageName}\" because the cobuild leaf project log only is allowed`);\n                        }\n                        else {\n                            buildCacheTerminal.writeWarningLine(`Failed to get log files only build cache for the project \"${project.packageName}\"`);\n                        }\n                    }\n                    cobuildLock = await this._tryGetCobuildLockAsync({\n                        buildCacheContext,\n                        projectBuildCache,\n                        cobuildConfiguration,\n                        packageName: project.packageName,\n                        phaseName: phase.name\n                    });\n                }\n                // eslint-disable-next-line require-atomic-updates -- we are mutating the build cache context intentionally\n                buildCacheContext.cobuildLock = cobuildLock;\n                // If possible, we want to skip this operation -- either by restoring it from the\n                // cache, if caching is enabled, or determining that the project\n                // is unchanged (using the older incremental execution logic). These two approaches,\n                // \"caching\" and \"skipping\", are incompatible, so only one applies.\n                //\n                // Note that \"caching\" and \"skipping\" take two different approaches\n                // to tracking dependents:\n                //\n                //   - For caching, \"isCacheReadAllowed\" is set if a project supports\n                //     incremental builds, and determining whether this project or a dependent\n                //     has changed happens inside the hashing logic.\n                //\n                const { error: errorLogPath } = getProjectLogFilePaths({\n                    project,\n                    logFilenameIdentifier: operation.logFilenameIdentifier\n                });\n                const restoreCacheAsync = async (\n                // TODO: Investigate if `projectBuildCacheForRestore` is always the same instance as `projectBuildCache`\n                // above, and if it is, remove this parameter\n                projectBuildCacheForRestore, specifiedCacheId) => {\n                    buildCacheContext.isCacheReadAttempted = true;\n                    const restoreFromCacheSuccess = await (projectBuildCacheForRestore === null || projectBuildCacheForRestore === void 0 ? void 0 : projectBuildCacheForRestore.tryRestoreFromCacheAsync(buildCacheTerminal, specifiedCacheId));\n                    if (restoreFromCacheSuccess) {\n                        buildCacheContext.cacheRestored = true;\n                        await runnerContext.runWithTerminalAsync(async (taskTerminal, terminalProvider) => {\n                            // Restore the original state of the operation without cache\n                            await (operationMetadataManager === null || operationMetadataManager === void 0 ? void 0 : operationMetadataManager.tryRestoreAsync({\n                                terminalProvider,\n                                terminal: buildCacheTerminal,\n                                errorLogPath\n                            }));\n                        }, { createLogFile: false });\n                    }\n                    return !!restoreFromCacheSuccess;\n                };\n                if (cobuildLock) {\n                    // handling rebuilds. \"rush rebuild\" or \"rush retest\" command will save operations to\n                    // the build cache once completed, but does not retrieve them (since the \"incremental\"\n                    // flag is disabled). However, we still need a cobuild to be able to retrieve a finished\n                    // build from another cobuild in this case.\n                    const cobuildCompletedState = await cobuildLock.getCompletedStateAsync();\n                    if (cobuildCompletedState) {\n                        const { status, cacheId } = cobuildCompletedState;\n                        if ((_b = record.operation.settings) === null || _b === void 0 ? void 0 : _b.allowCobuildWithoutCache) {\n                            // This should only be enabled if the experiment for cobuild orchestration is enabled.\n                            return status;\n                        }\n                        const restoreFromCacheSuccess = await restoreCacheAsync(cobuildLock.projectBuildCache, cacheId);\n                        if (restoreFromCacheSuccess) {\n                            return status;\n                        }\n                    }\n                    else if (!buildCacheContext.isCacheReadAttempted && buildCacheContext.isCacheReadAllowed) {\n                        const restoreFromCacheSuccess = await restoreCacheAsync(projectBuildCache);\n                        if (restoreFromCacheSuccess) {\n                            return OperationStatus.FromCache;\n                        }\n                    }\n                }\n                else if (buildCacheContext.isCacheReadAllowed) {\n                    const restoreFromCacheSuccess = await restoreCacheAsync(projectBuildCache);\n                    if (restoreFromCacheSuccess) {\n                        return OperationStatus.FromCache;\n                    }\n                }\n                if (buildCacheContext.isCacheWriteAllowed && cobuildLock) {\n                    const acquireSuccess = await cobuildLock.tryAcquireLockAsync();\n                    if (acquireSuccess) {\n                        const { periodicCallback } = buildCacheContext;\n                        periodicCallback.addCallback(async () => {\n                            await (cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.renewLockAsync());\n                        });\n                        periodicCallback.start();\n                    }\n                    else {\n                        setTimeout(() => {\n                            record.status = OperationStatus.Ready;\n                        }, 500);\n                        return OperationStatus.Executing;\n                    }\n                }\n            };\n            return await runBeforeExecute();\n        });\n        hooks.afterExecuteOperation.tapPromise(PLUGIN_NAME, async (runnerContext) => {\n            var _a;\n            const record = runnerContext;\n            const { status, stopwatch, _operationMetadataManager: operationMetadataManager, operation } = record;\n            const { associatedProject: project, associatedPhase: phase, runner, enabled } = operation;\n            if (!enabled || !project || !phase || !(runner === null || runner === void 0 ? void 0 : runner.cacheable) || !operationMetadataManager) {\n                return;\n            }\n            const buildCacheContext = this._getBuildCacheContextByOperation(operation);\n            if (!buildCacheContext) {\n                return;\n            }\n            // No need to run for the following operation status\n            if (!record.isTerminal || record.status === OperationStatus.NoOp) {\n                return;\n            }\n            const { cobuildLock, operationBuildCache, isCacheWriteAllowed, buildCacheTerminal, cacheRestored } = buildCacheContext;\n            try {\n                if (!cacheRestored) {\n                    // Save the metadata to disk\n                    const { logFilenameIdentifier } = operationMetadataManager;\n                    const { duration: durationInSeconds } = stopwatch;\n                    const { text: logPath, error: errorLogPath, jsonl: logChunksPath } = getProjectLogFilePaths({\n                        project,\n                        logFilenameIdentifier\n                    });\n                    await operationMetadataManager.saveAsync({\n                        durationInSeconds,\n                        cobuildContextId: cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.cobuildConfiguration.cobuildContextId,\n                        cobuildRunnerId: cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.cobuildConfiguration.cobuildRunnerId,\n                        logPath,\n                        errorLogPath,\n                        logChunksPath\n                    });\n                }\n                if (!buildCacheTerminal) {\n                    // This should not happen\n                    throw new InternalError(`Build Cache Terminal is not created`);\n                }\n                let setCompletedStatePromiseFunction;\n                let setCacheEntryPromise;\n                if (cobuildLock && isCacheWriteAllowed) {\n                    const { cacheId, contextId } = cobuildLock.cobuildContext;\n                    let finalCacheId = cacheId;\n                    if (status === OperationStatus.Failure) {\n                        finalCacheId = `${cacheId}-${contextId}-failed`;\n                    }\n                    else if (status === OperationStatus.SuccessWithWarning && !record.runner.warningsAreAllowed) {\n                        finalCacheId = `${cacheId}-${contextId}-warnings`;\n                    }\n                    switch (status) {\n                        case OperationStatus.SuccessWithWarning:\n                        case OperationStatus.Success:\n                        case OperationStatus.Failure: {\n                            const currentStatus = status;\n                            setCompletedStatePromiseFunction = () => {\n                                return cobuildLock === null || cobuildLock === void 0 ? void 0 : cobuildLock.setCompletedStateAsync({\n                                    status: currentStatus,\n                                    cacheId: finalCacheId\n                                });\n                            };\n                            setCacheEntryPromise = () => cobuildLock.projectBuildCache.trySetCacheEntryAsync(buildCacheTerminal, finalCacheId);\n                        }\n                    }\n                }\n                const taskIsSuccessful = status === OperationStatus.Success ||\n                    (status === OperationStatus.SuccessWithWarning &&\n                        record.runner.warningsAreAllowed &&\n                        allowWarningsInSuccessfulBuild);\n                // If the command is successful, we can calculate project hash, and no dependencies were skipped,\n                // write a new cache entry.\n                if (!setCacheEntryPromise && taskIsSuccessful && isCacheWriteAllowed && operationBuildCache) {\n                    setCacheEntryPromise = () => operationBuildCache.trySetCacheEntryAsync(buildCacheTerminal);\n                }\n                if (!cacheRestored) {\n                    const cacheWriteSuccess = await (setCacheEntryPromise === null || setCacheEntryPromise === void 0 ? void 0 : setCacheEntryPromise());\n                    await (setCompletedStatePromiseFunction === null || setCompletedStatePromiseFunction === void 0 ? void 0 : setCompletedStatePromiseFunction());\n                    if (cacheWriteSuccess === false && status === OperationStatus.Success) {\n                        record.status = OperationStatus.SuccessWithWarning;\n                    }\n                }\n            }\n            finally {\n                (_a = buildCacheContext.buildCacheTerminalWritable) === null || _a === void 0 ? void 0 : _a.close();\n                buildCacheContext.periodicCallback.stop();\n            }\n        });\n        hooks.afterExecuteOperation.tap(PLUGIN_NAME, (record) => {\n            const { operation } = record;\n            const buildCacheContext = this._buildCacheContextByOperation.get(operation);\n            // Status changes to direct dependents\n            let blockCacheWrite = !(buildCacheContext === null || buildCacheContext === void 0 ? void 0 : buildCacheContext.isCacheWriteAllowed);\n            switch (record.status) {\n                case OperationStatus.Skipped: {\n                    // Skipping means cannot guarantee integrity, so prevent cache writes in dependents.\n                    blockCacheWrite = true;\n                    break;\n                }\n            }\n            // Apply status changes to direct dependents\n            if (blockCacheWrite) {\n                for (const consumer of operation.consumers) {\n                    const consumerBuildCacheContext = this._getBuildCacheContextByOperation(consumer);\n                    if (consumerBuildCacheContext) {\n                        consumerBuildCacheContext.isCacheWriteAllowed = false;\n                    }\n                }\n            }\n        });\n        hooks.afterExecuteOperations.tapPromise(PLUGIN_NAME, async () => {\n            this._buildCacheContextByOperation.clear();\n        });\n    }\n    _getBuildCacheContextByOperation(operation) {\n        const buildCacheContext = this._buildCacheContextByOperation.get(operation);\n        return buildCacheContext;\n    }\n    _getBuildCacheContextByOperationOrThrow(operation) {\n        const buildCacheContext = this._getBuildCacheContextByOperation(operation);\n        if (!buildCacheContext) {\n            // This should not happen\n            throw new InternalError(`Build cache context for operation ${operation.name} should be defined`);\n        }\n        return buildCacheContext;\n    }\n    _tryGetProjectBuildCache({ buildCacheConfiguration, buildCacheContext, terminal, record }) {\n        var _a;\n        if (!buildCacheContext.operationBuildCache) {\n            const { cacheDisabledReason } = buildCacheContext;\n            if (cacheDisabledReason && !((_a = record.operation.settings) === null || _a === void 0 ? void 0 : _a.allowCobuildWithoutCache)) {\n                terminal.writeVerboseLine(cacheDisabledReason);\n                return;\n            }\n            if (!buildCacheConfiguration) {\n                // Unreachable, since this will have set `cacheDisabledReason`.\n                return;\n            }\n            // eslint-disable-next-line require-atomic-updates -- This is guaranteed to not be concurrent\n            buildCacheContext.operationBuildCache = ProjectBuildCache.forOperation(record, {\n                buildCacheConfiguration,\n                terminal\n            });\n        }\n        return buildCacheContext.operationBuildCache;\n    }\n    // Get a ProjectBuildCache only cache/restore log files\n    async _tryGetLogOnlyProjectBuildCacheAsync({ buildCacheContext, rushProject, terminal, buildCacheConfiguration, cobuildConfiguration, phase }) {\n        if (!(buildCacheConfiguration === null || buildCacheConfiguration === void 0 ? void 0 : buildCacheConfiguration.buildCacheEnabled)) {\n            return;\n        }\n        const { outputFolderNames, stateHash } = buildCacheContext;\n        const hasher = crypto.createHash('sha1');\n        hasher.update(stateHash);\n        if (cobuildConfiguration.cobuildContextId) {\n            hasher.update(`\\ncobuildContextId=${cobuildConfiguration.cobuildContextId}`);\n        }\n        hasher.update(`\\nlogFilesOnly=1`);\n        const operationStateHash = hasher.digest('hex');\n        const projectBuildCache = ProjectBuildCache.getProjectBuildCache({\n            project: rushProject,\n            projectOutputFolderNames: outputFolderNames,\n            buildCacheConfiguration,\n            terminal,\n            operationStateHash,\n            phaseName: phase.name\n        });\n        // eslint-disable-next-line require-atomic-updates -- This is guaranteed to not be concurrent\n        buildCacheContext.operationBuildCache = projectBuildCache;\n        return projectBuildCache;\n    }\n    async _tryGetCobuildLockAsync({ cobuildConfiguration, buildCacheContext, projectBuildCache, packageName, phaseName }) {\n        if (!buildCacheContext.cobuildLock) {\n            if (projectBuildCache && (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildFeatureEnabled)) {\n                if (!buildCacheContext.cobuildClusterId) {\n                    // This should not happen\n                    throw new InternalError('Cobuild cluster id is not defined');\n                }\n                buildCacheContext.cobuildLock = new CobuildLock({\n                    cobuildConfiguration,\n                    projectBuildCache,\n                    cobuildClusterId: buildCacheContext.cobuildClusterId,\n                    lockExpireTimeInSeconds: PERIODIC_CALLBACK_INTERVAL_IN_SECONDS * 3,\n                    packageName,\n                    phaseName\n                });\n            }\n        }\n        return buildCacheContext.cobuildLock;\n    }\n    async _createBuildCacheTerminalAsync({ record, buildCacheContext, buildCacheEnabled, rushProject, logFilenameIdentifier, quietMode, debugMode }) {\n        const silent = record.silent;\n        if (silent) {\n            const nullTerminalProvider = new NullTerminalProvider();\n            return new Terminal(nullTerminalProvider);\n        }\n        let cacheConsoleWritable;\n        // This creates the writer, only do this if necessary.\n        const collatedWriter = record.collatedWriter;\n        const cacheProjectLogWritable = await this._tryGetBuildCacheTerminalWritableAsync({\n            buildCacheContext,\n            buildCacheEnabled,\n            rushProject,\n            logFilenameIdentifier\n        });\n        if (quietMode) {\n            const discardTransform = new DiscardStdoutTransform({\n                destination: collatedWriter\n            });\n            const normalizeNewlineTransform = new TextRewriterTransform({\n                destination: discardTransform,\n                normalizeNewlines: NewlineKind.Lf,\n                ensureNewlineAtEnd: true\n            });\n            cacheConsoleWritable = normalizeNewlineTransform;\n        }\n        else {\n            cacheConsoleWritable = collatedWriter;\n        }\n        let cacheCollatedTerminal;\n        if (cacheProjectLogWritable) {\n            const cacheSplitterTransform = new SplitterTransform({\n                destinations: [cacheConsoleWritable, cacheProjectLogWritable]\n            });\n            cacheCollatedTerminal = new CollatedTerminal(cacheSplitterTransform);\n        }\n        else {\n            cacheCollatedTerminal = new CollatedTerminal(cacheConsoleWritable);\n        }\n        const buildCacheTerminalProvider = new CollatedTerminalProvider(cacheCollatedTerminal, {\n            debugEnabled: debugMode\n        });\n        return new Terminal(buildCacheTerminalProvider);\n    }\n    async _tryGetBuildCacheTerminalWritableAsync({ buildCacheEnabled, rushProject, buildCacheContext, logFilenameIdentifier }) {\n        // Only open the *.cache.log file(s) if the cache is enabled.\n        if (!buildCacheEnabled) {\n            return;\n        }\n        const logFilePaths = getProjectLogFilePaths({\n            project: rushProject,\n            logFilenameIdentifier: `${logFilenameIdentifier}.cache`\n        });\n        buildCacheContext.buildCacheTerminalWritable = await initializeProjectLogFilesAsync({\n            logFilePaths\n        });\n        return buildCacheContext.buildCacheTerminalWritable;\n    }\n}\nexport function clusterOperations(initialClusters, operationBuildCacheMap) {\n    var _a;\n    // If disjoint set exists, connect build cache disabled project with its consumers\n    for (const [operation, { cacheDisabledReason }] of operationBuildCacheMap) {\n        const { associatedProject: project, associatedPhase: phase } = operation;\n        if (project && phase) {\n            if (cacheDisabledReason && !((_a = operation.settings) === null || _a === void 0 ? void 0 : _a.allowCobuildWithoutCache)) {\n                /**\n                 * Group the project build cache disabled with its consumers. This won't affect too much in\n                 * a monorepo with high build cache coverage.\n                 *\n                 * The mental model is that if X disables the cache, and Y depends on X, then:\n                 *   1. Y must be built by the same VM that build X;\n                 *   2. OR, Y must be rebuilt on each VM that needs it.\n                 * Approach 1 is probably the better choice.\n                 */\n                for (const consumer of operation.consumers) {\n                    initialClusters === null || initialClusters === void 0 ? void 0 : initialClusters.union(operation, consumer);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=CacheableOperationPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport path from 'node:path';\nimport { FileSystem, JsonFile } from '@rushstack/node-core-library';\nimport { PrintUtilities, Colorize } from '@rushstack/terminal';\nimport { OperationStatus } from './OperationStatus';\nconst PLUGIN_NAME = 'LegacySkipPlugin';\nfunction _areShallowEqual(object1, object2) {\n    for (const n in object1) {\n        if (!(n in object2) || object1[n] !== object2[n]) {\n            return false;\n        }\n    }\n    for (const n in object2) {\n        if (!(n in object1)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Core phased command plugin that implements the legacy skip detection logic, used when build cache is disabled.\n */\nexport class LegacySkipPlugin {\n    constructor(options) {\n        this._options = options;\n    }\n    apply(hooks) {\n        const stateMap = new WeakMap();\n        const { terminal, changedProjectsOnly, isIncrementalBuildAllowed, allowWarningsInSuccessfulBuild } = this._options;\n        hooks.beforeExecuteOperations.tap(PLUGIN_NAME, (operations, context) => {\n            var _a;\n            let logGitWarning = false;\n            const { inputsSnapshot } = context;\n            for (const record of operations.values()) {\n                const { operation } = record;\n                const { associatedProject, runner, logFilenameIdentifier } = operation;\n                if (!associatedProject || !runner) {\n                    continue;\n                }\n                if (!runner.cacheable) {\n                    stateMap.set(operation, {\n                        allowSkip: true,\n                        packageDeps: undefined,\n                        packageDepsPath: ''\n                    });\n                    continue;\n                }\n                const packageDepsFilename = `package-deps_${logFilenameIdentifier}.json`;\n                const packageDepsPath = path.join(associatedProject.projectRushTempFolder, packageDepsFilename);\n                let packageDeps;\n                try {\n                    const fileHashes = inputsSnapshot === null || inputsSnapshot === void 0 ? void 0 : inputsSnapshot.getTrackedFileHashesForOperation(associatedProject, (_a = operation.associatedPhase) === null || _a === void 0 ? void 0 : _a.name);\n                    if (!fileHashes) {\n                        logGitWarning = true;\n                        continue;\n                    }\n                    const files = {};\n                    for (const [filePath, fileHash] of fileHashes) {\n                        files[filePath] = fileHash;\n                    }\n                    packageDeps = {\n                        files,\n                        arguments: runner.getConfigHash()\n                    };\n                }\n                catch (error) {\n                    // To test this code path:\n                    // Delete a project's \".rush/temp/shrinkwrap-deps.json\" then run \"rush build --verbose\"\n                    terminal.writeLine(`Unable to calculate incremental state for ${record.operation.name}: ` +\n                        error.toString());\n                    terminal.writeLine(Colorize.cyan('Rush will proceed without incremental execution and change detection.'));\n                }\n                stateMap.set(operation, {\n                    packageDepsPath,\n                    packageDeps,\n                    allowSkip: isIncrementalBuildAllowed\n                });\n            }\n            if (logGitWarning) {\n                // To test this code path:\n                // Remove the `.git` folder then run \"rush build --verbose\"\n                terminal.writeLine(Colorize.cyan(PrintUtilities.wrapWords('This workspace does not appear to be tracked by Git. ' +\n                    'Rush will proceed without incremental execution, caching, and change detection.')));\n            }\n        });\n        hooks.beforeExecuteOperation.tapPromise(PLUGIN_NAME, async (record) => {\n            const { operation } = record;\n            const skipRecord = stateMap.get(operation);\n            if (!skipRecord) {\n                // This operation doesn't support skip detection.\n                return;\n            }\n            if (!operation.runner.cacheable) {\n                // This operation doesn't support skip detection.\n                return;\n            }\n            const { associatedProject } = operation;\n            const { packageDepsPath, packageDeps, allowSkip } = skipRecord;\n            let lastProjectDeps = undefined;\n            try {\n                const lastDepsContents = await FileSystem.readFileAsync(packageDepsPath);\n                lastProjectDeps = JSON.parse(lastDepsContents);\n            }\n            catch (e) {\n                if (!FileSystem.isNotExistError(e)) {\n                    // Warn and ignore - treat failing to load the file as the operation being not built.\n                    // TODO: Update this to be the terminal specific to the operation.\n                    terminal.writeWarningLine(`Warning: error parsing ${packageDepsPath}: ${e}. Ignoring and treating this operation as not run.`);\n                }\n            }\n            if (allowSkip) {\n                const isPackageUnchanged = !!(lastProjectDeps &&\n                    packageDeps &&\n                    packageDeps.arguments === lastProjectDeps.arguments &&\n                    _areShallowEqual(packageDeps.files, lastProjectDeps.files));\n                if (isPackageUnchanged) {\n                    return OperationStatus.Skipped;\n                }\n            }\n            // TODO: Remove legacyDepsPath with the next major release of Rush\n            const legacyDepsPath = path.join(associatedProject.projectFolder, 'package-deps.json');\n            await Promise.all([\n                // Delete the legacy package-deps.json\n                FileSystem.deleteFileAsync(legacyDepsPath),\n                // If the deps file exists, remove it before starting execution.\n                FileSystem.deleteFileAsync(packageDepsPath)\n            ]);\n        });\n        hooks.afterExecuteOperation.tapPromise(PLUGIN_NAME, async (record) => {\n            const { status, operation } = record;\n            const skipRecord = stateMap.get(operation);\n            if (!skipRecord) {\n                return;\n            }\n            const blockSkip = !skipRecord.allowSkip ||\n                (!changedProjectsOnly &&\n                    (status === OperationStatus.Success || status === OperationStatus.SuccessWithWarning));\n            if (blockSkip) {\n                for (const consumer of operation.consumers) {\n                    const consumerSkipRecord = stateMap.get(consumer);\n                    if (consumerSkipRecord) {\n                        consumerSkipRecord.allowSkip = false;\n                    }\n                }\n            }\n            if (!record.operation.runner.cacheable) {\n                // This operation doesn't support skip detection.\n                return;\n            }\n            const { packageDeps, packageDepsPath } = skipRecord;\n            if (status === OperationStatus.NoOp ||\n                (packageDeps &&\n                    (status === OperationStatus.Success ||\n                        (status === OperationStatus.SuccessWithWarning &&\n                            record.operation.runner.warningsAreAllowed &&\n                            allowWarningsInSuccessfulBuild)))) {\n                // Write deps on success.\n                await JsonFile.saveAsync(packageDeps, packageDepsPath, {\n                    ensureFolderExists: true\n                });\n            }\n        });\n    }\n}\n//# sourceMappingURL=LegacySkipPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport path from 'path';\nimport { FileSystem } from '@rushstack/node-core-library';\nconst PLUGIN_NAME = 'NodeDiagnosticDirPlugin';\n/**\n * Phased command plugin that configures the NodeJS --diagnostic-dir option to contain the project and phase name.\n */\nexport class NodeDiagnosticDirPlugin {\n    constructor(options) {\n        this._diagnosticsDir = options.diagnosticDir;\n    }\n    apply(hooks) {\n        const getDiagnosticDir = (operation) => {\n            const { associatedProject } = operation;\n            if (!associatedProject) {\n                return;\n            }\n            const diagnosticDir = path.resolve(this._diagnosticsDir, associatedProject.packageName, operation.logFilenameIdentifier);\n            return diagnosticDir;\n        };\n        hooks.createEnvironmentForOperation.tap(PLUGIN_NAME, (env, record) => {\n            const diagnosticDir = getDiagnosticDir(record.operation);\n            if (!diagnosticDir) {\n                return env;\n            }\n            // Not all versions of NodeJS create the directory, so ensure it exists:\n            FileSystem.ensureFolder(diagnosticDir);\n            const { NODE_OPTIONS } = env;\n            const diagnosticDirEnv = `--diagnostic-dir=\"${diagnosticDir}\"`;\n            env.NODE_OPTIONS = NODE_OPTIONS ? `${NODE_OPTIONS} ${diagnosticDirEnv}` : diagnosticDirEnv;\n            return env;\n        });\n    }\n}\n//# sourceMappingURL=NodeDiagnosticDirPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Implementation of `IOperationRunner` for operations that require no work, such as empty scripts,\n * skipped operations, or blocked operations.\n */\nexport class NullOperationRunner {\n    constructor({ name, result, silent }) {\n        // This operation does nothing, so timing is meaningless\n        this.reportTiming = false;\n        // The operation is a no-op, so it is faster to not cache it\n        this.cacheable = false;\n        // Nothing will get logged, no point allowing warnings\n        this.warningsAreAllowed = false;\n        this.isNoOp = true;\n        this.name = name;\n        this.result = result;\n        this.silent = silent;\n    }\n    async executeAsync(context) {\n        return this.result;\n    }\n    getConfigHash() {\n        return '';\n    }\n}\n//# sourceMappingURL=NullOperationRunner.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * The `Operation` class is a node in the dependency graph of work that needs to be scheduled by the\n * `OperationExecutionManager`. Each `Operation` has a `runner` member of type `IOperationRunner`, whose\n * implementation manages the actual process of running a single operation.\n *\n * The graph of `Operation` instances will be cloned into a separate execution graph after processing.\n *\n * @alpha\n */\nexport class Operation {\n    constructor(options) {\n        /**\n         * A set of all operations which depend on this operation.\n         */\n        this.consumers = new Set();\n        /**\n         * A set of all dependencies which must be executed before this operation is complete.\n         */\n        this.dependencies = new Set();\n        /**\n         * When the scheduler is ready to process this `Operation`, the `runner` implements the actual work of\n         * running the operation.\n         */\n        this.runner = undefined;\n        /**\n         * The weight for this operation. This scalar is the contribution of this operation to the\n         * `criticalPathLength` calculation above. Modify to indicate the following:\n         * - `weight` === 1: indicates that this operation has an average duration\n         * - `weight` &gt; 1: indicates that this operation takes longer than average and so the scheduler\n         *     should try to favor starting it over other, shorter operations. An example might be an operation that\n         *     bundles an entire application and runs whole-program optimization.\n         * - `weight` &lt; 1: indicates that this operation takes less time than average and so the scheduler\n         *     should favor other, longer operations over it. An example might be an operation to unpack a cached\n         *     output, or an operation using NullOperationRunner, which might use a value of 0.\n         */\n        this.weight = 1;\n        /**\n         * Get the operation settings for this operation, defaults to the values defined in\n         *  the project configuration.\n         */\n        this.settings = undefined;\n        const { phase, project, runner, settings, logFilenameIdentifier } = options;\n        this.associatedPhase = phase;\n        this.associatedProject = project;\n        this.runner = runner;\n        this.settings = settings;\n        this.logFilenameIdentifier = logFilenameIdentifier;\n        this.enabled = true;\n    }\n    /**\n     * The name of this operation, for logging.\n     */\n    get name() {\n        var _a;\n        return (_a = this.runner) === null || _a === void 0 ? void 0 : _a.name;\n    }\n    /**\n     * If set to true, this operation is considered a no-op and can be considered always skipped for analysis purposes.\n     */\n    get isNoOp() {\n        var _a;\n        return !!((_a = this.runner) === null || _a === void 0 ? void 0 : _a.isNoOp);\n    }\n    /**\n     * Adds the specified operation as a dependency and updates the consumer list.\n     */\n    addDependency(dependency) {\n        // Cast internally to avoid adding the overhead of getters\n        this.dependencies.add(dependency);\n        dependency.consumers.add(this);\n    }\n    /**\n     * Deletes the specified operation as a dependency and updates the consumer list.\n     */\n    deleteDependency(dependency) {\n        // Cast internally to avoid adding the overhead of getters\n        this.dependencies.delete(dependency);\n        dependency.consumers.delete(this);\n    }\n}\n//# sourceMappingURL=Operation.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Encapsulates information about an error\n * @alpha\n */\nexport class OperationError extends Error {\n    constructor(type, message) {\n        super(message);\n        this._type = type;\n    }\n    get message() {\n        return `[${this._type}] '${super.message}'`;\n    }\n    toString() {\n        return this.message;\n    }\n}\n//# sourceMappingURL=OperationError.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { StdioWritable, TextRewriterTransform, Colorize, ConsoleTerminalProvider, TerminalChunkKind } from '@rushstack/terminal';\nimport { StreamCollator } from '@rushstack/stream-collator';\nimport { NewlineKind, Async, InternalError, AlreadyReportedError } from '@rushstack/node-core-library';\nimport { AsyncOperationQueue } from './AsyncOperationQueue';\nimport { OperationStatus } from './OperationStatus';\nimport { OperationExecutionRecord } from './OperationExecutionRecord';\n/**\n * Format \"======\" lines for a shell window with classic 80 columns\n */\nconst ASCII_HEADER_WIDTH = 79;\nconst prioritySort = (a, b) => {\n    return a.criticalPathLength - b.criticalPathLength;\n};\n/**\n * A class which manages the execution of a set of tasks with interdependencies.\n * Initially, and at the end of each task execution, all unblocked tasks\n * are added to a ready queue which is then executed. This is done continually until all\n * tasks are complete, or prematurely fails if any of the tasks fail.\n */\nexport class OperationExecutionManager {\n    constructor(operations, options) {\n        this._streamCollator_onWriterActive = (writer) => {\n            if (writer) {\n                this._completedOperations++;\n                // Format a header like this\n                //\n                // ==[ @rushstack/the-long-thing ]=================[ 1 of 1000 ]==\n                // leftPart: \"==[ @rushstack/the-long-thing \"\n                const leftPart = Colorize.gray('==[') + ' ' + Colorize.cyan(writer.taskName) + ' ';\n                const leftPartLength = 4 + writer.taskName.length + 1;\n                // rightPart: \" 1 of 1000 ]==\"\n                const completedOfTotal = `${this._completedOperations} of ${this._totalOperations}`;\n                const rightPart = ' ' + Colorize.white(completedOfTotal) + ' ' + Colorize.gray(']==');\n                const rightPartLength = 1 + completedOfTotal.length + 4;\n                // middlePart: \"]=================[\"\n                const twoBracketsLength = 2;\n                const middlePartLengthMinusTwoBrackets = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);\n                const middlePart = Colorize.gray(']' + '='.repeat(middlePartLengthMinusTwoBrackets) + '[');\n                this._terminal.writeStdoutLine('\\n' + leftPart + middlePart + rightPart);\n                if (!this._quietMode) {\n                    this._terminal.writeStdoutLine('');\n                }\n            }\n        };\n        const { quietMode, debugMode, parallelism, changedProjectsOnly, beforeExecuteOperationAsync: beforeExecuteOperation, afterExecuteOperationAsync: afterExecuteOperation, onOperationStatusChangedAsync: onOperationStatusChanged, beforeExecuteOperationsAsync: beforeExecuteOperations, createEnvironmentForOperation } = options;\n        this._completedOperations = 0;\n        this._quietMode = quietMode;\n        this._hasAnyFailures = false;\n        this._hasAnyNonAllowedWarnings = false;\n        this._changedProjectsOnly = changedProjectsOnly;\n        this._parallelism = parallelism;\n        this._beforeExecuteOperation = beforeExecuteOperation;\n        this._afterExecuteOperation = afterExecuteOperation;\n        this._beforeExecuteOperations = beforeExecuteOperations;\n        this._createEnvironmentForOperation = createEnvironmentForOperation;\n        this._onOperationStatusChanged = (record) => {\n            if (record.status === OperationStatus.Ready) {\n                this._executionQueue.assignOperations();\n            }\n            onOperationStatusChanged === null || onOperationStatusChanged === void 0 ? void 0 : onOperationStatusChanged(record);\n        };\n        // TERMINAL PIPELINE:\n        //\n        // streamCollator --> colorsNewlinesTransform --> StdioWritable\n        //\n        this._outputWritable = options.destination || StdioWritable.instance;\n        this._colorsNewlinesTransform = new TextRewriterTransform({\n            destination: this._outputWritable,\n            normalizeNewlines: NewlineKind.OsDefault,\n            removeColors: !ConsoleTerminalProvider.supportsColor\n        });\n        this._streamCollator = new StreamCollator({\n            destination: this._colorsNewlinesTransform,\n            onWriterActive: this._streamCollator_onWriterActive\n        });\n        this._terminal = this._streamCollator.terminal;\n        // Convert the developer graph to the mutable execution graph\n        const executionRecordContext = {\n            streamCollator: this._streamCollator,\n            onOperationStatusChanged: this._onOperationStatusChanged,\n            createEnvironment: this._createEnvironmentForOperation,\n            debugMode,\n            quietMode\n        };\n        let totalOperations = 0;\n        const executionRecords = (this._executionRecords = new Map());\n        for (const operation of operations) {\n            const executionRecord = new OperationExecutionRecord(operation, executionRecordContext);\n            executionRecords.set(operation, executionRecord);\n            if (!executionRecord.silent) {\n                // Only count non-silent operations\n                totalOperations++;\n            }\n        }\n        this._totalOperations = totalOperations;\n        for (const [operation, consumer] of executionRecords) {\n            for (const dependency of operation.dependencies) {\n                const dependencyRecord = executionRecords.get(dependency);\n                if (!dependencyRecord) {\n                    throw new Error(`Operation \"${consumer.name}\" declares a dependency on operation \"${dependency.name}\" that is not in the set of operations to execute.`);\n                }\n                consumer.dependencies.add(dependencyRecord);\n                dependencyRecord.consumers.add(consumer);\n            }\n        }\n        const executionQueue = new AsyncOperationQueue(this._executionRecords.values(), prioritySort);\n        this._executionQueue = executionQueue;\n    }\n    /**\n     * Executes all operations which have been registered, returning a promise which is resolved when all the\n     * operations are completed successfully, or rejects when any operation fails.\n     */\n    async executeAsync() {\n        var _a;\n        this._completedOperations = 0;\n        const totalOperations = this._totalOperations;\n        if (!this._quietMode) {\n            const plural = totalOperations === 1 ? '' : 's';\n            this._terminal.writeStdoutLine(`Selected ${totalOperations} operation${plural}:`);\n            const nonSilentOperations = [];\n            for (const record of this._executionRecords.values()) {\n                if (!record.silent) {\n                    nonSilentOperations.push(record.name);\n                }\n            }\n            nonSilentOperations.sort();\n            for (const name of nonSilentOperations) {\n                this._terminal.writeStdoutLine(`  ${name}`);\n            }\n            this._terminal.writeStdoutLine('');\n        }\n        this._terminal.writeStdoutLine(`Executing a maximum of ${this._parallelism} simultaneous processes...`);\n        const maxParallelism = Math.min(totalOperations, this._parallelism);\n        await ((_a = this._beforeExecuteOperations) === null || _a === void 0 ? void 0 : _a.call(this, this._executionRecords));\n        // This function is a callback because it may write to the collatedWriter before\n        // operation.executeAsync returns (and cleans up the writer)\n        const onOperationCompleteAsync = async (record) => {\n            var _a;\n            try {\n                await ((_a = this._afterExecuteOperation) === null || _a === void 0 ? void 0 : _a.call(this, record));\n            }\n            catch (e) {\n                this._reportOperationErrorIfAny(record);\n                record.error = e;\n                record.status = OperationStatus.Failure;\n            }\n            this._onOperationComplete(record);\n        };\n        const onOperationStartAsync = async (record) => {\n            var _a;\n            return await ((_a = this._beforeExecuteOperation) === null || _a === void 0 ? void 0 : _a.call(this, record));\n        };\n        await Async.forEachAsync(this._executionQueue, async (record) => {\n            await record.executeAsync({\n                onStart: onOperationStartAsync,\n                onResult: onOperationCompleteAsync\n            });\n        }, {\n            concurrency: maxParallelism,\n            weighted: true\n        });\n        const status = this._hasAnyFailures\n            ? OperationStatus.Failure\n            : this._hasAnyNonAllowedWarnings\n                ? OperationStatus.SuccessWithWarning\n                : OperationStatus.Success;\n        return {\n            operationResults: this._executionRecords,\n            status\n        };\n    }\n    _reportOperationErrorIfAny(record) {\n        // Failed operations get reported, even if silent.\n        // Generally speaking, silent operations shouldn't be able to fail, so this is a safety measure.\n        let message = undefined;\n        if (record.error) {\n            if (!(record.error instanceof AlreadyReportedError)) {\n                message = record.error.message;\n            }\n        }\n        if (message) {\n            // This creates the writer, so don't do this until needed\n            record.collatedWriter.terminal.writeStderrLine(message);\n            // Ensure that the summary isn't blank if we have an error message\n            // If the summary already contains max lines of stderr, this will get dropped, so we hope those lines\n            // are more useful than the final exit code.\n            record.stdioSummarizer.writeChunk({\n                text: `${message}\\n`,\n                kind: TerminalChunkKind.Stdout\n            });\n        }\n    }\n    /**\n     * Handles the result of the operation and propagates any relevant effects.\n     */\n    _onOperationComplete(record) {\n        const { runner, name, status, silent } = record;\n        switch (status) {\n            /**\n             * This operation failed. Mark it as such and all reachable dependents as blocked.\n             */\n            case OperationStatus.Failure: {\n                // Failed operations get reported, even if silent.\n                // Generally speaking, silent operations shouldn't be able to fail, so this is a safety measure.\n                this._reportOperationErrorIfAny(record);\n                // This creates the writer, so don't do this globally\n                const { terminal } = record.collatedWriter;\n                terminal.writeStderrLine(Colorize.red(`\"${name}\" failed to build.`));\n                const blockedQueue = new Set(record.consumers);\n                for (const blockedRecord of blockedQueue) {\n                    if (blockedRecord.status === OperationStatus.Waiting) {\n                        // Now that we have the concept of architectural no-ops, we could implement this by replacing\n                        // {blockedRecord.runner} with a no-op that sets status to Blocked and logs the blocking\n                        // operations. However, the existing behavior is a bit simpler, so keeping that for now.\n                        if (!blockedRecord.silent) {\n                            terminal.writeStdoutLine(`\"${blockedRecord.name}\" is blocked by \"${name}\".`);\n                        }\n                        blockedRecord.status = OperationStatus.Blocked;\n                        this._executionQueue.complete(blockedRecord);\n                        if (!blockedRecord.silent) {\n                            // Only increment the count if the operation is not silent to avoid confusing the user.\n                            // The displayed total is the count of non-silent operations.\n                            this._completedOperations++;\n                        }\n                        for (const dependent of blockedRecord.consumers) {\n                            blockedQueue.add(dependent);\n                        }\n                    }\n                    else if (blockedRecord.status !== OperationStatus.Blocked) {\n                        // It shouldn't be possible for operations to be in any state other than Waiting or Blocked\n                        throw new InternalError(`Blocked operation ${blockedRecord.name} is in an unexpected state: ${blockedRecord.status}`);\n                    }\n                }\n                this._hasAnyFailures = true;\n                break;\n            }\n            /**\n             * This operation was restored from the build cache.\n             */\n            case OperationStatus.FromCache: {\n                if (!silent) {\n                    record.collatedWriter.terminal.writeStdoutLine(Colorize.green(`\"${name}\" was restored from the build cache.`));\n                }\n                break;\n            }\n            /**\n             * This operation was skipped via legacy change detection.\n             */\n            case OperationStatus.Skipped: {\n                if (!silent) {\n                    record.collatedWriter.terminal.writeStdoutLine(Colorize.green(`\"${name}\" was skipped.`));\n                }\n                break;\n            }\n            /**\n             * This operation intentionally didn't do anything.\n             */\n            case OperationStatus.NoOp: {\n                if (!silent) {\n                    record.collatedWriter.terminal.writeStdoutLine(Colorize.gray(`\"${name}\" did not define any work.`));\n                }\n                break;\n            }\n            case OperationStatus.Success: {\n                if (!silent) {\n                    record.collatedWriter.terminal.writeStdoutLine(Colorize.green(`\"${name}\" completed successfully in ${record.stopwatch.toString()}.`));\n                }\n                break;\n            }\n            case OperationStatus.SuccessWithWarning: {\n                if (!silent) {\n                    record.collatedWriter.terminal.writeStderrLine(Colorize.yellow(`\"${name}\" completed with warnings in ${record.stopwatch.toString()}.`));\n                }\n                this._hasAnyNonAllowedWarnings = this._hasAnyNonAllowedWarnings || !runner.warningsAreAllowed;\n                break;\n            }\n        }\n        if (record.isTerminal) {\n            // If the operation was not remote, then we can notify queue that it is complete\n            this._executionQueue.complete(record);\n        }\n        else {\n            this._executionQueue.assignOperations();\n        }\n    }\n}\n//# sourceMappingURL=OperationExecutionManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as crypto from 'crypto';\nimport { DiscardStdoutTransform, SplitterTransform, StderrLineTransform, StdioSummarizer, TextRewriterTransform, Terminal } from '@rushstack/terminal';\nimport { InternalError, NewlineKind } from '@rushstack/node-core-library';\nimport { CollatedTerminal } from '@rushstack/stream-collator';\nimport { OperationStatus, TERMINAL_STATUSES } from './OperationStatus';\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { OperationMetadataManager } from './OperationMetadataManager';\nimport { CollatedTerminalProvider } from '../../utilities/CollatedTerminalProvider';\nimport { getProjectLogFilePaths, initializeProjectLogFilesAsync } from './ProjectLogWritable';\nimport { RushConstants } from '../RushConstants';\n/**\n * Internal class representing everything about executing an operation\n *\n * @internal\n */\nexport class OperationExecutionRecord {\n    constructor(operation, context) {\n        /**\n         * The error which occurred while executing this operation, this is stored in case we need\n         * it later (for example to re-print errors at end of execution).\n         */\n        this.error = undefined;\n        /**\n         * This number represents how far away this Operation is from the furthest \"root\" operation (i.e.\n         * an operation with no consumers). This helps us to calculate the critical path (i.e. the\n         * longest chain of projects which must be executed in order, thereby limiting execution speed\n         * of the entire operation tree.\n         *\n         * This number is calculated via a memoized depth-first search, and when choosing the next\n         * operation to execute, the operation with the highest criticalPathLength is chosen.\n         *\n         * Example:\n         * ```\n         *        (0) A\n         *             \\\n         *          (1) B     C (0)         (applications)\n         *               \\   /|\\\n         *                \\ / | \\\n         *             (2) D  |  X (1)      (utilities)\n         *                    | / \\\n         *                    |/   \\\n         *                (2) Y     Z (2)   (other utilities)\n         *\n         * All roots (A & C) have a criticalPathLength of 0.\n         * B has a score of 1, since A depends on it.\n         * D has a score of 2, since we look at the longest chain (e.g D->B->A is longer than D->C)\n         * X has a score of 1, since the only package which depends on it is A\n         * Z has a score of 2, since only X depends on it, and X has a score of 1\n         * Y has a score of 2, since the chain Y->X->C is longer than Y->C\n         * ```\n         *\n         * The algorithm is implemented in AsyncOperationQueue.ts as calculateCriticalPathLength()\n         */\n        this.criticalPathLength = undefined;\n        /**\n         * The set of operations that must complete before this operation executes.\n         */\n        this.dependencies = new Set();\n        /**\n         * The set of operations that depend on this operation.\n         */\n        this.consumers = new Set();\n        this.stopwatch = new Stopwatch();\n        this.stdioSummarizer = new StdioSummarizer({\n            // Allow writing to this object after transforms have been closed. We clean it up manually in a finally block.\n            preventAutoclose: true\n        });\n        this._collatedWriter = undefined;\n        const { runner, associatedPhase, associatedProject } = operation;\n        if (!runner) {\n            throw new InternalError(`Operation for phase '${associatedPhase === null || associatedPhase === void 0 ? void 0 : associatedPhase.name}' and project '${associatedProject === null || associatedProject === void 0 ? void 0 : associatedProject.packageName}' has no runner.`);\n        }\n        this.operation = operation;\n        this.runner = runner;\n        this.associatedPhase = associatedPhase;\n        this.associatedProject = associatedProject;\n        this.logFilePaths = undefined;\n        this._operationMetadataManager =\n            associatedPhase && associatedProject\n                ? new OperationMetadataManager({\n                    phase: associatedPhase,\n                    rushProject: associatedProject,\n                    operation\n                })\n                : undefined;\n        this._context = context;\n        this._status = operation.dependencies.size > 0 ? OperationStatus.Waiting : OperationStatus.Ready;\n    }\n    get name() {\n        return this.runner.name;\n    }\n    get weight() {\n        return this.operation.weight;\n    }\n    get debugMode() {\n        return this._context.debugMode;\n    }\n    get quietMode() {\n        return this._context.quietMode;\n    }\n    get collatedWriter() {\n        // Lazy instantiate because the registerTask() call affects display ordering\n        if (!this._collatedWriter) {\n            this._collatedWriter = this._context.streamCollator.registerTask(this.name);\n        }\n        return this._collatedWriter;\n    }\n    get nonCachedDurationMs() {\n        var _a, _b;\n        // Lazy calculated because the state file is created/restored later on\n        return (_b = (_a = this._operationMetadataManager) === null || _a === void 0 ? void 0 : _a.stateFile.state) === null || _b === void 0 ? void 0 : _b.nonCachedDurationMs;\n    }\n    get cobuildRunnerId() {\n        var _a, _b;\n        // Lazy calculated because the state file is created/restored later on\n        return (_b = (_a = this._operationMetadataManager) === null || _a === void 0 ? void 0 : _a.stateFile.state) === null || _b === void 0 ? void 0 : _b.cobuildRunnerId;\n    }\n    get environment() {\n        var _a, _b;\n        return (_b = (_a = this._context).createEnvironment) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n    }\n    get metadataFolderPath() {\n        var _a;\n        return (_a = this._operationMetadataManager) === null || _a === void 0 ? void 0 : _a.metadataFolderPath;\n    }\n    get isTerminal() {\n        return TERMINAL_STATUSES.has(this.status);\n    }\n    /**\n     * The current execution status of an operation. Operations start in the 'ready' state,\n     * but can be 'blocked' if an upstream operation failed. It is 'executing' when\n     * the operation is executing. Once execution is complete, it is either 'success' or\n     * 'failure'.\n     */\n    get status() {\n        return this._status;\n    }\n    set status(newStatus) {\n        var _a, _b;\n        if (newStatus === this._status) {\n            return;\n        }\n        this._status = newStatus;\n        (_b = (_a = this._context).onOperationStatusChanged) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n    }\n    get silent() {\n        return !this.operation.enabled || this.runner.silent;\n    }\n    get stateHash() {\n        if (!this._stateHash) {\n            throw new Error('Operation state hash is not calculated yet, you must call `calculateStateHash` first.');\n        }\n        return this._stateHash;\n    }\n    /**\n     * {@inheritdoc IOperationRunnerContext.runWithTerminalAsync}\n     */\n    async runWithTerminalAsync(callback, options) {\n        const { associatedPhase, associatedProject, stdioSummarizer } = this;\n        const { createLogFile, logFileSuffix = '' } = options;\n        const logFilePaths = createLogFile && associatedProject && associatedPhase && this._operationMetadataManager\n            ? getProjectLogFilePaths({\n                project: associatedProject,\n                logFilenameIdentifier: `${this._operationMetadataManager.logFilenameIdentifier}${logFileSuffix}`\n            })\n            : undefined;\n        this.logFilePaths = logFilePaths;\n        const projectLogWritable = logFilePaths\n            ? await initializeProjectLogFilesAsync({\n                logFilePaths,\n                enableChunkedOutput: true\n            })\n            : undefined;\n        try {\n            //#region OPERATION LOGGING\n            // TERMINAL PIPELINE:\n            //\n            //                             +--> quietModeTransform? --> collatedWriter\n            //                             |\n            // normalizeNewlineTransform --1--> stderrLineTransform --2--> projectLogWritable\n            //                                                        |\n            //                                                        +--> stdioSummarizer\n            const destination = projectLogWritable\n                ? new SplitterTransform({\n                    destinations: [projectLogWritable, stdioSummarizer]\n                })\n                : stdioSummarizer;\n            const stderrLineTransform = new StderrLineTransform({\n                destination,\n                newlineKind: NewlineKind.Lf // for StdioSummarizer\n            });\n            const splitterTransform1 = new SplitterTransform({\n                destinations: [\n                    this.quietMode\n                        ? new DiscardStdoutTransform({ destination: this.collatedWriter })\n                        : this.collatedWriter,\n                    stderrLineTransform\n                ]\n            });\n            const normalizeNewlineTransform = new TextRewriterTransform({\n                destination: splitterTransform1,\n                normalizeNewlines: NewlineKind.Lf,\n                ensureNewlineAtEnd: true\n            });\n            const collatedTerminal = new CollatedTerminal(normalizeNewlineTransform);\n            const terminalProvider = new CollatedTerminalProvider(collatedTerminal, {\n                debugEnabled: this.debugMode\n            });\n            const terminal = new Terminal(terminalProvider);\n            //#endregion\n            const result = await callback(terminal, terminalProvider);\n            normalizeNewlineTransform.close();\n            // If the pipeline is wired up correctly, then closing normalizeNewlineTransform should\n            // have closed projectLogWritable.\n            if (projectLogWritable === null || projectLogWritable === void 0 ? void 0 : projectLogWritable.isOpen) {\n                throw new InternalError('The output file handle was not closed');\n            }\n            return result;\n        }\n        finally {\n            projectLogWritable === null || projectLogWritable === void 0 ? void 0 : projectLogWritable.close();\n        }\n    }\n    async executeAsync({ onStart, onResult }) {\n        var _a;\n        if (!this.isTerminal) {\n            this.stopwatch.reset();\n        }\n        this.stopwatch.start();\n        this.status = OperationStatus.Executing;\n        try {\n            const earlyReturnStatus = await onStart(this);\n            // When the operation status returns by the hook, bypass the runner execution.\n            if (earlyReturnStatus) {\n                this.status = earlyReturnStatus;\n            }\n            else {\n                // If the operation is disabled, skip the runner and directly mark as Skipped.\n                // However, if the operation is a NoOp, return NoOp so that cache entries can still be written.\n                this.status = this.operation.enabled\n                    ? await this.runner.executeAsync(this)\n                    : this.runner.isNoOp\n                        ? OperationStatus.NoOp\n                        : OperationStatus.Skipped;\n            }\n            // Delegate global state reporting\n            await onResult(this);\n        }\n        catch (error) {\n            this.status = OperationStatus.Failure;\n            this.error = error;\n            // Delegate global state reporting\n            await onResult(this);\n        }\n        finally {\n            if (this.isTerminal) {\n                (_a = this._collatedWriter) === null || _a === void 0 ? void 0 : _a.close();\n                this.stdioSummarizer.close();\n                this.stopwatch.stop();\n            }\n        }\n    }\n    calculateStateHash(options) {\n        if (!this._stateHash) {\n            const { inputsSnapshot, buildCacheConfiguration: { cacheHashSalt } } = options;\n            // Examples of data in the config hash:\n            // - CLI parameters (ShellOperationRunner)\n            const configHash = this.runner.getConfigHash();\n            const { associatedProject, associatedPhase } = this;\n            // Examples of data in the local state hash:\n            // - Environment variables specified in `dependsOnEnvVars`\n            // - Git hashes of tracked files in the associated project\n            // - Git hash of the shrinkwrap file for the project\n            // - Git hashes of any files specified in `dependsOnAdditionalFiles` (must not be associated with a project)\n            const localStateHash = associatedProject &&\n                inputsSnapshot.getOperationOwnStateHash(associatedProject, associatedPhase === null || associatedPhase === void 0 ? void 0 : associatedPhase.name);\n            // The final state hashes of operation dependencies are factored into the hash to ensure that any\n            // state changes in dependencies will invalidate the cache.\n            const dependencyHashes = Array.from(this.dependencies, (record) => {\n                return `${RushConstants.hashDelimiter}${record.name}=${record.calculateStateHash(options)}`;\n            }).sort();\n            const hasher = crypto.createHash('sha1');\n            // This property is used to force cache bust when version changes, e.g. when fixing bugs in the content\n            // of the build cache.\n            hasher.update(`${RushConstants.buildCacheVersion}`);\n            if (cacheHashSalt !== undefined) {\n                // This allows repository owners to force a cache bust by changing the salt.\n                // A common use case is to invalidate the cache when adding/removing/updating rush plugins that alter the build output.\n                hasher.update(cacheHashSalt);\n            }\n            for (const dependencyHash of dependencyHashes) {\n                hasher.update(dependencyHash);\n            }\n            if (localStateHash) {\n                hasher.update(`${RushConstants.hashDelimiter}${localStateHash}`);\n            }\n            hasher.update(`${RushConstants.hashDelimiter}${configHash}`);\n            const hash = hasher.digest('hex');\n            this._stateHash = hash;\n        }\n        return this._stateHash;\n    }\n}\n//# sourceMappingURL=OperationExecutionRecord.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport * as fs from 'fs';\nimport { Async, FileSystem } from '@rushstack/node-core-library';\nimport { TerminalChunkKind, TerminalProviderSeverity } from '@rushstack/terminal';\nimport { OperationStateFile } from './OperationStateFile';\nimport { RushConstants } from '../RushConstants';\n/**\n * A helper class for managing the meta files of a operation.\n *\n * @internal\n */\nexport class OperationMetadataManager {\n    constructor(options) {\n        const { rushProject, operation: { logFilenameIdentifier } } = options;\n        const { projectFolder } = rushProject;\n        this.logFilenameIdentifier = logFilenameIdentifier;\n        const metadataFolderPath = `${RushConstants.projectRushFolderName}/${RushConstants.rushTempFolderName}/operation/${logFilenameIdentifier}`;\n        this.stateFile = new OperationStateFile({\n            projectFolder: projectFolder,\n            metadataFolder: metadataFolderPath\n        });\n        this._metadataFolderPath = metadataFolderPath;\n        this._logPath = `${projectFolder}/${metadataFolderPath}/all.log`;\n        this._errorLogPath = `${projectFolder}/${metadataFolderPath}/error.log`;\n        this._logChunksPath = `${projectFolder}/${metadataFolderPath}/log-chunks.jsonl`;\n    }\n    /**\n     * Returns the relative paths of the metadata files to project folder.\n     *\n     * Example: `.rush/temp/operation/_phase_build/state.json`\n     * Example: `.rush/temp/operation/_phase_build/all.log`\n     * Example: `.rush/temp/operation/_phase_build/error.log`\n     */\n    get metadataFolderPath() {\n        return this._metadataFolderPath;\n    }\n    async saveAsync({ durationInSeconds, cobuildContextId, cobuildRunnerId, logPath, errorLogPath, logChunksPath }) {\n        const state = {\n            nonCachedDurationMs: durationInSeconds * 1000,\n            cobuildContextId,\n            cobuildRunnerId\n        };\n        await this.stateFile.writeAsync(state);\n        const copyFileOptions = [\n            {\n                sourcePath: logPath,\n                destinationPath: this._logPath\n            },\n            {\n                sourcePath: errorLogPath,\n                destinationPath: this._errorLogPath\n            },\n            {\n                sourcePath: logChunksPath,\n                destinationPath: this._logChunksPath\n            }\n        ];\n        // Try to copy log files\n        await Async.forEachAsync(copyFileOptions, async (options) => {\n            try {\n                await FileSystem.copyFileAsync(options);\n            }\n            catch (e) {\n                if (!FileSystem.isNotExistError(e)) {\n                    throw e;\n                }\n            }\n        });\n    }\n    async tryRestoreAsync({ terminal, terminalProvider, errorLogPath }) {\n        await this.stateFile.tryRestoreAsync();\n        try {\n            const rawLogChunks = await FileSystem.readFileAsync(this._logChunksPath);\n            const chunks = [];\n            for (const chunk of rawLogChunks.split('\\n')) {\n                if (chunk) {\n                    chunks.push(JSON.parse(chunk));\n                }\n            }\n            for (const { kind, text } of chunks) {\n                if (kind === TerminalChunkKind.Stderr) {\n                    terminalProvider.write(text, TerminalProviderSeverity.error);\n                }\n                else {\n                    terminalProvider.write(text, TerminalProviderSeverity.log);\n                }\n            }\n        }\n        catch (e) {\n            if (FileSystem.isNotExistError(e)) {\n                // Log chunks file doesn't exist, try to restore log file\n                await restoreFromLogFile(terminal, this._logPath);\n            }\n            else {\n                throw e;\n            }\n        }\n        // Try to restore cached error log as error log file\n        try {\n            await FileSystem.copyFileAsync({\n                sourcePath: this._errorLogPath,\n                destinationPath: errorLogPath\n            });\n        }\n        catch (e) {\n            if (!FileSystem.isNotExistError(e)) {\n                throw e;\n            }\n        }\n    }\n}\nasync function restoreFromLogFile(terminal, path) {\n    var _a, e_1, _b, _c;\n    let logReadStream;\n    try {\n        logReadStream = fs.createReadStream(path, {\n            encoding: 'utf-8'\n        });\n        try {\n            for (var _d = true, logReadStream_1 = __asyncValues(logReadStream), logReadStream_1_1; logReadStream_1_1 = await logReadStream_1.next(), _a = logReadStream_1_1.done, !_a; _d = true) {\n                _c = logReadStream_1_1.value;\n                _d = false;\n                const data = _c;\n                terminal.write(data);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_d && !_a && (_b = logReadStream_1.return)) await _b.call(logReadStream_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    catch (logReadStreamError) {\n        if (!FileSystem.isNotExistError(logReadStreamError)) {\n            throw logReadStreamError;\n        }\n    }\n    finally {\n        // Close the read stream\n        logReadStream === null || logReadStream === void 0 ? void 0 : logReadStream.close();\n    }\n}\n//# sourceMappingURL=OperationMetadataManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { InternalError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { OperationStatus } from './OperationStatus';\nconst PLUGIN_NAME = 'OperationResultSummarizerPlugin';\n/**\n * Format \"======\" lines for a shell window with classic 80 columns\n */\nconst ASCII_HEADER_WIDTH = 79;\n/**\n * Phased command plugin that emits a summary of build results to the console.\n */\nexport class OperationResultSummarizerPlugin {\n    constructor(terminal) {\n        this._terminal = terminal;\n    }\n    apply(hooks) {\n        hooks.afterExecuteOperations.tap(PLUGIN_NAME, (result, context) => {\n            _printOperationStatus(this._terminal, result);\n        });\n    }\n}\n/**\n * Prints out a report of the status of each project\n * @internal\n */\nexport function _printOperationStatus(terminal, result) {\n    const { operationResults } = result;\n    const operationsByStatus = new Map();\n    for (const record of operationResults) {\n        if (record[1].silent) {\n            // Don't report silenced operations\n            continue;\n        }\n        const { status } = record[1];\n        switch (status) {\n            // These are the sections that we will report below\n            case OperationStatus.Skipped:\n            case OperationStatus.FromCache:\n            case OperationStatus.Success:\n            case OperationStatus.SuccessWithWarning:\n            case OperationStatus.Blocked:\n            case OperationStatus.Failure:\n            case OperationStatus.NoOp:\n                break;\n            default:\n                // This should never happen\n                throw new InternalError(`Unexpected operation status: ${status}`);\n        }\n        const collection = operationsByStatus.get(status);\n        if (collection) {\n            collection.push(record);\n        }\n        else {\n            operationsByStatus.set(status, [record]);\n        }\n    }\n    // Skip a few lines before we start the summary\n    terminal.writeLine('\\n\\n');\n    // These are ordered so that the most interesting statuses appear last:\n    writeCondensedSummary(terminal, OperationStatus.Skipped, operationsByStatus, Colorize.green, 'These operations were already up to date:');\n    writeCondensedSummary(terminal, OperationStatus.NoOp, operationsByStatus, Colorize.gray, 'These operations did not define any work:');\n    writeCondensedSummary(terminal, OperationStatus.FromCache, operationsByStatus, Colorize.green, 'These operations were restored from the build cache:');\n    writeCondensedSummary(terminal, OperationStatus.Success, operationsByStatus, Colorize.green, 'These operations completed successfully:');\n    writeDetailedSummary(terminal, OperationStatus.SuccessWithWarning, operationsByStatus, Colorize.yellow, 'WARNING');\n    writeCondensedSummary(terminal, OperationStatus.Blocked, operationsByStatus, Colorize.white, 'These operations were blocked by dependencies that failed:');\n    writeDetailedSummary(terminal, OperationStatus.Failure, operationsByStatus, Colorize.red);\n    terminal.writeLine('');\n    switch (result.status) {\n        case OperationStatus.Failure:\n            terminal.writeErrorLine('Operations failed.\\n');\n            break;\n        case OperationStatus.SuccessWithWarning:\n            terminal.writeWarningLine('Operations succeeded with warnings.\\n');\n            break;\n    }\n}\nfunction writeCondensedSummary(terminal, status, operationsByStatus, headingColor, preamble) {\n    // Example:\n    //\n    // ==[ BLOCKED: 4 projects ]==============================================================\n    //\n    // These projects were blocked by dependencies that failed:\n    //   @scope/name\n    //   e\n    //   k\n    const operations = operationsByStatus.get(status);\n    if (!operations || operations.length === 0) {\n        return;\n    }\n    writeSummaryHeader(terminal, status, operations, headingColor);\n    terminal.writeLine(preamble);\n    let longestTaskName = 0;\n    for (const [operation] of operations) {\n        const nameLength = (operation.name || '').length;\n        if (nameLength > longestTaskName) {\n            longestTaskName = nameLength;\n        }\n    }\n    for (const [operation, operationResult] of operations) {\n        if (operationResult.stopwatch.duration !== 0 &&\n            operation.runner.reportTiming &&\n            operationResult.status !== OperationStatus.Skipped) {\n            const time = operationResult.stopwatch.toString();\n            const padding = ' '.repeat(longestTaskName - (operation.name || '').length);\n            terminal.writeLine(`  ${operation.name}${padding}    ${time}`);\n        }\n        else {\n            terminal.writeLine(`  ${operation.name}`);\n        }\n    }\n    terminal.writeLine('');\n}\nfunction writeDetailedSummary(terminal, status, operationsByStatus, headingColor, shortStatusName) {\n    // Example:\n    //\n    // ==[ SUCCESS WITH WARNINGS: 2 projects ]================================\n    //\n    // --[ WARNINGS: f ]------------------------------------[ 5.07 seconds ]--\n    //\n    // [eslint] Warning: src/logic/operations/OperationsExecutionManager.ts:393:3 ...\n    const operations = operationsByStatus.get(status);\n    if (!operations || operations.length === 0) {\n        return;\n    }\n    writeSummaryHeader(terminal, status, operations, headingColor);\n    if (shortStatusName === undefined) {\n        shortStatusName = status;\n    }\n    for (const [operation, operationResult] of operations) {\n        // Format a header like this\n        //\n        // --[ WARNINGS: f ]------------------------------------[ 5.07 seconds ]--\n        // leftPart: \"--[ WARNINGS: f \"\n        const subheadingText = `${shortStatusName}: ${operation.name}`;\n        const leftPartLength = 4 + subheadingText.length + 1;\n        // rightPart: \" 5.07 seconds ]--\"\n        const time = operationResult.stopwatch.toString();\n        const rightPartLength = 1 + time.length + 1 + 3;\n        // middlePart: \"]----------------------[\"\n        const twoBracketsLength = 2;\n        const middlePartLengthMinusTwoBrackets = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);\n        terminal.writeLine(`${Colorize.gray('--[')} ${headingColor(subheadingText)} ${Colorize.gray(`]${'-'.repeat(middlePartLengthMinusTwoBrackets)}[`)} ${Colorize.white(time)} ${Colorize.gray(']--')}\\n`);\n        const details = operationResult.stdioSummarizer.getReport();\n        if (details) {\n            // Don't write a newline, because the report will always end with a newline\n            terminal.write(details);\n        }\n        terminal.writeLine('');\n    }\n}\nfunction writeSummaryHeader(terminal, status, operations, headingColor) {\n    // Format a header like this\n    //\n    // ==[ FAILED: 2 operations ]================================================\n    // \"2 operations\"\n    const projectsText = `${operations.length}${operations.length === 1 ? ' operation' : ' operations'}`;\n    const headingText = `${status}: ${projectsText}`;\n    // leftPart: \"==[ FAILED: 2 operations \"\n    const leftPartLength = 3 + 1 + headingText.length + 1;\n    const rightPartLengthMinusBracket = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + 1), 0);\n    // rightPart: \"]======================\"\n    terminal.writeLine(`${Colorize.gray('==[')} ${headingColor(headingText)} ${Colorize.gray(`]${'='.repeat(rightPartLengthMinusBracket)}`)}\\n`);\n}\n//# sourceMappingURL=OperationResultSummarizerPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, InternalError, JsonFile } from '@rushstack/node-core-library';\n/**\n * A helper class for managing the state file of a operation.\n *\n * @internal\n */\nexport class OperationStateFile {\n    constructor(options) {\n        const { projectFolder, metadataFolder } = options;\n        this.relativeFilepath = `${metadataFolder}/${OperationStateFile.filename}`;\n        this.filepath = `${projectFolder}/${this.relativeFilepath}`;\n    }\n    get state() {\n        return this._state;\n    }\n    async writeAsync(json) {\n        await JsonFile.saveAsync(json, this.filepath, { ensureFolderExists: true, ignoreUndefinedValues: true });\n        this._state = json;\n    }\n    async tryRestoreAsync() {\n        try {\n            this._state = await JsonFile.loadAsync(this.filepath);\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                this._state = undefined;\n            }\n            else {\n                // This should not happen\n                throw new InternalError(error);\n            }\n        }\n        return this._state;\n    }\n}\nOperationStateFile.filename = 'state.json';\n//# sourceMappingURL=OperationStateFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Enumeration defining potential states of an operation\n * @beta\n */\nexport var OperationStatus;\n(function (OperationStatus) {\n    /**\n     * The Operation is ready to execute. All its dependencies have succeeded.\n     */\n    OperationStatus[\"Ready\"] = \"READY\";\n    /**\n     * The Operation is waiting for one or more dependencies to complete.\n     */\n    OperationStatus[\"Waiting\"] = \"WAITING\";\n    /**\n     * The Operation is Queued\n     */\n    OperationStatus[\"Queued\"] = \"QUEUED\";\n    /**\n     * The Operation is currently executing\n     */\n    OperationStatus[\"Executing\"] = \"EXECUTING\";\n    /**\n     * The Operation completed successfully and did not write to standard output\n     */\n    OperationStatus[\"Success\"] = \"SUCCESS\";\n    /**\n     * The Operation completed successfully, but wrote to standard output\n     */\n    OperationStatus[\"SuccessWithWarning\"] = \"SUCCESS WITH WARNINGS\";\n    /**\n     * The Operation was skipped via the legacy incremental build logic\n     */\n    OperationStatus[\"Skipped\"] = \"SKIPPED\";\n    /**\n     * The Operation had its outputs restored from the build cache\n     */\n    OperationStatus[\"FromCache\"] = \"FROM CACHE\";\n    /**\n     * The Operation failed\n     */\n    OperationStatus[\"Failure\"] = \"FAILURE\";\n    /**\n     * The Operation could not be executed because one or more of its dependencies failed\n     */\n    OperationStatus[\"Blocked\"] = \"BLOCKED\";\n    /**\n     * The Operation was a no-op (for example, it had an empty script)\n     */\n    OperationStatus[\"NoOp\"] = \"NO OP\";\n})(OperationStatus || (OperationStatus = {}));\n/**\n * The set of statuses that are considered terminal.\n * @alpha\n */\nexport const TERMINAL_STATUSES = new Set([\n    OperationStatus.Success,\n    OperationStatus.SuccessWithWarning,\n    OperationStatus.Skipped,\n    OperationStatus.Blocked,\n    OperationStatus.FromCache,\n    OperationStatus.Failure,\n    OperationStatus.NoOp\n]);\n//# sourceMappingURL=OperationStatus.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * A help class to run callbacks in a loop with a specified interval.\n *\n * @beta\n */\nexport class PeriodicCallback {\n    constructor(options) {\n        this._callbacks = [];\n        this._interval = options.interval;\n        this._isRunning = false;\n    }\n    addCallback(callback) {\n        if (this._isRunning) {\n            throw new Error('Can not add callback while watcher is running');\n        }\n        this._callbacks.push(callback);\n    }\n    start() {\n        if (this._intervalId) {\n            throw new Error('Watcher already started');\n        }\n        if (this._callbacks.length === 0) {\n            return;\n        }\n        this._isRunning = true;\n        this._intervalId = setInterval(() => {\n            this._callbacks.forEach((callback) => callback());\n        }, this._interval);\n    }\n    stop() {\n        if (this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n            this._isRunning = false;\n        }\n    }\n}\n//# sourceMappingURL=PeriodicCallback.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Operation } from './Operation';\nconst PLUGIN_NAME = 'PhasedOperationPlugin';\n/**\n * Core phased command plugin that provides the functionality for generating a base operation graph\n * from the set of selected projects and phases.\n */\nexport class PhasedOperationPlugin {\n    apply(hooks) {\n        hooks.createOperations.tap(PLUGIN_NAME, createOperations);\n    }\n}\nfunction createOperations(existingOperations, context) {\n    const { projectsInUnknownState: changedProjects, phaseOriginal, phaseSelection, projectSelection, projectConfigurations, includePhaseDeps, isInitial } = context;\n    const operationsWithWork = new Set();\n    const operations = new Map();\n    // Create tasks for selected phases and projects\n    for (const phase of phaseOriginal) {\n        for (const project of projectSelection) {\n            getOrCreateOperation(phase, project);\n        }\n    }\n    // Recursively expand all consumers in the `operationsWithWork` set.\n    for (const operation of operationsWithWork) {\n        for (const consumer of operation.consumers) {\n            operationsWithWork.add(consumer);\n        }\n    }\n    for (const operation of operations.values()) {\n        if (!operationsWithWork.has(operation)) {\n            // This operation is in scope, but did not change since it was last executed by the current command.\n            // However, we have no state tracking across executions, so treat as unknown.\n            operation.enabled = false;\n        }\n    }\n    return existingOperations;\n    // Binds phaseSelection, projectSelection, operations via closure\n    function getOrCreateOperation(phase, project) {\n        var _a;\n        const key = getOperationKey(phase, project);\n        let operation = operations.get(key);\n        if (!operation) {\n            const { dependencies: { self, upstream }, name, logFilenameIdentifier } = phase;\n            const operationSettings = (_a = projectConfigurations\n                .get(project)) === null || _a === void 0 ? void 0 : _a.operationSettingsByOperationName.get(name);\n            operation = new Operation({\n                project,\n                phase,\n                settings: operationSettings,\n                logFilenameIdentifier: logFilenameIdentifier\n            });\n            if (!phaseSelection.has(phase) || !projectSelection.has(project)) {\n                if (includePhaseDeps && isInitial) {\n                    operationsWithWork.add(operation);\n                }\n                else {\n                    // Not in scope. Mark disabled, which will report as OperationStatus.Skipped.\n                    operation.enabled = false;\n                }\n            }\n            else if (changedProjects.has(project)) {\n                operationsWithWork.add(operation);\n            }\n            operations.set(key, operation);\n            existingOperations.add(operation);\n            for (const depPhase of self) {\n                operation.addDependency(getOrCreateOperation(depPhase, project));\n            }\n            if (upstream.size) {\n                const { dependencyProjects } = project;\n                if (dependencyProjects.size) {\n                    for (const depPhase of upstream) {\n                        for (const dependencyProject of dependencyProjects) {\n                            operation.addDependency(getOrCreateOperation(depPhase, dependencyProject));\n                        }\n                    }\n                }\n            }\n        }\n        return operation;\n    }\n}\n// Convert the [IPhase, RushConfigurationProject] into a value suitable for use as a Map key\nfunction getOperationKey(phase, project) {\n    return `${project.packageName};${phase.name}`;\n}\n//# sourceMappingURL=PhasedOperationPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, FileWriter, InternalError, NewlineKind } from '@rushstack/node-core-library';\nimport { SplitterTransform, TerminalChunkKind, TerminalWritable, TextRewriterTransform } from '@rushstack/terminal';\nimport { PackageNameParsers } from '../../api/PackageNameParsers';\nimport { RushConstants } from '../RushConstants';\nconst LOG_CHUNKS_FOLDER_RELATIVE_PATH = `${RushConstants.projectRushFolderName}/${RushConstants.rushTempFolderName}/chunked-rush-logs`;\n/**\n * A terminal stream that writes all log chunks to a JSONL format so they can be faithfully reconstructed\n *  during build cache restores. This is used for adding warning + error messages in cobuilds where the original\n *  logs cannot be completely restored from the existing `all.log` and `error.log` files.\n *\n * Example output:\n * libraries/rush-lib/.rush/temp/operations/rush-lib._phase_build.chunks.jsonl\n * ```\n * {\"kind\":\"O\",\"text\":\"Invoking: heft run --only build -- --clean \\n\"}\n * {\"kind\":\"O\",\"text\":\" ---- build started ---- \\n\"}\n * {\"kind\":\"O\",\"text\":\"[build:clean] Deleted 0 files and 5 folders\\n\"}\n * {\"kind\":\"O\",\"text\":\"[build:typescript] Using TypeScript version 5.4.2\\n\"}\n * {\"kind\":\"O\",\"text\":\"[build:lint] Using ESLint version 8.57.0\\n\"}\n * {\"kind\":\"E\",\"text\":\"[build:lint] Warning: libraries/rush-lib/src/logic/operations/LogChunksWritable.ts:15:7 - (@typescript-eslint/typedef) Expected test to have a type annotation.\\n\"}\n * {\"kind\":\"E\",\"text\":\"[build:lint] Warning: libraries/rush-lib/src/logic/operations/LogChunksWritable.ts:15:7 - (@typescript-eslint/no-unused-vars) 'test' is assigned a value but never used.\\n\"}\n * {\"kind\":\"O\",\"text\":\"[build:typescript] Copied 1138 folders or files and linked 0 files\\n\"}\n * {\"kind\":\"O\",\"text\":\"[build:webpack] Using Webpack version 5.82.1\\n\"}\n * {\"kind\":\"O\",\"text\":\"[build:webpack] Running Webpack compilation\\n\"}\n * {\"kind\":\"O\",\"text\":\"[build:api-extractor] Using API Extractor version 7.43.1\\n\"}\n * {\"kind\":\"O\",\"text\":\"[build:api-extractor] Analysis will use the bundled TypeScript version 5.4.2\\n\"}\n * {\"kind\":\"O\",\"text\":\"[build:copy-mock-flush-telemetry-plugin] Copied 1260 folders or files and linked 5 files\\n\"}\n * {\"kind\":\"O\",\"text\":\" ---- build finished (6.856s) ---- \\n\"}\n * {\"kind\":\"O\",\"text\":\"-------------------- Finished (6.858s) --------------------\\n\"}\n * ```\n */\nexport class JsonLFileWritable extends TerminalWritable {\n    constructor(logPath) {\n        super();\n        this.logPath = logPath;\n        this._writer = FileWriter.open(logPath);\n    }\n    // Override writeChunk function to throw custom error\n    writeChunk(chunk) {\n        if (!this._writer) {\n            throw new InternalError(`Log writer was closed for ${this.logPath}`);\n        }\n        // Stderr can always get written to a error log writer\n        super.writeChunk(chunk);\n    }\n    onWriteChunk(chunk) {\n        if (!this._writer) {\n            throw new InternalError(`Log writer was closed for ${this.logPath}`);\n        }\n        this._writer.write(JSON.stringify(chunk) + '\\n');\n    }\n    onClose() {\n        if (this._writer) {\n            try {\n                this._writer.close();\n            }\n            catch (error) {\n                throw new InternalError('Failed to close file handle for ' + this._writer.filePath);\n            }\n            this._writer = undefined;\n        }\n    }\n}\n/**\n * A terminal stream that writes two text log files: one with interleaved stdout and stderr, and one with just stderr.\n */\nexport class SplitLogFileWritable extends TerminalWritable {\n    constructor(logPath, errorLogPath) {\n        super();\n        this._logWriter = undefined;\n        this._errorLogWriter = undefined;\n        this.logPath = logPath;\n        this.errorLogPath = errorLogPath;\n        this._logWriter = FileWriter.open(logPath);\n        this._errorLogWriter = undefined;\n    }\n    // Override writeChunk function to throw custom error\n    writeChunk(chunk) {\n        if (!this._logWriter) {\n            throw new InternalError(`Log writer was closed for ${this.logPath}`);\n        }\n        // Stderr can always get written to a error log writer\n        super.writeChunk(chunk);\n    }\n    onWriteChunk(chunk) {\n        if (!this._logWriter) {\n            throw new InternalError('Output file was closed');\n        }\n        // Both stderr and stdout get written to *.<phaseName>.log\n        this._logWriter.write(chunk.text);\n        if (chunk.kind === TerminalChunkKind.Stderr) {\n            // Only stderr gets written to *.<phaseName>.error.log\n            if (!this._errorLogWriter) {\n                this._errorLogWriter = FileWriter.open(this.errorLogPath);\n            }\n            this._errorLogWriter.write(chunk.text);\n        }\n    }\n    onClose() {\n        if (this._logWriter) {\n            try {\n                this._logWriter.close();\n            }\n            catch (error) {\n                throw new InternalError('Failed to close file handle for ' + this._logWriter.filePath);\n            }\n            this._logWriter = undefined;\n        }\n        if (this._errorLogWriter) {\n            try {\n                this._errorLogWriter.close();\n            }\n            catch (error) {\n                throw new InternalError('Failed to close file handle for ' + this._errorLogWriter.filePath);\n            }\n            this._errorLogWriter = undefined;\n        }\n    }\n}\n/**\n * Initializes the project log files for a project. Produces a combined log file, an error log file, and optionally a\n * chunks file that can be used to reconstrct the original console output.\n * @param options - The options to initialize the project log files.\n * @returns The terminal writable stream that will write to the log files.\n */\nexport async function initializeProjectLogFilesAsync(options) {\n    const { logFilePaths, enableChunkedOutput = false } = options;\n    const { textFolder: logFolderPath, jsonlFolder: jsonlFolderPath, text: logPath, error: errorLogPath, jsonl: jsonlPath } = logFilePaths;\n    await Promise.all([\n        FileSystem.ensureFolderAsync(logFolderPath),\n        enableChunkedOutput && FileSystem.ensureFolderAsync(jsonlFolderPath),\n        FileSystem.deleteFileAsync(logPath),\n        FileSystem.deleteFileAsync(errorLogPath),\n        FileSystem.deleteFileAsync(jsonlPath)\n    ]);\n    const splitLog = new TextRewriterTransform({\n        destination: new SplitLogFileWritable(logPath, errorLogPath),\n        removeColors: true,\n        normalizeNewlines: NewlineKind.OsDefault\n    });\n    if (enableChunkedOutput) {\n        const chunksFile = new JsonLFileWritable(jsonlPath);\n        const splitter = new SplitterTransform({\n            destinations: [splitLog, chunksFile]\n        });\n        return splitter;\n    }\n    return splitLog;\n}\n/**\n * @internal\n *\n * @param packageName - The raw package name\n * @param logFilenameIdentifier - The identifier to append to the log file name (typically the phase name)\n * @returns The base names of the log files\n */\nexport function getLogfileBaseNames(packageName, logFilenameIdentifier) {\n    const unscopedProjectName = PackageNameParsers.permissive.getUnscopedName(packageName);\n    const logFileBaseName = `${unscopedProjectName}.${logFilenameIdentifier}`;\n    return {\n        textFileName: `${logFileBaseName}.log`,\n        jsonlFileName: `${logFileBaseName}.chunks.jsonl`,\n        errorFileName: `${logFileBaseName}.error.log`\n    };\n}\n/**\n * @internal\n *\n * @param projectFolder - The absolute path of the project folder\n * @returns The absolute paths of the log folders for regular and chunked logs\n */\nexport function getProjectLogFolders(projectFolder) {\n    const textFolder = `${projectFolder}/${RushConstants.rushLogsFolderName}`;\n    const jsonlFolder = `${projectFolder}/${LOG_CHUNKS_FOLDER_RELATIVE_PATH}`;\n    return { textFolder, jsonlFolder };\n}\n/**\n * @internal\n *\n * @param options - The options to get the log file paths\n * @returns All information about log file paths for the project and log identifier\n */\nexport function getProjectLogFilePaths(options) {\n    const { project: { projectFolder, packageName }, logFilenameIdentifier } = options;\n    const { textFolder, jsonlFolder } = getProjectLogFolders(projectFolder);\n    const { textFileName: textLog, jsonlFileName: jsonlLog, errorFileName: errorLog } = getLogfileBaseNames(packageName, logFilenameIdentifier);\n    const textPath = `${textFolder}/${textLog}`;\n    const errorPath = `${textFolder}/${errorLog}`;\n    const jsonlPath = `${jsonlFolder}/${jsonlLog}`;\n    return {\n        textFolder,\n        jsonlFolder,\n        text: textPath,\n        error: errorPath,\n        jsonl: jsonlPath\n    };\n}\n//# sourceMappingURL=ProjectLogWritable.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushConstants } from '../RushConstants';\nimport { NullOperationRunner } from './NullOperationRunner';\nimport { Operation } from './Operation';\nimport { OperationStatus } from './OperationStatus';\nimport { getCustomParameterValuesByPhase, getDisplayName, initializeShellOperationRunner } from './ShellOperationRunnerPlugin';\nexport const PLUGIN_NAME = 'ShardedPhasedOperationPlugin';\n// eslint-disable-next-line @typescript-eslint/typedef\nconst TemplateStrings = {\n    SHARD_INDEX: '{shardIndex}',\n    SHARD_COUNT: '{shardCount}',\n    PHASE_NAME: '{phaseName}'\n};\n// eslint-disable-next-line @typescript-eslint/typedef\nconst TemplateStringRegexes = {\n    SHARD_INDEX: new RegExp(TemplateStrings.SHARD_INDEX, 'g'),\n    SHARD_COUNT: new RegExp(TemplateStrings.SHARD_COUNT, 'g'),\n    PHASE_NAME: new RegExp(TemplateStrings.PHASE_NAME, 'g')\n};\n/**\n * Phased command that shards a phase into multiple operations.\n */\nexport class ShardedPhasedOperationPlugin {\n    apply(hooks) {\n        hooks.createOperations.tap(PLUGIN_NAME, spliceShards);\n    }\n}\nfunction spliceShards(existingOperations, context) {\n    var _a, _b, _c, _d;\n    const { rushConfiguration, projectConfigurations } = context;\n    const getCustomParameterValuesForPhase = getCustomParameterValuesByPhase();\n    for (const operation of existingOperations) {\n        const { associatedPhase: phase, associatedProject: project, settings: operationSettings, logFilenameIdentifier: baseLogFilenameIdentifier } = operation;\n        if (phase && project && (operationSettings === null || operationSettings === void 0 ? void 0 : operationSettings.sharding) && !operation.runner) {\n            const { count: shards } = operationSettings.sharding;\n            /**\n             * A single operation to reduce the number of edges in the graph when creating shards.\n             * ```\n             * depA -\\          /- shard 1 -\\\n             * depB -- > noop < -- shard 2 -- > collator (reused operation)\n             * depC -/          \\- shard 3 -/\n             * ```\n             */\n            const preShardOperation = new Operation({\n                phase,\n                project,\n                settings: operationSettings,\n                runner: new NullOperationRunner({\n                    name: `${getDisplayName(phase, project)} - pre-shard`,\n                    result: OperationStatus.NoOp,\n                    silent: true\n                }),\n                logFilenameIdentifier: `${baseLogFilenameIdentifier}_pre-shard`\n            });\n            existingOperations.add(preShardOperation);\n            for (const dependency of operation.dependencies) {\n                preShardOperation.addDependency(dependency);\n                operation.deleteDependency(dependency);\n            }\n            const outputFolderArgumentFormat = (_a = operationSettings.sharding.outputFolderArgumentFormat) !== null && _a !== void 0 ? _a : `--shard-output-directory=${RushConstants.projectRushFolderName}/operations/${TemplateStrings.PHASE_NAME}/shards/${TemplateStrings.SHARD_INDEX}`;\n            if (!outputFolderArgumentFormat.includes('=')) {\n                throw new Error('sharding.outputFolderArgumentFormat must contain an \"=\" sign to differentiate between the key and the value');\n            }\n            if (!outputFolderArgumentFormat.endsWith(TemplateStrings.SHARD_INDEX)) {\n                throw new Error(`sharding.outputFolderArgumentFormat must end with ${TemplateStrings.SHARD_INDEX}, \"${outputFolderArgumentFormat}\"`);\n            }\n            // Replace the phase name only to begin with.\n            const outputDirectoryArgument = outputFolderArgumentFormat.replace(TemplateStringRegexes.PHASE_NAME, baseLogFilenameIdentifier);\n            const outputFolderWithTemplate = outputDirectoryArgument.substring(outputDirectoryArgument.indexOf('=') + 1);\n            const parentFolder = outputFolderWithTemplate.substring(0, outputFolderWithTemplate.indexOf(TemplateStrings.SHARD_INDEX));\n            const collatorDisplayName = `${getDisplayName(phase, project)} - collate`;\n            const customParameters = getCustomParameterValuesForPhase(phase);\n            const collatorParameters = [\n                ...customParameters,\n                `--shard-parent-folder=\"${parentFolder}\"`,\n                `--shard-count=\"${shards}\"`\n            ];\n            const { scripts } = project.packageJson;\n            const commandToRun = (_b = phase.shellCommand) !== null && _b !== void 0 ? _b : scripts === null || scripts === void 0 ? void 0 : scripts[phase.name];\n            operation.logFilenameIdentifier = `${baseLogFilenameIdentifier}_collate`;\n            operation.runner = initializeShellOperationRunner({\n                phase,\n                project,\n                displayName: collatorDisplayName,\n                rushConfiguration,\n                commandToRun,\n                customParameterValues: collatorParameters\n            });\n            const shardOperationName = `${phase.name}:shard`;\n            const baseCommand = scripts === null || scripts === void 0 ? void 0 : scripts[shardOperationName];\n            if (baseCommand === undefined) {\n                throw new Error(`The project '${project.packageName}' does not define a '${phase.name}:shard' command in the 'scripts' section of its package.json`);\n            }\n            const shardArgumentFormat = (_c = operationSettings.sharding.shardArgumentFormat) !== null && _c !== void 0 ? _c : `--shard=${TemplateStrings.SHARD_INDEX}/${TemplateStrings.SHARD_COUNT}`;\n            if (operationSettings.sharding.shardArgumentFormat &&\n                !shardArgumentFormat.includes(TemplateStrings.SHARD_INDEX) &&\n                !shardArgumentFormat.includes(TemplateStrings.SHARD_COUNT)) {\n                throw new Error(`'shardArgumentFormat' must contain both ${TemplateStrings.SHARD_INDEX} and ${TemplateStrings.SHARD_COUNT} to be used for sharding.`);\n            }\n            const projectConfiguration = projectConfigurations.get(project);\n            for (let shard = 1; shard <= shards; shard++) {\n                const outputDirectory = outputFolderWithTemplate.replace(TemplateStringRegexes.SHARD_INDEX, shard.toString());\n                const shardOperationSettings = (_d = projectConfiguration === null || projectConfiguration === void 0 ? void 0 : projectConfiguration.operationSettingsByOperationName.get(shardOperationName)) !== null && _d !== void 0 ? _d : operationSettings.sharding.shardOperationSettings;\n                const shardOperation = new Operation({\n                    project,\n                    phase,\n                    settings: Object.assign(Object.assign({}, shardOperationSettings), { operationName: shardOperationName, outputFolderNames: [outputDirectory] }),\n                    logFilenameIdentifier: `${baseLogFilenameIdentifier}_shard_${shard}`\n                });\n                const shardArgument = shardArgumentFormat\n                    .replace(TemplateStringRegexes.SHARD_INDEX, shard.toString())\n                    .replace(TemplateStringRegexes.SHARD_COUNT, shards.toString());\n                const outputDirectoryArgumentWithShard = outputDirectoryArgument.replace(TemplateStringRegexes.SHARD_INDEX, shard.toString());\n                const shardedParameters = [\n                    ...customParameters,\n                    shardArgument,\n                    outputDirectoryArgumentWithShard\n                ];\n                const shardDisplayName = `${getDisplayName(phase, project)} - shard ${shard}/${shards}`;\n                shardOperation.runner = initializeShellOperationRunner({\n                    phase,\n                    project,\n                    commandToRun: baseCommand,\n                    customParameterValues: shardedParameters,\n                    displayName: shardDisplayName,\n                    rushConfiguration\n                });\n                shardOperation.addDependency(preShardOperation);\n                operation.addDependency(shardOperation);\n                existingOperations.add(shardOperation);\n            }\n        }\n    }\n    return existingOperations;\n}\n//# sourceMappingURL=ShardedPhaseOperationPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Text } from '@rushstack/node-core-library';\nimport { TerminalProviderSeverity } from '@rushstack/terminal';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport { Utilities } from '../../utilities/Utilities';\nimport { OperationError } from './OperationError';\nimport { OperationStatus } from './OperationStatus';\n/**\n * An `IOperationRunner` subclass that performs an operation via a shell command.\n * Currently contains the build cache logic, pending extraction as separate operations.\n * Supports skipping an operation if allowed and it is already up-to-date.\n */\nexport class ShellOperationRunner {\n    constructor(options) {\n        this.reportTiming = true;\n        this.silent = false;\n        this.cacheable = true;\n        const { phase } = options;\n        this.name = options.displayName;\n        this.warningsAreAllowed =\n            EnvironmentConfiguration.allowWarningsInSuccessfulBuild || phase.allowWarningsOnSuccess || false;\n        this._rushProject = options.rushProject;\n        this.commandToRun = options.commandToRun;\n        this._commandForHash = options.commandForHash;\n    }\n    async executeAsync(context) {\n        try {\n            return await this._executeAsync(context);\n        }\n        catch (error) {\n            throw new OperationError('executing', error.message);\n        }\n    }\n    getConfigHash() {\n        return this._commandForHash;\n    }\n    async _executeAsync(context) {\n        return await context.runWithTerminalAsync(async (terminal, terminalProvider) => {\n            var _a, _b;\n            let hasWarningOrError = false;\n            // Run the operation\n            terminal.writeLine(`Invoking: ${this.commandToRun}`);\n            const { rushConfiguration, projectFolder } = this._rushProject;\n            const { environment: initialEnvironment } = context;\n            const subProcess = Utilities.executeLifecycleCommandAsync(this.commandToRun, {\n                rushConfiguration: rushConfiguration,\n                workingDirectory: projectFolder,\n                initCwd: rushConfiguration.commonTempFolder,\n                handleOutput: true,\n                environmentPathOptions: {\n                    includeProjectBin: true\n                },\n                initialEnvironment\n            });\n            // Hook into events, in order to get live streaming of the log\n            (_a = subProcess.stdout) === null || _a === void 0 ? void 0 : _a.on('data', (data) => {\n                const text = data.toString();\n                terminalProvider.write(text, TerminalProviderSeverity.log);\n            });\n            (_b = subProcess.stderr) === null || _b === void 0 ? void 0 : _b.on('data', (data) => {\n                const text = data.toString();\n                terminalProvider.write(text, TerminalProviderSeverity.error);\n                hasWarningOrError = true;\n            });\n            const status = await new Promise((resolve, reject) => {\n                subProcess.on('close', (exitCode, signal) => {\n                    try {\n                        // Do NOT reject here immediately, give a chance for other logic to suppress the error\n                        if (signal) {\n                            context.error = new OperationError('error', `Terminated by signal: ${signal}`);\n                            resolve(OperationStatus.Failure);\n                        }\n                        else if (exitCode !== 0) {\n                            context.error = new OperationError('error', `Returned error code: ${exitCode}`);\n                            resolve(OperationStatus.Failure);\n                        }\n                        else if (hasWarningOrError) {\n                            resolve(OperationStatus.SuccessWithWarning);\n                        }\n                        else {\n                            resolve(OperationStatus.Success);\n                        }\n                    }\n                    catch (error) {\n                        context.error = error;\n                        reject(error);\n                    }\n                });\n            });\n            return status;\n        }, {\n            createLogFile: true\n        });\n    }\n}\n/**\n * When running a command from the \"scripts\" block in package.json, if the command\n * contains Unix-style path slashes and the OS is Windows, the package managers will\n * convert slashes to backslashes.  This is a complicated undertaking.  For example, they\n * need to convert \"node_modules/bin/this && ./scripts/that --name keep/this\"\n * to \"node_modules\\bin\\this && .\\scripts\\that --name keep/this\", and they don't want to\n * convert ANY of the slashes in \"cmd.exe /c echo a/b\".  NPM and PNPM use npm-lifecycle for this,\n * but it unfortunately has a dependency on the entire node-gyp kitchen sink.  Yarn has a\n * simplified implementation in fix-cmd-win-slashes.js, but it's not exposed as a library.\n *\n * Fundamentally NPM's whole feature seems misguided:  They start by inviting people to write\n * shell scripts that will be executed by wildly different shell languages (e.g. cmd.exe and Bash).\n * It's very tricky for a developer to guess what's safe to do without testing every OS.\n * Even simple path separators are not portable, so NPM added heuristics to figure out which\n * slashes are part of a path or not, and convert them.  These workarounds end up having tons\n * of special cases.  They probably could have implemented their own entire minimal cross-platform\n * shell language with less code and less confusion than npm-lifecycle's approach.\n *\n * We've deprecated shell operators inside package.json.  Instead, we advise people to move their\n * scripts into conventional script files, and put only a file path in package.json.  So, for\n * Rush's workaround here, we really only care about supporting the small set of cases seen in the\n * unit tests.  For anything that doesn't fit those patterns, we leave the string untouched\n * (i.e. err on the side of not breaking anything).  We could revisit this later if someone\n * complains about it, but so far nobody has.  :-)\n */\nexport function convertSlashesForWindows(command) {\n    // The first group will match everything up to the first space, \"&\", \"|\", \"<\", \">\", or quote.\n    // The second group matches the remainder.\n    const commandRegExp = /^([^\\s&|<>\"]+)(.*)$/;\n    const match = commandRegExp.exec(command);\n    if (match) {\n        // Example input: \"bin/blarg --path ./config/blah.json && a/b\"\n        // commandPart=\"bin/blarg\"\n        // remainder=\" --path ./config/blah.json && a/b\"\n        const commandPart = match[1];\n        const remainder = match[2];\n        // If the command part already contains a backslash, then leave it alone\n        if (commandPart.indexOf('\\\\') < 0) {\n            // Replace all the slashes with backslashes, e.g. to produce:\n            // \"bin\\blarg --path ./config/blah.json && a/b\"\n            //\n            // NOTE: we don't attempt to process the path parameter or stuff after \"&&\"\n            return Text.replaceAll(commandPart, '/', '\\\\') + remainder;\n        }\n    }\n    // Don't change anything\n    return command;\n}\n//# sourceMappingURL=ShellOperationRunner.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushConstants } from '../RushConstants';\nimport { NullOperationRunner } from './NullOperationRunner';\nimport { convertSlashesForWindows, ShellOperationRunner } from './ShellOperationRunner';\nimport { OperationStatus } from './OperationStatus';\nexport const PLUGIN_NAME = 'ShellOperationRunnerPlugin';\n/**\n * Core phased command plugin that provides the functionality for executing an operation via shell command.\n */\nexport class ShellOperationRunnerPlugin {\n    apply(hooks) {\n        hooks.createOperations.tap(PLUGIN_NAME, function createShellOperations(operations, context) {\n            var _a;\n            const { rushConfiguration, isInitial } = context;\n            const getCustomParameterValuesForPhase = getCustomParameterValuesByPhase();\n            for (const operation of operations) {\n                const { associatedPhase: phase, associatedProject: project } = operation;\n                if (phase && project && !operation.runner) {\n                    // This is a shell command. In the future, may consider having a property on the initial operation\n                    // to specify a runner type requested in rush-project.json\n                    const customParameterValues = getCustomParameterValuesForPhase(phase);\n                    const displayName = getDisplayName(phase, project);\n                    const { name: phaseName, shellCommand } = phase;\n                    const { scripts } = project.packageJson;\n                    // This is the command that will be used to identify the cache entry for this operation\n                    const commandForHash = shellCommand !== null && shellCommand !== void 0 ? shellCommand : scripts === null || scripts === void 0 ? void 0 : scripts[phaseName];\n                    // For execution of non-initial runs, prefer the `:incremental` script if it exists.\n                    // However, the `shellCommand` value still takes precedence per the spec for that feature.\n                    const commandToRun = (_a = shellCommand !== null && shellCommand !== void 0 ? shellCommand : (!isInitial ? scripts === null || scripts === void 0 ? void 0 : scripts[`${phaseName}:incremental`] : undefined)) !== null && _a !== void 0 ? _a : scripts === null || scripts === void 0 ? void 0 : scripts[phaseName];\n                    operation.runner = initializeShellOperationRunner({\n                        phase,\n                        project,\n                        displayName,\n                        commandForHash,\n                        commandToRun,\n                        customParameterValues,\n                        rushConfiguration\n                    });\n                }\n            }\n            return operations;\n        });\n    }\n}\nexport function initializeShellOperationRunner(options) {\n    const { phase, project, commandToRun: rawCommandToRun, displayName } = options;\n    if (typeof rawCommandToRun !== 'string' && phase.missingScriptBehavior === 'error') {\n        throw new Error(`The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`);\n    }\n    if (rawCommandToRun) {\n        const { commandForHash: rawCommandForHash, customParameterValues } = options;\n        const commandToRun = formatCommand(rawCommandToRun, customParameterValues);\n        const commandForHash = rawCommandForHash\n            ? formatCommand(rawCommandForHash, customParameterValues)\n            : commandToRun;\n        return new ShellOperationRunner({\n            commandToRun,\n            commandForHash,\n            displayName,\n            phase,\n            rushProject: project\n        });\n    }\n    else {\n        // Empty build script indicates a no-op, so use a no-op runner\n        return new NullOperationRunner({\n            name: displayName,\n            result: OperationStatus.NoOp,\n            silent: phase.missingScriptBehavior === 'silent'\n        });\n    }\n}\n/**\n * Memoizer for custom parameter values by phase\n * @returns A function that returns the custom parameter values for a given phase\n */\nexport function getCustomParameterValuesByPhase() {\n    const customParametersByPhase = new Map();\n    function getCustomParameterValuesForPhase(phase) {\n        let customParameterValues = customParametersByPhase.get(phase);\n        if (!customParameterValues) {\n            customParameterValues = [];\n            for (const tsCommandLineParameter of phase.associatedParameters) {\n                tsCommandLineParameter.appendToArgList(customParameterValues);\n            }\n            customParametersByPhase.set(phase, customParameterValues);\n        }\n        return customParameterValues;\n    }\n    return getCustomParameterValuesForPhase;\n}\nexport function formatCommand(rawCommand, customParameterValues) {\n    if (!rawCommand) {\n        return '';\n    }\n    else {\n        const fullCommand = `${rawCommand} ${customParameterValues.join(' ')}`;\n        return process.platform === 'win32' ? convertSlashesForWindows(fullCommand) : fullCommand;\n    }\n}\nexport function getDisplayName(phase, project) {\n    if (phase.isSynthetic) {\n        // Because this is a synthetic phase, just use the project name because there aren't any other phases\n        return project.packageName;\n    }\n    else {\n        const phaseNameWithoutPrefix = phase.name.slice(RushConstants.phaseNamePrefix.length);\n        return `${project.packageName} (${phaseNameWithoutPrefix})`;\n    }\n}\n//# sourceMappingURL=ShellOperationRunnerPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nconst PLUGIN_NAME = 'ValidateOperationsPlugin';\n/**\n * Core phased command plugin that provides the functionality for generating a base operation graph\n * from the set of selected projects and phases.\n */\nexport class ValidateOperationsPlugin {\n    constructor(terminal) {\n        this._terminal = terminal;\n    }\n    apply(hooks) {\n        hooks.beforeExecuteOperations.tap(PLUGIN_NAME, this._validateOperations.bind(this));\n    }\n    _validateOperations(records, context) {\n        const phasesByProject = new Map();\n        for (const { associatedPhase, associatedProject, runner } of records.keys()) {\n            if (associatedProject && associatedPhase && !(runner === null || runner === void 0 ? void 0 : runner.isNoOp)) {\n                // Ignore operations that aren't associated with a project or phase, or that\n                // use the NullOperationRunner (i.e. - the phase doesn't do anything)\n                let projectPhases = phasesByProject.get(associatedProject);\n                if (!projectPhases) {\n                    projectPhases = new Set();\n                    phasesByProject.set(associatedProject, projectPhases);\n                }\n                projectPhases.add(associatedPhase);\n            }\n        }\n        for (const [project, phases] of phasesByProject) {\n            const projectConfiguration = context.projectConfigurations.get(project);\n            if (projectConfiguration) {\n                projectConfiguration.validatePhaseConfiguration(phases, this._terminal);\n            }\n        }\n    }\n}\n//# sourceMappingURL=ValidateOperationsPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Async } from '@rushstack/node-core-library';\nconst PLUGIN_NAME = 'WeightedOperationPlugin';\n/**\n * Add weights to operations based on the operation settings in rush-project.json.\n *\n * This also sets the weight of no-op operations to 0.\n */\nexport class WeightedOperationPlugin {\n    apply(hooks) {\n        hooks.beforeExecuteOperations.tap(PLUGIN_NAME, weightOperations);\n    }\n}\nfunction weightOperations(operations, context) {\n    var _a;\n    const { projectConfigurations } = context;\n    for (const [operation, record] of operations) {\n        const { runner } = record;\n        const { associatedProject: project, associatedPhase: phase } = operation;\n        if (runner.isNoOp) {\n            operation.weight = 0;\n        }\n        else if (project && phase) {\n            const projectConfiguration = projectConfigurations.get(project);\n            const operationSettings = (_a = operation.settings) !== null && _a !== void 0 ? _a : projectConfiguration === null || projectConfiguration === void 0 ? void 0 : projectConfiguration.operationSettingsByOperationName.get(phase.name);\n            if (operationSettings === null || operationSettings === void 0 ? void 0 : operationSettings.weight) {\n                operation.weight = operationSettings.weight;\n            }\n        }\n        Async.validateWeightedIterable(operation);\n    }\n    return operations;\n}\n//# sourceMappingURL=WeightedOperationPlugin.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile } from '@rushstack/node-core-library';\nimport { NonProjectConfigurationFile } from '@rushstack/heft-config-file';\nimport { ConsoleTerminalProvider, Terminal } from '@rushstack/terminal';\nimport { PackageManagerOptionsConfigurationBase } from '../base/BasePackageManagerOptionsConfiguration';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport schemaJson from '../../schemas/pnpm-config.schema.json';\n/**\n * Options that are only used when the PNPM package manager is selected.\n * Use this class to load \"common/config/rush/pnpm-config.json\" file,\n * or, load json from \"pnpmOptions\" field in \"rush.json\" for legacy support.\n *\n * @remarks\n * It is valid to define these options in rush.json even if the PNPM package manager\n * is not being used.\n *\n * @public\n */\nexport class PnpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {\n    /**\n     * (GENERATED BY RUSH-PNPM PATCH-COMMIT) When modifying this property, make sure you know what you are doing.\n     *\n     * The `globalPatchedDependencies` is added/updated automatically when you run pnpm patch-commit\n     * command. It is a dictionary where the key should be the package name and exact version. The value\n     * should be a relative path to a patch file.\n     *\n     * PNPM documentation: https://pnpm.io/package_json#pnpmpatcheddependencies\n     */\n    get globalPatchedDependencies() {\n        return this._globalPatchedDependencies;\n    }\n    constructor(json, commonTempFolder, jsonFilename) {\n        super(json);\n        this._json = json;\n        this.jsonFilename = jsonFilename;\n        this.pnpmStore = json.pnpmStore || 'local';\n        if (EnvironmentConfiguration.pnpmStorePathOverride) {\n            this.pnpmStorePath = EnvironmentConfiguration.pnpmStorePathOverride;\n        }\n        else if (this.pnpmStore === 'global') {\n            this.pnpmStorePath = '';\n        }\n        else {\n            this.pnpmStorePath = `${commonTempFolder}/pnpm-store`;\n        }\n        this.strictPeerDependencies = !!json.strictPeerDependencies;\n        this.preventManualShrinkwrapChanges = !!json.preventManualShrinkwrapChanges;\n        this.useWorkspaces = !!json.useWorkspaces;\n        this.globalOverrides = json.globalOverrides;\n        this.globalPeerDependencyRules = json.globalPeerDependencyRules;\n        this.globalPackageExtensions = json.globalPackageExtensions;\n        this.globalNeverBuiltDependencies = json.globalNeverBuiltDependencies;\n        this.globalIgnoredOptionalDependencies = json.globalIgnoredOptionalDependencies;\n        this.globalAllowedDeprecatedVersions = json.globalAllowedDeprecatedVersions;\n        this.unsupportedPackageJsonSettings = json.unsupportedPackageJsonSettings;\n        this._globalPatchedDependencies = json.globalPatchedDependencies;\n        this.resolutionMode = json.resolutionMode;\n        this.autoInstallPeers = json.autoInstallPeers;\n        this.alwaysInjectDependenciesFromOtherSubspaces = json.alwaysInjectDependenciesFromOtherSubspaces;\n        this.alwaysFullInstall = json.alwaysFullInstall;\n        this.pnpmLockfilePolicies = json.pnpmLockfilePolicies;\n    }\n    /** @internal */\n    static loadFromJsonFileOrThrow(jsonFilename, commonTempFolder) {\n        // TODO: plumb through the terminal\n        const terminal = new Terminal(new ConsoleTerminalProvider());\n        const pnpmOptionsConfigFile = new NonProjectConfigurationFile({\n            jsonSchemaObject: schemaJson\n        });\n        const pnpmOptionJson = pnpmOptionsConfigFile.loadConfigurationFile(terminal, jsonFilename);\n        return new PnpmOptionsConfiguration(pnpmOptionJson || {}, commonTempFolder, jsonFilename);\n    }\n    /** @internal */\n    static loadFromJsonObject(json, commonTempFolder) {\n        return new PnpmOptionsConfiguration(json, commonTempFolder);\n    }\n    /**\n     * Updates patchedDependencies field of the PNPM options in the common/config/rush/pnpm-config.json file.\n     */\n    updateGlobalPatchedDependencies(patchedDependencies) {\n        this._globalPatchedDependencies = patchedDependencies;\n        this._json.globalPatchedDependencies = patchedDependencies;\n        if (this.jsonFilename) {\n            JsonFile.save(this._json, this.jsonFilename, { updateExistingFile: true });\n        }\n    }\n}\n//# sourceMappingURL=PnpmOptionsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as crypto from 'crypto';\nimport { InternalError, JsonFile } from '@rushstack/node-core-library';\nimport { BaseProjectShrinkwrapFile } from '../base/BaseProjectShrinkwrapFile';\nimport { RushConstants } from '../RushConstants';\n/**\n *\n */\nexport class PnpmProjectShrinkwrapFile extends BaseProjectShrinkwrapFile {\n    /**\n     * Generate and write the project shrinkwrap file to <project>/.rush/temp/shrinkwrap-deps.json.\n     * @returns True if the project shrinkwrap was created or updated, false otherwise.\n     */\n    async updateProjectShrinkwrapAsync() {\n        const projectShrinkwrapMap = this.generateProjectShrinkwrapMap();\n        return projectShrinkwrapMap ? this.saveAsync(projectShrinkwrapMap) : this.deleteIfExistsAsync();\n    }\n    hasChanges(otherShrinkwrap) {\n        if (!otherShrinkwrap.shrinkwrapFile.isWorkspaceCompatible &&\n            !otherShrinkwrap.shrinkwrapFile.getTempProjectDependencyKey(this.project.tempProjectName)) {\n            // The project is new to the shrinkwrap file.\n            return true;\n        }\n        const otherMap = otherShrinkwrap.generateProjectShrinkwrapMap();\n        const thisMap = this.generateProjectShrinkwrapMap();\n        if (!thisMap || !otherMap) {\n            // Handle one or both being undefined.\n            return !!(thisMap || otherMap);\n        }\n        if (thisMap.size !== otherMap.size) {\n            // Entries added or removed\n            return true;\n        }\n        for (const [key, value] of thisMap) {\n            if (otherMap.get(key) !== value) {\n                // A dependency changed or was added/removed\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Generate the project shrinkwrap file content\n     */\n    generateProjectShrinkwrapMap() {\n        const projectShrinkwrapMap = this.shrinkwrapFile.isWorkspaceCompatible\n            ? this.generateWorkspaceProjectShrinkwrapMap()\n            : this.generateLegacyProjectShrinkwrapMap();\n        return projectShrinkwrapMap;\n    }\n    generateWorkspaceProjectShrinkwrapMap() {\n        // Obtain the workspace importer from the shrinkwrap, which lists resolved dependencies\n        const subspace = this.project.subspace;\n        const importerKey = this.shrinkwrapFile.getImporterKeyByPath(subspace.getSubspaceTempFolderPath(), this.project.projectFolder);\n        const projectShrinkwrapMap = this.shrinkwrapFile.getIntegrityForImporter(importerKey);\n        return projectShrinkwrapMap;\n    }\n    generateLegacyProjectShrinkwrapMap() {\n        const tempProjectDependencyKey = this.shrinkwrapFile.getTempProjectDependencyKey(this.project.tempProjectName);\n        if (!tempProjectDependencyKey) {\n            throw new Error(`Cannot get dependency key for temp project: ${this.project.tempProjectName}`);\n        }\n        const parentShrinkwrapEntry = this.shrinkwrapFile.getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey);\n        const allDependencies = [\n            ...Object.entries(parentShrinkwrapEntry.dependencies || {}),\n            ...Object.entries(parentShrinkwrapEntry.optionalDependencies || {})\n        ];\n        const projectShrinkwrapMap = new Map();\n        for (const [name, version] of allDependencies) {\n            if (name.indexOf(`${RushConstants.rushTempNpmScope}/`) < 0) {\n                // Only select the shrinkwrap dependencies that are non-local since we already handle local\n                // project changes\n                this._addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry);\n            }\n        }\n        // Since peer dependencies within on external packages may be hoisted up to the top-level package,\n        // we need to resolve and add these dependencies directly\n        this._resolveAndAddPeerDependencies(projectShrinkwrapMap, parentShrinkwrapEntry);\n        return projectShrinkwrapMap;\n    }\n    _addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry, throwIfShrinkwrapEntryMissing = true) {\n        var _a;\n        const specifier = `${name}@${version}`;\n        if (projectShrinkwrapMap.has(specifier)) {\n            // getShrinkwrapEntry is idempotent with respect to name and version\n            return;\n        }\n        const shrinkwrapEntry = this.shrinkwrapFile.getShrinkwrapEntry(name, version);\n        if (!shrinkwrapEntry) {\n            if (throwIfShrinkwrapEntryMissing) {\n                throw new InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);\n            }\n            return;\n        }\n        let integrity = (_a = shrinkwrapEntry.resolution) === null || _a === void 0 ? void 0 : _a.integrity;\n        if (!integrity) {\n            // git dependency specifiers do not have an integrity entry. Instead, they specify the tarball field.\n            // So instead, we will hash the contents of the dependency entry and use that as the integrity hash.\n            // Ex:\n            // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:\n            //   ...\n            //   resolution:\n            //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'\n            const sha256Digest = crypto\n                .createHash('sha256')\n                .update(JSON.stringify(shrinkwrapEntry))\n                .digest('hex');\n            integrity = `${name}@${version}:${sha256Digest}:`;\n        }\n        // Add the current dependency\n        projectShrinkwrapMap.set(specifier, integrity);\n        // Add the dependencies of the dependency\n        for (const [dependencyName, dependencyVersion] of Object.entries(shrinkwrapEntry.dependencies || {})) {\n            this._addDependencyRecursive(projectShrinkwrapMap, dependencyName, dependencyVersion, shrinkwrapEntry);\n        }\n        // Add the optional dependencies of the dependency, and don't blow up if they don't exist\n        for (const [dependencyName, dependencyVersion] of Object.entries(shrinkwrapEntry.optionalDependencies || {})) {\n            this._addDependencyRecursive(projectShrinkwrapMap, dependencyName, dependencyVersion, shrinkwrapEntry, \n            /* throwIfShrinkwrapEntryMissing */ false);\n        }\n        // When using workspaces, hoisting of peer dependencies to a singular top-level project is not possible.\n        // Therefore, all packages that are consumed should be specified in the dependency tree. Given this, there\n        // is no need to look for peer dependencies, since it is simply a constraint to be validated by the\n        // package manager.\n        if (!this.shrinkwrapFile.isWorkspaceCompatible) {\n            this._resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry);\n        }\n    }\n    _resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry) {\n        var _a, _b, _c;\n        for (const peerDependencyName of Object.keys(shrinkwrapEntry.peerDependencies || {})) {\n            // Skip peer dependency resolution of local package peer dependencies\n            if (peerDependencyName.indexOf(RushConstants.rushTempNpmScope) !== -1) {\n                continue;\n            }\n            // Check to see if the peer dependency is satisfied with the current shrinkwrap\n            // entry. If not, check the parent shrinkwrap entry. Finally, if neither have\n            // the specified dependency, check that the parent mentions the dependency in\n            // it's own peer dependencies. If it is, we can rely on the package manager and\n            // make the assumption that we've already found it further up the stack.\n            if (((_a = shrinkwrapEntry.dependencies) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(peerDependencyName)) ||\n                ((_b = parentShrinkwrapEntry === null || parentShrinkwrapEntry === void 0 ? void 0 : parentShrinkwrapEntry.dependencies) === null || _b === void 0 ? void 0 : _b.hasOwnProperty(peerDependencyName)) ||\n                ((_c = parentShrinkwrapEntry === null || parentShrinkwrapEntry === void 0 ? void 0 : parentShrinkwrapEntry.peerDependencies) === null || _c === void 0 ? void 0 : _c.hasOwnProperty(peerDependencyName))) {\n                continue;\n            }\n            // As a last attempt, check if it's been hoisted up as a top-level dependency. If\n            // we can't find it, we can assume that it's already been provided somewhere up the\n            // dependency tree.\n            const topLevelDependencySpecifier = this.shrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);\n            if (topLevelDependencySpecifier) {\n                this._addDependencyRecursive(projectShrinkwrapMap, peerDependencyName, this.shrinkwrapFile.getTopLevelDependencyKey(peerDependencyName), shrinkwrapEntry);\n            }\n        }\n    }\n    /**\n     * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json\n     */\n    async saveAsync(projectShrinkwrapMap) {\n        const file = {};\n        const keys = Array.from(projectShrinkwrapMap.keys()).sort();\n        for (const key of keys) {\n            file[key] = projectShrinkwrapMap.get(key);\n        }\n        await JsonFile.saveAsync(file, this.projectShrinkwrapFilePath, { ensureFolderExists: true });\n    }\n}\n//# sourceMappingURL=PnpmProjectShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/**\n * Fork https://github.com/pnpm/pnpm/blob/main/lockfile/fs/src/lockfileFormatConverters.ts\n *\n * Pnpm lockfile v9 have some breaking changes on the lockfile format. For Example, the \"packages\" field has been split into \"packages\" and \"snapshots\" two parts.\n * Rush should not parse the lockfile by itself, but should rely on pnpm to parse the lockfile.\n * To ensure consistency with pnpm's parsing logic, I copied the relevant logic from @pnpm/lockfile.fs to this file.\n *\n * There are some reasons for copying the relevant logic instead of depending on @pnpm/lockfile.fs directly:\n * 1. @pnpm/lockfile.fs has a exports filed in package.json, which will cause convertLockfileV9ToLockfileObject cannot be imported directly.\n * 2. @pnpm/lockfile.fs only provides asynchronous read methods, while rush requires synchronous reading of the lockfile file.\n * Perhaps this file will be deleted in the future and instead depend on @pnpm/lockfile.fs directly.\n */\nimport { removeSuffix } from '@pnpm/dependency-path';\nimport { removeNullishProps } from '../../utilities/objectUtilities';\n// eslint-disable-next-line @typescript-eslint/typedef\nconst DEPENDENCIES_FIELDS = ['optionalDependencies', 'dependencies', 'devDependencies'];\nfunction revertProjectSnapshot(from) {\n    const specifiers = {};\n    function moveSpecifiers(fromDep) {\n        const resolvedDependencies = {};\n        for (const [depName, { specifier, version }] of Object.entries(fromDep)) {\n            const existingValue = specifiers[depName];\n            if (existingValue != null && existingValue !== specifier) {\n                throw new Error(`Project snapshot lists the same dependency more than once with conflicting versions: ${depName}`);\n            }\n            specifiers[depName] = specifier;\n            resolvedDependencies[depName] = version;\n        }\n        return resolvedDependencies;\n    }\n    const dependencies = from.dependencies == null ? from.dependencies : moveSpecifiers(from.dependencies);\n    const devDependencies = from.devDependencies == null ? from.devDependencies : moveSpecifiers(from.devDependencies);\n    const optionalDependencies = from.optionalDependencies == null ? from.optionalDependencies : moveSpecifiers(from.optionalDependencies);\n    return Object.assign(Object.assign({}, removeNullishProps(Object.assign(Object.assign({}, from), { dependencies,\n        devDependencies,\n        optionalDependencies }))), { specifiers });\n}\nfunction convertFromLockfileFileMutable(lockfileFile) {\n    if (typeof (lockfileFile === null || lockfileFile === void 0 ? void 0 : lockfileFile.importers) === 'undefined') {\n        lockfileFile.importers = {\n            '.': {\n                dependenciesMeta: lockfileFile.dependenciesMeta,\n                publishDirectory: lockfileFile.publishDirectory\n            }\n        };\n        for (const depType of DEPENDENCIES_FIELDS) {\n            if (lockfileFile[depType] != null) {\n                lockfileFile.importers['.'][depType] = lockfileFile[depType];\n                delete lockfileFile[depType];\n            }\n        }\n    }\n    return lockfileFile;\n}\nfunction mapValues(obj, mapper) {\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n        result[key] = mapper(value, key);\n    }\n    return result;\n}\n/**\n * Convert lockfile v9 object to standard lockfile object.\n *\n * This function will mutate the lockfile object. It will:\n * 1. Ensure importers['.'] exists.\n * 2. Merge snapshots and packages into packages.\n * 3. Extract specifier from importers['xxx'] into the specifiers field.\n */\nexport function convertLockfileV9ToLockfileObject(lockfile) {\n    var _a, _b;\n    const _c = convertFromLockfileFileMutable(lockfile), { importers } = _c, rest = __rest(_c, [\"importers\"]);\n    const packages = {};\n    for (const [depPath, pkg] of Object.entries((_a = lockfile.snapshots) !== null && _a !== void 0 ? _a : {})) {\n        const pkgId = removeSuffix(depPath);\n        packages[depPath] = Object.assign(pkg, (_b = lockfile.packages) === null || _b === void 0 ? void 0 : _b[pkgId]);\n    }\n    return Object.assign(Object.assign({}, rest), { packages, importers: mapValues(importers !== null && importers !== void 0 ? importers : {}, revertProjectSnapshot) });\n}\n//# sourceMappingURL=PnpmShrinkWrapFileConverters.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport crypto from 'crypto';\nimport { FileSystem, AlreadyReportedError, Import, Path, InternalError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport * as dependencyPathLockfilePreV9 from '@pnpm/dependency-path-lockfile-pre-v9';\nimport * as dependencyPath from '@pnpm/dependency-path';\nimport { BaseShrinkwrapFile } from '../base/BaseShrinkwrapFile';\nimport { DependencySpecifier } from '../DependencySpecifier';\nimport { PNPM_SHRINKWRAP_YAML_FORMAT } from './PnpmYamlCommon';\nimport { RushConstants } from '../RushConstants';\nimport { DependencyType, PackageJsonEditor } from '../../api/PackageJsonEditor';\nimport { PnpmfileConfiguration } from './PnpmfileConfiguration';\nimport { PnpmProjectShrinkwrapFile } from './PnpmProjectShrinkwrapFile';\nimport { PnpmOptionsConfiguration } from './PnpmOptionsConfiguration';\nimport { CustomTipId } from '../../api/CustomTipsConfiguration';\nimport { convertLockfileV9ToLockfileObject } from './PnpmShrinkWrapFileConverters';\nconst yamlModule = Import.lazy('js-yaml', require);\nexport var ShrinkwrapFileMajorVersion;\n(function (ShrinkwrapFileMajorVersion) {\n    ShrinkwrapFileMajorVersion[ShrinkwrapFileMajorVersion[\"V6\"] = 6] = \"V6\";\n    ShrinkwrapFileMajorVersion[ShrinkwrapFileMajorVersion[\"V9\"] = 9] = \"V9\";\n})(ShrinkwrapFileMajorVersion || (ShrinkwrapFileMajorVersion = {}));\nexport function parsePnpm9DependencyKey(dependencyName, versionSpecifier) {\n    var _a, _b, _c;\n    if (!versionSpecifier) {\n        return undefined;\n    }\n    const dependencyKey = normalizePnpmVersionSpecifier(versionSpecifier);\n    // Example: file:projects/project2\n    // Example: project-2@file:projects/project2\n    // Example: link:../projects/project1\n    if (/(file|link):/.test(dependencyKey)) {\n        // If it starts with an NPM scheme such as \"file:projects/my-app.tgz\", we don't support that\n        return undefined;\n    }\n    const { peersIndex } = dependencyPath.indexOfPeersSuffix(dependencyKey);\n    if (peersIndex !== -1) {\n        // Remove peer suffix\n        const key = dependencyKey.slice(0, peersIndex);\n        // Example: 7.26.0\n        if (semver.valid(key)) {\n            return new DependencySpecifier(dependencyName, key);\n        }\n    }\n    // Example: @babel/preset-env@7.26.0                                                          -> name=@babel/preset-env version=7.26.0\n    // Example: @babel/preset-env@7.26.0(peer@1.2.3)                                              -> name=@babel/preset-env version=7.26.0\n    // Example: https://github.com/jonschlinkert/pad-left/tarball/2.1.0                           -> name=undefined         version=undefined\n    // Example: pad-left@https://github.com/jonschlinkert/pad-left/tarball/2.1.0                  -> name=pad-left          nonSemverVersion=https://xxxx\n    // Example: pad-left@https://codeload.github.com/jonschlinkert/pad-left/tar.gz/7798d648225aa5 -> name=pad-left          nonSemverVersion=https://xxxx\n    const dependency = dependencyPath.parse(dependencyKey);\n    const name = (_a = dependency.name) !== null && _a !== void 0 ? _a : dependencyName;\n    const version = (_c = (_b = dependency.version) !== null && _b !== void 0 ? _b : dependency.nonSemverVersion) !== null && _c !== void 0 ? _c : dependencyKey;\n    // Example: https://xxxx/pad-left/tarball/2.1.0\n    // Example: https://github.com/jonschlinkert/pad-left/tarball/2.1.0\n    // Example: https://codeload.github.com/jonschlinkert/pad-left/tar.gz/7798d648225aa5d879660a37c408ab4675b65ac7\n    if (/^https?:/.test(version)) {\n        return new DependencySpecifier(name, version);\n    }\n    // Is it an alias for a different package?\n    if (name === dependencyName) {\n        // No, it's a regular dependency\n        return new DependencySpecifier(name, version);\n    }\n    else {\n        // If the parsed package name is different from the dependencyName, then this is an NPM package alias\n        return new DependencySpecifier(dependencyName, `npm:${name}@${version}`);\n    }\n}\n/**\n * Given an encoded \"dependency key\" from the PNPM shrinkwrap file, this parses it into an equivalent\n * DependencySpecifier.\n *\n * @returns a SemVer string, or undefined if the version specifier cannot be parsed\n */\nexport function parsePnpmDependencyKey(dependencyName, versionSpecifier) {\n    if (!versionSpecifier) {\n        return undefined;\n    }\n    const dependencyKey = normalizePnpmVersionSpecifier(versionSpecifier);\n    if (/^\\w+:/.test(dependencyKey)) {\n        // If it starts with an NPM scheme such as \"file:projects/my-app.tgz\", we don't support that\n        return undefined;\n    }\n    // The package name parsed from the dependency key, or dependencyName if it was omitted.\n    // Example: \"@scope/depame\"\n    let parsedPackageName;\n    // The trailing portion of the dependency key that includes the version and optional peer dependency path.\n    // Example: \"2.8.0/chai@3.5.0+sinon@1.17.7\"\n    let parsedInstallPath;\n    // Example: \"path.pkgs.visualstudio.com/@scope/depame/1.4.0\"  --> 0=\"@scope/depame\" 1=\"1.4.0\"\n    // Example: \"/isarray/2.0.1\"                                  --> 0=\"isarray\"       1=\"2.0.1\"\n    // Example: \"/sinon-chai/2.8.0/chai@3.5.0+sinon@1.17.7\"       --> 0=\"sinon-chai\"    1=\"2.8.0/chai@3.5.0+sinon@1.17.7\"\n    // Example: \"/typescript@5.1.6\"                               --> 0=typescript      1=\"5.1.6\"\n    // Example: 1.2.3_peer-dependency@.4.5.6                      --> no match\n    // Example: 1.2.3_@scope+peer-dependency@.4.5.6               --> no match\n    // Example: 1.2.3(peer-dependency@.4.5.6)                     --> no match\n    // Example: 1.2.3(@scope/peer-dependency@.4.5.6)              --> no match\n    const packageNameMatch = /^[^\\/(]*\\/((?:@[^\\/(]+\\/)?[^\\/(]+)[\\/@](.*)$/.exec(dependencyKey);\n    if (packageNameMatch) {\n        parsedPackageName = packageNameMatch[1];\n        parsedInstallPath = packageNameMatch[2];\n    }\n    else {\n        parsedPackageName = dependencyName;\n        // Example: \"23.6.0_babel-core@6.26.3\"\n        // Example: \"23.6.0\"\n        parsedInstallPath = dependencyKey;\n    }\n    // The SemVer value\n    // Example: \"2.8.0\"\n    let parsedVersionPart;\n    // Example: \"23.6.0_babel-core@6.26.3\" --> \"23.6.0\"\n    // Example: \"2.8.0/chai@3.5.0+sinon@1.17.7\" --> \"2.8.0\"\n    // Example: \"0.53.1(@types/node@14.18.36)\" --> \"0.53.1\"\n    const versionMatch = /^([^\\(\\/_]+)[(\\/_]/.exec(parsedInstallPath);\n    if (versionMatch) {\n        parsedVersionPart = versionMatch[1];\n    }\n    else {\n        // Example: \"2.8.0\"\n        parsedVersionPart = parsedInstallPath;\n    }\n    // By this point, we expect parsedVersionPart to be a valid SemVer range\n    if (!parsedVersionPart) {\n        return undefined;\n    }\n    if (!semver.valid(parsedVersionPart)) {\n        const urlRegex = /^(git@|@)?([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}(\\/|\\+)([^\\/\\\\]+\\/?)*([^\\/\\\\]+)$/i;\n        // Test for urls:\n        // Examples:\n        //     @github.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     github.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     github.com.au/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     bitbucket.com/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     bitbucket.com+abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     git@bitbucket.com+abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        //     bitbucket.co.in/abc/def/188ed64efd5218beda276e02f2277bf3a6b745b2\n        if (urlRegex.test(dependencyKey)) {\n            const dependencySpecifier = new DependencySpecifier(dependencyName, dependencyKey);\n            return dependencySpecifier;\n        }\n        else {\n            return undefined;\n        }\n    }\n    // Is it an alias for a different package?\n    if (parsedPackageName === dependencyName) {\n        // No, it's a regular dependency\n        return new DependencySpecifier(parsedPackageName, parsedVersionPart);\n    }\n    else {\n        // If the parsed package name is different from the dependencyName, then this is an NPM package alias\n        return new DependencySpecifier(dependencyName, `npm:${parsedPackageName}@${parsedVersionPart}`);\n    }\n}\nexport function normalizePnpmVersionSpecifier(versionSpecifier) {\n    if (typeof versionSpecifier === 'string') {\n        return versionSpecifier;\n    }\n    else {\n        return versionSpecifier.version;\n    }\n}\nexport class PnpmShrinkwrapFile extends BaseShrinkwrapFile {\n    constructor(shrinkwrapJson) {\n        super();\n        this._shrinkwrapJson = shrinkwrapJson;\n        // Normalize the data\n        const lockfileVersion = shrinkwrapJson.lockfileVersion;\n        if (typeof lockfileVersion === 'string') {\n            const isDotIncluded = lockfileVersion.includes('.');\n            this.shrinkwrapFileMajorVersion = parseInt(lockfileVersion.substring(0, isDotIncluded ? lockfileVersion.indexOf('.') : undefined), 10);\n        }\n        else if (typeof lockfileVersion === 'number') {\n            this.shrinkwrapFileMajorVersion = Math.floor(lockfileVersion);\n        }\n        else {\n            this.shrinkwrapFileMajorVersion = 0;\n        }\n        this.registry = shrinkwrapJson.registry || '';\n        this.dependencies = new Map(Object.entries(shrinkwrapJson.dependencies || {}));\n        this.importers = new Map(Object.entries(shrinkwrapJson.importers || {}));\n        this.specifiers = new Map(Object.entries(shrinkwrapJson.specifiers || {}));\n        this.packages = new Map(Object.entries(shrinkwrapJson.packages || {}));\n        this.overrides = new Map(Object.entries(shrinkwrapJson.overrides || {}));\n        this.packageExtensionsChecksum = shrinkwrapJson.packageExtensionsChecksum;\n        // Lockfile v9 always has \".\" in importers filed.\n        this.isWorkspaceCompatible =\n            this.shrinkwrapFileMajorVersion >= ShrinkwrapFileMajorVersion.V9\n                ? this.importers.size > 1\n                : this.importers.size > 0;\n        this._integrities = new Map();\n    }\n    static getLockfileV9PackageId(name, version) {\n        /**\n         * name@1.2.3                -> name@1.2.3\n         * name@1.2.3(peer)          -> name@1.2.3(peer)\n         * https://xxx/@a/b          -> name@https://xxx/@a/b\n         * file://xxx                -> name@file://xxx\n         * 1.2.3                     -> name@1.2.3\n         */\n        if (/https?:/.test(version)) {\n            return /@https?:/.test(version) ? version : `${name}@${version}`;\n        }\n        else if (/file:/.test(version)) {\n            return /@file:/.test(version) ? version : `${name}@${version}`;\n        }\n        return dependencyPath.removeSuffix(version).includes('@', 1) ? version : `${name}@${version}`;\n    }\n    static loadFromFile(shrinkwrapYamlFilePath, { withCaching } = {}) {\n        let loaded;\n        if (withCaching) {\n            loaded = PnpmShrinkwrapFile._cacheByLockfilePath.get(shrinkwrapYamlFilePath);\n        }\n        // TODO: Promisify this\n        loaded !== null && loaded !== void 0 ? loaded : (loaded = (() => {\n            try {\n                const shrinkwrapContent = FileSystem.readFile(shrinkwrapYamlFilePath);\n                return PnpmShrinkwrapFile.loadFromString(shrinkwrapContent);\n            }\n            catch (error) {\n                if (FileSystem.isNotExistError(error)) {\n                    return undefined; // file does not exist\n                }\n                throw new Error(`Error reading \"${shrinkwrapYamlFilePath}\":\\n  ${error.message}`);\n            }\n        })());\n        PnpmShrinkwrapFile._cacheByLockfilePath.set(shrinkwrapYamlFilePath, loaded);\n        return loaded;\n    }\n    static loadFromString(shrinkwrapContent) {\n        var _a;\n        const shrinkwrapJson = yamlModule.safeLoad(shrinkwrapContent);\n        if (shrinkwrapJson.snapshots) {\n            const lockfile = convertLockfileV9ToLockfileObject(shrinkwrapJson);\n            /**\n             * In Lockfile V9,\n             * 1. There is no top-level dependencies field, but it is a property of the importers field.\n             * 2. The version may is not equal to the key in the package field. Thus, it needs to be standardized in the form of `<name>:<version>`.\n             *\n             * importers:\n             *  .:\n             *    dependencies:\n             *      'project1':\n             *        specifier: file:./projects/project1\n             *        version: file:projects/project1\n             *\n             * packages:\n             *   project1@file:projects/project1:\n             *     resolution: {directory: projects/project1, type: directory}\n             */\n            const dependencies = (_a = lockfile.importers['.']) === null || _a === void 0 ? void 0 : _a.dependencies;\n            if (dependencies) {\n                lockfile.dependencies = {};\n                for (const [name, versionSpecifier] of Object.entries(dependencies)) {\n                    lockfile.dependencies[name] = PnpmShrinkwrapFile.getLockfileV9PackageId(name, versionSpecifier);\n                }\n            }\n            return new PnpmShrinkwrapFile(lockfile);\n        }\n        return new PnpmShrinkwrapFile(shrinkwrapJson);\n    }\n    getShrinkwrapHash(experimentsConfig) {\n        // The 'omitImportersFromPreventManualShrinkwrapChanges' experiment skips the 'importers' section\n        // when computing the hash, since the main concern is changes to the overall external dependency footprint\n        const { omitImportersFromPreventManualShrinkwrapChanges } = experimentsConfig || {};\n        const shrinkwrapContent = this._serializeInternal(omitImportersFromPreventManualShrinkwrapChanges);\n        return crypto.createHash('sha1').update(shrinkwrapContent).digest('hex');\n    }\n    /**\n     * Determine whether `pnpm-lock.yaml` contains insecure sha1 hashes.\n     * @internal\n     */\n    _disallowInsecureSha1(customTipsConfiguration, exemptPackageVersions, terminal, subspaceName) {\n        var _a;\n        const exemptPackageList = new Map();\n        for (const [pkgName, versions] of Object.entries(exemptPackageVersions)) {\n            for (const version of versions) {\n                exemptPackageList.set(this._getPackageId(pkgName, version), true);\n            }\n        }\n        for (const [pkgName, { resolution }] of this.packages) {\n            if (((_a = resolution === null || resolution === void 0 ? void 0 : resolution.integrity) === null || _a === void 0 ? void 0 : _a.startsWith('sha1')) &&\n                !exemptPackageList.has(this._parseDependencyPath(pkgName))) {\n                terminal.writeErrorLine('Error: An integrity field with \"sha1\" was detected in the pnpm-lock.yaml file located in subspace ' +\n                    `${subspaceName}; this conflicts with the \"disallowInsecureSha1\" policy from pnpm-config.json.\\n`);\n                customTipsConfiguration._showErrorTip(terminal, CustomTipId.TIP_RUSH_DISALLOW_INSECURE_SHA1);\n                return true; // Indicates an error was found\n            }\n        }\n        return false;\n    }\n    /** @override */\n    validateShrinkwrapAfterUpdate(rushConfiguration, subspace, terminal) {\n        var _a;\n        const pnpmOptions = subspace.getPnpmOptions() || rushConfiguration.pnpmOptions;\n        const { pnpmLockfilePolicies } = pnpmOptions;\n        let invalidPoliciesCount = 0;\n        if ((_a = pnpmLockfilePolicies === null || pnpmLockfilePolicies === void 0 ? void 0 : pnpmLockfilePolicies.disallowInsecureSha1) === null || _a === void 0 ? void 0 : _a.enabled) {\n            const isError = this._disallowInsecureSha1(rushConfiguration.customTipsConfiguration, pnpmLockfilePolicies.disallowInsecureSha1.exemptPackageVersions, terminal, subspace.subspaceName);\n            if (isError) {\n                invalidPoliciesCount += 1;\n            }\n        }\n        if (invalidPoliciesCount > 0) {\n            throw new AlreadyReportedError();\n        }\n    }\n    /** @override */\n    validate(packageManagerOptionsConfig, policyOptions, experimentsConfig) {\n        super.validate(packageManagerOptionsConfig, policyOptions);\n        if (!(packageManagerOptionsConfig instanceof PnpmOptionsConfiguration)) {\n            throw new Error('The provided package manager options are not valid for PNPM shrinkwrap files.');\n        }\n        if (!policyOptions.allowShrinkwrapUpdates) {\n            if (!policyOptions.repoState.isValid) {\n                // eslint-disable-next-line no-console\n                console.log(Colorize.red(`The ${RushConstants.repoStateFilename} file is invalid. There may be a merge conflict marker ` +\n                    'in the file. You may need to run \"rush update\" to refresh its contents.') + '\\n');\n                throw new AlreadyReportedError();\n            }\n            // Only check the hash if allowShrinkwrapUpdates is false. If true, the shrinkwrap file\n            // may have changed and the hash could be invalid.\n            if (packageManagerOptionsConfig.preventManualShrinkwrapChanges) {\n                if (!policyOptions.repoState.pnpmShrinkwrapHash) {\n                    // eslint-disable-next-line no-console\n                    console.log(Colorize.red('The existing shrinkwrap file hash could not be found. You may need to run \"rush update\" to ' +\n                        'populate the hash. See the \"preventManualShrinkwrapChanges\" setting documentation for details.') + '\\n');\n                    throw new AlreadyReportedError();\n                }\n                if (this.getShrinkwrapHash(experimentsConfig) !== policyOptions.repoState.pnpmShrinkwrapHash) {\n                    // eslint-disable-next-line no-console\n                    console.log(Colorize.red('The shrinkwrap file hash does not match the expected hash. Please run \"rush update\" to ensure the ' +\n                        'shrinkwrap file is up to date. See the \"preventManualShrinkwrapChanges\" setting documentation for ' +\n                        'details.') + '\\n');\n                    throw new AlreadyReportedError();\n                }\n            }\n        }\n    }\n    /**\n     * This operation exactly mirrors the behavior of PNPM's own implementation:\n     * https://github.com/pnpm/pnpm/blob/73ebfc94e06d783449579cda0c30a40694d210e4/lockfile/lockfile-file/src/experiments/inlineSpecifiersLockfileConverters.ts#L162\n     */\n    _convertLockfileV6DepPathToV5DepPath(newDepPath) {\n        if (!newDepPath.includes('@', 2) || newDepPath.startsWith('file:'))\n            return newDepPath;\n        const index = newDepPath.indexOf('@', newDepPath.indexOf('/@') + 2);\n        if (newDepPath.includes('(') && index > dependencyPathLockfilePreV9.indexOfPeersSuffix(newDepPath))\n            return newDepPath;\n        return `${newDepPath.substring(0, index)}/${newDepPath.substring(index + 1)}`;\n    }\n    /**\n     * Normalize dependency paths for PNPM shrinkwrap files.\n     * Example: \"/eslint-utils@3.0.0(eslint@8.23.1)\" --> \"/eslint-utils@3.0.0\"\n     * Example: \"/@typescript-eslint/experimental-utils/5.9.1_eslint@8.6.0+typescript@4.4.4\" --> \"/@typescript-eslint/experimental-utils/5.9.1\"\n     */\n    _parseDependencyPath(packagePath) {\n        let depPath = packagePath;\n        if (this.shrinkwrapFileMajorVersion >= 6) {\n            depPath = this._convertLockfileV6DepPathToV5DepPath(packagePath);\n        }\n        const pkgInfo = dependencyPathLockfilePreV9.parse(depPath);\n        return this._getPackageId(pkgInfo.name, pkgInfo.version);\n    }\n    /** @override */\n    getTempProjectNames() {\n        return this._getTempProjectNames(this._shrinkwrapJson.dependencies || {});\n    }\n    /**\n     * Gets the path to the tarball file if the package is a tarball.\n     * Returns undefined if the package entry doesn't exist or the package isn't a tarball.\n     * Example of return value: file:projects/build-tools.tgz\n     */\n    getTarballPath(packageName) {\n        var _a;\n        const dependency = this.packages.get(packageName);\n        return (_a = dependency === null || dependency === void 0 ? void 0 : dependency.resolution) === null || _a === void 0 ? void 0 : _a.tarball;\n    }\n    getTopLevelDependencyKey(dependencyName) {\n        return this.dependencies.get(dependencyName);\n    }\n    /**\n     * Gets the version number from the list of top-level dependencies in the \"dependencies\" section\n     * of the shrinkwrap file. Sample return values:\n     *   '2.1.113'\n     *   '1.9.0-dev.27'\n     *   'file:projects/empty-webpart-project.tgz'\n     *   undefined\n     *\n     * @override\n     */\n    getTopLevelDependencyVersion(dependencyName) {\n        var _a, _b;\n        let value = this.dependencies.get(dependencyName);\n        if (value) {\n            value = normalizePnpmVersionSpecifier(value);\n            // Getting the top level dependency version from a PNPM lockfile version 5.x or 6.1\n            // --------------------------------------------------------------------------\n            //\n            // 1) Top-level tarball dependency entries in pnpm-lock.yaml look like in 5.x:\n            //    ```\n            //    '@rush-temp/sp-filepicker': 'file:projects/sp-filepicker.tgz_0ec79d3b08edd81ebf49cd19ca50b3f5'\n            //    ```\n            //    And in version 6.1, they look like:\n            //    ```\n            //    '@rush-temp/sp-filepicker':\n            //      specifier: file:./projects/generate-api-docs.tgz\n            //      version: file:projects/generate-api-docs.tgz\n            //    ```\n            //    Then, it would be defined below (version 5.x):\n            //    ```\n            //    'file:projects/sp-filepicker.tgz_0ec79d3b08edd81ebf49cd19ca50b3f5':\n            //      dependencies:\n            //       '@microsoft/load-themed-styles': 1.10.7\n            //       ...\n            //      resolution:\n            //       integrity: sha512-guuoFIc**==\n            //       tarball: 'file:projects/sp-filepicker.tgz'\n            //    ```\n            //    Or in version 6.1:\n            //    ```\n            //    file:projects/sp-filepicker.tgz:\n            //      resolution: {integrity: sha512-guuoFIc**==, tarball: file:projects/sp-filepicker.tgz}\n            //      name: '@rush-temp/sp-filepicker'\n            //      version: 0.0.0\n            //      dependencies:\n            //        '@microsoft/load-themed-styles': 1.10.7\n            //        ...\n            //      dev: false\n            //    ```\n            //    Here, we are interested in the part 'file:projects/sp-filepicker.tgz'. Splitting by underscores is not the\n            //    best way to get this because file names could have underscores in them. Instead, we could use the tarball\n            //    field in the resolution section.\n            // 2) Top-level non-tarball dependency entries in pnpm-lock.yaml would look like in 5.x:\n            //    ```\n            //    '@rushstack/set-webpack-public-path-plugin': 2.1.133\n            //    @microsoft/sp-build-node': 1.9.0-dev.27_typescript@2.9.2\n            //    ```\n            //    And in version 6.1, they look like:\n            //    ```\n            //    '@rushstack/set-webpack-public-path-plugin':\n            //      specifier: ^2.1.133\n            //      version: 2.1.133\n            //    '@microsoft/sp-build-node':\n            //      specifier: 1.9.0-dev.27\n            //      version: 1.9.0-dev.27(typescript@2.9.2)\n            //    ```\n            //    Here, we could either just split by underscores and take the first part (5.x) or use the specifier field\n            //    (6.1).\n            // The below code is also compatible with lockfile versions < 5.1\n            const dependency = this.packages.get(value);\n            if (((_a = dependency === null || dependency === void 0 ? void 0 : dependency.resolution) === null || _a === void 0 ? void 0 : _a.tarball) && value.startsWith(dependency.resolution.tarball)) {\n                return new DependencySpecifier(dependencyName, dependency.resolution.tarball);\n            }\n            if (this.shrinkwrapFileMajorVersion >= ShrinkwrapFileMajorVersion.V9) {\n                const { version, nonSemverVersion } = dependencyPath.parse(value);\n                value = (_b = version !== null && version !== void 0 ? version : nonSemverVersion) !== null && _b !== void 0 ? _b : value;\n            }\n            else {\n                let underscoreOrParenthesisIndex = value.indexOf('_');\n                if (underscoreOrParenthesisIndex < 0) {\n                    underscoreOrParenthesisIndex = value.indexOf('(');\n                }\n                if (underscoreOrParenthesisIndex >= 0) {\n                    value = value.substring(0, underscoreOrParenthesisIndex);\n                }\n            }\n            return new DependencySpecifier(dependencyName, value);\n        }\n        return undefined;\n    }\n    /**\n     * The PNPM shrinkwrap file has top-level dependencies on the temp projects like this (version 5.x):\n     *\n     * ```\n     * dependencies:\n     *   '@rush-temp/my-app': 'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0'\n     * packages:\n     *   /@types/node/10.14.15:\n     *     dev: false\n     *   'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0':\n     *     dev: false\n     *     name: '@rush-temp/my-app'\n     *     version: 0.0.0\n     * ```\n     *\n     * or in version 6.1, like this:\n     * ```\n     * dependencies:\n     *  '@rush-temp/my-app':\n     *    specifier: file:./projects/my-app.tgz\n     *    version: file:projects/my-app.tgz\n     *  packages:\n     *    /@types/node@10.14.15:\n     *      resolution: {integrity: sha512-iAB+**==}\n     *      dev: false\n     *    file:projects/my-app.tgz\n     *      resolution: {integrity: sha512-guuoFIc**==, tarball: file:projects/sp-filepicker.tgz}\n     *      name: '@rush-temp/my-app'\n     *      version: 0.0.0\n     *      dependencies:\n     *        '@microsoft/load-themed-styles': 1.10.7\n     *        ...\n     *      dev: false\n     * ```\n     *\n     * We refer to 'file:projects/my-app.tgz_25c559a5921686293a001a397be4dce0' or 'file:projects/my-app.tgz' as\n     * the temp project dependency key of the temp project '@rush-temp/my-app'.\n     */\n    getTempProjectDependencyKey(tempProjectName) {\n        const tempProjectDependencyKey = this.dependencies.get(tempProjectName);\n        return tempProjectDependencyKey ? normalizePnpmVersionSpecifier(tempProjectDependencyKey) : undefined;\n    }\n    getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey) {\n        return this.packages.get(tempProjectDependencyKey);\n    }\n    getShrinkwrapEntry(name, version) {\n        const packageId = this._getPackageId(name, version);\n        return this.packages.get(packageId);\n    }\n    /**\n     * Serializes the PNPM Shrinkwrap file\n     *\n     * @override\n     */\n    serialize() {\n        return this._serializeInternal(false);\n    }\n    /**\n     * Gets the resolved version number of a dependency for a specific temp project.\n     * For PNPM, we can reuse the version that another project is using.\n     * Note that this function modifies the shrinkwrap data if tryReusingPackageVersionsFromShrinkwrap is set to true.\n     *\n     * @override\n     */\n    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {\n        // PNPM doesn't have the same advantage of NPM, where we can skip generate as long as the\n        // shrinkwrap file puts our dependency in either the top of the node_modules folder\n        // or underneath the package we are looking at.\n        // This is because the PNPM shrinkwrap file describes the exact links that need to be created\n        // to recreate the graph..\n        // Because of this, we actually need to check for a version that this package is directly\n        // linked to.\n        const packageName = dependencySpecifier.packageName;\n        const tempProjectDependencyKey = this.getTempProjectDependencyKey(tempProjectName);\n        if (!tempProjectDependencyKey) {\n            return undefined;\n        }\n        const packageDescription = this._getPackageDescription(tempProjectDependencyKey);\n        if (!packageDescription ||\n            !packageDescription.dependencies ||\n            !packageDescription.dependencies.hasOwnProperty(packageName)) {\n            return undefined;\n        }\n        const dependencyKey = packageDescription.dependencies[packageName];\n        return this._parsePnpmDependencyKey(packageName, dependencyKey);\n    }\n    /** @override */\n    findOrphanedProjects(rushConfiguration, subspace) {\n        // The base shrinkwrap handles orphaned projects the same across all package managers,\n        // but this is only valid for non-workspace installs\n        if (!this.isWorkspaceCompatible) {\n            return super.findOrphanedProjects(rushConfiguration, subspace);\n        }\n        const orphanedProjectPaths = [];\n        for (const importerKey of this.getImporterKeys()) {\n            // PNPM importer keys are relative paths from the workspace root, which is the common temp folder\n            const rushProjectPath = path.resolve(subspace.getSubspaceTempFolderPath(), importerKey);\n            if (!rushConfiguration.tryGetProjectForPath(rushProjectPath)) {\n                orphanedProjectPaths.push(rushProjectPath);\n            }\n        }\n        return orphanedProjectPaths;\n    }\n    /** @override */\n    getProjectShrinkwrap(project) {\n        return new PnpmProjectShrinkwrapFile(this, project);\n    }\n    *getImporterKeys() {\n        // Filter out the root importer used for the generated package.json in the root\n        // of the install, since we do not use this.\n        for (const key of this.importers.keys()) {\n            if (key !== '.') {\n                yield key;\n            }\n        }\n    }\n    getImporterKeyByPath(workspaceRoot, projectFolder) {\n        return Path.convertToSlashes(path.relative(workspaceRoot, projectFolder));\n    }\n    getImporter(importerKey) {\n        return this.importers.get(importerKey);\n    }\n    getIntegrityForImporter(importerKey) {\n        // This logic formerly lived in PnpmProjectShrinkwrapFile. Moving it here allows caching of the external\n        // dependency integrity relationships across projects\n        let integrityMap = this._integrities.get(importerKey);\n        if (!integrityMap) {\n            const importer = this.getImporter(importerKey);\n            if (importer) {\n                integrityMap = new Map();\n                this._integrities.set(importerKey, integrityMap);\n                const sha256Digest = crypto\n                    .createHash('sha256')\n                    .update(JSON.stringify(importer))\n                    .digest('base64');\n                const selfIntegrity = `${importerKey}:${sha256Digest}:`;\n                integrityMap.set(importerKey, selfIntegrity);\n                const { dependencies, devDependencies, optionalDependencies } = importer;\n                const externalFilter = (name, versionSpecifier) => {\n                    const version = normalizePnpmVersionSpecifier(versionSpecifier);\n                    return !version.includes('link:');\n                };\n                if (dependencies) {\n                    this._addIntegrities(integrityMap, dependencies, false, externalFilter);\n                }\n                if (devDependencies) {\n                    this._addIntegrities(integrityMap, devDependencies, false, externalFilter);\n                }\n                if (optionalDependencies) {\n                    this._addIntegrities(integrityMap, optionalDependencies, true, externalFilter);\n                }\n            }\n        }\n        return integrityMap;\n    }\n    /** @override */\n    async isWorkspaceProjectModifiedAsync(project, subspace, variant) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;\n        const importerKey = this.getImporterKeyByPath(subspace.getSubspaceTempFolderPath(), project.projectFolder);\n        const importer = this.getImporter(importerKey);\n        if (!importer) {\n            return true;\n        }\n        // First, let's transform the package.json using the pnpmfile\n        const packageJson = project.packageJsonEditor.saveToObject();\n        // Initialize the pnpmfile if it doesn't exist\n        if (!this._pnpmfileConfiguration) {\n            this._pnpmfileConfiguration = await PnpmfileConfiguration.initializeAsync(project.rushConfiguration, subspace, variant);\n        }\n        let transformedPackageJson = packageJson;\n        let subspacePnpmfile;\n        if (project.rushConfiguration.subspacesFeatureEnabled) {\n            // Get the pnpmfile\n            const subspacePnpmfilePath = path.join(subspace.getSubspaceTempFolderPath(), RushConstants.pnpmfileGlobalFilename);\n            if (await FileSystem.existsAsync(subspacePnpmfilePath)) {\n                try {\n                    subspacePnpmfile = require(subspacePnpmfilePath);\n                }\n                catch (err) {\n                    if (err instanceof SyntaxError) {\n                        // eslint-disable-next-line no-console\n                        console.error(Colorize.red(`A syntax error in the ${RushConstants.pnpmfileV6Filename} at ${subspacePnpmfilePath}\\n`));\n                    }\n                    else {\n                        // eslint-disable-next-line no-console\n                        console.error(Colorize.red(`Error during pnpmfile execution. pnpmfile: \"${subspacePnpmfilePath}\". Error: \"${err.message}\".` +\n                            '\\n'));\n                    }\n                }\n            }\n            if (subspacePnpmfile) {\n                const individualContext = {\n                    log: (message) => {\n                        // eslint-disable-next-line no-console\n                        console.log(message);\n                    }\n                };\n                try {\n                    transformedPackageJson =\n                        ((_b = (_a = subspacePnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) === null || _b === void 0 ? void 0 : _b.call(_a, transformedPackageJson, individualContext)) ||\n                            transformedPackageJson;\n                }\n                catch (err) {\n                    // eslint-disable-next-line no-console\n                    console.error(Colorize.red(`Error during readPackage hook execution. pnpmfile: \"${subspacePnpmfilePath}\". Error: \"${err.message}\".` +\n                        '\\n'));\n                }\n            }\n        }\n        // Use a new PackageJsonEditor since it will classify each dependency type, making tracking the\n        // found versions much simpler.\n        const { dependencyList, devDependencyList, dependencyMetaList } = PackageJsonEditor.fromObject(this._pnpmfileConfiguration.transform(transformedPackageJson), project.packageJsonEditor.filePath);\n        const allDependencies = [...dependencyList, ...devDependencyList];\n        if (this.shrinkwrapFileMajorVersion < 6) {\n            // PNPM <= v7\n            // Then get the unique package names and map them to package versions.\n            const dependencyVersions = new Map();\n            for (const packageDependency of allDependencies) {\n                // We will also filter out peer dependencies since these are not installed at development time.\n                if (packageDependency.dependencyType === DependencyType.Peer) {\n                    continue;\n                }\n                const foundDependency = dependencyVersions.get(packageDependency.name);\n                if (!foundDependency) {\n                    dependencyVersions.set(packageDependency.name, packageDependency);\n                }\n                else {\n                    // Shrinkwrap will prioritize optional dependencies, followed by regular dependencies, with dev being\n                    // the least prioritized. We will only keep the most prioritized option.\n                    // See: https://github.com/pnpm/pnpm/blob/main/packages/lockfile-utils/src/satisfiesPackageManifest.ts\n                    switch (foundDependency.dependencyType) {\n                        case DependencyType.Optional:\n                            break;\n                        case DependencyType.Regular:\n                            if (packageDependency.dependencyType === DependencyType.Optional) {\n                                dependencyVersions.set(packageDependency.name, packageDependency);\n                            }\n                            break;\n                        case DependencyType.Dev:\n                            dependencyVersions.set(packageDependency.name, packageDependency);\n                            break;\n                    }\n                }\n            }\n            // Then validate that the dependency fields are as expected in the shrinkwrap to avoid false-negatives\n            // when moving a package from one field to the other.\n            for (const { dependencyType, name } of dependencyVersions.values()) {\n                switch (dependencyType) {\n                    case DependencyType.Optional:\n                        if (!((_c = importer.optionalDependencies) === null || _c === void 0 ? void 0 : _c[name]))\n                            return true;\n                        break;\n                    case DependencyType.Regular:\n                        if (!((_d = importer.dependencies) === null || _d === void 0 ? void 0 : _d[name]))\n                            return true;\n                        break;\n                    case DependencyType.Dev:\n                        if (!((_e = importer.devDependencies) === null || _e === void 0 ? void 0 : _e[name]))\n                            return true;\n                        break;\n                }\n            }\n            const specifiers = importer.specifiers;\n            if (!specifiers) {\n                throw new InternalError('Expected specifiers to be defined, but is expected in lockfile version 5');\n            }\n            // Then validate the length matches between the importer and the dependency list, since duplicates are\n            // a valid use-case. Importers will only take one of these values, so no need to do more work here.\n            if (dependencyVersions.size !== Object.keys(specifiers).length) {\n                return true;\n            }\n            // Finally, validate that all values in the importer are also present in the dependency list.\n            for (const [importerPackageName, importerVersionSpecifier] of Object.entries(specifiers)) {\n                const foundDependency = dependencyVersions.get(importerPackageName);\n                if (!foundDependency) {\n                    return true;\n                }\n                const resolvedVersion = (_f = this.overrides.get(importerPackageName)) !== null && _f !== void 0 ? _f : foundDependency.version;\n                if (resolvedVersion !== importerVersionSpecifier) {\n                    return true;\n                }\n            }\n        }\n        else {\n            //  >= PNPM v8\n            const importerOptionalDependencies = new Set(Object.keys((_g = importer.optionalDependencies) !== null && _g !== void 0 ? _g : {}));\n            const importerDependencies = new Set(Object.keys((_h = importer.dependencies) !== null && _h !== void 0 ? _h : {}));\n            const importerDevDependencies = new Set(Object.keys((_j = importer.devDependencies) !== null && _j !== void 0 ? _j : {}));\n            const importerDependenciesMeta = new Set(Object.keys((_k = importer.dependenciesMeta) !== null && _k !== void 0 ? _k : {}));\n            for (const { dependencyType, name, version } of allDependencies) {\n                let isOptional = false;\n                let specifierFromLockfile;\n                let isDevDepFallThrough = false;\n                switch (dependencyType) {\n                    case DependencyType.Optional: {\n                        specifierFromLockfile = (_l = importer.optionalDependencies) === null || _l === void 0 ? void 0 : _l[name];\n                        importerOptionalDependencies.delete(name);\n                        break;\n                    }\n                    case DependencyType.Peer: {\n                        // Peer dependencies of workspace projects may be installed as regular dependencies\n                        isOptional = true; // fall through\n                    }\n                    case DependencyType.Dev: {\n                        specifierFromLockfile = (_m = importer.devDependencies) === null || _m === void 0 ? void 0 : _m[name];\n                        if (specifierFromLockfile) {\n                            // If the dev dependency is not found, it may be installed as a regular dependency,\n                            // so fall through\n                            importerDevDependencies.delete(name);\n                            break;\n                        }\n                        // If fall through, there is a chance the package declares an inconsistent version, ignore it.\n                        isDevDepFallThrough = true;\n                    }\n                    // eslint-disable-next-line no-fallthrough\n                    case DependencyType.Regular:\n                        specifierFromLockfile = (_o = importer.dependencies) === null || _o === void 0 ? void 0 : _o[name];\n                        importerDependencies.delete(name);\n                        break;\n                }\n                if (!specifierFromLockfile) {\n                    if (!isOptional) {\n                        return true;\n                    }\n                }\n                else {\n                    if (this.shrinkwrapFileMajorVersion >= ShrinkwrapFileMajorVersion.V9) {\n                        // TODO: Emit an error message when someone tries to override a version of something in one of their\n                        // local repo packages.\n                        let resolvedVersion = (_p = this.overrides.get(name)) !== null && _p !== void 0 ? _p : version;\n                        // convert path in posix style, otherwise pnpm install will fail in subspace case\n                        resolvedVersion = Path.convertToSlashes(resolvedVersion);\n                        const specifier = importer.specifiers[name];\n                        if (specifier !== resolvedVersion && !isDevDepFallThrough && !isOptional) {\n                            return true;\n                        }\n                    }\n                    else {\n                        if (typeof specifierFromLockfile === 'string') {\n                            throw new Error(`The PNPM lockfile is in an unexpected format. The \"${name}\" package is specified as ` +\n                                `\"${specifierFromLockfile}\" instead of an object.`);\n                        }\n                        else {\n                            // TODO: Emit an error message when someone tries to override a version of something in one of their\n                            // local repo packages.\n                            let resolvedVersion = (_q = this.overrides.get(name)) !== null && _q !== void 0 ? _q : version;\n                            // convert path in posix style, otherwise pnpm install will fail in subspace case\n                            resolvedVersion = Path.convertToSlashes(resolvedVersion);\n                            if (specifierFromLockfile.specifier !== resolvedVersion && !isDevDepFallThrough && !isOptional) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n            for (const { name, injected } of dependencyMetaList) {\n                if (((_s = (_r = importer.dependenciesMeta) === null || _r === void 0 ? void 0 : _r[name]) === null || _s === void 0 ? void 0 : _s.injected) === injected) {\n                    importerDependenciesMeta.delete(name);\n                }\n            }\n            // Finally, validate that all values in the importer are also present in the dependency list.\n            if (importerOptionalDependencies.size > 0 ||\n                importerDependencies.size > 0 ||\n                importerDevDependencies.size > 0 ||\n                importerDependenciesMeta.size > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _getIntegrityForPackage(specifier, optional) {\n        var _a;\n        const integrities = this._integrities;\n        let integrityMap = integrities.get(specifier);\n        if (integrityMap) {\n            return integrityMap;\n        }\n        integrityMap = new Map();\n        integrities.set(specifier, integrityMap);\n        const shrinkwrapEntry = this.packages.get(specifier);\n        if (!shrinkwrapEntry) {\n            if (!optional) {\n                // This algorithm heeds to be robust against missing shrinkwrap entries, so we can't just throw\n                // Instead set it to a value which will not match any valid shrinkwrap record\n                integrityMap.set(specifier, 'Missing shrinkwrap entry!');\n            }\n            // Indicate an empty entry\n            return integrityMap;\n        }\n        let selfIntegrity = (_a = shrinkwrapEntry.resolution) === null || _a === void 0 ? void 0 : _a.integrity;\n        if (!selfIntegrity) {\n            // git dependency specifiers do not have an integrity entry. Instead, they specify the tarball field.\n            // So instead, we will hash the contents of the dependency entry and use that as the integrity hash.\n            // Ex:\n            // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:\n            //   ...\n            //   resolution:\n            //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'\n            const sha256Digest = crypto\n                .createHash('sha256')\n                .update(JSON.stringify(shrinkwrapEntry))\n                .digest('base64');\n            selfIntegrity = `${specifier}:${sha256Digest}:`;\n        }\n        integrityMap.set(specifier, selfIntegrity);\n        const { dependencies, optionalDependencies } = shrinkwrapEntry;\n        if (dependencies) {\n            this._addIntegrities(integrityMap, dependencies, false);\n        }\n        if (optionalDependencies) {\n            this._addIntegrities(integrityMap, optionalDependencies, true);\n        }\n        return integrityMap;\n    }\n    _addIntegrities(integrityMap, collection, optional, filter) {\n        for (const [name, version] of Object.entries(collection)) {\n            if (filter && !filter(name, version)) {\n                continue;\n            }\n            const packageId = this._getPackageId(name, version);\n            if (integrityMap.has(packageId)) {\n                // The entry could already have been added as a nested dependency\n                continue;\n            }\n            const contribution = this._getIntegrityForPackage(packageId, optional);\n            for (const [dep, integrity] of contribution) {\n                integrityMap.set(dep, integrity);\n            }\n        }\n    }\n    /**\n     * Gets the package description for a tempProject from the shrinkwrap file.\n     */\n    _getPackageDescription(tempProjectDependencyKey) {\n        const packageDescription = this.packages.get(tempProjectDependencyKey);\n        return packageDescription && packageDescription.dependencies ? packageDescription : undefined;\n    }\n    _getPackageId(name, versionSpecifier) {\n        const version = normalizePnpmVersionSpecifier(versionSpecifier);\n        if (this.shrinkwrapFileMajorVersion >= ShrinkwrapFileMajorVersion.V9) {\n            return PnpmShrinkwrapFile.getLockfileV9PackageId(name, version);\n        }\n        else if (this.shrinkwrapFileMajorVersion >= ShrinkwrapFileMajorVersion.V6) {\n            if (version.startsWith('@github')) {\n                // This is a github repo reference\n                return version;\n            }\n            else {\n                return version.startsWith('/') ? version : `/${name}@${version}`;\n            }\n        }\n        else {\n            // Version can sometimes be in the form of a path that's already in the /name/version format.\n            return version.indexOf('/') !== -1 ? version : `/${name}/${version}`;\n        }\n    }\n    _parsePnpmDependencyKey(dependencyName, pnpmDependencyKey) {\n        if (pnpmDependencyKey) {\n            const result = this.shrinkwrapFileMajorVersion >= ShrinkwrapFileMajorVersion.V9\n                ? parsePnpm9DependencyKey(dependencyName, pnpmDependencyKey)\n                : parsePnpmDependencyKey(dependencyName, pnpmDependencyKey);\n            if (!result) {\n                throw new Error(`Cannot parse PNPM shrinkwrap version specifier: \"${pnpmDependencyKey}\"` +\n                    ` for \"${dependencyName}\"`);\n            }\n            return result;\n        }\n        else {\n            return undefined;\n        }\n    }\n    _serializeInternal(omitImporters = false) {\n        // Ensure that if any of the top-level properties are provided but empty are removed. We populate the object\n        // properties when we read the shrinkwrap but PNPM does not set these top-level properties unless they are present.\n        const shrinkwrapToSerialize = {};\n        for (const [key, value] of Object.entries(this._shrinkwrapJson)) {\n            if (omitImporters && key === 'importers') {\n                continue;\n            }\n            if (!value || typeof value !== 'object' || Object.keys(value).length > 0) {\n                shrinkwrapToSerialize[key] = value;\n            }\n        }\n        return yamlModule.safeDump(shrinkwrapToSerialize, PNPM_SHRINKWRAP_YAML_FORMAT);\n    }\n}\n// TODO: Implement cache eviction when a lockfile is copied back\nPnpmShrinkwrapFile._cacheByLockfilePath = new Map();\n//# sourceMappingURL=PnpmShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n// This is based on PNPM's own configuration:\n// https://github.com/pnpm/pnpm-shrinkwrap/blob/master/src/write.ts\nexport const PNPM_SHRINKWRAP_YAML_FORMAT = {\n    lineWidth: 1000,\n    noCompatMode: true,\n    noRefs: true,\n    sortKeys: true\n};\n//# sourceMappingURL=PnpmYamlCommon.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport { FileSystem, Import, JsonFile, MapExtensions } from '@rushstack/node-core-library';\nimport * as pnpmfile from './PnpmfileShim';\nimport { pnpmfileShimFilename, scriptsFolderPath } from '../../utilities/PathConstants';\n/**\n * Loads PNPM's pnpmfile.js configuration, and invokes it to preprocess package.json files,\n * optionally utilizing a pnpmfile shim to inject preferred versions.\n */\nexport class PnpmfileConfiguration {\n    constructor(context) {\n        pnpmfile.reset();\n        this._context = context;\n    }\n    static async initializeAsync(rushConfiguration, subspace, variant) {\n        if (rushConfiguration.packageManager !== 'pnpm') {\n            throw new Error(`PnpmfileConfiguration cannot be used with package manager \"${rushConfiguration.packageManager}\"`);\n        }\n        // Set the context to swallow log output and store our settings\n        const context = {\n            log: (message) => { },\n            pnpmfileShimSettings: await PnpmfileConfiguration._getPnpmfileShimSettingsAsync(rushConfiguration, subspace, variant)\n        };\n        return new PnpmfileConfiguration(context);\n    }\n    static async writeCommonTempPnpmfileShimAsync(rushConfiguration, targetDir, subspace, variant) {\n        if (rushConfiguration.packageManager !== 'pnpm') {\n            throw new Error(`PnpmfileConfiguration cannot be used with package manager \"${rushConfiguration.packageManager}\"`);\n        }\n        const pnpmfilePath = path.join(targetDir, rushConfiguration.packageManagerWrapper.pnpmfileFilename);\n        // Write the shim itself\n        await FileSystem.copyFileAsync({\n            sourcePath: `${scriptsFolderPath}/${pnpmfileShimFilename}`,\n            destinationPath: pnpmfilePath\n        });\n        const pnpmfileShimSettings = await PnpmfileConfiguration._getPnpmfileShimSettingsAsync(rushConfiguration, subspace, variant);\n        // Write the settings file used by the shim\n        await JsonFile.saveAsync(pnpmfileShimSettings, path.join(targetDir, 'pnpmfileSettings.json'), {\n            ensureFolderExists: true\n        });\n    }\n    static async _getPnpmfileShimSettingsAsync(rushConfiguration, subspace, variant) {\n        let allPreferredVersions = {};\n        let allowedAlternativeVersions = {};\n        const workspaceVersions = {};\n        // Only workspaces shims in the common versions using pnpmfile\n        if (rushConfiguration.packageManagerOptions.useWorkspaces) {\n            const commonVersionsConfiguration = subspace.getCommonVersions(variant);\n            const preferredVersions = new Map();\n            MapExtensions.mergeFromMap(preferredVersions, rushConfiguration.getImplicitlyPreferredVersions(subspace, variant));\n            for (const [name, version] of commonVersionsConfiguration.getAllPreferredVersions()) {\n                // Use the most restrictive version range available\n                if (!preferredVersions.has(name) || semver.subset(version, preferredVersions.get(name))) {\n                    preferredVersions.set(name, version);\n                }\n            }\n            allPreferredVersions = MapExtensions.toObject(preferredVersions);\n            allowedAlternativeVersions = MapExtensions.toObject(commonVersionsConfiguration.allowedAlternativeVersions);\n            for (const project of rushConfiguration.projects) {\n                workspaceVersions[project.packageName] = project.packageJson.version;\n            }\n        }\n        const settings = {\n            allPreferredVersions,\n            allowedAlternativeVersions,\n            workspaceVersions,\n            semverPath: Import.resolveModule({ modulePath: 'semver', baseFolderPath: __dirname })\n        };\n        // Use the provided path if available. Otherwise, use the default path.\n        const userPnpmfilePath = subspace.getPnpmfilePath(variant);\n        if (userPnpmfilePath && FileSystem.exists(userPnpmfilePath)) {\n            settings.userPnpmfilePath = userPnpmfilePath;\n        }\n        return settings;\n    }\n    /**\n     * Transform a package.json file using the pnpmfile.js hook.\n     * @returns the transformed object, or the original input if pnpmfile.js was not found.\n     */\n    transform(packageJson) {\n        var _a;\n        if (!((_a = pnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) || !this._context) {\n            return packageJson;\n        }\n        else {\n            return pnpmfile.hooks.readPackage(packageJson, this._context);\n        }\n    }\n}\n//# sourceMappingURL=PnpmfileConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar _a;\nlet settings;\nlet allPreferredVersions;\nlet allowedAlternativeVersions;\nlet userPnpmfile;\nlet semver;\n// Resets the internal state of the pnpmfile\nexport function reset() {\n    settings = undefined;\n    allPreferredVersions = undefined;\n    allowedAlternativeVersions = undefined;\n    userPnpmfile = undefined;\n    semver = undefined;\n}\n// Initialize all external aspects of the pnpmfile shim. When using the shim, settings\n// are always expected to be available. Init must be called before running any hook that\n// depends on a resource obtained from or related to the settings, and will require modules\n// once so they aren't repeatedly required in the hook functions.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction init(context) {\n    // Sometimes PNPM may provide us a context arg that doesn't fit spec, ex.:\n    // https://github.com/pnpm/pnpm/blob/97c64bae4d14a8c8f05803f1d94075ee29c2df2f/packages/get-context/src/index.ts#L134\n    // So we need to normalize the context format before we move on\n    if (typeof context !== 'object' || Array.isArray(context)) {\n        context = {\n            log: (message) => { },\n            originalContext: context\n        };\n    }\n    if (!settings) {\n        // Initialize the settings from file\n        if (!context.pnpmfileShimSettings) {\n            context.pnpmfileShimSettings = __non_webpack_require__('./pnpmfileSettings.json');\n        }\n        settings = context.pnpmfileShimSettings;\n    }\n    else if (!context.pnpmfileShimSettings) {\n        // Reuse the already initialized settings\n        context.pnpmfileShimSettings = settings;\n    }\n    if (!allPreferredVersions && settings.allPreferredVersions) {\n        allPreferredVersions = new Map(Object.entries(settings.allPreferredVersions));\n    }\n    if (!allowedAlternativeVersions && settings.allowedAlternativeVersions) {\n        allowedAlternativeVersions = new Map(Object.entries(settings.allowedAlternativeVersions).map(([packageName, versions]) => {\n            return [packageName, new Set(versions)];\n        }));\n    }\n    // If a userPnpmfilePath is provided, we expect it to exist\n    if (!userPnpmfile && settings.userPnpmfilePath) {\n        userPnpmfile = require(settings.userPnpmfilePath);\n    }\n    // If a semverPath is provided, we expect it to exist\n    if (!semver && settings.semverPath) {\n        semver = require(settings.semverPath);\n    }\n    // Return the normalized context\n    return context;\n}\n// Set the preferred versions on the dependency map. If the version on the map is an allowedAlternativeVersion\n// then skip it. Otherwise, check to ensure that the common version is a subset of the specified version. If\n// it is, then replace the specified version with the preferredVersion\nfunction setPreferredVersions(dependencies) {\n    var _a;\n    for (const [name, version] of Object.entries(dependencies || {})) {\n        const preferredVersion = allPreferredVersions === null || allPreferredVersions === void 0 ? void 0 : allPreferredVersions.get(name);\n        if (preferredVersion && !((_a = allowedAlternativeVersions === null || allowedAlternativeVersions === void 0 ? void 0 : allowedAlternativeVersions.get(name)) === null || _a === void 0 ? void 0 : _a.has(version))) {\n            let preferredVersionRange;\n            let versionRange;\n            try {\n                preferredVersionRange = new semver.Range(preferredVersion);\n                versionRange = new semver.Range(version);\n            }\n            catch (_b) {\n                // Swallow invalid range errors\n            }\n            if (preferredVersionRange &&\n                versionRange &&\n                semver.subset(preferredVersionRange, versionRange, { includePrerelease: true })) {\n                dependencies[name] = preferredVersion;\n            }\n        }\n    }\n}\nexport const hooks = {\n    // Call the original pnpmfile (if it exists)\n    afterAllResolved: (lockfile, context) => {\n        var _a;\n        context = init(context);\n        return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.afterAllResolved)\n            ? userPnpmfile.hooks.afterAllResolved(lockfile, context)\n            : lockfile;\n    },\n    // Set the preferred versions in the package, then call the original pnpmfile (if it exists)\n    readPackage: (pkg, context) => {\n        var _a;\n        context = init(context);\n        setPreferredVersions(pkg.dependencies);\n        setPreferredVersions(pkg.devDependencies);\n        setPreferredVersions(pkg.optionalDependencies);\n        return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) ? userPnpmfile.hooks.readPackage(pkg, context) : pkg;\n    },\n    // Call the original pnpmfile (if it exists)\n    filterLog: (_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.filterLog\n};\n//# sourceMappingURL=PnpmfileShim.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, Import, JsonFile } from '@rushstack/node-core-library';\nimport { subspacePnpmfileShimFilename, scriptsFolderPath } from '../../utilities/PathConstants';\nimport { RushConstants } from '../RushConstants';\n/**\n * Loads PNPM's pnpmfile.js configuration, and invokes it to preprocess package.json files,\n * optionally utilizing a pnpmfile shim to inject preferred versions.\n */\nexport class SubspacePnpmfileConfiguration {\n    /**\n     * Split workspace use global pnpmfile, because in split workspace, user may set `shared-workspace-lockfile=false`.\n     * That means each project owns their individual pnpmfile under project folder. While the global pnpmfile could be\n     * under the common/temp-split/ folder and be used by all split workspace projects.\n     */\n    static async writeCommonTempSubspaceGlobalPnpmfileAsync(rushConfiguration, subspace, variant) {\n        if (rushConfiguration.packageManager !== 'pnpm') {\n            throw new Error(`PnpmfileConfiguration cannot be used with package manager \"${rushConfiguration.packageManager}\"`);\n        }\n        const targetDir = subspace.getSubspaceTempFolderPath();\n        const subspaceGlobalPnpmfilePath = path.join(targetDir, RushConstants.pnpmfileGlobalFilename);\n        // Write the shim itself\n        await FileSystem.copyFileAsync({\n            sourcePath: `${scriptsFolderPath}/${subspacePnpmfileShimFilename}`,\n            destinationPath: subspaceGlobalPnpmfilePath\n        });\n        const subspaceGlobalPnpmfileShimSettings = SubspacePnpmfileConfiguration.getSubspacePnpmfileShimSettings(rushConfiguration, subspace, variant);\n        // Write the settings file used by the shim\n        await JsonFile.saveAsync(subspaceGlobalPnpmfileShimSettings, path.join(targetDir, 'pnpmfileSettings.json'), {\n            ensureFolderExists: true\n        });\n    }\n    static getSubspacePnpmfileShimSettings(rushConfiguration, subspace, variant) {\n        const workspaceProjects = {};\n        const subspaceProjects = {};\n        const projectNameToInjectedDependenciesMap = SubspacePnpmfileConfiguration._getProjectNameToInjectedDependenciesMap(rushConfiguration, subspace);\n        for (const project of rushConfiguration.projects) {\n            const { packageName, projectRelativeFolder, packageJson } = project;\n            const workspaceProjectInfo = {\n                packageName,\n                projectRelativeFolder,\n                packageVersion: packageJson.version,\n                injectedDependencies: Array.from(projectNameToInjectedDependenciesMap.get(packageName) || [])\n            };\n            (subspace.contains(project) ? subspaceProjects : workspaceProjects)[packageName] = workspaceProjectInfo;\n        }\n        const settings = {\n            workspaceProjects,\n            subspaceProjects,\n            semverPath: Import.resolveModule({ modulePath: 'semver', baseFolderPath: __dirname })\n        };\n        // common/config/subspaces/<subspace_name>/.pnpmfile.cjs\n        const userPnpmfilePath = path.join(subspace.getVariantDependentSubspaceConfigFolderPath(variant), rushConfiguration.packageManagerWrapper.pnpmfileFilename);\n        if (FileSystem.exists(userPnpmfilePath)) {\n            settings.userPnpmfilePath = userPnpmfilePath;\n        }\n        return settings;\n    }\n    static _getProjectNameToInjectedDependenciesMap(rushConfiguration, subspace) {\n        var _a, _b, _c, _d;\n        const projectNameToInjectedDependenciesMap = new Map();\n        const workspaceProjectsMap = new Map();\n        const subspaceProjectsMap = new Map();\n        for (const project of rushConfiguration.projects) {\n            if (subspace.contains(project)) {\n                subspaceProjectsMap.set(project.packageName, project);\n            }\n            else {\n                workspaceProjectsMap.set(project.packageName, project);\n            }\n            projectNameToInjectedDependenciesMap.set(project.packageName, new Set());\n        }\n        const processTransitiveInjectedInstallQueue = [];\n        for (const subspaceProject of subspaceProjectsMap.values()) {\n            const injectedDependencySet = new Set();\n            const dependenciesMeta = subspaceProject.packageJson.dependenciesMeta;\n            if (dependenciesMeta) {\n                for (const [dependencyName, { injected }] of Object.entries(dependenciesMeta)) {\n                    if (injected) {\n                        injectedDependencySet.add(dependencyName);\n                        (_a = projectNameToInjectedDependenciesMap.get(subspaceProject.packageName)) === null || _a === void 0 ? void 0 : _a.add(dependencyName);\n                        //if this dependency is in the same subspace, leave as it is, PNPM will handle it\n                        //if this dependency is in another subspace, then it is transitive injected installation\n                        //so, we need to let all the workspace dependencies along the dependency chain to use injected installation\n                        if (!subspaceProjectsMap.has(dependencyName)) {\n                            processTransitiveInjectedInstallQueue.push(workspaceProjectsMap.get(dependencyName));\n                        }\n                    }\n                }\n            }\n            // if alwaysInjectDependenciesFromOtherSubspaces policy is true in pnpm-config.json\n            // and the dependency is not injected yet\n            // and the dependency is in another subspace\n            // then, make this dependency as injected dependency\n            const pnpmOptions = subspace.getPnpmOptions() || rushConfiguration.pnpmOptions;\n            if (pnpmOptions && pnpmOptions.alwaysInjectDependenciesFromOtherSubspaces) {\n                const dependencyProjects = subspaceProject.dependencyProjects;\n                for (const dependencyProject of dependencyProjects) {\n                    const dependencyName = dependencyProject.packageName;\n                    if (!injectedDependencySet.has(dependencyName) && !subspaceProjectsMap.has(dependencyName)) {\n                        (_b = projectNameToInjectedDependenciesMap.get(subspaceProject.packageName)) === null || _b === void 0 ? void 0 : _b.add(dependencyName);\n                        // process transitive injected installation\n                        processTransitiveInjectedInstallQueue.push(workspaceProjectsMap.get(dependencyName));\n                    }\n                }\n            }\n        }\n        // rewrite all workspace dependencies to injected install all for transitive injected installation case\n        while (processTransitiveInjectedInstallQueue.length > 0) {\n            const currentProject = processTransitiveInjectedInstallQueue.shift();\n            const dependencies = (_c = currentProject === null || currentProject === void 0 ? void 0 : currentProject.packageJson) === null || _c === void 0 ? void 0 : _c.dependencies;\n            const optionalDependencies = (_d = currentProject === null || currentProject === void 0 ? void 0 : currentProject.packageJson) === null || _d === void 0 ? void 0 : _d.optionalDependencies;\n            if (currentProject) {\n                if (dependencies) {\n                    SubspacePnpmfileConfiguration._processDependenciesForTransitiveInjectedInstall(projectNameToInjectedDependenciesMap, processTransitiveInjectedInstallQueue, dependencies, currentProject, rushConfiguration);\n                }\n                if (optionalDependencies) {\n                    SubspacePnpmfileConfiguration._processDependenciesForTransitiveInjectedInstall(projectNameToInjectedDependenciesMap, processTransitiveInjectedInstallQueue, optionalDependencies, currentProject, rushConfiguration);\n                }\n            }\n        }\n        return projectNameToInjectedDependenciesMap;\n    }\n    static _processDependenciesForTransitiveInjectedInstall(projectNameToInjectedDependencies, processTransitiveInjectedInstallQueue, dependencies, currentProject, rushConfiguration) {\n        var _a;\n        for (const dependencyName in dependencies) {\n            if (dependencies[dependencyName].startsWith('workspace:')) {\n                (_a = projectNameToInjectedDependencies.get(currentProject.packageName)) === null || _a === void 0 ? void 0 : _a.add(dependencyName);\n                const nextProject = rushConfiguration.getProjectByName(dependencyName);\n                if (nextProject) {\n                    processTransitiveInjectedInstallQueue.push(nextProject);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=SubspacePnpmfileConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError, Async, FileSystem } from '@rushstack/node-core-library';\nimport { RushConstants } from '../RushConstants';\n/**\n * Ensures the environment where the Rush repo exists is valid\n */\nexport async function validateAsync(rushConfiguration, options) {\n    if (rushConfiguration.experimentsConfiguration.configuration.forbidPhantomResolvableNodeModulesFolders) {\n        const pathParts = rushConfiguration.rushJsonFolder.split(/[\\/\\\\]/);\n        const existingNodeModulesPaths = [];\n        await Async.forEachAsync(pathParts, async (pathPart, index) => {\n            const potentialNodeModulesPath = `${pathParts.slice(0, index + 1).join('/')}/node_modules`;\n            const pathExists = await FileSystem.existsAsync(potentialNodeModulesPath);\n            if (pathExists) {\n                existingNodeModulesPaths.push(potentialNodeModulesPath);\n            }\n        }, { concurrency: 5 });\n        if (existingNodeModulesPaths.length > 0) {\n            const paths = existingNodeModulesPaths.sort().join(', ');\n            let errorMessage = `The following node_modules folders exist in the path to the Rush repo: ${paths}. ` +\n                `This is not supported, and may cause issues.`;\n            if (options.bypassPolicyAllowed) {\n                errorMessage += ` To ignore, use the \"${RushConstants.bypassPolicyFlagLongName}\" flag.`;\n            }\n            // eslint-disable-next-line no-console\n            console.error(errorMessage);\n            throw new AlreadyReportedError();\n        }\n    }\n}\n//# sourceMappingURL=EnvironmentPolicy.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { Utilities } from '../../utilities/Utilities';\nimport { Git } from '../Git';\nimport { RushConstants } from '../RushConstants';\nexport async function validateAsync(rushConfiguration, options) {\n    const git = new Git(rushConfiguration);\n    if (!git.isGitPresent()) {\n        // If Git isn't installed, or this Rush project is not under a Git working folder,\n        // then we don't care about the Git email\n        // eslint-disable-next-line no-console\n        console.log(Colorize.cyan('Ignoring Git validation because the Git binary was not found in the shell path.') + '\\n');\n        return;\n    }\n    if (!git.isPathUnderGitWorkingTree()) {\n        // If Git isn't installed, or this Rush project is not under a Git working folder,\n        // then we don't care about the Git email\n        // eslint-disable-next-line no-console\n        console.log(Colorize.cyan('Ignoring Git validation because this is not a Git working folder.') + '\\n');\n        return;\n    }\n    let userEmail = await git.tryGetGitEmailAsync();\n    // If there isn't a Git policy, then we don't care whether the person configured\n    // a Git email address at all.\n    if (rushConfiguration.gitAllowedEmailRegExps.length === 0) {\n        if (userEmail === undefined) {\n            return;\n        }\n        // Otherwise, if an email *is* configured at all, then we still perform the basic\n        // sanity checks (e.g. no spaces in the address).\n    }\n    try {\n        userEmail = git.validateGitEmail(userEmail);\n        // sanity check; a valid email should not contain any whitespace\n        // if this fails, then we have another issue to report\n        if (!userEmail.match(/^\\S+$/g)) {\n            // eslint-disable-next-line no-console\n            console.log([\n                Colorize.red('Your Git email address is invalid: ' + JSON.stringify(userEmail)),\n                '',\n                `To configure your Git email address, try something like this:`,\n                '',\n                ...getEmailExampleLines(rushConfiguration),\n                ''\n            ].join('\\n'));\n            throw new AlreadyReportedError();\n        }\n    }\n    catch (e) {\n        if (e instanceof AlreadyReportedError) {\n            let errorMessage = 'Aborting, so you can go fix your settings.';\n            if (options.bypassPolicyAllowed) {\n                errorMessage += ` (Or use \"${RushConstants.bypassPolicyFlagLongName}\" to skip.)`;\n            }\n            // eslint-disable-next-line no-console\n            console.log(Colorize.red(errorMessage));\n            throw e;\n        }\n        else {\n            throw e;\n        }\n    }\n    if (rushConfiguration.gitAllowedEmailRegExps.length === 0) {\n        // If there is no policy, then we're good\n        return;\n    }\n    // eslint-disable-next-line no-console\n    console.log('Checking Git policy for this repository.\\n');\n    // If there is a policy, at least one of the RegExp's must match\n    for (const pattern of rushConfiguration.gitAllowedEmailRegExps) {\n        const regex = new RegExp(`^${pattern}$`, 'i');\n        if (userEmail.match(regex)) {\n            return;\n        }\n    }\n    // Show the user's name as well.\n    // Ex. \"Example Name <name@example.com>\"\n    let fancyEmail = Colorize.cyan(userEmail);\n    try {\n        const userName = (await Utilities.executeCommandAndCaptureOutputAsync(git.gitPath, ['config', 'user.name'], '.')).trim();\n        if (userName) {\n            fancyEmail = `${userName} <${fancyEmail}>`;\n        }\n    }\n    catch (e) {\n        // but if it fails, this isn't critical, so don't bother them about it\n    }\n    // eslint-disable-next-line no-console\n    console.log([\n        'Hey there!  To keep things tidy, this repo asks you to submit your Git commits using an email like ' +\n            (rushConfiguration.gitAllowedEmailRegExps.length > 1 ? 'one of these patterns:' : 'this pattern:'),\n        '',\n        ...rushConfiguration.gitAllowedEmailRegExps.map((pattern) => '    ' + Colorize.cyan(pattern)),\n        '',\n        '...but yours is configured like this:',\n        '',\n        `    ${fancyEmail}`,\n        '',\n        'To fix it, you can use commands like this:',\n        '',\n        ...getEmailExampleLines(rushConfiguration),\n        ''\n    ].join('\\n'));\n    let errorMessage = 'Aborting, so you can go fix your settings.';\n    if (options.bypassPolicyAllowed) {\n        errorMessage += ` (Or use \"${RushConstants.bypassPolicyFlagLongName}\" to skip.)`;\n    }\n    // eslint-disable-next-line no-console\n    console.log(Colorize.red(errorMessage));\n    throw new AlreadyReportedError();\n}\nexport function getEmailExampleLines(rushConfiguration) {\n    return [\n        Colorize.cyan('    git config --local user.name \"Example Name\"'),\n        Colorize.cyan(`    git config --local user.email \"${rushConfiguration.gitSampleEmail || 'name@example.com'}\"`)\n    ];\n}\n//# sourceMappingURL=GitEmailPolicy.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as GitEmailPolicy from './GitEmailPolicy';\nimport * as ShrinkwrapFilePolicy from './ShrinkwrapFilePolicy';\nimport * as EnvironmentPolicy from './EnvironmentPolicy';\nexport async function validatePolicyAsync(rushConfiguration, subspace, variant, options) {\n    if (!options.bypassPolicy) {\n        await GitEmailPolicy.validateAsync(rushConfiguration, options);\n        await EnvironmentPolicy.validateAsync(rushConfiguration, options);\n        if (!options.allowShrinkwrapUpdates) {\n            // Don't validate the shrinkwrap if updates are allowed, as it's likely to change\n            // It also may have merge conflict markers, which PNPM can gracefully handle, but the validator cannot\n            ShrinkwrapFilePolicy.validate(rushConfiguration, subspace, variant, options);\n        }\n    }\n}\n//# sourceMappingURL=PolicyValidator.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { ShrinkwrapFileFactory } from '../ShrinkwrapFileFactory';\n/**\n *  A policy that validates shrinkwrap files used by package managers.\n */\nexport function validate(rushConfiguration, subspace, variant, options) {\n    // eslint-disable-next-line no-console\n    console.log('Validating package manager shrinkwrap file.\\n');\n    const shrinkwrapFile = ShrinkwrapFileFactory.getShrinkwrapFile(rushConfiguration.packageManager, subspace.getCommittedShrinkwrapFilePath(variant));\n    if (!shrinkwrapFile) {\n        // eslint-disable-next-line no-console\n        console.log('Shrinkwrap file could not be found, skipping validation.\\n');\n        return;\n    }\n    // Run shrinkwrap-specific validation\n    shrinkwrapFile.validate(rushConfiguration.packageManagerOptions, Object.assign(Object.assign({}, options), { repoState: subspace.getRepoState() }), rushConfiguration.experimentsConfiguration.configuration);\n}\n//# sourceMappingURL=ShrinkwrapFilePolicy.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { ProjectChangeAnalyzer } from '../ProjectChangeAnalyzer';\nexport class GitChangedProjectSelectorParser {\n    constructor(rushConfiguration, options) {\n        this._rushConfiguration = rushConfiguration;\n        this._options = options;\n    }\n    async evaluateSelectorAsync({ unscopedSelector, terminal }) {\n        const projectChangeAnalyzer = new ProjectChangeAnalyzer(this._rushConfiguration);\n        const options = Object.assign({ terminal, targetBranchName: unscopedSelector }, this._options);\n        return await projectChangeAnalyzer.getChangedProjectsAsync(options);\n    }\n    getCompletions() {\n        return [this._rushConfiguration.repositoryDefaultBranch, 'HEAD~1', 'HEAD'];\n    }\n}\n//# sourceMappingURL=GitChangedProjectSelectorParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError, PackageName } from '@rushstack/node-core-library';\nimport { RushConstants } from '../RushConstants';\nexport class NamedProjectSelectorParser {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    async evaluateSelectorAsync({ unscopedSelector, terminal, parameterName }) {\n        const project = this._rushConfiguration.findProjectByShorthandName(unscopedSelector);\n        if (!project) {\n            terminal.writeErrorLine(`The project name \"${unscopedSelector}\" passed to \"${parameterName}\" does not exist in ` +\n                `${RushConstants.rushJsonFilename}.`);\n            throw new AlreadyReportedError();\n        }\n        return [project];\n    }\n    getCompletions() {\n        const unscopedNamesMap = new Map();\n        const scopedNames = new Set();\n        for (const project of this._rushConfiguration.rushConfigurationJson.projects) {\n            scopedNames.add(project.packageName);\n            const unscopedName = PackageName.getUnscopedName(project.packageName);\n            const count = unscopedNamesMap.get(unscopedName) || 0;\n            unscopedNamesMap.set(unscopedName, count + 1);\n        }\n        const unscopedNames = [];\n        for (const [unscopedName, unscopedNameCount] of unscopedNamesMap) {\n            // don't suggest ambiguous unscoped names\n            if (unscopedNameCount === 1 && !scopedNames.has(unscopedName)) {\n                unscopedNames.push(unscopedName);\n            }\n        }\n        return unscopedNames.sort().concat([...scopedNames].sort());\n    }\n}\n//# sourceMappingURL=NamedProjectSelectorParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushConstants } from '../RushConstants';\nexport class SubspaceSelectorParser {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    async evaluateSelectorAsync({ unscopedSelector }) {\n        const subspace = this._rushConfiguration.getSubspace(unscopedSelector);\n        return subspace.getProjects();\n    }\n    getCompletions() {\n        // Tab completion is a performance sensitive operation, so avoid loading all the projects\n        const subspaceNames = [];\n        if (this._rushConfiguration.subspacesConfiguration) {\n            subspaceNames.push(...this._rushConfiguration.subspacesConfiguration.subspaceNames);\n        }\n        if (!subspaceNames.indexOf(RushConstants.defaultSubspaceName)) {\n            subspaceNames.push(RushConstants.defaultSubspaceName);\n        }\n        return subspaceNames;\n    }\n}\n//# sourceMappingURL=SubspaceSelectorParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nimport { RushConstants } from '../RushConstants';\nexport class TagProjectSelectorParser {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    async evaluateSelectorAsync({ unscopedSelector, terminal, parameterName }) {\n        const selection = this._rushConfiguration.projectsByTag.get(unscopedSelector);\n        if (!selection) {\n            terminal.writeErrorLine(`The tag \"${unscopedSelector}\" passed to \"${parameterName}\" is not specified for any projects in ` +\n                `${RushConstants.rushJsonFilename}.`);\n            throw new AlreadyReportedError();\n        }\n        return selection;\n    }\n    getCompletions() {\n        return this._rushConfiguration.projectsByTag.keys();\n    }\n}\n//# sourceMappingURL=TagProjectSelectorParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nexport class VersionPolicyProjectSelectorParser {\n    constructor(rushConfiguration) {\n        this._rushConfiguration = rushConfiguration;\n    }\n    async evaluateSelectorAsync({ unscopedSelector, terminal, parameterName }) {\n        const selection = new Set();\n        if (!this._rushConfiguration.versionPolicyConfiguration.versionPolicies.has(unscopedSelector)) {\n            terminal.writeErrorLine(`The version policy \"${unscopedSelector}\" passed to \"${parameterName}\" does not exist in version-policies.json.`);\n            throw new AlreadyReportedError();\n        }\n        for (const project of this._rushConfiguration.projects) {\n            if (project.versionPolicyName === unscopedSelector) {\n                selection.add(project);\n            }\n        }\n        return selection;\n    }\n    getCompletions() {\n        return this._rushConfiguration.versionPolicyConfiguration.versionPolicies.keys();\n    }\n}\n//# sourceMappingURL=VersionPolicyProjectSelectorParser.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { JsonFile, JsonSchema, FileSystem } from '@rushstack/node-core-library';\nimport schemaJson from '../../schemas/artifactory.schema.json';\n/**\n * Use this class to load the \"common/config/rush/artifactory.json\" config file.\n * It configures the \"rush setup\" command.\n */\nexport class ArtifactoryConfiguration {\n    /**\n     * @internal\n     */\n    constructor(jsonFileName) {\n        this._jsonFileName = jsonFileName;\n        this.configuration = {\n            packageRegistry: {\n                enabled: false,\n                registryUrl: '',\n                artifactoryWebsiteUrl: ''\n            }\n        };\n        if (FileSystem.exists(this._jsonFileName)) {\n            this.configuration = JsonFile.loadAndValidate(this._jsonFileName, ArtifactoryConfiguration._jsonSchema);\n            if (!this.configuration.packageRegistry.credentialType) {\n                this.configuration.packageRegistry.credentialType = 'password';\n            }\n        }\n    }\n}\nArtifactoryConfiguration._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=ArtifactoryConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as readline from 'readline';\nimport * as process from 'process';\nimport { AlreadyReportedError, InternalError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\n// TODO: Integrate these into the AnsiEscape API in @rushstack/terminal\n// As part of that work we should generalize the \"Colorize\" API to support more general\n// terminal escapes, and simplify the interface for that API.\nconst ANSI_ESCAPE_SHOW_CURSOR = '\\u001B[?25l';\nconst ANSI_ESCAPE_HIDE_CURSOR = '\\u001B[?25h';\nexport class KeyboardLoop {\n    constructor() {\n        this._cursorHidden = false;\n        this._onKeypress = (character, key) => {\n            if (key.name === 'c' && key.ctrl && !key.meta && !key.shift) {\n                // Intercept CTRL+C\n                process.kill(process.pid, 'SIGINT');\n                return;\n            }\n            try {\n                this.onKeypress(character, key);\n            }\n            catch (error) {\n                throw new InternalError('Uncaught exception in Prompter.onKeypress(): ' + error.toString());\n            }\n        };\n        this.stdin = process.stdin;\n        this.stderr = process.stderr;\n    }\n    get capturedInput() {\n        return this._readlineInterface !== undefined;\n    }\n    _captureInput() {\n        if (this._readlineInterface) {\n            return;\n        }\n        this._checkForTTY();\n        this._readlineInterface = readline.createInterface({ input: this.stdin });\n        readline.emitKeypressEvents(process.stdin);\n        this.stdin.setRawMode(true);\n        this.stdin.addListener('keypress', this._onKeypress);\n    }\n    _checkForTTY() {\n        var _a;\n        // Typescript thinks setRawMode always extists, but we're testing that assumption here.\n        if (this.stdin.isTTY && this.stdin.setRawMode) {\n            return;\n        }\n        if (process.platform === 'win32') {\n            const shell = (_a = process.env.SHELL) !== null && _a !== void 0 ? _a : '';\n            if (shell.toUpperCase().endsWith('BASH.EXE')) {\n                // Git Bash has a known problem where the Node.js TTY is lost when invoked via an NPM binary script.\n                // eslint-disable-next-line no-console\n                console.error(Colorize.red('ERROR: It appears that Rush was invoked from Git Bash shell, which does not support the\\n' +\n                    'TTY mode for interactive input that is required by this feature.') +\n                    '\\n\\nKnown workarounds are:\\n' +\n                    '- Invoke Rush using \"winpty rush.cmd\" instead of \"rush\"\\n' +\n                    '- Or add this to your .bashrc:  alias rush=\"winpty rush.cmd\"\\n' +\n                    '- Or create a Git Bash shortcut icon that launches\\n' +\n                    '  \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\" instead of \"git-bash.exe\"\\n\\n' +\n                    'For details, refer to https://github.com/microsoft/rushstack/issues/3217');\n                throw new AlreadyReportedError();\n            }\n        }\n        // eslint-disable-next-line no-console\n        console.error(Colorize.red('ERROR: Rush was invoked by a command whose STDIN does not support the TTY mode for\\n' +\n            'interactive input that is required by this feature.') + '\\n\\nTry invoking \"rush\" directly from your shell.');\n        throw new AlreadyReportedError();\n    }\n    _uncaptureInput() {\n        if (!this._readlineInterface) {\n            return;\n        }\n        this.stdin.removeListener('keypress', this._onKeypress);\n        this.stdin.setRawMode(false);\n        this._readlineInterface.close();\n        this._readlineInterface = undefined;\n    }\n    hideCursor() {\n        if (this._cursorHidden) {\n            return;\n        }\n        this._cursorHidden = true;\n        this.stderr.write(ANSI_ESCAPE_SHOW_CURSOR);\n    }\n    unhideCursor() {\n        if (!this._cursorHidden) {\n            return;\n        }\n        this._cursorHidden = false;\n        this.stderr.write(ANSI_ESCAPE_HIDE_CURSOR);\n    }\n    async startAsync() {\n        try {\n            this._captureInput();\n            this.onStart();\n            await new Promise((resolve, reject) => {\n                this._resolvePromise = resolve;\n                this._rejectPromise = reject;\n            });\n        }\n        finally {\n            this._uncaptureInput();\n            this.unhideCursor();\n        }\n    }\n    resolveAsync() {\n        if (!this._resolvePromise) {\n            return;\n        }\n        this._resolvePromise();\n        this._resolvePromise = undefined;\n        this._rejectPromise = undefined;\n    }\n    rejectAsync(error) {\n        if (!this._rejectPromise) {\n            return;\n        }\n        this._rejectPromise(error);\n        this._resolvePromise = undefined;\n        this._rejectPromise = undefined;\n    }\n    /** @virtual */\n    onStart() { }\n    /** @virtual */\n    onKeypress(character, key) { }\n}\n//# sourceMappingURL=KeyboardLoop.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { AlreadyReportedError, Executable, FileSystem, InternalError, NewlineKind, Text } from '@rushstack/node-core-library';\nimport { PrintUtilities, Colorize, ConsoleTerminalProvider, Terminal } from '@rushstack/terminal';\nimport { Utilities } from '../../utilities/Utilities';\nimport { ArtifactoryConfiguration } from './ArtifactoryConfiguration';\nimport { TerminalInput } from './TerminalInput';\nconst defaultMessages = {\n    introduction: 'This monorepo consumes packages from an Artifactory private NPM registry.',\n    obtainAnAccount: 'Please contact the repository maintainers for help with setting up an Artifactory user account.',\n    visitWebsite: 'Please open this URL in your web browser:',\n    locateUserName: 'Your user name appears in the upper-right corner of the JFrog website.',\n    locateApiKey: 'Click \"Edit Profile\" on the JFrog website.  Click the \"Generate API Key\"' +\n        \" button if you haven't already done so previously.\",\n    userNamePrompt: 'What is your Artifactory user name?',\n    apiKeyPrompt: 'What is your Artifactory API key?'\n};\nexport class SetupPackageRegistry {\n    constructor(options) {\n        this._options = options;\n        this.rushConfiguration = options.rushConfiguration;\n        this._terminal = new Terminal(new ConsoleTerminalProvider({\n            verboseEnabled: options.isDebug\n        }));\n        this._artifactoryConfiguration = new ArtifactoryConfiguration(path.join(this.rushConfiguration.commonRushConfigFolder, 'artifactory.json'));\n        this._messages = Object.assign(Object.assign({}, defaultMessages), this._artifactoryConfiguration.configuration.packageRegistry.messageOverrides);\n    }\n    _writeInstructionBlock(message) {\n        if (message === '') {\n            return;\n        }\n        this._terminal.writeLine(PrintUtilities.wrapWords(message));\n        this._terminal.writeLine();\n    }\n    /**\n     * Test whether the NPM token is valid.\n     *\n     * @returns - `true` if valid, `false` if not valid\n     */\n    async checkOnlyAsync() {\n        var _a;\n        const packageRegistry = this._artifactoryConfiguration.configuration.packageRegistry;\n        if (!packageRegistry.enabled) {\n            this._terminal.writeVerbose('Skipping package registry setup because packageRegistry.enabled=false');\n            return true;\n        }\n        const registryUrl = ((packageRegistry === null || packageRegistry === void 0 ? void 0 : packageRegistry.registryUrl) || '').trim();\n        if (registryUrl.length === 0) {\n            throw new Error('The \"registryUrl\" setting in artifactory.json is missing or empty');\n        }\n        if (!this._options.syncNpmrcAlreadyCalled) {\n            Utilities.syncNpmrc({\n                sourceNpmrcFolder: this.rushConfiguration.commonRushConfigFolder,\n                targetNpmrcFolder: this.rushConfiguration.commonTempFolder,\n                supportEnvVarFallbackSyntax: this.rushConfiguration.isPnpm\n            });\n        }\n        // Artifactory does not implement the \"npm ping\" protocol or any equivalent REST API.\n        // But if we query a package that is known not to exist, Artifactory will only return\n        // a 404 error if it is successfully authenticated.  We can use this negative query\n        // to validate the credentials.\n        const npmArgs = [\n            'view',\n            '@rushstack/nonexistent-package',\n            '--json',\n            '--registry=' + packageRegistry.registryUrl\n        ];\n        this._terminal.writeLine('Testing access to private NPM registry: ' + packageRegistry.registryUrl);\n        const result = Executable.spawnSync('npm', npmArgs, {\n            currentWorkingDirectory: this.rushConfiguration.commonTempFolder,\n            stdio: ['ignore', 'pipe', 'pipe'],\n            // Wait at most 10 seconds for \"npm view\" to succeed\n            timeoutMs: 10 * 1000\n        });\n        this._terminal.writeLine();\n        // (This is not exactly correct, for example Node.js puts a string in error.errno instead of a string.)\n        const error = result.error;\n        if (error) {\n            if (error.code === 'ETIMEDOUT') {\n                // For example, an incorrect \"https-proxy\" setting can hang for a long time\n                throw new Error('The \"npm view\" command timed out; check your .npmrc file for an incorrect setting');\n            }\n            throw new Error('Error invoking \"npm view\": ' + result.error);\n        }\n        if (result.status === 0) {\n            throw new InternalError('\"npm view\" unexpectedly succeeded');\n        }\n        // NPM 6.x writes to stdout\n        let jsonContent = SetupPackageRegistry._tryFindJson(result.stdout);\n        if (jsonContent === undefined) {\n            // NPM 7.x writes dirty output to stderr; see https://github.com/npm/cli/issues/2740\n            jsonContent = SetupPackageRegistry._tryFindJson(result.stderr);\n        }\n        if (jsonContent === undefined) {\n            throw new InternalError('The \"npm view\" command did not return a JSON structure');\n        }\n        let jsonOutput;\n        try {\n            jsonOutput = JSON.parse(jsonContent);\n        }\n        catch (e) {\n            this._terminal.writeVerboseLine('NPM response:\\n\\n--------\\n' + jsonContent + '\\n--------\\n\\n');\n            throw new InternalError('The \"npm view\" command returned an invalid JSON structure');\n        }\n        const errorCode = (_a = jsonOutput === null || jsonOutput === void 0 ? void 0 : jsonOutput.error) === null || _a === void 0 ? void 0 : _a.code;\n        if (typeof errorCode !== 'string') {\n            this._terminal.writeVerboseLine('NPM response:\\n' + JSON.stringify(jsonOutput, undefined, 2) + '\\n\\n');\n            throw new InternalError('The \"npm view\" command returned unexpected output');\n        }\n        switch (errorCode) {\n            case 'E404':\n                this._terminal.writeLine('NPM credentials are working');\n                this._terminal.writeLine();\n                return true;\n            case 'E401':\n            case 'E403':\n                this._terminal.writeVerboseLine('NPM response:\\n' + JSON.stringify(jsonOutput, undefined, 2) + '\\n\\n');\n                // Credentials are missing or expired\n                return false;\n            default:\n                this._terminal.writeVerboseLine('NPM response:\\n' + JSON.stringify(jsonOutput, undefined, 2) + '\\n\\n');\n                throw new Error(`The \"npm view\" command returned an unexpected error code \"${errorCode}\"`);\n        }\n    }\n    /**\n     * Test whether the NPM token is valid.  If not, prompt to update it.\n     */\n    async checkAndSetupAsync() {\n        if (await this.checkOnlyAsync()) {\n            return;\n        }\n        this._terminal.writeWarningLine('NPM credentials are missing or expired');\n        this._terminal.writeLine();\n        const packageRegistry = this._artifactoryConfiguration.configuration.packageRegistry;\n        const fixThisProblem = await TerminalInput.promptYesNoAsync({\n            message: 'Fix this problem now?',\n            defaultValue: false\n        });\n        this._terminal.writeLine();\n        if (!fixThisProblem) {\n            return;\n        }\n        this._writeInstructionBlock(this._messages.introduction);\n        const hasArtifactoryAccount = await TerminalInput.promptYesNoAsync({\n            message: 'Do you already have an Artifactory user account?'\n        });\n        this._terminal.writeLine();\n        if (!hasArtifactoryAccount) {\n            this._writeInstructionBlock(this._messages.obtainAnAccount);\n            throw new AlreadyReportedError();\n        }\n        if (this._messages.visitWebsite) {\n            this._writeInstructionBlock(this._messages.visitWebsite);\n            const artifactoryWebsiteUrl = this._artifactoryConfiguration.configuration.packageRegistry.artifactoryWebsiteUrl;\n            if (artifactoryWebsiteUrl) {\n                this._terminal.writeLine('  ', Colorize.cyan(artifactoryWebsiteUrl));\n                this._terminal.writeLine();\n            }\n        }\n        this._writeInstructionBlock(this._messages.locateUserName);\n        let artifactoryUser = await TerminalInput.promptLineAsync({\n            message: this._messages.userNamePrompt\n        });\n        this._terminal.writeLine();\n        artifactoryUser = artifactoryUser.trim();\n        if (artifactoryUser.length === 0) {\n            this._terminal.writeLine(Colorize.red('Operation aborted because the input was empty'));\n            this._terminal.writeLine();\n            throw new AlreadyReportedError();\n        }\n        this._writeInstructionBlock(this._messages.locateApiKey);\n        let artifactoryKey = await TerminalInput.promptPasswordLineAsync({\n            message: this._messages.apiKeyPrompt\n        });\n        this._terminal.writeLine();\n        artifactoryKey = artifactoryKey.trim();\n        if (artifactoryKey.length === 0) {\n            this._terminal.writeLine(Colorize.red('Operation aborted because the input was empty'));\n            this._terminal.writeLine();\n            throw new AlreadyReportedError();\n        }\n        await this._fetchTokenAndUpdateNpmrcAsync(artifactoryUser, artifactoryKey, packageRegistry);\n    }\n    /**\n     * Fetch a valid NPM token from the Artifactory service and add it to the `~/.npmrc` file,\n     * preserving other settings in that file.\n     */\n    async _fetchTokenAndUpdateNpmrcAsync(artifactoryUser, artifactoryKey, packageRegistry) {\n        this._terminal.writeLine('\\nFetching an NPM token from the Artifactory service...');\n        // Defer this import since it is conditionally needed.\n        const { WebClient } = await import('../../utilities/WebClient');\n        const webClient = new WebClient();\n        webClient.addBasicAuthHeader(artifactoryUser, artifactoryKey);\n        let queryUrl = packageRegistry.registryUrl;\n        if (!queryUrl.endsWith('/')) {\n            queryUrl += '/';\n        }\n        // There doesn't seem to be a way to invoke the \"/auth\" REST endpoint without a resource name.\n        // Artifactory's NPM folders always seem to contain a \".npm\" folder, so we can use that to obtain\n        // our token.\n        queryUrl += `auth/.npm`;\n        let response;\n        try {\n            response = await webClient.fetchAsync(queryUrl);\n        }\n        catch (e) {\n            // eslint-disable-next-line no-console\n            console.log(e.toString());\n            return;\n        }\n        if (!response.ok) {\n            if (response.status === 401) {\n                throw new Error('Authorization failed; the Artifactory user name or API key may be incorrect.');\n            }\n            throw new Error(`The Artifactory request failed:\\n  (${response.status}) ${response.statusText}`);\n        }\n        // We expect a response like this:\n        //\n        //   @.npm:registry=https://your-company.jfrog.io/your-artifacts/api/npm/npm-private/\n        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:_password=dGhlIHRva2VuIGdvZXMgaGVyZQ==\n        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:username=your.name@your-company.com\n        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:email=your.name@your-company.com\n        //   //your-company.jfrog.io/your-artifacts/api/npm/npm-private/:always-auth=true\n        const responseText = await response.getTextAsync();\n        const responseLines = Text.convertToLf(responseText).trim().split('\\n');\n        if (responseLines.length < 2 || !responseLines[0].startsWith('@.npm:')) {\n            throw new Error('Unexpected response from Artifactory');\n        }\n        responseLines.shift(); // Remove the @.npm line\n        // If we are configured to use authToken for authentication, we still go through the above process\n        // (both to ensure the user's credentials are valid, and to let Artifactory format the standard\n        // npmrc boilerplate for us), but we'll discard the generated password and use the authToken instead.\n        if (packageRegistry.credentialType === 'authToken') {\n            for (let i = 0; i < responseLines.length; i++) {\n                responseLines[i] = responseLines[i].replace(/_password=.+/, '_authToken=' + artifactoryKey);\n            }\n        }\n        // These are the lines to be injected in ~/.npmrc\n        const linesToAdd = [];\n        // Start with userNpmrcLinesToAdd...\n        if (packageRegistry.userNpmrcLinesToAdd) {\n            linesToAdd.push(...packageRegistry.userNpmrcLinesToAdd);\n        }\n        // ...then append the stuff we got from the REST API, but discard any junk that isn't a proper key/value\n        linesToAdd.push(...responseLines.filter((x) => SetupPackageRegistry._getNpmrcKey(x) !== undefined));\n        const npmrcPath = path.join(Utilities.getHomeFolder(), '.npmrc');\n        this._mergeLinesIntoNpmrc(npmrcPath, linesToAdd);\n    }\n    /**\n     * Update the `~/.npmrc` file by adding `linesToAdd` to it.\n     * @remarks\n     *\n     * If the `.npmrc` file has existing content, it gets merged as follows:\n     * - If `linesToAdd` contains key/value pairs and the key already appears in .npmrc,\n     *   that line will be overwritten in place\n     * - If `linesToAdd` contains non-key lines (e.g. a comment) and it exactly matches a\n     *   line in .npmrc, then that line will be kept where it is\n     * - The remaining `linesToAdd` that weren't handled by one of the two rules above\n     *   are simply appended to the end of the file\n     * - Under no circumstances is a duplicate key/value added to the file; in the case of\n     *   duplicates, the earliest line in `linesToAdd` takes precedence\n     */\n    _mergeLinesIntoNpmrc(npmrcPath, linesToAdd) {\n        // We'll replace entries with \"undefined\" if they get discarded\n        const workingLinesToAdd = [...linesToAdd];\n        // Now build a table of .npmrc keys that can be replaced if they already exist in the file.\n        // For example, if we are adding \"always-auth=false\" then we should delete an existing line\n        // that says \"always-auth=true\".\n        const keysToReplace = new Map(); // key --> linesToAdd index\n        for (let index = 0; index < workingLinesToAdd.length; ++index) {\n            const lineToAdd = workingLinesToAdd[index];\n            const key = SetupPackageRegistry._getNpmrcKey(lineToAdd);\n            if (key !== undefined) {\n                // If there are duplicate keys, the first one takes precedence.\n                // In particular this means \"userNpmrcLinesToAdd\" takes precedence over the REST API response\n                if (keysToReplace.has(key)) {\n                    // Discard the duplicate key\n                    workingLinesToAdd[index] = undefined;\n                }\n                else {\n                    keysToReplace.set(key, index);\n                }\n            }\n        }\n        this._terminal.writeLine();\n        this._terminal.writeLine(Colorize.green('Adding Artifactory token to: '), npmrcPath);\n        const npmrcLines = [];\n        if (FileSystem.exists(npmrcPath)) {\n            const npmrcContent = FileSystem.readFile(npmrcPath, { convertLineEndings: NewlineKind.Lf });\n            npmrcLines.push(...npmrcContent.trimRight().split('\\n'));\n        }\n        if (npmrcLines.length === 1 && npmrcLines[0] === '') {\n            // Edge case where split() adds a blank line to the start of the file\n            npmrcLines.length = 0;\n        }\n        // Make a set of existing .npmrc lines that are not key/value pairs.\n        const npmrcNonKeyLinesSet = new Set();\n        for (const npmrcLine of npmrcLines) {\n            const trimmed = npmrcLine.trim();\n            if (trimmed.length > 0) {\n                if (SetupPackageRegistry._getNpmrcKey(trimmed) === undefined) {\n                    npmrcNonKeyLinesSet.add(trimmed);\n                }\n            }\n        }\n        // Overwrite any existing lines that match a key from \"linesToAdd\"\n        for (let index = 0; index < npmrcLines.length; ++index) {\n            const line = npmrcLines[index];\n            const key = SetupPackageRegistry._getNpmrcKey(line);\n            if (key) {\n                const linesToAddIndex = keysToReplace.get(key);\n                if (linesToAddIndex !== undefined) {\n                    npmrcLines[index] = workingLinesToAdd[linesToAddIndex] || '';\n                    // Delete it since it's been replaced\n                    keysToReplace.delete(key);\n                    // Also remove it from \"linesToAdd\"\n                    workingLinesToAdd[linesToAddIndex] = undefined;\n                }\n            }\n        }\n        if (npmrcLines.length > 0 && npmrcLines[npmrcLines.length - 1] !== '') {\n            // Append a blank line\n            npmrcLines.push('');\n        }\n        // Add any remaining values that weren't matched above\n        for (const lineToAdd of workingLinesToAdd) {\n            // If a line is undefined, that means we already used it to replace an existing line above\n            if (lineToAdd !== undefined) {\n                // If a line belongs to npmrcNonKeyLinesSet, then we should not add it because it's\n                // already in the .npmrc file\n                if (!npmrcNonKeyLinesSet.has(lineToAdd.trim())) {\n                    npmrcLines.push(lineToAdd);\n                }\n            }\n        }\n        // Save the result\n        FileSystem.writeFile(npmrcPath, npmrcLines.join('\\n').trimRight() + '\\n');\n    }\n    static _getNpmrcKey(npmrcLine) {\n        if (SetupPackageRegistry._isCommentLine(npmrcLine)) {\n            return undefined;\n        }\n        const delimiterIndex = npmrcLine.indexOf('=');\n        if (delimiterIndex < 1) {\n            return undefined;\n        }\n        const key = npmrcLine.substring(0, delimiterIndex + 1);\n        return key.trim();\n    }\n    static _isCommentLine(npmrcLine) {\n        return /^\\s*#/.test(npmrcLine);\n    }\n    /**\n     * This is a workaround for https://github.com/npm/cli/issues/2740 where the NPM tool sometimes\n     * mixes together JSON and terminal messages in a single STDERR stream.\n     *\n     * @remarks\n     * Given an input like this:\n     * ```\n     * npm ERR! 404 Note that you can also install from a\n     * npm ERR! 404 tarball, folder, http url, or git url.\n     * {\n     *   \"error\": {\n     *     \"code\": \"E404\",\n     *     \"summary\": \"Not Found - GET https://registry.npmjs.org/@rushstack%2fnonexistent-package - Not found\"\n     *   }\n     * }\n     * npm ERR! A complete log of this run can be found in:\n     * ```\n     *\n     * @returns the JSON section, or `undefined` if a JSON object could not be detected\n     */\n    static _tryFindJson(dirtyOutput) {\n        const lines = Text.splitByNewLines(dirtyOutput);\n        let startIndex;\n        let endIndex;\n        // Find the first line that starts with \"{\"\n        for (let i = 0; i < lines.length; ++i) {\n            const line = lines[i];\n            if (/^\\s*\\{/.test(line)) {\n                startIndex = i;\n                break;\n            }\n        }\n        if (startIndex === undefined) {\n            return undefined;\n        }\n        // Find the last line that ends with \"}\"\n        for (let i = lines.length - 1; i >= startIndex; --i) {\n            const line = lines[i];\n            if (/\\}\\s*$/.test(line)) {\n                endIndex = i;\n                break;\n            }\n        }\n        if (endIndex === undefined) {\n            return undefined;\n        }\n        return lines.slice(startIndex, endIndex + 1).join('\\n');\n    }\n}\n//# sourceMappingURL=SetupPackageRegistry.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as readline from 'readline';\nimport * as process from 'process';\nimport { AnsiEscape, Colorize } from '@rushstack/terminal';\nimport { KeyboardLoop } from './KeyboardLoop';\nclass YesNoKeyboardLoop extends KeyboardLoop {\n    constructor(options) {\n        super();\n        this.result = undefined;\n        this.options = options;\n    }\n    onStart() {\n        this.stderr.write(Colorize.green('==>') + ' ');\n        this.stderr.write(Colorize.bold(this.options.message));\n        let optionSuffix = '';\n        switch (this.options.defaultValue) {\n            case true:\n                optionSuffix = '(Y/n)';\n                break;\n            case false:\n                optionSuffix = '(y/N)';\n                break;\n            default:\n                optionSuffix = '(y/n)';\n                break;\n        }\n        this.stderr.write(' ' + Colorize.bold(optionSuffix) + ' ');\n    }\n    onKeypress(character, key) {\n        if (this.result !== undefined) {\n            return;\n        }\n        switch (key.name) {\n            case 'y':\n                this.result = true;\n                break;\n            case 'n':\n                this.result = false;\n                break;\n            case 'enter':\n            case 'return':\n                if (this.options.defaultValue !== undefined) {\n                    this.result = this.options.defaultValue;\n                }\n                break;\n        }\n        if (this.result !== undefined) {\n            this.stderr.write(this.result ? 'Yes\\n' : 'No\\n');\n            this.resolveAsync();\n            return;\n        }\n    }\n}\nclass PasswordKeyboardLoop extends KeyboardLoop {\n    constructor(options) {\n        super();\n        this._startX = 0;\n        this._printedY = 0;\n        this._lastPrintedLength = 0;\n        this.result = '';\n        this._options = options;\n        this._passwordCharacter =\n            this._options.passwordCharacter === undefined ? '*' : this._options.passwordCharacter.substr(0, 1);\n    }\n    _getLineWrapWidth() {\n        return this.stderr.columns ? this.stderr.columns : 80;\n    }\n    onStart() {\n        this.result = '';\n        readline.cursorTo(this.stderr, 0);\n        readline.clearLine(this.stderr, 1);\n        const prefix = Colorize.green('==>') + ' ' + Colorize.bold(this._options.message) + ' ';\n        this.stderr.write(prefix);\n        let lineStartIndex = prefix.lastIndexOf('\\n');\n        if (lineStartIndex < 0) {\n            lineStartIndex = 0;\n        }\n        const line = prefix.substring(lineStartIndex);\n        this._startX = AnsiEscape.removeCodes(line).length % this._getLineWrapWidth();\n    }\n    onKeypress(character, key) {\n        switch (key.name) {\n            case 'enter':\n            case 'return':\n                if (this._passwordCharacter !== '') {\n                    // To avoid disclosing the length of the password, after the user presses ENTER,\n                    // replace the \"*********\" sequence with exactly three stars (\"***\").\n                    this._render(this._passwordCharacter.repeat(3));\n                }\n                this.stderr.write('\\n');\n                this.resolveAsync();\n                return;\n            case 'backspace':\n                this.result = this.result.substring(0, this.result.length - 1);\n                this._render(this.result);\n                break;\n            default:\n                let printable = true;\n                if (character === '') {\n                    printable = false;\n                }\n                else if (key.name && key.name.length !== 1 && key.name !== 'space') {\n                    printable = false;\n                }\n                else if (!key.name && !key.sequence) {\n                    printable = false;\n                }\n                if (printable) {\n                    this.result += character;\n                    this._render(this.result);\n                }\n        }\n    }\n    _render(text) {\n        // Optimize rendering when we don't need to erase anything\n        const needsClear = text.length < this._lastPrintedLength;\n        this._lastPrintedLength = text.length;\n        this.hideCursor();\n        // Restore Y\n        while (this._printedY > 0) {\n            readline.cursorTo(this.stderr, 0);\n            if (needsClear) {\n                readline.clearLine(this.stderr, 1);\n            }\n            readline.moveCursor(this.stderr, 0, -1);\n            --this._printedY;\n        }\n        // Restore X\n        readline.cursorTo(this.stderr, this._startX);\n        let i = 0;\n        let column = this._startX;\n        this._printedY = 0;\n        let buffer = '';\n        while (i < text.length) {\n            if (this._passwordCharacter === '') {\n                buffer += text.substr(i, 1);\n            }\n            else {\n                buffer += this._passwordCharacter;\n            }\n            ++i;\n            ++column;\n            // -1 to avoid weird TTY behavior in final column\n            if (column >= this._getLineWrapWidth() - 1) {\n                column = 0;\n                ++this._printedY;\n                buffer += '\\n';\n            }\n        }\n        this.stderr.write(buffer);\n        if (needsClear) {\n            readline.clearLine(this.stderr, 1);\n        }\n        this.unhideCursor();\n    }\n}\nexport class TerminalInput {\n    static async _readLineAsync() {\n        const readlineInterface = readline.createInterface({ input: process.stdin });\n        try {\n            return await new Promise((resolve, reject) => {\n                readlineInterface.question('', (answer) => {\n                    resolve(answer);\n                });\n            });\n        }\n        finally {\n            readlineInterface.close();\n        }\n    }\n    static async promptYesNoAsync(options) {\n        const keyboardLoop = new YesNoKeyboardLoop(options);\n        await keyboardLoop.startAsync();\n        return keyboardLoop.result;\n    }\n    static async promptLineAsync(options) {\n        const stderr = process.stderr;\n        stderr.write(Colorize.green('==>') + ' ');\n        stderr.write(Colorize.bold(options.message));\n        stderr.write(' ');\n        return await TerminalInput._readLineAsync();\n    }\n    static async promptPasswordLineAsync(options) {\n        const keyboardLoop = new PasswordKeyboardLoop(options);\n        await keyboardLoop.startAsync();\n        return keyboardLoop.result;\n    }\n}\n//# sourceMappingURL=TerminalInput.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { DependencyType } from '../../api/PackageJsonEditor';\nimport { VersionMismatchFinderProject } from './VersionMismatchFinderProject';\nimport { VersionMismatchFinderCommonVersions } from './VersionMismatchFinderCommonVersions';\nimport { CustomTipId } from '../../api/CustomTipsConfiguration';\nconst TRUNCATE_AFTER_PACKAGE_NAME_COUNT = 5;\nexport class VersionMismatchFinder {\n    constructor(projects, allowedAlternativeVersions) {\n        this._projects = projects;\n        this._mismatches = new Map();\n        this._allowedAlternativeVersion = allowedAlternativeVersions || new Map();\n        this._analyze();\n    }\n    static rushCheck(rushConfiguration, terminal, options) {\n        const { variant, subspace = rushConfiguration.defaultSubspace, printAsJson, truncateLongPackageNameLists } = options !== null && options !== void 0 ? options : {};\n        VersionMismatchFinder._checkForInconsistentVersions(rushConfiguration, {\n            variant,\n            subspace,\n            printAsJson,\n            truncateLongPackageNameLists,\n            terminal,\n            isRushCheckCommand: true\n        });\n    }\n    static ensureConsistentVersions(rushConfiguration, terminal, options) {\n        const { variant, subspace = rushConfiguration.defaultSubspace } = options !== null && options !== void 0 ? options : {};\n        VersionMismatchFinder._checkForInconsistentVersions(rushConfiguration, {\n            subspace,\n            variant,\n            terminal,\n            isRushCheckCommand: false,\n            truncateLongPackageNameLists: true\n        });\n    }\n    /**\n     * Populates a version mismatch finder object given a Rush Configuration.\n     * Intentionally considers preferred versions.\n     */\n    static getMismatches(rushConfiguration, options) {\n        const { subspace = rushConfiguration.defaultSubspace, variant } = options !== null && options !== void 0 ? options : {};\n        const commonVersions = subspace.getCommonVersions(variant);\n        const projects = [];\n        // Create an object for the purposes of reporting conflicts with preferredVersions from common-versions.json\n        // Make sure this one is first so it doesn't get truncated when a long list is printed\n        projects.push(new VersionMismatchFinderCommonVersions(commonVersions));\n        // If subspace is specified, only go through projects in that subspace\n        for (const project of subspace.getProjects()) {\n            projects.push(new VersionMismatchFinderProject(project));\n        }\n        return new VersionMismatchFinder(projects, commonVersions.allowedAlternativeVersions);\n    }\n    static _checkForInconsistentVersions(rushConfiguration, options) {\n        const { variant, isRushCheckCommand, printAsJson, subspace, truncateLongPackageNameLists, terminal } = options;\n        if (subspace.shouldEnsureConsistentVersions(variant) || isRushCheckCommand) {\n            const mismatchFinder = VersionMismatchFinder.getMismatches(rushConfiguration, options);\n            if (printAsJson) {\n                mismatchFinder.printAsJson();\n            }\n            else {\n                mismatchFinder.print(truncateLongPackageNameLists);\n                if (mismatchFinder.numberOfMismatches > 0) {\n                    // eslint-disable-next-line no-console\n                    console.log(Colorize.red(`Found ${mismatchFinder.numberOfMismatches} mis-matching dependencies ${(subspace === null || subspace === void 0 ? void 0 : subspace.subspaceName) ? `in subspace: ${subspace === null || subspace === void 0 ? void 0 : subspace.subspaceName}` : ''}`));\n                    rushConfiguration.customTipsConfiguration._showErrorTip(terminal, CustomTipId.TIP_RUSH_INCONSISTENT_VERSIONS);\n                    if (!isRushCheckCommand && truncateLongPackageNameLists) {\n                        // There isn't a --verbose flag in `rush install`/`rush update`, so a long list will always be truncated.\n                        // eslint-disable-next-line no-console\n                        console.log('For more detailed reporting about these version mismatches, use the \"rush check --verbose\" command.');\n                    }\n                    throw new AlreadyReportedError();\n                }\n                else {\n                    if (isRushCheckCommand) {\n                        // eslint-disable-next-line no-console\n                        console.log(Colorize.green(`Found no mis-matching dependencies!`));\n                    }\n                }\n            }\n        }\n    }\n    get mismatches() {\n        return this._mismatches;\n    }\n    get numberOfMismatches() {\n        return this._mismatches.size;\n    }\n    getMismatches() {\n        return this._getKeys(this._mismatches);\n    }\n    getVersionsOfMismatch(mismatch) {\n        return this._mismatches.has(mismatch) ? this._getKeys(this._mismatches.get(mismatch)) : undefined;\n    }\n    getConsumersOfMismatch(mismatch, version) {\n        const mismatchedPackage = this._mismatches.get(mismatch);\n        if (!mismatchedPackage) {\n            return undefined;\n        }\n        const mismatchedVersion = mismatchedPackage.get(version);\n        return mismatchedVersion;\n    }\n    printAsJson() {\n        const mismatchDependencies = [];\n        this.getMismatches().forEach((dependency) => {\n            const mismatchDependencyVersionArray = [];\n            this.getVersionsOfMismatch(dependency).forEach((version) => {\n                const projects = [];\n                this.getConsumersOfMismatch(dependency, version).forEach((project) => {\n                    projects.push(project.friendlyName);\n                });\n                const mismatchDependencyVersion = {\n                    version: version,\n                    projects: projects\n                };\n                mismatchDependencyVersionArray.push(mismatchDependencyVersion);\n            });\n            const mismatchDependency = {\n                dependencyName: dependency,\n                versions: mismatchDependencyVersionArray\n            };\n            mismatchDependencies.push(mismatchDependency);\n        });\n        const output = {\n            mismatchedVersions: mismatchDependencies\n        };\n        // eslint-disable-next-line no-console\n        console.log(JSON.stringify(output, undefined, 2));\n    }\n    print(truncateLongPackageNameLists = false) {\n        // Iterate over the list. For any dependency with mismatching versions, print the projects\n        this.getMismatches().forEach((dependency) => {\n            // eslint-disable-next-line no-console\n            console.log(Colorize.yellow(dependency));\n            this.getVersionsOfMismatch(dependency).forEach((version) => {\n                // eslint-disable-next-line no-console\n                console.log(`  ${version}`);\n                const consumersOfMismatch = this.getConsumersOfMismatch(dependency, version);\n                let numberToPrint = truncateLongPackageNameLists\n                    ? TRUNCATE_AFTER_PACKAGE_NAME_COUNT\n                    : consumersOfMismatch.length;\n                let numberRemaining = consumersOfMismatch.length;\n                for (const { friendlyName } of consumersOfMismatch) {\n                    if (numberToPrint-- === 0) {\n                        break;\n                    }\n                    numberRemaining--;\n                    // eslint-disable-next-line no-console\n                    console.log(`   - ${friendlyName}`);\n                }\n                if (numberRemaining > 0) {\n                    // eslint-disable-next-line no-console\n                    console.log(`   (and ${numberRemaining} others)`);\n                }\n            });\n            // eslint-disable-next-line no-console\n            console.log();\n        });\n    }\n    _analyze() {\n        this._projects.forEach((project) => {\n            if (!project.skipRushCheck) {\n                // NOTE: We do not consider peer dependencies here.  The purpose of \"rush check\" is\n                // mainly to avoid side-by-side duplicates in the node_modules folder, whereas\n                // peer dependencies are just a compatibility statement that will be satisfied by a\n                // regular dependency.  (It might be useful for Rush to help people keep their peer dependency\n                // patterns consistent, but on the other hand different projects may have different\n                // levels of compatibility -- we should wait for someone to actually request this feature\n                // before we get into that.)\n                project.allDependencies.forEach((dependency) => {\n                    if (dependency.dependencyType !== DependencyType.Peer) {\n                        const version = dependency.version;\n                        const isCyclic = project.decoupledLocalDependencies.has(dependency.name);\n                        if (this._isVersionAllowedAlternative(dependency.name, version)) {\n                            return;\n                        }\n                        const name = dependency.name + (isCyclic ? ' (cyclic)' : '');\n                        let dependencyVersions = this._mismatches.get(name);\n                        if (!dependencyVersions) {\n                            this._mismatches.set(name, (dependencyVersions = new Map()));\n                        }\n                        const consumers = dependencyVersions.get(version);\n                        if (!consumers) {\n                            dependencyVersions.set(version, [project]);\n                        }\n                        else {\n                            consumers.push(project);\n                        }\n                    }\n                });\n            }\n        });\n        this._mismatches.forEach((mismatches, project) => {\n            if (mismatches.size <= 1) {\n                this._mismatches.delete(project);\n            }\n        });\n    }\n    _isVersionAllowedAlternative(dependency, version) {\n        const allowedAlternatives = this._allowedAlternativeVersion.get(dependency);\n        return Boolean(allowedAlternatives && allowedAlternatives.indexOf(version) > -1);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _getKeys(iterable) {\n        const keys = [];\n        if (iterable) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            iterable.forEach((value, key) => {\n                keys.push(key);\n            });\n        }\n        return keys;\n    }\n}\n//# sourceMappingURL=VersionMismatchFinder.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { RushConstants } from '../RushConstants';\nimport { PackageJsonDependency, DependencyType } from '../../api/PackageJsonEditor';\nimport { VersionMismatchFinderEntity } from './VersionMismatchFinderEntity';\nexport class VersionMismatchFinderCommonVersions extends VersionMismatchFinderEntity {\n    constructor(commonVersionsConfiguration) {\n        super({\n            friendlyName: `preferred versions from ${RushConstants.commonVersionsFilename}`,\n            decoupledLocalDependencies: new Set()\n        });\n        this._fileManager = commonVersionsConfiguration;\n    }\n    get filePath() {\n        return this._fileManager.filePath;\n    }\n    get allDependencies() {\n        const dependencies = [];\n        this._fileManager.getAllPreferredVersions().forEach((version, dependencyName) => {\n            dependencies.push(this._getPackageJsonDependency(dependencyName, version));\n        });\n        return dependencies;\n    }\n    tryGetDependency(packageName) {\n        const version = this._fileManager.getAllPreferredVersions().get(packageName);\n        if (!version) {\n            return undefined;\n        }\n        else {\n            return this._getPackageJsonDependency(packageName, version);\n        }\n    }\n    tryGetDevDependency(packageName) {\n        return undefined; // common-versions.json doesn't have a distinction between dev and non-dev dependencies\n    }\n    addOrUpdateDependency(packageName, newVersion, dependencyType) {\n        if (dependencyType !== DependencyType.Regular) {\n            throw new Error(`${RushConstants.commonVersionsFilename} only accepts \"${DependencyType.Regular}\" dependencies`);\n        }\n        this._fileManager.preferredVersions.set(packageName, newVersion);\n    }\n    removeDependency(packageName) {\n        throw new Error('Not supported.');\n    }\n    saveIfModified() {\n        return this._fileManager.save();\n    }\n    _getPackageJsonDependency(dependencyName, version) {\n        return new PackageJsonDependency(dependencyName, version, DependencyType.Regular, () => this.addOrUpdateDependency(dependencyName, version, DependencyType.Regular));\n    }\n}\n//# sourceMappingURL=VersionMismatchFinderCommonVersions.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nexport class VersionMismatchFinderEntity {\n    constructor(options) {\n        this.friendlyName = options.friendlyName;\n        this.decoupledLocalDependencies = options.decoupledLocalDependencies;\n        this.skipRushCheck = options.skipRushCheck;\n    }\n}\n//# sourceMappingURL=VersionMismatchFinderEntity.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { VersionMismatchFinderEntity } from './VersionMismatchFinderEntity';\nexport class VersionMismatchFinderProject extends VersionMismatchFinderEntity {\n    constructor(project) {\n        super({\n            friendlyName: project.packageName,\n            decoupledLocalDependencies: project.decoupledLocalDependencies,\n            skipRushCheck: project.skipRushCheck\n        });\n        this._fileManager = project.packageJsonEditor;\n        this.packageName = project.packageName;\n    }\n    get filePath() {\n        return this._fileManager.filePath;\n    }\n    get allDependencies() {\n        return [...this._fileManager.dependencyList, ...this._fileManager.devDependencyList];\n    }\n    tryGetDependency(packageName) {\n        return this._fileManager.tryGetDependency(packageName);\n    }\n    tryGetDevDependency(packageName) {\n        return this._fileManager.tryGetDevDependency(packageName);\n    }\n    addOrUpdateDependency(packageName, newVersion, dependencyType) {\n        return this._fileManager.addOrUpdateDependency(packageName, newVersion, dependencyType);\n    }\n    removeDependency(packageName, dependencyType) {\n        return this._fileManager.removeDependency(packageName, dependencyType);\n    }\n    saveIfModified() {\n        return this._fileManager.saveIfModified();\n    }\n}\n//# sourceMappingURL=VersionMismatchFinderProject.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageManagerOptionsConfigurationBase } from '../base/BasePackageManagerOptionsConfiguration';\n/**\n * Options that are only used when the yarn package manager is selected.\n *\n * @remarks\n * It is valid to define these options in rush.json even if the yarn package manager\n * is not being used.\n *\n * @public\n */\nexport class YarnOptionsConfiguration extends PackageManagerOptionsConfigurationBase {\n    /** @internal */\n    constructor(json) {\n        super(json);\n        this.ignoreEngines = !!json.ignoreEngines;\n    }\n}\n//# sourceMappingURL=YarnOptionsConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { BaseShrinkwrapFile } from '../base/BaseShrinkwrapFile';\nimport { FileSystem, InternalError, Import } from '@rushstack/node-core-library';\nimport { RushConstants } from '../RushConstants';\nimport { PackageNameParsers } from '../../api/PackageNameParsers';\nconst lockfileModule = Import.lazy('@yarnpkg/lockfile', require);\n/**\n * Support for consuming the \"yarn.lock\" file.\n *\n * Yarn refers to its shrinkwrap file as a \"lock file\", even though it has nothing to do\n * with file locking.  Apparently this was based on a convention of the Ruby bundler.\n * Since Rush has to work interchangeably with 3 different package managers, here we refer\n * generically to yarn.lock as a \"shrinkwrap file\".\n *\n * If Rush's Yarn support gains popularity, we will try to improve the wording of\n * logging messages to use terminology more consistent with Yarn's own documentation.\n */\nexport class YarnShrinkwrapFile extends BaseShrinkwrapFile {\n    constructor(shrinkwrapJson) {\n        super();\n        this._shrinkwrapJson = shrinkwrapJson;\n        this._tempProjectNames = [];\n        const seenEntries = new Set();\n        for (const key of Object.keys(this._shrinkwrapJson)) {\n            // Example key:\n            const packageNameAndSemVer = YarnShrinkwrapFile._decodePackageNameAndSemVer(key);\n            // If it starts with @rush-temp, then include it:\n            if (PackageNameParsers.permissive.getScope(packageNameAndSemVer.packageName) ===\n                RushConstants.rushTempNpmScope) {\n                if (!/^file:/i.test(packageNameAndSemVer.semVerRange)) {\n                    // Sanity check to make sure this is a real package.\n                    // (Nobody should ever have an actual dependency on an \"@rush-temp/\" package.\n                    throw new Error('Unexpected package/semver expression found in the Yarn shrinkwrap file (yarn.lock): ' +\n                        JSON.stringify(key));\n                }\n                if (!seenEntries.add(packageNameAndSemVer.packageName)) {\n                    // Sanity check -- this should never happen\n                    throw new Error('Duplicate @rush-temp package found in the Yarn shrinkwrap file (yarn.lock): ' +\n                        JSON.stringify(key));\n                }\n                this._tempProjectNames.push(packageNameAndSemVer.packageName);\n                const entry = this._shrinkwrapJson[key];\n                // Yarn fails installation if the integrity hash does not match a \"file://\" reference to a tarball.\n                // This is incorrect:  Normally a mismatched integrity hash does indicate a corrupted download,\n                // since an NPM registry normally guarantees that a specific version number cannot be republished\n                // with different content.  But this is NOT true for a \"file://\" reference, and there are valid\n                // reasons why someone would update the file.  (PNPM handles this correctly, by simply reinstalling\n                // the tarball if its hash has changed.)\n                //\n                // As a workaround, we can simply remove the hashes from the shrinkwrap file.  We will convert this:\n                //   \"file:./projects/my-project.tgz#80cefe05fd715e65219d1ed481209dc4023408aa\"\n                // ..to this:\n                //   \"file:./projects/my-project.tgz\"\n                const indexOfHash = entry.resolved.indexOf('#');\n                if (indexOfHash >= 0) {\n                    entry.resolved = entry.resolved.substring(0, indexOfHash);\n                }\n            }\n        }\n        this._tempProjectNames.sort(); // make the result deterministic\n        // We don't support Yarn workspaces yet\n        this.isWorkspaceCompatible = false;\n    }\n    static loadFromFile(shrinkwrapFilename) {\n        try {\n            const shrinkwrapContent = FileSystem.readFile(shrinkwrapFilename);\n            return YarnShrinkwrapFile.loadFromString(shrinkwrapContent);\n        }\n        catch (error) {\n            if (FileSystem.isNotExistError(error)) {\n                return undefined; // file does not exist\n            }\n            throw new Error(`Error reading \"${shrinkwrapFilename}\":\\n  ${error.message}`);\n        }\n    }\n    static loadFromString(shrinkwrapContent) {\n        const shrinkwrapJson = lockfileModule.parse(shrinkwrapContent);\n        return new YarnShrinkwrapFile(shrinkwrapJson.object);\n    }\n    /**\n     * The `@yarnpkg/lockfile` API only partially deserializes its data, and expects the caller\n     * to parse the yarn.lock lookup keys (sometimes called a \"pattern\").\n     *\n     * Example input:  \"js-tokens@^3.0.0 || ^4.0.0\"\n     * Example output: { packageName: \"js-tokens\", semVerRange: \"^3.0.0 || ^4.0.0\" }\n     */\n    static _decodePackageNameAndSemVer(packageNameAndSemVer) {\n        const result = YarnShrinkwrapFile._packageNameAndSemVerRegExp.exec(packageNameAndSemVer);\n        if (!result) {\n            // Sanity check -- this should never happen\n            throw new Error('Unable to parse package/semver expression in the Yarn shrinkwrap file (yarn.lock): ' +\n                JSON.stringify(packageNameAndSemVer));\n        }\n        const packageName = result[1] || '';\n        const parsedPackageName = PackageNameParsers.permissive.tryParse(packageName);\n        if (parsedPackageName.error) {\n            // Sanity check -- this should never happen\n            throw new Error('Invalid package name the Yarn shrinkwrap file (yarn.lock): ' +\n                JSON.stringify(packageNameAndSemVer) +\n                '\\n' +\n                parsedPackageName.error);\n        }\n        return {\n            packageName,\n            semVerRange: result[2] || ''\n        };\n    }\n    /**\n     * This is the inverse of _decodePackageNameAndSemVer():\n     * Given an IPackageNameAndSemVer object, recreate the yarn.lock lookup key\n     * (sometimes called a \"pattern\").\n     */\n    static _encodePackageNameAndSemVer(packageNameAndSemVer) {\n        return packageNameAndSemVer.packageName + '@' + packageNameAndSemVer.semVerRange;\n    }\n    /** @override */\n    getTempProjectNames() {\n        return this._tempProjectNames;\n    }\n    /** @override */\n    hasCompatibleTopLevelDependency(dependencySpecifier) {\n        // It seems like we should normalize the key somehow, but Yarn apparently does not\n        // do any normalization.\n        const key = YarnShrinkwrapFile._encodePackageNameAndSemVer({\n            packageName: dependencySpecifier.packageName,\n            semVerRange: dependencySpecifier.versionSpecifier\n        });\n        // Check whether this exact key appears in the shrinkwrap file\n        return Object.hasOwnProperty.call(this._shrinkwrapJson, key);\n    }\n    /** @override */\n    tryEnsureCompatibleDependency(dependencySpecifier, tempProjectName) {\n        return this.hasCompatibleTopLevelDependency(dependencySpecifier);\n    }\n    /** @override */\n    serialize() {\n        return lockfileModule.stringify(this._shrinkwrapJson);\n    }\n    /** @override */\n    getTopLevelDependencyVersion(dependencyName) {\n        throw new InternalError('Not implemented');\n    }\n    /** @override */\n    tryEnsureDependencyVersion(dependencySpecifier, tempProjectName) {\n        throw new InternalError('Not implemented');\n    }\n    /** @override */\n    getProjectShrinkwrap(project) {\n        return undefined;\n    }\n    /** @override */\n    async isWorkspaceProjectModifiedAsync(project, subspace) {\n        throw new InternalError('Not implemented');\n    }\n}\n// Example inputs:\n// \"js-tokens@^3.0.0 || ^4.0.0\"\n// \"@rush-temp/api-extractor-test-03@file:./projects/api-extractor-test-03.tgz\"\nYarnShrinkwrapFile._packageNameAndSemVerRegExp = /^(@?[^@\\s]+)(?:@(.*))?$/;\n//# sourceMappingURL=YarnShrinkwrapFile.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AsyncParallelHook, AsyncSeriesBailHook, AsyncSeriesHook, AsyncSeriesWaterfallHook, SyncHook, SyncWaterfallHook } from 'tapable';\n/**\n * Hooks into the execution process for phased commands\n * @alpha\n */\nexport class PhasedCommandHooks {\n    constructor() {\n        /**\n         * Hook invoked to create operations for execution.\n         * Use the context to distinguish between the initial run and phased runs.\n         */\n        this.createOperations = new AsyncSeriesWaterfallHook(['operations', 'context'], 'createOperations');\n        /**\n         * Hook invoked before operation start\n         * Hook is series for stable output.\n         */\n        this.beforeExecuteOperations = new AsyncSeriesHook(['records', 'context']);\n        /**\n         * Hook invoked when operation status changed\n         * Hook is series for stable output.\n         */\n        this.onOperationStatusChanged = new SyncHook(['record']);\n        /**\n         * Hook invoked after executing a set of operations.\n         * Use the context to distinguish between the initial run and phased runs.\n         * Hook is series for stable output.\n         */\n        this.afterExecuteOperations = new AsyncSeriesHook(['results', 'context']);\n        /**\n         * Hook invoked before executing a operation.\n         */\n        this.beforeExecuteOperation = new AsyncSeriesBailHook(['runnerContext'], 'beforeExecuteOperation');\n        /**\n         * Hook invoked to define environment variables for an operation.\n         * May be invoked by the runner to get the environment for the operation.\n         */\n        this.createEnvironmentForOperation = new SyncWaterfallHook(['environment', 'runnerContext'], 'createEnvironmentForOperation');\n        /**\n         * Hook invoked after executing a operation.\n         */\n        this.afterExecuteOperation = new AsyncSeriesHook(['runnerContext'], 'afterExecuteOperation');\n        /**\n         * Hook invoked to shutdown long-lived work in plugins.\n         */\n        this.shutdownAsync = new AsyncParallelHook(undefined, 'shutdown');\n        /**\n         * Hook invoked after a run has finished and the command is watching for changes.\n         * May be used to display additional relevant data to the user.\n         * Only relevant when running in watch mode.\n         */\n        this.waitingForChanges = new SyncHook(undefined, 'waitingForChanges');\n        /**\n         * Hook invoked after executing operations and before waitingForChanges. Allows the caller\n         * to augment or modify the log entry about to be written.\n         */\n        this.beforeLog = new SyncHook(['telemetryData'], 'beforeLog');\n    }\n}\n//# sourceMappingURL=PhasedCommandHooks.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { FileSystem, JsonFile, PosixModeBits } from '@rushstack/node-core-library';\nimport { Autoinstaller } from '../../logic/Autoinstaller';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { PluginLoaderBase } from './PluginLoaderBase';\n/**\n * @beta\n */\nexport class AutoinstallerPluginLoader extends PluginLoaderBase {\n    constructor(options) {\n        super(options);\n        this.autoinstaller = new Autoinstaller({\n            autoinstallerName: options.pluginConfiguration.autoinstallerName,\n            rushConfiguration: this._rushConfiguration,\n            restrictConsoleOutput: options.restrictConsoleOutput,\n            rushGlobalFolder: options.rushGlobalFolder\n        });\n        this.packageFolder = path.join(this.autoinstaller.folderFullPath, 'node_modules', this.packageName);\n    }\n    /**\n     * The folder where rush plugins static files are stored.\n     * Example: `C:\\MyRepo\\common\\autoinstallers\\<autoinstaller_name>\\rush-plugins`\n     */\n    static getPluginAutoinstallerStorePath(autoinstaller) {\n        return path.join(autoinstaller.folderFullPath, 'rush-plugins');\n    }\n    update() {\n        const packageName = this.packageName;\n        const pluginName = this.pluginName;\n        const packageFolder = this.packageFolder;\n        const manifestPath = path.join(packageFolder, RushConstants.rushPluginManifestFilename);\n        // validate\n        const manifest = JsonFile.loadAndValidate(manifestPath, AutoinstallerPluginLoader._jsonSchema);\n        const destinationManifestPath = this._getManifestPath();\n        FileSystem.copyFile({\n            sourcePath: manifestPath,\n            destinationPath: destinationManifestPath\n        });\n        // Make permission consistent since it will be committed to Git\n        FileSystem.changePosixModeBits(destinationManifestPath, \n        // eslint-disable-next-line no-bitwise\n        PosixModeBits.AllRead | PosixModeBits.UserWrite);\n        const pluginManifest = manifest.plugins.find((item) => item.pluginName === pluginName);\n        if (!pluginManifest) {\n            throw new Error(`A plugin named \"${pluginName}\" is not provided by the Rush plugin package \"${packageName}\"`);\n        }\n        const commandLineJsonFilePath = pluginManifest.commandLineJsonFilePath;\n        if (commandLineJsonFilePath) {\n            const commandLineJsonFullFilePath = path.join(packageFolder, commandLineJsonFilePath);\n            if (!FileSystem.exists(commandLineJsonFullFilePath)) {\n                this._terminal.writeErrorLine(`The Rush plugin \"${pluginName}\" from \"${packageName}\" specifies a commandLineJsonFilePath` +\n                    ` ${commandLineJsonFilePath} that does not exist.`);\n            }\n            const destinationCommandLineJsonFilePath = this._getCommandLineJsonFilePath();\n            FileSystem.copyFile({\n                sourcePath: commandLineJsonFullFilePath,\n                destinationPath: destinationCommandLineJsonFilePath\n            });\n            // Make permission consistent since it will be committed to Git\n            FileSystem.changePosixModeBits(destinationCommandLineJsonFilePath, \n            // eslint-disable-next-line no-bitwise\n            PosixModeBits.AllRead | PosixModeBits.UserWrite);\n        }\n    }\n    _getCommandLineAdditionalPathFolders() {\n        const additionalPathFolders = super._getCommandLineAdditionalPathFolders();\n        additionalPathFolders.push(\n        // Example: `common/autoinstaller/plugins/node_modules/.bin`\n        path.join(this.autoinstaller.folderFullPath, 'node_modules', '.bin'));\n        return additionalPathFolders;\n    }\n    _getPluginOptions() {\n        const optionsJsonFilePath = this._getPluginOptionsJsonFilePath();\n        const optionsSchema = this._getRushPluginOptionsSchema();\n        let pluginOptions = {};\n        try {\n            pluginOptions = JsonFile.load(optionsJsonFilePath);\n        }\n        catch (e) {\n            if (FileSystem.isFileDoesNotExistError(e)) {\n                if (optionsSchema) {\n                    throw new Error(`Plugin options are required by ${this.pluginName} from package ${this.packageName}, please create it at ${optionsJsonFilePath}.`);\n                }\n                else {\n                    return {};\n                }\n            }\n            throw e;\n        }\n        if (optionsSchema) {\n            optionsSchema.validateObject(pluginOptions, optionsJsonFilePath);\n        }\n        return pluginOptions;\n    }\n    _getManifestPath() {\n        return path.join(AutoinstallerPluginLoader.getPluginAutoinstallerStorePath(this.autoinstaller), this.packageName, RushConstants.rushPluginManifestFilename);\n    }\n    _getCommandLineJsonFilePath() {\n        return path.join(AutoinstallerPluginLoader.getPluginAutoinstallerStorePath(this.autoinstaller), this.packageName, this.pluginName, RushConstants.commandLineFilename);\n    }\n}\n//# sourceMappingURL=AutoinstallerPluginLoader.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PluginLoaderBase } from './PluginLoaderBase';\n/**\n * @remarks\n * Used to load plugins that are dependencies of Rush.\n */\nexport class BuiltInPluginLoader extends PluginLoaderBase {\n    constructor(options) {\n        super(options);\n        this.packageFolder = options.pluginConfiguration.pluginPackageFolder;\n    }\n}\n//# sourceMappingURL=BuiltInPluginLoader.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, InternalError, JsonFile, JsonSchema } from '@rushstack/node-core-library';\nimport * as path from 'path';\nimport { CommandLineConfiguration } from '../../api/CommandLineConfiguration';\nimport { RushConstants } from '../../logic/RushConstants';\nimport { RushSdk } from './RushSdk';\nimport schemaJson from '../../schemas/rush-plugin-manifest.schema.json';\nexport class PluginLoaderBase {\n    constructor({ pluginConfiguration, rushConfiguration, terminal }) {\n        this.packageName = pluginConfiguration.packageName;\n        this.pluginName = pluginConfiguration.pluginName;\n        this._rushConfiguration = rushConfiguration;\n        this._terminal = terminal;\n    }\n    load() {\n        const resolvedPluginPath = this._resolvePlugin();\n        if (!resolvedPluginPath) {\n            return undefined;\n        }\n        const pluginOptions = this._getPluginOptions();\n        RushSdk.ensureInitialized();\n        return this._loadAndValidatePluginPackage(resolvedPluginPath, pluginOptions);\n    }\n    get pluginManifest() {\n        return this._getRushPluginManifest();\n    }\n    getCommandLineConfiguration() {\n        const commandLineJsonFilePath = this._getCommandLineJsonFilePath();\n        if (!commandLineJsonFilePath) {\n            return undefined;\n        }\n        const commandLineConfiguration = CommandLineConfiguration.tryLoadFromFile(commandLineJsonFilePath);\n        if (!commandLineConfiguration) {\n            return undefined;\n        }\n        for (const additionalPathFolder of this._getCommandLineAdditionalPathFolders().reverse()) {\n            commandLineConfiguration.prependAdditionalPathFolder(additionalPathFolder);\n        }\n        commandLineConfiguration.shellCommandTokenContext = {\n            packageFolder: this.packageFolder\n        };\n        return commandLineConfiguration;\n    }\n    _getCommandLineAdditionalPathFolders() {\n        return [\n            // Example: `@microsoft/rush-lib/node_modules/<packageName>/node_modules/.bin`\n            // Example: `common/autoinstaller/plugins/node_modules/<packageName>/node_modules/.bin`\n            path.join(this.packageFolder, 'node_modules', '.bin')\n        ];\n    }\n    _getCommandLineJsonFilePath() {\n        const { commandLineJsonFilePath } = this._getRushPluginManifest();\n        if (!commandLineJsonFilePath) {\n            return undefined;\n        }\n        return path.join(this.packageFolder, commandLineJsonFilePath);\n    }\n    _loadAndValidatePluginPackage(resolvedPluginPath, options) {\n        let pluginPackage;\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            const loadedPluginPackage = require(resolvedPluginPath);\n            pluginPackage = loadedPluginPackage.default || loadedPluginPackage;\n        }\n        catch (e) {\n            throw new InternalError(`Error loading rush plugin from \"${resolvedPluginPath}\": ${e}`);\n        }\n        if (!pluginPackage) {\n            throw new InternalError(`Rush plugin loaded from \"${resolvedPluginPath}\" is null or undefined.`);\n        }\n        this._terminal.writeVerboseLine(`Loaded rush plugin from \"${resolvedPluginPath}\"`);\n        const plugin = new pluginPackage(options);\n        if (!plugin.apply || typeof pluginPackage.apply !== 'function') {\n            throw new InternalError(`Rush plugin must define an \"apply\" function. The plugin loaded from \"${resolvedPluginPath}\" ` +\n                'either doesn\\'t define an \"apply\" property, or its value isn\\'t a function.');\n        }\n        return plugin;\n    }\n    _resolvePlugin() {\n        const entryPoint = this._getRushPluginManifest().entryPoint;\n        if (!entryPoint) {\n            return undefined;\n        }\n        const packageFolder = this.packageFolder;\n        const modulePath = path.join(packageFolder, entryPoint);\n        if (!FileSystem.exists(modulePath)) {\n            throw new InternalError(`Unable to find entry point \"${modulePath}\" for rush plugin \"${this.pluginName}\".`);\n        }\n        return modulePath;\n    }\n    _getPluginOptions() {\n        const optionsJsonFilePath = this._getPluginOptionsJsonFilePath();\n        const optionsSchema = this._getRushPluginOptionsSchema();\n        let pluginOptions = {};\n        try {\n            pluginOptions = JsonFile.load(optionsJsonFilePath);\n        }\n        catch (e) {\n            if (FileSystem.isFileDoesNotExistError(e)) {\n                return {};\n            }\n            throw e;\n        }\n        if (optionsSchema) {\n            optionsSchema.validateObject(pluginOptions, optionsJsonFilePath);\n        }\n        return pluginOptions;\n    }\n    _getPluginOptionsJsonFilePath() {\n        return path.join(this._rushConfiguration.rushPluginOptionsFolder, `${this.pluginName}.json`);\n    }\n    _getRushPluginOptionsSchema() {\n        const optionsSchema = this._getRushPluginManifest().optionsSchema;\n        if (!optionsSchema) {\n            return undefined;\n        }\n        const optionsSchemaFilePath = path.join(this.packageFolder, optionsSchema);\n        return JsonSchema.fromFile(optionsSchemaFilePath);\n    }\n    _getRushPluginManifest() {\n        if (!this._manifestCache) {\n            const packageName = this.packageName;\n            const pluginName = this.pluginName;\n            const manifestPath = this._getManifestPath();\n            if (!FileSystem.exists(manifestPath)) {\n                throw new Error(`Manifest for rush plugin package ${packageName} not found.\\nPlease run 'rush update' first.`);\n            }\n            const rushPluginManifestJson = JsonFile.loadAndValidate(manifestPath, PluginLoaderBase._jsonSchema);\n            const pluginManifest = rushPluginManifestJson.plugins.find((item) => item.pluginName === pluginName);\n            if (!pluginManifest) {\n                throw new Error(`${pluginName} is not provided by Rush plugin package \"${packageName}\"`);\n            }\n            this._manifestCache = pluginManifest;\n        }\n        return this._manifestCache;\n    }\n    _getManifestPath() {\n        return path.join(this.packageFolder, RushConstants.rushPluginManifestFilename);\n    }\n}\nPluginLoaderBase._jsonSchema = JsonSchema.fromLoadedObject(schemaJson);\n//# sourceMappingURL=PluginLoaderBase.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nexport class RushSdk {\n    static ensureInitialized() {\n        if (!RushSdk._initialized) {\n            const rushLibModule = require('../../index');\n            // The \"@rushstack/rush-sdk\" shim will look for this global variable to obtain\n            // Rush's instance of \"@microsoft/rush-lib\".\n            global.___rush___rushLibModule = rushLibModule;\n            RushSdk._initialized = true;\n        }\n    }\n}\nRushSdk._initialized = false;\n//# sourceMappingURL=RushSdk.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, Import, InternalError } from '@rushstack/node-core-library';\nimport { BuiltInPluginLoader } from './PluginLoader/BuiltInPluginLoader';\nimport { AutoinstallerPluginLoader } from './PluginLoader/AutoinstallerPluginLoader';\nimport { Rush } from '../api/Rush';\nexport class PluginManager {\n    constructor(options) {\n        var _a, _b;\n        this._loadedPluginNames = new Set();\n        this._terminal = options.terminal;\n        this._rushConfiguration = options.rushConfiguration;\n        this._rushSession = options.rushSession;\n        this._restrictConsoleOutput = options.restrictConsoleOutput;\n        this._rushGlobalFolder = options.rushGlobalFolder;\n        this._installedAutoinstallerNames = new Set();\n        // Eventually we will require end users to explicitly configure all Rush plugins in use, regardless of\n        // whether they are first party or third party plugins.  However, we're postponing that requirement\n        // until after the plugin feature has stabilized and is fully documented.  In the meantime, Rush's\n        // built-in plugins are dependencies of @microsoft/rush-lib and get loaded by default (without any\n        // configuration).\n        //\n        // The plugins have devDependencies on Rush, which would create a circular dependency in our local\n        // workspace if we added them to rush-lib/package.json.  Instead we put them in a special section\n        // \"publishOnlyDependencies\" which gets moved into \"dependencies\" during publishing.\n        const builtInPluginConfigurations = options.builtInPluginConfigurations;\n        const ownPackageJsonDependencies = Rush._rushLibPackageJson.dependencies || {};\n        function tryAddBuiltInPlugin(builtInPluginName, pluginPackageName) {\n            if (!pluginPackageName) {\n                pluginPackageName = `@rushstack/${builtInPluginName}`;\n            }\n            if (ownPackageJsonDependencies[pluginPackageName]) {\n                builtInPluginConfigurations.push({\n                    packageName: pluginPackageName,\n                    pluginName: builtInPluginName,\n                    pluginPackageFolder: Import.resolvePackage({\n                        packageName: pluginPackageName,\n                        baseFolderPath: __dirname\n                    })\n                });\n            }\n        }\n        tryAddBuiltInPlugin('rush-amazon-s3-build-cache-plugin');\n        tryAddBuiltInPlugin('rush-azure-storage-build-cache-plugin');\n        tryAddBuiltInPlugin('rush-http-build-cache-plugin');\n        // This is a secondary plugin inside the `@rushstack/rush-azure-storage-build-cache-plugin`\n        // package. Because that package comes with Rush (for now), it needs to get registered here.\n        // If the necessary config file doesn't exist, this plugin doesn't do anything.\n        tryAddBuiltInPlugin('rush-azure-interactive-auth-plugin', '@rushstack/rush-azure-storage-build-cache-plugin');\n        this._builtInPluginLoaders = builtInPluginConfigurations.map((pluginConfiguration) => {\n            return new BuiltInPluginLoader({\n                pluginConfiguration,\n                rushConfiguration: this._rushConfiguration,\n                terminal: this._terminal\n            });\n        });\n        this._autoinstallerPluginLoaders = ((_b = (_a = this._rushConfiguration) === null || _a === void 0 ? void 0 : _a._rushPluginsConfiguration.configuration.plugins) !== null && _b !== void 0 ? _b : []).map((pluginConfiguration) => {\n            return new AutoinstallerPluginLoader({\n                pluginConfiguration,\n                rushConfiguration: this._rushConfiguration,\n                terminal: this._terminal,\n                restrictConsoleOutput: this._restrictConsoleOutput,\n                rushGlobalFolder: this._rushGlobalFolder\n            });\n        });\n    }\n    /**\n     * If an error occurs while attempting to load plugins, it will be saved in this property.\n     * Rush will attempt to continue and will report the error later by `BaseRushAction._throwPluginErrorIfNeed()`\n     * (unless we are invoking a command that is used to fix plugin problems).\n     */\n    get error() {\n        return this._error;\n    }\n    async updateAsync() {\n        await this._preparePluginAutoinstallersAsync(this._autoinstallerPluginLoaders);\n        const preparedAutoinstallerNames = new Set();\n        for (const { autoinstaller } of this._autoinstallerPluginLoaders) {\n            const storePath = AutoinstallerPluginLoader.getPluginAutoinstallerStorePath(autoinstaller);\n            if (!preparedAutoinstallerNames.has(autoinstaller.name)) {\n                FileSystem.ensureEmptyFolder(storePath);\n                preparedAutoinstallerNames.add(autoinstaller.name);\n            }\n        }\n        for (const pluginLoader of this._autoinstallerPluginLoaders) {\n            pluginLoader.update();\n        }\n    }\n    async reinitializeAllPluginsForCommandAsync(commandName) {\n        this._error = undefined;\n        await this.tryInitializeUnassociatedPluginsAsync();\n        await this.tryInitializeAssociatedCommandPluginsAsync(commandName);\n    }\n    async _preparePluginAutoinstallersAsync(pluginLoaders) {\n        for (const { autoinstaller } of pluginLoaders) {\n            if (!this._installedAutoinstallerNames.has(autoinstaller.name)) {\n                await autoinstaller.prepareAsync();\n                this._installedAutoinstallerNames.add(autoinstaller.name);\n            }\n        }\n    }\n    async tryInitializeUnassociatedPluginsAsync() {\n        try {\n            const autoinstallerPluginLoaders = this._getUnassociatedPluginLoaders(this._autoinstallerPluginLoaders);\n            await this._preparePluginAutoinstallersAsync(autoinstallerPluginLoaders);\n            const builtInPluginLoaders = this._getUnassociatedPluginLoaders(this._builtInPluginLoaders);\n            this._initializePlugins([...builtInPluginLoaders, ...autoinstallerPluginLoaders]);\n        }\n        catch (e) {\n            this._error = e;\n        }\n    }\n    async tryInitializeAssociatedCommandPluginsAsync(commandName) {\n        try {\n            const autoinstallerPluginLoaders = this._getPluginLoadersForCommand(commandName, this._autoinstallerPluginLoaders);\n            await this._preparePluginAutoinstallersAsync(autoinstallerPluginLoaders);\n            const builtInPluginLoaders = this._getPluginLoadersForCommand(commandName, this._builtInPluginLoaders);\n            this._initializePlugins([...builtInPluginLoaders, ...autoinstallerPluginLoaders]);\n        }\n        catch (e) {\n            this._error = e;\n        }\n    }\n    tryGetCustomCommandLineConfigurationInfos() {\n        const commandLineConfigurationInfos = [];\n        for (const pluginLoader of this._autoinstallerPluginLoaders) {\n            const commandLineConfiguration = pluginLoader.getCommandLineConfiguration();\n            if (commandLineConfiguration) {\n                commandLineConfigurationInfos.push({\n                    commandLineConfiguration,\n                    pluginLoader\n                });\n            }\n        }\n        return commandLineConfigurationInfos;\n    }\n    _initializePlugins(pluginLoaders) {\n        for (const pluginLoader of pluginLoaders) {\n            const pluginName = pluginLoader.pluginName;\n            if (this._loadedPluginNames.has(pluginName)) {\n                throw new Error(`Error applying plugin: A plugin with name \"${pluginName}\" has already been applied`);\n            }\n            const plugin = pluginLoader.load();\n            this._loadedPluginNames.add(pluginName);\n            if (plugin) {\n                this._applyPlugin(plugin, pluginName);\n            }\n        }\n    }\n    _getUnassociatedPluginLoaders(pluginLoaders) {\n        return pluginLoaders.filter((pluginLoader) => {\n            return !pluginLoader.pluginManifest.associatedCommands;\n        });\n    }\n    _getPluginLoadersForCommand(commandName, pluginLoaders) {\n        return pluginLoaders.filter((pluginLoader) => {\n            var _a;\n            return (_a = pluginLoader.pluginManifest.associatedCommands) === null || _a === void 0 ? void 0 : _a.includes(commandName);\n        });\n    }\n    _applyPlugin(plugin, pluginName) {\n        try {\n            plugin.apply(this._rushSession, this._rushConfiguration);\n        }\n        catch (e) {\n            throw new InternalError(`Error applying \"${pluginName}\": ${e}`);\n        }\n    }\n}\n//# sourceMappingURL=PluginManager.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AsyncParallelHook, AsyncSeriesHook, HookMap } from 'tapable';\n/**\n * Hooks into the lifecycle of the Rush process invocation that plugins may tap into.\n *\n * @beta\n */\nexport class RushLifecycleHooks {\n    constructor() {\n        /**\n         * The hook to run before executing any Rush CLI Command.\n         */\n        this.initialize = new AsyncSeriesHook(['command'], 'initialize');\n        /**\n         * The hook to run before executing any global Rush CLI Command (defined in command-line.json).\n         */\n        this.runAnyGlobalCustomCommand = new AsyncSeriesHook(['command'], 'runAnyGlobalCustomCommand');\n        /**\n         * A hook map to allow plugins to hook specific named global commands (defined in command-line.json) before execution.\n         */\n        this.runGlobalCustomCommand = new HookMap((key) => {\n            return new AsyncSeriesHook(['command'], key);\n        }, 'runGlobalCustomCommand');\n        /**\n         * The hook to run before executing any phased Rush CLI Command (defined in command-line.json, or the default \"build\" or \"rebuild\").\n         */\n        this.runAnyPhasedCommand = new AsyncSeriesHook(['command'], 'runAnyPhasedCommand');\n        /**\n         * A hook map to allow plugins to hook specific named phased commands (defined in command-line.json) before execution.\n         */\n        this.runPhasedCommand = new HookMap((key) => {\n            return new AsyncSeriesHook(['command'], key);\n        }, 'runPhasedCommand');\n        /**\n         * The hook to run between preparing the common/temp folder and invoking the package manager during \"rush install\" or \"rush update\".\n         */\n        this.beforeInstall = new AsyncSeriesHook(['command', 'subspace', 'variant'], 'beforeInstall');\n        /**\n         * The hook to run after a successful install.\n         */\n        this.afterInstall = new AsyncSeriesHook(['command', 'subspace', 'variant'], 'afterInstall');\n        /**\n         * A hook to allow plugins to hook custom logic to process telemetry data.\n         */\n        this.flushTelemetry = new AsyncParallelHook(['telemetryData'], 'flushTelemetry');\n    }\n}\n//# sourceMappingURL=RushLifeCycle.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { InternalError } from '@rushstack/node-core-library';\nimport { Logger } from './logging/Logger';\nimport { RushLifecycleHooks } from './RushLifeCycle';\n/**\n * @beta\n */\nexport class RushSession {\n    constructor(options) {\n        this._cloudBuildCacheProviderFactories = new Map();\n        this._cobuildLockProviderFactories = new Map();\n        this._options = options;\n        this.hooks = new RushLifecycleHooks();\n    }\n    getLogger(name) {\n        if (!name) {\n            throw new InternalError('RushSession.getLogger(name) called without a name');\n        }\n        const terminalProvider = this._options.terminalProvider;\n        const loggerOptions = {\n            loggerName: name,\n            getShouldPrintStacks: () => this._options.getIsDebugMode(),\n            terminalProvider\n        };\n        return new Logger(loggerOptions);\n    }\n    get terminalProvider() {\n        return this._options.terminalProvider;\n    }\n    registerCloudBuildCacheProviderFactory(cacheProviderName, factory) {\n        if (this._cloudBuildCacheProviderFactories.has(cacheProviderName)) {\n            throw new Error(`A build cache provider factory for ${cacheProviderName} has already been registered`);\n        }\n        this._cloudBuildCacheProviderFactories.set(cacheProviderName, factory);\n    }\n    getCloudBuildCacheProviderFactory(cacheProviderName) {\n        return this._cloudBuildCacheProviderFactories.get(cacheProviderName);\n    }\n    registerCobuildLockProviderFactory(cobuildLockProviderName, factory) {\n        if (this._cobuildLockProviderFactories.has(cobuildLockProviderName)) {\n            throw new Error(`A cobuild lock provider factory for ${cobuildLockProviderName} has already been registered`);\n        }\n        this._cobuildLockProviderFactories.set(cobuildLockProviderName, factory);\n    }\n    getCobuildLockProviderFactory(cobuildLockProviderName) {\n        return this._cobuildLockProviderFactories.get(cobuildLockProviderName);\n    }\n}\n//# sourceMappingURL=RushSession.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Terminal } from '@rushstack/terminal';\nexport class Logger {\n    constructor(options) {\n        this._errors = [];\n        this._warnings = [];\n        this._options = options;\n        this.terminal = new Terminal(options.terminalProvider);\n    }\n    get errors() {\n        return [...this.errors];\n    }\n    get warnings() {\n        return [...this.warnings];\n    }\n    static getErrorMessage(error) {\n        return error.message;\n    }\n    /**\n     * {@inheritdoc ILogger.emitError}\n     */\n    emitError(error) {\n        this._errors.push(error);\n        this.terminal.writeErrorLine(`Error: ${Logger.getErrorMessage(error)}`);\n        if (this._shouldPrintStacks && error.stack) {\n            this.terminal.writeErrorLine(error.stack);\n        }\n    }\n    /**\n     * {@inheritdoc ILogger.emitWarning}\n     */\n    emitWarning(warning) {\n        this._warnings.push(warning);\n        this.terminal.writeWarningLine(`Warning: ${Logger.getErrorMessage(warning)}`);\n        if (this._shouldPrintStacks && warning.stack) {\n            this.terminal.writeWarningLine(warning.stack);\n        }\n    }\n    get _shouldPrintStacks() {\n        return this._options.getShouldPrintStacks();\n    }\n}\n//# sourceMappingURL=Logger.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as child_process from 'child_process';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { Text, Path, FileSystem } from '@rushstack/node-core-library';\nimport { Utilities } from './Utilities';\n/**\n * For deleting large folders, AsyncRecycler is significantly faster than Utilities.dangerouslyDeletePath().\n * It works by moving one or more folders into a temporary \"recycler\" folder, and then launches a separate\n * background process to recursively delete that folder.\n */\nexport class AsyncRecycler {\n    constructor(recyclerFolder) {\n        this.recyclerFolder = path.resolve(recyclerFolder);\n        this._movedFolderCount = 0;\n        this._deleting = false;\n        this._prefix = `${Date.now()}`;\n    }\n    /**\n     * Synchronously moves the specified folder into the recycler folder.  If the specified folder\n     * does not exist, then no operation is performed.  After calling this function one or more times,\n     * deleteAll() must be called to actually delete the contents of the recycler folder.\n     */\n    moveFolder(folderPath) {\n        if (this._deleting) {\n            throw new Error('AsyncRecycler.moveFolder() must not be called after deleteAll() has started');\n        }\n        if (Path.isUnder(this.recyclerFolder, folderPath)) {\n            throw new Error('AsyncRecycler.moveFolder() cannot be called on a parent of the recycler folder');\n        }\n        if (!FileSystem.exists(folderPath)) {\n            return;\n        }\n        ++this._movedFolderCount;\n        // We need to do a simple \"fs.renameSync\" here, however if the folder we're trying to rename\n        // has a lock, or if its destination container doesn't exist yet,\n        // then there seems to be some OS process (virus scanner?) that holds\n        // a lock on the folder for a split second, which causes renameSync to\n        // fail. To workaround that, retry for up to 7 seconds before giving up.\n        const maxWaitTimeMs = 7 * 1000;\n        Utilities.createFolderWithRetry(this.recyclerFolder);\n        Utilities.retryUntilTimeout(() => this._renameOrRecurseInFolder(folderPath), maxWaitTimeMs, (e) => new Error(`Error: ${e}\\nOften this is caused by a file lock from a process like the virus scanner.`), 'recycleFolder');\n    }\n    /**\n     * This deletes all items under the specified folder, except for the items in the membersToExclude.\n     * To be conservative, a case-insensitive comparison is used for membersToExclude.\n     * The membersToExclude must be file/folder names that would match readdir() results.\n     */\n    moveAllItemsInFolder(folderPath, membersToExclude) {\n        const resolvedFolderPath = path.resolve(folderPath);\n        const excludeSet = new Set((membersToExclude || []).map((x) => x.toUpperCase()));\n        for (const dirent of FileSystem.readFolderItems(resolvedFolderPath)) {\n            const normalizedMemberName = dirent.name.toUpperCase();\n            if (!excludeSet.has(normalizedMemberName)) {\n                const absolutePath = path.resolve(folderPath, dirent.name);\n                if (dirent.isDirectory()) {\n                    this._renameOrRecurseInFolder(absolutePath);\n                }\n                else {\n                    FileSystem.deleteFile(absolutePath);\n                }\n            }\n        }\n    }\n    /**\n     * Starts an asynchronous process to delete the recycler folder.  Deleting will continue\n     * even if the current Node.js process is killed.\n     *\n     * NOTE: To avoid spawning multiple instances of the same command, moveFolder()\n     * MUST NOT be called again after deleteAll() has started.\n     */\n    async startDeleteAllAsync() {\n        if (this._deleting) {\n            throw new Error(`${AsyncRecycler.name}.${this.startDeleteAllAsync.name}() must not be called more than once`);\n        }\n        this._deleting = true;\n        if (this._movedFolderCount === 0) {\n            // Nothing to do\n            return;\n        }\n        // Asynchronously delete the folder contents.\n        let command;\n        let args;\n        const options = {\n            detached: true,\n            // The child won't stay alive unless we detach its stdio\n            stdio: 'ignore'\n        };\n        if (os.platform() === 'win32') {\n            // PowerShell.exe doesn't work with a detached console, so we need cmd.exe to create\n            // the new console for us.\n            command = 'cmd.exe';\n            // In PowerShell single-quote literals, single quotes are escaped by doubling them\n            const escapedRecyclerFolder = Text.replaceAll(this.recyclerFolder, \"'\", \"''\");\n            // As of PowerShell 3.0, the \"\\\\?\" prefix can be used for paths that exceed MAX_PATH.\n            // (This prefix does not seem to work for cmd.exe's \"rd\" command.)\n            args = [\n                '/c',\n                '\"' +\n                    'PowerShell.exe -Version 3.0 -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -Command' +\n                    ` Get-ChildItem -Force '${escapedRecyclerFolder}'` +\n                    // The \"^|\" here prevents cmd.exe from interpreting the \"|\" symbol\n                    ` ^| ForEach ($_) { Remove-Item -ErrorAction Ignore -Force -Recurse \"\\\\\\\\?\\\\$($_.FullName)\" }` +\n                    '\"'\n            ];\n            options.windowsVerbatimArguments = true;\n        }\n        else {\n            command = 'rm';\n            args = ['-rf'];\n            let pathCount = 0;\n            let folderItemNames = [];\n            try {\n                folderItemNames = await FileSystem.readFolderItemNamesAsync(this.recyclerFolder);\n            }\n            catch (e) {\n                if (!FileSystem.isNotExistError(e)) {\n                    throw e;\n                }\n            }\n            // child_process.spawn() doesn't expand wildcards.  To be safe, we will do it manually\n            // rather than rely on an unknown shell.\n            for (const filename of folderItemNames) {\n                // The \".\" and \"..\" are supposed to be excluded, but let's be safe\n                if (filename !== '.' && filename !== '..') {\n                    args.push(path.join(this.recyclerFolder, filename));\n                    ++pathCount;\n                }\n            }\n            if (pathCount === 0) {\n                // Nothing to do\n                return;\n            }\n        }\n        const process = child_process.spawn(command, args, options);\n        // The child won't stay alive unless we unlink it from the parent process\n        process.unref();\n    }\n    _renameOrRecurseInFolder(folderPath) {\n        const ordinal = this._movedFolderCount++;\n        const targetDir = `${this.recyclerFolder}/${this._prefix}_${ordinal}`;\n        try {\n            fs.renameSync(folderPath, targetDir);\n            return;\n        }\n        catch (err) {\n            if (FileSystem.isNotExistError(err)) {\n                return;\n            }\n            if (err.code !== 'EPERM') {\n                throw err;\n            }\n        }\n        const children = FileSystem.readFolderItems(folderPath);\n        for (const child of children) {\n            const absoluteChild = `${folderPath}/${child.name}`;\n            if (child.isDirectory()) {\n                this._renameOrRecurseInFolder(absoluteChild);\n            }\n            else {\n                FileSystem.deleteFile(absoluteChild);\n            }\n        }\n        // Yes, this is a folder. The API deletes empty folders, too.\n        FileSystem.deleteFile(folderPath);\n    }\n}\n//# sourceMappingURL=AsyncRecycler.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { TerminalProviderSeverity, TerminalChunkKind } from '@rushstack/terminal';\nexport class CollatedTerminalProvider {\n    get hasErrors() {\n        return this._hasErrors;\n    }\n    get hasWarnings() {\n        return this._hasWarnings;\n    }\n    constructor(collatedTerminal, options) {\n        this._hasErrors = false;\n        this._hasWarnings = false;\n        this._debugEnabled = false;\n        this.supportsColor = true;\n        this.eolCharacter = '\\n';\n        this._collatedTerminal = collatedTerminal;\n        this._debugEnabled = !!(options === null || options === void 0 ? void 0 : options.debugEnabled);\n    }\n    write(data, severity) {\n        switch (severity) {\n            case TerminalProviderSeverity.log:\n            case TerminalProviderSeverity.verbose: {\n                // Unlike the basic ConsoleTerminalProvider, verbose messages are always passed\n                // to stdout -- by convention the user-controlled build script output is sent\n                // to verbose, and will be routed to a variety of other providers in the ProjectBuilder.\n                this._collatedTerminal.writeChunk({ text: data, kind: TerminalChunkKind.Stdout });\n                break;\n            }\n            case TerminalProviderSeverity.debug: {\n                // Similar to the basic ConsoleTerminalProvider, debug messages are discarded\n                // unless they are explicitly enabled.\n                if (this._debugEnabled) {\n                    this._collatedTerminal.writeChunk({ text: data, kind: TerminalChunkKind.Stdout });\n                }\n                break;\n            }\n            case TerminalProviderSeverity.error: {\n                this._collatedTerminal.writeChunk({ text: data, kind: TerminalChunkKind.Stderr });\n                this._hasErrors = true;\n                break;\n            }\n            case TerminalProviderSeverity.warning: {\n                this._collatedTerminal.writeChunk({ text: data, kind: TerminalChunkKind.Stderr });\n                this._hasWarnings = true;\n                break;\n            }\n            default: {\n                throw new Error(`Unexpected severity: ${severity}`);\n            }\n        }\n    }\n}\n//# sourceMappingURL=CollatedTerminalProvider.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Utilities } from './Utilities';\nimport * as semver from 'semver';\nexport class Npm {\n    static async getPublishedVersionsAsync(packageName, cwd, env, extraArgs = []) {\n        const versions = [];\n        try {\n            const packageTime = await Utilities.executeCommandAndCaptureOutputAsync('npm', ['view', packageName, 'time', '--json', ...extraArgs], cwd, env, true);\n            if (packageTime && packageTime !== '') {\n                Object.keys(JSON.parse(packageTime)).forEach((v) => {\n                    if (semver.valid(v)) {\n                        versions.push(v);\n                    }\n                });\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.log(`Package ${packageName} time value does not exist. Fall back to versions.`);\n                // time property does not exist. It happens sometimes. Fall back to versions.\n                const packageVersions = await Utilities.executeCommandAndCaptureOutputAsync('npm', ['view', packageName, 'versions', '--json', ...extraArgs], cwd, env, true);\n                if (packageVersions && packageVersions.length > 0) {\n                    const parsedPackageVersions = JSON.parse(packageVersions);\n                    // NPM <= 6 always returns an array, NPM >= 7 returns a string if the package has only one version available\n                    (Array.isArray(parsedPackageVersions) ? parsedPackageVersions : [parsedPackageVersions]).forEach((version) => {\n                        versions.push(version);\n                    });\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.log(`No version is found for ${packageName}`);\n                }\n            }\n        }\n        catch (e) {\n            const error = e;\n            if (['E404', 'npm ERR! 404'].some((check) => error.message.indexOf(check))) {\n                // eslint-disable-next-line no-console\n                console.log(`Package ${packageName} does not exist in the registry.`);\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.log(`Failed to get NPM information about ${packageName}.`);\n                throw error;\n            }\n        }\n        return versions;\n    }\n}\n//# sourceMappingURL=Npm.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * A terminal provider like /dev/null\n */\nexport class NullTerminalProvider {\n    constructor() {\n        this.supportsColor = false;\n        this.eolCharacter = '\\n';\n    }\n    write() { }\n}\n//# sourceMappingURL=NullTerminalProvider.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * This is a tool for determining if a set of paths overlap. For example 'lib' and 'lib/x' overlap,\n * 'lib/x' and 'lib/y' do not.\n */\nexport class OverlappingPathAnalyzer {\n    constructor() {\n        this._root = {\n            encounteredLabels: new Set(),\n            paths: {}\n        };\n    }\n    addPathAndGetFirstEncounteredLabels(path, label) {\n        const pathParts = path.split('/');\n        let currentNode = this._root;\n        let currentNodeIsNew = false;\n        let labelWasAlreadyPresentInCurrentNode = false;\n        for (const pathPart of pathParts) {\n            if (pathPart === '') {\n                continue;\n            }\n            if (currentNode.label) {\n                return [currentNode.label];\n            }\n            if (!currentNode.paths[pathPart]) {\n                currentNodeIsNew = true;\n                currentNode = currentNode.paths[pathPart] = {\n                    encounteredLabels: new Set(),\n                    paths: {}\n                };\n            }\n            else {\n                currentNodeIsNew = false;\n                currentNode = currentNode.paths[pathPart];\n            }\n            labelWasAlreadyPresentInCurrentNode = currentNode.encounteredLabels.has(label);\n            if (!labelWasAlreadyPresentInCurrentNode) {\n                currentNode.encounteredLabels.add(label);\n            }\n        }\n        if (currentNodeIsNew) {\n            currentNode.label = label;\n            return undefined;\n        }\n        else if (labelWasAlreadyPresentInCurrentNode) {\n            return Array.from(currentNode.encounteredLabels);\n        }\n        else {\n            const clonedEncounteredLabels = new Set(currentNode.encounteredLabels);\n            clonedEncounteredLabels.delete(label);\n            return Array.from(clonedEncounteredLabels);\n        }\n    }\n}\n//# sourceMappingURL=OverlappingPathAnalyzer.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageJsonLookup } from '@rushstack/node-core-library';\n/**\n * The currently-executing rush-lib package's root folder path.\n */\nexport const rushLibFolderRootPath = PackageJsonLookup.instance.tryGetPackageFolderFor(__dirname);\n/**\n * The path to the assets folder in rush-lib.\n */\nexport const assetsFolderPath = `${rushLibFolderRootPath}/assets`;\n/**\n * The folder name (\"scripts\") where the scripts in rush-lib are built.\n */\nexport const scriptsFolderName = 'scripts';\nexport const pnpmfileShimFilename = 'PnpmfileShim.js';\nexport const subspacePnpmfileShimFilename = 'SubspaceGlobalPnpmfileShim.js';\nexport const installRunScriptFilename = 'install-run.js';\nexport const installRunRushScriptFilename = 'install-run-rush.js';\nexport const installRunRushxScriptFilename = 'install-run-rushx.js';\nexport const installRunRushPnpmScriptFilename = 'install-run-rush-pnpm.js';\n/**\n * The path to the scripts folder in rush-lib/dist.\n */\nexport const scriptsFolderPath = `${rushLibFolderRootPath}/dist/${scriptsFolderName}`;\n//# sourceMappingURL=PathConstants.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { AlreadyReportedError } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { LogMessageIdentifier, LogMessageKind } from 'pnpm-sync-lib';\nexport class PnpmSyncUtilities {\n    static _addLinePrefix(message) {\n        return message\n            .split('\\n')\n            .map((x) => (x.trim() ? Colorize.cyan(`pnpm-sync: `) + x : x))\n            .join('\\n');\n    }\n    static processLogMessage(options, terminal) {\n        const message = options.message;\n        const details = options.details;\n        // Special formatting for interested messages\n        switch (details.messageIdentifier) {\n            case LogMessageIdentifier.PREPARE_FINISHING:\n                terminal.writeVerboseLine(PnpmSyncUtilities._addLinePrefix(`Regenerated .pnpm-sync.json in ${Math.round(details.executionTimeInMs)} ms`));\n                return;\n            case LogMessageIdentifier.COPY_FINISHING:\n                {\n                    const customMessage = `Synced ${details.fileCount} ` +\n                        (details.fileCount === 1 ? 'file' : 'files') +\n                        ` in ${Math.round(details.executionTimeInMs)} ms`;\n                    terminal.writeVerboseLine(PnpmSyncUtilities._addLinePrefix(customMessage));\n                }\n                return;\n            case LogMessageIdentifier.PREPARE_REPLACING_FILE:\n                {\n                    const customMessage = `Expecting .pnpm-sync.json version ${details.expectedVersion}, ` +\n                        `but found version ${details.actualVersion}`;\n                    terminal.writeVerboseLine(PnpmSyncUtilities._addLinePrefix(message));\n                    terminal.writeVerboseLine(PnpmSyncUtilities._addLinePrefix(customMessage));\n                }\n                return;\n            case LogMessageIdentifier.COPY_ERROR_INCOMPATIBLE_SYNC_FILE: {\n                terminal.writeErrorLine(PnpmSyncUtilities._addLinePrefix(`The workspace was installed using an incompatible version of pnpm-sync.\\n` +\n                    `Please run \"rush install\" or \"rush update\" again.`));\n                terminal.writeLine(PnpmSyncUtilities._addLinePrefix(`Expecting .pnpm-sync.json version ${details.expectedVersion}, ` +\n                    `but found version ${details.actualVersion}\\n` +\n                    `Affected folder: ${details.pnpmSyncJsonPath}`));\n                throw new AlreadyReportedError();\n            }\n        }\n        // Default handling for other messages\n        switch (options.messageKind) {\n            case LogMessageKind.ERROR:\n                terminal.writeErrorLine(Colorize.red('ERROR: pnpm-sync: ' + message));\n                throw new AlreadyReportedError();\n            case LogMessageKind.WARNING:\n                terminal.writeWarningLine(Colorize.yellow('pnpm-sync: ' + message));\n                return;\n            case LogMessageKind.INFO:\n            case LogMessageKind.VERBOSE:\n                terminal.writeDebugLine(PnpmSyncUtilities._addLinePrefix(message));\n                return;\n        }\n    }\n}\n//# sourceMappingURL=PnpmSyncUtilities.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Colorize, PrintUtilities } from '@rushstack/terminal';\nimport { FileSystem, JsonFile, JsonSchema, JsonSyntax } from '@rushstack/node-core-library';\nimport rushAlertsSchemaJson from '../schemas/rush-alerts.schema.json';\nimport { RushConstants } from '../logic/RushConstants';\nvar AlertDisplayInterval;\n(function (AlertDisplayInterval) {\n    AlertDisplayInterval[\"ALWAYS\"] = \"always\";\n    AlertDisplayInterval[\"MONTHLY\"] = \"monthly\";\n    AlertDisplayInterval[\"WEEKLY\"] = \"weekly\";\n    AlertDisplayInterval[\"DAILY\"] = \"daily\";\n    AlertDisplayInterval[\"HOURLY\"] = \"hourly\";\n})(AlertDisplayInterval || (AlertDisplayInterval = {}));\nvar AlertPriority;\n(function (AlertPriority) {\n    AlertPriority[\"HIGH\"] = \"high\";\n    AlertPriority[\"NORMAL\"] = \"normal\";\n    AlertPriority[\"LOW\"] = \"low\";\n})(AlertPriority || (AlertPriority = {}));\nexport class RushAlerts {\n    constructor(options) {\n        var _a;\n        this._terminal = options.terminal;\n        this._rushJsonFolder = options.rushJsonFolder;\n        this.rushAlertsStateFilePath = options.rushAlertsStateFilePath;\n        this.rushAlertsConfigFilePath = options.rushAlertsConfigFilePath;\n        this._rushAlertsConfig = options.rushAlertsConfig;\n        this._rushAlertsState = (_a = options.rushAlertsState) !== null && _a !== void 0 ? _a : {};\n    }\n    static async loadFromConfigurationAsync(rushConfiguration, terminal) {\n        const rushAlertsStateFilePath = `${rushConfiguration.commonTempFolder}/${RushConstants.rushAlertsConfigFilename}`;\n        const rushAlertsConfigFilePath = `${rushConfiguration.commonRushConfigFolder}/${RushConstants.rushAlertsConfigFilename}`;\n        const rushJsonFolder = rushConfiguration.rushJsonFolder;\n        const [isRushAlertsStateFileExists, isRushAlertsConfigFileExists] = await Promise.all([\n            FileSystem.existsAsync(rushAlertsStateFilePath),\n            FileSystem.existsAsync(rushAlertsConfigFilePath)\n        ]);\n        const [rushAlertsConfig, rushAlertsState] = await Promise.all([\n            isRushAlertsConfigFileExists\n                ? JsonFile.loadAndValidateAsync(rushAlertsConfigFilePath, JsonSchema.fromLoadedObject(rushAlertsSchemaJson))\n                : undefined,\n            isRushAlertsStateFileExists\n                ? JsonFile.loadAsync(rushAlertsStateFilePath, { jsonSyntax: JsonSyntax.JsonWithComments })\n                : undefined\n        ]);\n        return new RushAlerts({\n            terminal,\n            rushAlertsStateFilePath,\n            rushAlertsConfigFilePath,\n            rushJsonFolder,\n            rushAlertsConfig,\n            rushAlertsState\n        });\n    }\n    _ensureAlertStateIsUpToDate() {\n        // ensure `temp/rush-alerts.json` is up to date\n        if (this._rushAlertsConfig) {\n            for (const alert of this._rushAlertsConfig.alerts) {\n                if (!(alert.alertId in this._rushAlertsState)) {\n                    this._rushAlertsState[alert.alertId] = {\n                        snooze: false\n                    };\n                }\n            }\n        }\n    }\n    async printAlertsAsync() {\n        if (!this._rushAlertsConfig || this._rushAlertsConfig.alerts.length === 0)\n            return;\n        this._ensureAlertStateIsUpToDate();\n        this._terminal.writeLine();\n        const alert = await this._selectAlertByPriorityAsync();\n        if (alert) {\n            this._printMessageInBoxStyle(alert);\n            this._rushAlertsState[alert.alertId].lastDisplayTime = new Date().toISOString();\n        }\n        await this._writeRushAlertStateAsync();\n    }\n    async printAllAlertsAsync() {\n        var _a, _b;\n        const allAlerts = (_b = (_a = this._rushAlertsConfig) === null || _a === void 0 ? void 0 : _a.alerts) !== null && _b !== void 0 ? _b : [];\n        const activeAlerts = [];\n        const snoozedAlerts = [];\n        const inactiveAlerts = [];\n        await Promise.all(allAlerts.map(async (alert) => {\n            const isAlertValid = await this._isAlertValidAsync(alert);\n            const alertState = this._rushAlertsState[alert.alertId];\n            if (!isAlertValid) {\n                inactiveAlerts.push(alert);\n                return;\n            }\n            if (this._isSnoozing(alertState)) {\n                snoozedAlerts.push(alert);\n                return;\n            }\n            activeAlerts.push(alert);\n        }));\n        this._printAlerts(activeAlerts, 'active');\n        this._printAlerts(snoozedAlerts, 'snoozed');\n        this._printAlerts(inactiveAlerts, 'inactive');\n    }\n    _printAlerts(alerts, status) {\n        if (alerts.length === 0)\n            return;\n        switch (status) {\n            case 'active':\n            case 'inactive':\n                this._terminal.writeLine(Colorize.yellow(`The following alerts are currently ${status}:`));\n                break;\n            case 'snoozed':\n                this._terminal.writeLine(Colorize.yellow('The following alerts are currently active but snoozed:'));\n                break;\n        }\n        alerts.forEach(({ title }) => {\n            this._terminal.writeLine(Colorize.green(`\"${title}\"`));\n        });\n        this._terminal.writeLine();\n    }\n    async snoozeAlertsByAlertIdAsync(alertId, forever = false) {\n        this._ensureAlertStateIsUpToDate();\n        if (forever) {\n            this._rushAlertsState[alertId].snooze = true;\n        }\n        else {\n            this._rushAlertsState[alertId].snooze = true;\n            const snoozeEndTime = new Date();\n            snoozeEndTime.setDate(snoozeEndTime.getDate() + 7);\n            this._rushAlertsState[alertId].snoozeEndTime = snoozeEndTime.toISOString();\n        }\n        await this._writeRushAlertStateAsync();\n    }\n    async _selectAlertByPriorityAsync() {\n        const alerts = this._rushAlertsConfig.alerts;\n        const alertsState = this._rushAlertsState;\n        const needDisplayAlerts = (await Promise.all(alerts.map(async (alert) => {\n            var _a;\n            const isAlertValid = await this._isAlertValidAsync(alert);\n            const alertState = alertsState[alert.alertId];\n            if (isAlertValid &&\n                !this._isSnoozing(alertState) &&\n                (!alertState.lastDisplayTime ||\n                    Number(new Date()) - Number(new Date(alertState.lastDisplayTime)) >\n                        RushAlerts.alertDisplayIntervalDurations.get((_a = alert.maximumDisplayInterval) !== null && _a !== void 0 ? _a : AlertDisplayInterval.ALWAYS))) {\n                return alert;\n            }\n        }))).filter((alert) => alert !== undefined);\n        const alertsSortedByPriority = needDisplayAlerts.sort((a, b) => {\n            var _a, _b;\n            return (RushAlerts.ALERT_PRIORITY.indexOf((_a = a.priority) !== null && _a !== void 0 ? _a : AlertPriority.NORMAL) -\n                RushAlerts.ALERT_PRIORITY.indexOf((_b = b.priority) !== null && _b !== void 0 ? _b : AlertPriority.NORMAL));\n        });\n        return alertsSortedByPriority[0];\n    }\n    static _parseDate(dateString) {\n        const parsedDate = new Date(dateString);\n        if (isNaN(parsedDate.getTime())) {\n            throw new Error(`Invalid date/time value ${JSON.stringify(dateString)}`);\n        }\n        return parsedDate;\n    }\n    _isSnoozing(alertState) {\n        return (Boolean(alertState.snooze) &&\n            (!alertState.snoozeEndTime || Number(new Date()) < Number(new Date(alertState.snoozeEndTime))));\n    }\n    async _isAlertValidAsync(alert) {\n        const timeNow = new Date();\n        if (alert.startTime) {\n            const startTime = RushAlerts._parseDate(alert.startTime);\n            if (timeNow < startTime) {\n                return false;\n            }\n        }\n        if (alert.endTime) {\n            const endTime = RushAlerts._parseDate(alert.endTime);\n            if (timeNow > endTime) {\n                return false;\n            }\n        }\n        const conditionScript = alert.conditionScript;\n        if (conditionScript) {\n            // \"(OPTIONAL) The filename of a script that determines whether this alert can be shown,\n            // found in the \"common/config/rush/alert-scripts\" folder.\" ... \"To ensure up-to-date alerts, Rush\n            // may fetch and checkout the \"common/config/rush-alerts\" folder in an unpredictable temporary\n            // path.  Therefore, your script should avoid importing dependencies from outside its folder,\n            // generally be kept as simple and reliable and quick as possible.\"\n            if (conditionScript.indexOf('/') >= 0 || conditionScript.indexOf('\\\\') >= 0) {\n                throw new Error(`The rush-alerts.json file contains a \"conditionScript\" that is not inside the \"alert-scripts\" folder: ` +\n                    JSON.stringify(conditionScript));\n            }\n            const conditionScriptPath = `${this._rushJsonFolder}/common/config/rush/alert-scripts/${conditionScript}`;\n            if (!(await FileSystem.existsAsync(conditionScriptPath))) {\n                throw new Error('The \"conditionScript\" field in rush-alerts.json refers to a nonexistent file:\\n' +\n                    conditionScriptPath);\n            }\n            this._terminal.writeDebugLine(`Invoking condition script \"${conditionScript}\" from rush-alerts.json`);\n            const startTimemark = performance.now();\n            let conditionScriptModule;\n            try {\n                conditionScriptModule = require(conditionScriptPath);\n                if (typeof conditionScriptModule.canShowAlert !== 'function') {\n                    throw new Error('The \"canShowAlert\" module export is missing');\n                }\n            }\n            catch (e) {\n                throw new Error(`Error loading condition script \"${conditionScript}\" from rush-alerts.json:\\n${e.stack}`);\n            }\n            const oldCwd = process.cwd();\n            let conditionResult;\n            try {\n                // \"Rush will invoke this script with the working directory set to the monorepo root folder,\n                // with no guarantee that `rush install` has been run.\"\n                process.chdir(this._rushJsonFolder);\n                conditionResult = conditionScriptModule.canShowAlert();\n                if (typeof conditionResult !== 'boolean') {\n                    throw new Error('canShowAlert() did not return a boolean value');\n                }\n            }\n            catch (e) {\n                throw new Error(`Error invoking condition script \"${conditionScript}\" from rush-alerts.json:\\n${e.stack}`);\n            }\n            finally {\n                process.chdir(oldCwd);\n            }\n            const totalMs = performance.now() - startTimemark;\n            this._terminal.writeDebugLine(`Invoked conditionScript \"${conditionScript}\"` +\n                ` in ${Math.round(totalMs)} ms with result \"${conditionResult}\"`);\n            if (!conditionResult) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _printMessageInBoxStyle(alert) {\n        var _a;\n        const boxTitle = alert.title.toUpperCase();\n        const boxMessage = typeof alert.message === 'string' ? alert.message : alert.message.join('');\n        const boxDetails = alert.detailsUrl ? 'Details: ' + alert.detailsUrl : '';\n        // ...minus the padding.\n        const PADDING = '╔══╗'.length;\n        // Try to make it wide enough to fit the (unwrapped) strings...\n        let lineLength = Math.max(boxTitle.length, boxMessage.length, boxDetails.length);\n        // ...but don't exceed the console width, and also keep it under 80...\n        lineLength = Math.min(lineLength, ((_a = PrintUtilities.getConsoleWidth()) !== null && _a !== void 0 ? _a : 80) - PADDING, 80 - PADDING);\n        // ...and the width needs to be at least 40 characters...\n        lineLength = Math.max(lineLength, 40 - PADDING);\n        const lines = [\n            ...PrintUtilities.wrapWordsToLines(boxTitle, lineLength).map((x) => Colorize.bold(x.padEnd(lineLength))),\n            '',\n            ...PrintUtilities.wrapWordsToLines(boxMessage, lineLength).map((x) => x.padEnd(lineLength))\n        ];\n        if (boxDetails) {\n            lines.push('', ...PrintUtilities.wrapWordsToLines(boxDetails, lineLength).map((x) => Colorize.cyan(x.padEnd(lineLength))));\n        }\n        // Print the box\n        this._terminal.writeLine('╔═' + '═'.repeat(lineLength) + '═╗');\n        for (const line of lines) {\n            this._terminal.writeLine(`║ ${line.padEnd(lineLength)} ║`);\n        }\n        this._terminal.writeLine('╚═' + '═'.repeat(lineLength) + '═╝');\n        this._terminal.writeLine(`To stop seeing this alert, run \"rush alert --snooze ${alert.alertId}\"`);\n    }\n    async _writeRushAlertStateAsync() {\n        await JsonFile.saveAsync(this._rushAlertsState, this.rushAlertsStateFilePath, {\n            ignoreUndefinedValues: true,\n            headerComment: '// THIS FILE IS MACHINE-GENERATED -- DO NOT MODIFY',\n            jsonSyntax: JsonSyntax.JsonWithComments\n        });\n    }\n}\nRushAlerts.ALERT_PRIORITY = [\n    AlertPriority.HIGH,\n    AlertPriority.NORMAL,\n    AlertPriority.LOW\n];\nRushAlerts.alertDisplayIntervalDurations = new Map([\n    [AlertDisplayInterval.ALWAYS, -1],\n    [AlertDisplayInterval.MONTHLY, 1000 * 60 * 60 * 24 * 30],\n    [AlertDisplayInterval.WEEKLY, 1000 * 60 * 60 * 24 * 7],\n    [AlertDisplayInterval.DAILY, 1000 * 60 * 60 * 24],\n    [AlertDisplayInterval.HOURLY, 1000 * 60 * 60]\n]);\n// only display alerts when certain specific actions are triggered\nRushAlerts.alertTriggerActions = [\n    'add',\n    'change',\n    'deploy',\n    'init',\n    'publish',\n    'purge',\n    'remove',\n    'update',\n    'install',\n    'build',\n    'list',\n    'version'\n];\n//# sourceMappingURL=RushAlerts.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { PackageJsonLookup } from '@rushstack/node-core-library';\nimport { EnvironmentVariableNames } from '../api/EnvironmentConfiguration';\nconst rootDir = PackageJsonLookup.instance.tryGetPackageFolderFor(__dirname);\nif (rootDir) {\n    // Route to the 'main' field of package.json\n    const rushLibIndex = require.resolve(rootDir, { paths: [] });\n    process.env[EnvironmentVariableNames._RUSH_LIB_PATH] = rushLibIndex;\n}\n//# sourceMappingURL=SetRushLibPath.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { Utilities } from './Utilities';\n/**\n * Used with the Stopwatch class.\n */\nexport var StopwatchState;\n(function (StopwatchState) {\n    StopwatchState[StopwatchState[\"Stopped\"] = 1] = \"Stopped\";\n    StopwatchState[StopwatchState[\"Started\"] = 2] = \"Started\";\n})(StopwatchState || (StopwatchState = {}));\n/**\n * Represents a typical timer/stopwatch which keeps track\n * of elapsed time in between two events.\n */\nexport class Stopwatch {\n    constructor(getTime = Utilities.getTimeInMs) {\n        this._startTime = undefined;\n        this._endTime = undefined;\n        this._getTime = getTime;\n        this._state = StopwatchState.Stopped;\n    }\n    /**\n     * Static helper function which creates a stopwatch which is immediately started\n     */\n    static start() {\n        return new Stopwatch().start();\n    }\n    get state() {\n        return this._state;\n    }\n    /**\n     * Starts the stopwatch. Note that if end() has been called,\n     * reset() should be called before calling start() again.\n     */\n    start() {\n        if (this._startTime !== undefined) {\n            throw new Error('Call reset() before starting the Stopwatch');\n        }\n        this._startTime = this._getTime();\n        this._endTime = undefined;\n        this._state = StopwatchState.Started;\n        return this;\n    }\n    /**\n     * Stops executing the stopwatch and saves the current timestamp\n     */\n    stop() {\n        this._endTime = this._startTime !== undefined ? this._getTime() : undefined;\n        this._state = StopwatchState.Stopped;\n        return this;\n    }\n    /**\n     * Resets all values of the stopwatch back to the original\n     */\n    reset() {\n        this._endTime = this._startTime = undefined;\n        this._state = StopwatchState.Stopped;\n        return this;\n    }\n    /**\n     * Displays how long the stopwatch has been executing in a human readable format.\n     */\n    toString() {\n        if (this._state === StopwatchState.Stopped && this._startTime === undefined) {\n            return '0.00 seconds (stopped)';\n        }\n        const totalSeconds = this.duration;\n        if (totalSeconds > 60) {\n            const minutes = Math.floor(totalSeconds / 60);\n            const seconds = totalSeconds % 60.0;\n            return `${minutes.toFixed(0)} minute${minutes === 1 ? '' : 's'} ${seconds.toFixed(1)} seconds`;\n        }\n        else {\n            return `${totalSeconds.toFixed(2)} seconds`;\n        }\n    }\n    /**\n     * Get the duration in seconds.\n     */\n    get duration() {\n        if (this._startTime === undefined) {\n            return 0;\n        }\n        const curTime = this._endTime !== undefined ? this._endTime : this._getTime();\n        return (curTime - this._startTime) / 1000.0;\n    }\n    /**\n     * Return the start time of the most recent stopwatch run.\n     */\n    get startTime() {\n        return this._startTime;\n    }\n    /**\n     * Return the end time of the most recent stopwatch run.\n     */\n    get endTime() {\n        return this._endTime;\n    }\n}\n//# sourceMappingURL=Stopwatch.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport os from 'os';\nimport { Executable, FileSystem, FileWriter } from '@rushstack/node-core-library';\nimport events from 'events';\nimport { EnvironmentConfiguration } from '../api/EnvironmentConfiguration';\nexport class TarExecutable {\n    constructor(tarExecutablePath) {\n        this._tarExecutablePath = tarExecutablePath;\n    }\n    static async tryInitializeAsync(terminal) {\n        terminal.writeVerboseLine('Trying to find \"tar\" binary');\n        const tarExecutablePath = EnvironmentConfiguration.tarBinaryPath || (await TarExecutable._tryFindTarExecutablePathAsync());\n        if (!tarExecutablePath) {\n            terminal.writeVerboseLine('\"tar\" was not found on the PATH');\n            return undefined;\n        }\n        return new TarExecutable(tarExecutablePath);\n    }\n    /**\n     * @returns\n     * The \"tar\" exit code\n     */\n    async tryUntarAsync(options) {\n        return await this._spawnTarWithLoggingAsync(\n        // These parameters are chosen for compatibility with the very primitive bsdtar 3.3.2 shipped with Windows 10.\n        [\n            // [Windows bsdtar 3.3.2] Extract: tar -x [options] [<patterns>]\n            '-x',\n            // [Windows bsdtar 3.3.2] -m    Don't restore modification times\n            '-m',\n            // [Windows bsdtar 3.3.2] -f <filename>  Location of archive (default \\\\.\\tape0)\n            '-f',\n            options.archivePath\n        ], options.outputFolderPath, options.logFilePath);\n    }\n    /**\n     * @returns\n     * The \"tar\" exit code\n     */\n    async tryCreateArchiveFromProjectPathsAsync(options) {\n        const { project, archivePath, paths, logFilePath } = options;\n        const tarInput = paths.join('\\n');\n        // On Windows, tar.exe will report a \"Failed to clean up compressor\" error if the target folder\n        // does not exist (GitHub #2622)\n        await FileSystem.ensureFolderAsync(path.dirname(archivePath));\n        const projectFolderPath = project.projectFolder;\n        const tarExitCode = await this._spawnTarWithLoggingAsync(\n        // These parameters are chosen for compatibility with the very primitive bsdtar 3.3.2 shipped with Windows 10.\n        [\n            // [Windows bsdtar 3.3.2] -c Create\n            '-c',\n            // [Windows bsdtar 3.3.2] -f <filename>  Location of archive (default \\\\.\\tape0)\n            '-f',\n            archivePath,\n            // [Windows bsdtar 3.3.2] -z, -j, -J, --lzma  Compress archive with gzip/bzip2/xz/lzma\n            '-z',\n            // [GNU tar 1.33] -T, --files-from=FILE      get names to extract or create from FILE\n            //\n            // Windows bsdtar does not document this parameter, but seems to accept it.\n            '--files-from=-'\n        ], projectFolderPath, logFilePath, tarInput);\n        return tarExitCode;\n    }\n    async _spawnTarWithLoggingAsync(args, currentWorkingDirectory, logFilePath, input) {\n        // Runs \"tar\" with the specified args and logs its output to the specified location.\n        // The log file looks like this:\n        //\n        // Windows:\n        // Start time: Mon Apr 19 2021 13:06:40 GMT-0700 (Pacific Daylight Time)\n        // Invoking \"C:\\WINDOWS\\system32\\tar.exe -x -f E:\\rush-cache\\d18105f7f83eb610b468be4e2421681f4a52e44d\"\n        //\n        // ======= BEGIN PROCESS OUTPUT =======\n        // [stdout] <tar stdout output>\n        // [stderr] <tar stderr output>\n        // ======== END PROCESS OUTPUT ========\n        //\n        // Exited with code \"0\"\n        //\n        // Linux:\n        // Start time: Mon Apr 19 2021 13:06:40 GMT-0700 (Pacific Daylight Time)\n        // Invoking \"/bin/tar -x -f /home/username/rush-cache/d18105f7f83eb610b468be4e2421681f4a52e44d\"\n        //\n        // ======= BEGIN PROCESS OUTPUT =======\n        // [stdout] <tar stdout output>\n        // [stderr] <tar stderr output>\n        // ======== END PROCESS OUTPUT ========\n        //\n        // Exited with code \"0\"\n        await FileSystem.ensureFolderAsync(path.dirname(logFilePath));\n        const fileWriter = FileWriter.open(logFilePath);\n        fileWriter.write([\n            `Start time: ${new Date().toString()}`,\n            `Invoking \"${this._tarExecutablePath} ${args.join(' ')}\"`,\n            '',\n            `======= BEGIN PROCESS INPUT ======`,\n            input || '',\n            '======== END PROCESS INPUT =======',\n            '======= BEGIN PROCESS OUTPUT =======',\n            ''\n        ].join('\\n'));\n        const childProcess = Executable.spawn(this._tarExecutablePath, args, {\n            currentWorkingDirectory: currentWorkingDirectory\n        });\n        childProcess.stdout.on('data', (chunk) => fileWriter.write(`[stdout] ${chunk}`));\n        childProcess.stderr.on('data', (chunk) => fileWriter.write(`[stderr] ${chunk}`));\n        if (input !== undefined) {\n            childProcess.stdin.write(input, 'utf-8');\n            childProcess.stdin.end();\n        }\n        // Wait for process to exit and all streams to close\n        const [tarExitCode] = await events.once(childProcess, 'close');\n        fileWriter.write(['======== END PROCESS OUTPUT ========', '', `Exited with code \"${tarExitCode}\"`].join('\\n'));\n        fileWriter.close();\n        return tarExitCode;\n    }\n    static async _tryFindTarExecutablePathAsync() {\n        if (os.platform() === 'win32') {\n            // If we're running on Windows, first try to use the OOB tar executable. If\n            // we're running in the Git Bash, the tar executable on the PATH doesn't handle\n            // Windows file paths correctly.\n            // eslint-disable-next-line dot-notation\n            const windowsFolderPath = process.env['WINDIR'];\n            if (windowsFolderPath) {\n                const defaultWindowsTarExecutablePath = `${windowsFolderPath}\\\\system32\\\\tar.exe`;\n                if (await FileSystem.existsAsync(defaultWindowsTarExecutablePath)) {\n                    return defaultWindowsTarExecutablePath;\n                }\n            }\n        }\n        return Executable.tryResolve('tar');\n    }\n}\n//# sourceMappingURL=TarExecutable.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as child_process from 'child_process';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { performance } from 'perf_hooks';\nimport { Transform } from 'stream';\nimport { JsonFile, FileSystem, FileConstants, SubprocessTerminator, Executable, Async } from '@rushstack/node-core-library';\nimport { syncNpmrc } from './npmrcUtilities';\nimport { EnvironmentVariableNames } from '../api/EnvironmentConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const UNINITIALIZED = 'UNINITIALIZED';\nexport class Utilities {\n    /**\n     * Get the user's home directory. On windows this looks something like \"C:\\users\\username\\\" and on UNIX\n     * this looks something like \"/home/username/\"\n     */\n    static getHomeFolder() {\n        const unresolvedUserFolder = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];\n        const dirError = \"Unable to determine the current user's home directory\";\n        if (unresolvedUserFolder === undefined) {\n            throw new Error(dirError);\n        }\n        const homeFolder = path.resolve(unresolvedUserFolder);\n        if (!FileSystem.exists(homeFolder)) {\n            throw new Error(dirError);\n        }\n        return homeFolder;\n    }\n    /**\n     * Node.js equivalent of performance.now().\n     */\n    static getTimeInMs() {\n        return performance.now();\n    }\n    /**\n     * Retries a function until a timeout is reached. The function is expected to throw if it failed and\n     *  should be retried.\n     */\n    static retryUntilTimeout(fn, maxWaitTimeMs, getTimeoutError, fnName) {\n        const startTime = Utilities.getTimeInMs();\n        let looped = false;\n        let result;\n        for (;;) {\n            try {\n                result = fn();\n                break;\n            }\n            catch (e) {\n                looped = true;\n                const currentTime = Utilities.getTimeInMs();\n                if (currentTime - startTime > maxWaitTimeMs) {\n                    throw getTimeoutError(e);\n                }\n            }\n        }\n        if (looped) {\n            const currentTime = Utilities.getTimeInMs();\n            const totalSeconds = ((currentTime - startTime) / 1000.0).toFixed(2);\n            // This logging statement isn't meaningful to the end-user. `fnName` should be updated\n            // to something like `operationDescription`\n            // eslint-disable-next-line no-console\n            console.log(`${fnName}() stalled for ${totalSeconds} seconds`);\n        }\n        return result;\n    }\n    /**\n     * Creates the specified folder by calling FileSystem.ensureFolder(), but using a\n     * retry loop to recover from temporary locks that may be held by other processes.\n     * If the folder already exists, no error occurs.\n     */\n    static createFolderWithRetry(folderName) {\n        // Note: If a file exists with the same name, then we fall through and report\n        // an error.\n        if (Utilities.directoryExists(folderName)) {\n            return;\n        }\n        // We need to do a simple \"FileSystem.ensureFolder(localModulesFolder)\" here,\n        // however if the folder we deleted above happened to contain any files,\n        // then there seems to be some OS process (virus scanner?) that holds\n        // a lock on the folder for a split second, which causes mkdirSync to\n        // fail.  To workaround that, retry for up to 7 seconds before giving up.\n        const maxWaitTimeMs = 7 * 1000;\n        return Utilities.retryUntilTimeout(() => FileSystem.ensureFolder(folderName), maxWaitTimeMs, (e) => new Error(`Error: ${e}\\nOften this is caused by a file lock ` +\n            'from a process such as your text editor, command prompt, ' +\n            'or a filesystem watcher.'), 'createFolderWithRetry');\n    }\n    /**\n     * Determines if a path points to a directory and that it exists.\n     */\n    static directoryExists(directoryPath) {\n        let exists = false;\n        try {\n            const lstat = FileSystem.getLinkStatistics(directoryPath);\n            exists = lstat.isDirectory();\n        }\n        catch (e) {\n            /* no-op */\n        }\n        return exists;\n    }\n    /**\n     * BE VERY CAREFUL CALLING THIS FUNCTION!\n     * If you specify the wrong folderPath (e.g. \"/\"), it could potentially delete your entire\n     * hard disk.\n     */\n    static dangerouslyDeletePath(folderPath) {\n        try {\n            FileSystem.deleteFolder(folderPath);\n        }\n        catch (e) {\n            throw new Error(`${e.message}\\nOften this is caused by a file lock from a process ` +\n                'such as your text editor, command prompt, or a filesystem watcher');\n        }\n    }\n    /*\n     * Returns true if dateToCompare is more recent than all of the inputFilenames, which\n     * would imply that we don't need to rebuild it. Returns false if any of the files\n     * does not exist.\n     * NOTE: The filenames can also be paths for directories, in which case the directory\n     * timestamp is compared.\n     */\n    static async isFileTimestampCurrentAsync(dateToCompare, inputFilePaths) {\n        let anyAreOutOfDate = false;\n        await Async.forEachAsync(inputFilePaths, async (filePath) => {\n            if (!anyAreOutOfDate) {\n                let inputStats;\n                try {\n                    inputStats = await FileSystem.getStatisticsAsync(filePath);\n                }\n                catch (e) {\n                    if (FileSystem.isNotExistError(e)) {\n                        // eslint-disable-next-line require-atomic-updates\n                        anyAreOutOfDate = true;\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n                if (inputStats && dateToCompare < inputStats.mtime) {\n                    // eslint-disable-next-line require-atomic-updates\n                    anyAreOutOfDate = true;\n                }\n            }\n        }, { concurrency: 10 });\n        return !anyAreOutOfDate;\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     */\n    static async executeCommandAsync({ command, args, workingDirectory, suppressOutput, onStdoutStreamChunk, environment, keepEnvironment, captureExitCodeAndSignal }) {\n        const { exitCode, signal } = await Utilities._executeCommandInternalAsync({\n            command,\n            args,\n            workingDirectory,\n            stdio: onStdoutStreamChunk\n                ? // Inherit the stdin and stderr streams, but pipe the stdout stream, which will then be piped\n                    // to the process's stdout after being intercepted by the onStdoutStreamChunk callback.\n                    ['inherit', 'pipe', 'inherit']\n                : suppressOutput\n                    ? // If the output is being suppressed, create pipes for all streams to prevent the child process\n                        // from printing to the parent process's (this process's) stdout/stderr, but allow the stdout and\n                        // stderr to be inspected if an error occurs.\n                        // TODO: Consider ignoring stdout and stdin and only piping stderr for inspection on error.\n                        ['pipe', 'pipe', 'pipe']\n                    : // If the output is not being suppressed or intercepted, inherit all streams from the parent process.\n                        ['inherit', 'inherit', 'inherit'],\n            environment,\n            keepEnvironment,\n            onStdoutStreamChunk,\n            captureOutput: false,\n            captureExitCodeAndSignal\n        });\n        if (captureExitCodeAndSignal) {\n            return { exitCode, signal };\n        }\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     */\n    static async executeCommandAndCaptureOutputAsync(command, args, workingDirectory, environment, keepEnvironment = false) {\n        const { stdout } = await Utilities._executeCommandInternalAsync({\n            command,\n            args,\n            workingDirectory,\n            stdio: ['pipe', 'pipe', 'pipe'],\n            environment,\n            keepEnvironment,\n            captureOutput: true\n        });\n        return stdout;\n    }\n    /**\n     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.\n     */\n    static async executeCommandWithRetryAsync(options, maxAttempts, retryCallback) {\n        if (maxAttempts < 1) {\n            throw new Error('The maxAttempts parameter cannot be less than 1');\n        }\n        let attemptNumber = 1;\n        for (;;) {\n            try {\n                await Utilities.executeCommandAsync(options);\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.log('\\nThe command failed:');\n                const { command, args } = options;\n                // eslint-disable-next-line no-console\n                console.log(` ${command} ` + args.join(' '));\n                // eslint-disable-next-line no-console\n                console.log(`ERROR: ${error.toString()}`);\n                if (attemptNumber < maxAttempts) {\n                    ++attemptNumber;\n                    // eslint-disable-next-line no-console\n                    console.log(`Trying again (attempt #${attemptNumber})...\\n`);\n                    if (retryCallback) {\n                        retryCallback();\n                    }\n                    continue;\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.error(`Giving up after ${attemptNumber} attempts\\n`);\n                    throw error;\n                }\n            }\n            break;\n        }\n    }\n    /**\n     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.\n     * @param command - the command to run on shell\n     * @param options - options for how the command should be run\n     */\n    static executeLifecycleCommand(command, options) {\n        const result = Utilities._executeLifecycleCommandInternal(command, child_process.spawnSync, options);\n        if (options.handleOutput) {\n            Utilities._processResult({\n                error: result.error,\n                status: result.status,\n                stderr: result.stderr.toString()\n            });\n        }\n        if (result.status !== null) {\n            return result.status;\n        }\n        else {\n            throw result.error || new Error('An unknown error occurred.');\n        }\n    }\n    /**\n     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.\n     * @param command - the command to run on shell\n     * @param options - options for how the command should be run\n     */\n    static executeLifecycleCommandAsync(command, options) {\n        const child = Utilities._executeLifecycleCommandInternal(command, child_process.spawn, options);\n        if (options.connectSubprocessTerminator) {\n            SubprocessTerminator.killProcessTreeOnExit(child, SubprocessTerminator.RECOMMENDED_OPTIONS);\n        }\n        return child;\n    }\n    /**\n     * For strings passed to a shell command, this adds appropriate escaping\n     * to avoid misinterpretation of spaces or special characters.\n     *\n     * Example: 'hello there' --> '\"hello there\"'\n     */\n    static escapeShellParameter(parameter) {\n        // This approach is based on what NPM 7 now does:\n        // https://github.com/npm/run-script/blob/47a4d539fb07220e7215cc0e482683b76407ef9b/lib/run-script-pkg.js#L34\n        return JSON.stringify(parameter);\n    }\n    /**\n     * Installs a package by name and version in the specified directory.\n     */\n    static async installPackageInDirectoryAsync({ packageName, version, tempPackageTitle, commonRushConfigFolder, maxInstallAttempts, suppressOutput, directory }) {\n        directory = path.resolve(directory);\n        const directoryExists = await FileSystem.existsAsync(directory);\n        if (directoryExists) {\n            // eslint-disable-next-line no-console\n            console.log('Deleting old files from ' + directory);\n        }\n        await FileSystem.ensureEmptyFolderAsync(directory);\n        const npmPackageJson = {\n            dependencies: {\n                [packageName]: version\n            },\n            description: 'Temporary file generated by the Rush tool',\n            name: tempPackageTitle,\n            private: true,\n            version: '0.0.0'\n        };\n        await JsonFile.saveAsync(npmPackageJson, path.join(directory, FileConstants.PackageJson));\n        if (commonRushConfigFolder) {\n            Utilities.syncNpmrc({\n                sourceNpmrcFolder: commonRushConfigFolder,\n                targetNpmrcFolder: directory,\n                supportEnvVarFallbackSyntax: false\n            });\n        }\n        // eslint-disable-next-line no-console\n        console.log('\\nRunning \"npm install\" in ' + directory);\n        // NOTE: Here we use whatever version of NPM we happen to find in the PATH\n        await Utilities.executeCommandWithRetryAsync({\n            command: 'npm',\n            args: ['install'],\n            workingDirectory: directory,\n            environment: Utilities._createEnvironmentForRushCommand({}),\n            suppressOutput\n        }, maxInstallAttempts);\n    }\n    /**\n     * Copies the file \"sourcePath\" to \"destinationPath\", overwriting the target file location.\n     * If the source file does not exist, then the target file is deleted.\n     */\n    static syncFile(sourcePath, destinationPath) {\n        if (FileSystem.exists(sourcePath)) {\n            // eslint-disable-next-line no-console\n            console.log(`Copying \"${sourcePath}\"`);\n            // eslint-disable-next-line no-console\n            console.log(`  --> \"${destinationPath}\"`);\n            FileSystem.copyFile({ sourcePath, destinationPath });\n        }\n        else {\n            if (FileSystem.exists(destinationPath)) {\n                // If the source file doesn't exist and there is one in the target, delete the one in the target\n                // eslint-disable-next-line no-console\n                console.log(`Deleting ${destinationPath}`);\n                FileSystem.deleteFile(destinationPath);\n            }\n        }\n    }\n    static getRushConfigNotFoundError() {\n        return new Error(`Unable to find ${RushConstants.rushJsonFilename} configuration file`);\n    }\n    static async usingAsync(getDisposableAsync, doActionAsync) {\n        let disposable;\n        try {\n            disposable = (await getDisposableAsync());\n            await doActionAsync(disposable);\n        }\n        finally {\n            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\n        }\n    }\n    static trimAfterLastSlash(filePath) {\n        const indexOfLastSlash = Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\\\'));\n        if (indexOfLastSlash < 0) {\n            return filePath;\n        }\n        return filePath.substring(0, indexOfLastSlash);\n    }\n    /**\n     * If the path refers to a symlink, `FileSystem.exists()` would normally test whether the symlink\n     * points to a target that exists. By contrast, `existsOrIsBrokenSymlink()` will return true even if\n     * the symlink exists but its target does not. */\n    static existsOrIsSymlink(linkPath) {\n        try {\n            FileSystem.getLinkStatistics(linkPath);\n            return true;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    static _executeLifecycleCommandInternal(command, spawnFunction, options) {\n        var _a;\n        let shellCommand = process.env.comspec || 'cmd';\n        let commandFlags = '/d /s /c';\n        let useShell = true;\n        if (process.platform !== 'win32') {\n            shellCommand = 'sh';\n            commandFlags = '-c';\n            useShell = false;\n        }\n        const environment = Utilities._createEnvironmentForRushCommand({\n            initCwd: options.initCwd,\n            initialEnvironment: options.initialEnvironment,\n            pathOptions: Object.assign(Object.assign({}, options.environmentPathOptions), { rushJsonFolder: (_a = options.rushConfiguration) === null || _a === void 0 ? void 0 : _a.rushJsonFolder, projectRoot: options.workingDirectory, commonTempFolder: options.rushConfiguration ? options.rushConfiguration.commonTempFolder : undefined })\n        });\n        const stdio = options.handleOutput ? ['pipe', 'pipe', 'pipe'] : [0, 1, 2];\n        if (options.ipc) {\n            stdio.push('ipc');\n        }\n        const spawnOptions = {\n            cwd: options.workingDirectory,\n            shell: useShell,\n            env: environment,\n            stdio\n        };\n        if (options.connectSubprocessTerminator) {\n            Object.assign(spawnOptions, SubprocessTerminator.RECOMMENDED_OPTIONS);\n        }\n        return spawnFunction(shellCommand, [commandFlags, command], spawnOptions);\n    }\n    /**\n     * Returns a process.env environment suitable for executing lifecycle scripts.\n     * @param initialEnvironment - an existing environment to copy instead of process.env\n     *\n     * @remarks\n     * Rush._assignRushInvokedFolder() assigns the `RUSH_INVOKED_FOLDER` variable globally\n     * via the parent process's environment.\n     */\n    static _createEnvironmentForRushCommand(options) {\n        var _a;\n        if (options.initialEnvironment === undefined) {\n            options.initialEnvironment = process.env;\n        }\n        // Set some defaults for the environment\n        const environment = {};\n        if ((_a = options.pathOptions) === null || _a === void 0 ? void 0 : _a.rushJsonFolder) {\n            environment.RUSHSTACK_FILE_ERROR_BASE_FOLDER = options.pathOptions.rushJsonFolder;\n        }\n        for (const key of Object.getOwnPropertyNames(options.initialEnvironment)) {\n            const normalizedKey = os.platform() === 'win32' ? key.toUpperCase() : key;\n            // If Rush itself was invoked inside a lifecycle script, this may be set and would interfere\n            // with Rush's installations.  If we actually want it, we will set it explicitly below.\n            if (normalizedKey === 'INIT_CWD') {\n                continue;\n            }\n            // When NPM invokes a lifecycle event, it copies its entire configuration into environment\n            // variables.  Rush is supposed to be a deterministic controlled environment, so don't bring\n            // this along.\n            //\n            // NOTE: Longer term we should clean out the entire environment and use rush.json to bring\n            // back specific environment variables that the repo maintainer has determined to be safe.\n            if (normalizedKey.match(/^NPM_CONFIG_/)) {\n                continue;\n            }\n            // Use the uppercased environment variable name on Windows because environment variable names\n            // are case-insensitive on Windows\n            environment[normalizedKey] = options.initialEnvironment[key];\n        }\n        // When NPM invokes a lifecycle script, it sets an environment variable INIT_CWD that remembers\n        // the directory that NPM started in.  This allows naive scripts to change their current working directory\n        // and invoke NPM operations, while still be able to find a local .npmrc file.  Although Rush recommends\n        // for toolchain scripts to be professionally written (versus brittle stuff like\n        // \"cd ./lib && npm run tsc && cd ..\"), we support INIT_CWD for compatibility.\n        //\n        // More about this feature: https://github.com/npm/npm/pull/12356\n        if (options.initCwd) {\n            environment['INIT_CWD'] = options.initCwd; // eslint-disable-line dot-notation\n        }\n        if (options.pathOptions) {\n            if (options.pathOptions.includeRepoBin && options.pathOptions.commonTempFolder) {\n                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.commonTempFolder);\n            }\n            if (options.pathOptions.includeProjectBin && options.pathOptions.projectRoot) {\n                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.projectRoot);\n            }\n            if (options.pathOptions.additionalPathFolders) {\n                environment.PATH = [...options.pathOptions.additionalPathFolders, environment.PATH].join(path.delimiter);\n            }\n        }\n        // Communicate to downstream calls that they should not try to run hooks\n        environment[EnvironmentVariableNames._RUSH_RECURSIVE_RUSHX_CALL] = '1';\n        return environment;\n    }\n    /**\n     * Prepend the node_modules/.bin folder under the specified folder to the specified PATH variable. For example,\n     * if `rootDirectory` is \"/foobar\" and `existingPath` is \"/bin\", this function will return\n     * \"/foobar/node_modules/.bin:/bin\"\n     */\n    static _prependNodeModulesBinToPath(existingPath, rootDirectory) {\n        const binPath = path.resolve(rootDirectory, 'node_modules', '.bin');\n        if (existingPath) {\n            return `${binPath}${path.delimiter}${existingPath}`;\n        }\n        else {\n            return binPath;\n        }\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     */\n    static async _executeCommandInternalAsync({ command, args, workingDirectory, stdio, environment, keepEnvironment, onStdoutStreamChunk, captureOutput, captureExitCodeAndSignal }) {\n        var _a;\n        const options = {\n            cwd: workingDirectory,\n            shell: true,\n            stdio: stdio,\n            env: keepEnvironment\n                ? environment\n                : Utilities._createEnvironmentForRushCommand({ initialEnvironment: environment }),\n            maxBuffer: 10 * 1024 * 1024 // Set default max buffer size to 10MB\n        };\n        // This is needed since we specify shell=true below.\n        // NOTE: On Windows if we escape \"NPM\", the spawnSync() function runs something like this:\n        //   [ 'C:\\\\Windows\\\\system32\\\\cmd.exe', '/s', '/c', '\"\"NPM\" \"install\"\"' ]\n        //\n        // Due to a bug with Windows cmd.exe, the npm.cmd batch file's \"%~dp0\" variable will\n        // return the current working directory instead of the batch file's directory.\n        // The workaround is to not escape, npm, i.e. do this instead:\n        //   [ 'C:\\\\Windows\\\\system32\\\\cmd.exe', '/s', '/c', '\"npm \"install\"\"' ]\n        //\n        // We will come up with a better solution for this when we promote executeCommand()\n        // into node-core-library, but for now this hack will unblock people:\n        // Only escape the command if it actually contains spaces:\n        const escapedCommand = command.indexOf(' ') < 0 ? command : Utilities.escapeShellParameter(command);\n        const escapedArgs = args.map((x) => Utilities.escapeShellParameter(x));\n        const childProcess = child_process.spawn(escapedCommand, escapedArgs, options);\n        if (onStdoutStreamChunk) {\n            const inspectStream = new Transform({\n                transform: onStdoutStreamChunk\n                    ? (chunk, encoding, callback) => {\n                        const chunkString = chunk.toString();\n                        const updatedChunk = onStdoutStreamChunk(chunkString);\n                        callback(undefined, updatedChunk !== null && updatedChunk !== void 0 ? updatedChunk : chunk);\n                    }\n                    : undefined\n            });\n            (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.pipe(inspectStream).pipe(process.stdout);\n        }\n        return await Executable.waitForExitAsync(childProcess, {\n            encoding: captureOutput ? 'utf8' : undefined,\n            throwOnNonZeroExitCode: !captureExitCodeAndSignal,\n            throwOnSignal: !captureExitCodeAndSignal\n        });\n    }\n    static _processResult({ error, stderr, status }) {\n        if (error) {\n            error.message += `\\n${stderr}`;\n            if (status) {\n                error.message += `\\nExited with status ${status}`;\n            }\n            throw error;\n        }\n        if (status) {\n            throw new Error(`The command failed with exit code ${status}\\n${stderr}`);\n        }\n    }\n}\nUtilities.syncNpmrc = syncNpmrc;\n//# sourceMappingURL=Utilities.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n// IMPORTANT - do not use any non-built-in libraries in this file\nimport * as fs from 'fs';\nimport * as path from 'path';\n/**\n * This function reads the content for given .npmrc file path, and also trims\n * unusable lines from the .npmrc file.\n *\n * @returns\n * The text of the the .npmrc.\n */\n// create a global _combinedNpmrc for cache purpose\nconst _combinedNpmrcMap = new Map();\nfunction _trimNpmrcFile(options) {\n    const { sourceNpmrcPath, linesToPrepend, linesToAppend, supportEnvVarFallbackSyntax } = options;\n    const combinedNpmrcFromCache = _combinedNpmrcMap.get(sourceNpmrcPath);\n    if (combinedNpmrcFromCache !== undefined) {\n        return combinedNpmrcFromCache;\n    }\n    let npmrcFileLines = [];\n    if (linesToPrepend) {\n        npmrcFileLines.push(...linesToPrepend);\n    }\n    if (fs.existsSync(sourceNpmrcPath)) {\n        npmrcFileLines.push(...fs.readFileSync(sourceNpmrcPath).toString().split('\\n'));\n    }\n    if (linesToAppend) {\n        npmrcFileLines.push(...linesToAppend);\n    }\n    npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());\n    const resultLines = trimNpmrcFileLines(npmrcFileLines, process.env, supportEnvVarFallbackSyntax);\n    const combinedNpmrc = resultLines.join('\\n');\n    //save the cache\n    _combinedNpmrcMap.set(sourceNpmrcPath, combinedNpmrc);\n    return combinedNpmrc;\n}\n/**\n *\n * @param npmrcFileLines The npmrc file's lines\n * @param env The environment variables object\n * @param supportEnvVarFallbackSyntax Whether to support fallback values in the form of `${VAR_NAME:-fallback}`\n * @returns\n */\nexport function trimNpmrcFileLines(npmrcFileLines, env, supportEnvVarFallbackSyntax) {\n    var _a;\n    const resultLines = [];\n    // This finds environment variable tokens that look like \"${VAR_NAME}\"\n    const expansionRegExp = /\\$\\{([^\\}]+)\\}/g;\n    // Comment lines start with \"#\" or \";\"\n    const commentRegExp = /^\\s*[#;]/;\n    // Trim out lines that reference environment variables that aren't defined\n    for (let line of npmrcFileLines) {\n        let lineShouldBeTrimmed = false;\n        //remove spaces before or after key and value\n        line = line\n            .split('=')\n            .map((lineToTrim) => lineToTrim.trim())\n            .join('=');\n        // Ignore comment lines\n        if (!commentRegExp.test(line)) {\n            const environmentVariables = line.match(expansionRegExp);\n            if (environmentVariables) {\n                for (const token of environmentVariables) {\n                    /**\n                     * Remove the leading \"${\" and the trailing \"}\" from the token\n                     *\n                     * ${nameString}                  -> nameString\n                     * ${nameString-fallbackString}   -> name-fallbackString\n                     * ${nameString:-fallbackString}  -> name:-fallbackString\n                     */\n                    const nameWithFallback = token.substring(2, token.length - 1);\n                    let environmentVariableName;\n                    let fallback;\n                    if (supportEnvVarFallbackSyntax) {\n                        /**\n                         * Get the environment variable name and fallback value.\n                         *\n                         *                                name          fallback\n                         * nameString                 ->  nameString    undefined\n                         * nameString-fallbackString  ->  nameString    fallbackString\n                         * nameString:-fallbackString ->  nameString    fallbackString\n                         */\n                        const matched = nameWithFallback.match(/^([^:-]+)(?:\\:?-(.+))?$/);\n                        // matched: [originStr, variableName, fallback]\n                        environmentVariableName = (_a = matched === null || matched === void 0 ? void 0 : matched[1]) !== null && _a !== void 0 ? _a : nameWithFallback;\n                        fallback = matched === null || matched === void 0 ? void 0 : matched[2];\n                    }\n                    else {\n                        environmentVariableName = nameWithFallback;\n                    }\n                    // Is the environment variable and fallback value defined.\n                    if (!env[environmentVariableName] && !fallback) {\n                        // No, so trim this line\n                        lineShouldBeTrimmed = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (lineShouldBeTrimmed) {\n            // Example output:\n            // \"; MISSING ENVIRONMENT VARIABLE: //my-registry.com/npm/:_authToken=${MY_AUTH_TOKEN}\"\n            resultLines.push('; MISSING ENVIRONMENT VARIABLE: ' + line);\n        }\n        else {\n            resultLines.push(line);\n        }\n    }\n    return resultLines;\n}\nfunction _copyAndTrimNpmrcFile(options) {\n    const { logger, sourceNpmrcPath, targetNpmrcPath } = options;\n    logger.info(`Transforming ${sourceNpmrcPath}`); // Verbose\n    logger.info(`  --> \"${targetNpmrcPath}\"`);\n    const combinedNpmrc = _trimNpmrcFile(options);\n    fs.writeFileSync(targetNpmrcPath, combinedNpmrc);\n    return combinedNpmrc;\n}\nexport function syncNpmrc(options) {\n    const { sourceNpmrcFolder, targetNpmrcFolder, useNpmrcPublish, logger = {\n        // eslint-disable-next-line no-console\n        info: console.log,\n        // eslint-disable-next-line no-console\n        error: console.error\n    }, createIfMissing = false } = options;\n    const sourceNpmrcPath = path.join(sourceNpmrcFolder, !useNpmrcPublish ? '.npmrc' : '.npmrc-publish');\n    const targetNpmrcPath = path.join(targetNpmrcFolder, '.npmrc');\n    try {\n        if (fs.existsSync(sourceNpmrcPath) || createIfMissing) {\n            // Ensure the target folder exists\n            if (!fs.existsSync(targetNpmrcFolder)) {\n                fs.mkdirSync(targetNpmrcFolder, { recursive: true });\n            }\n            return _copyAndTrimNpmrcFile(Object.assign({ sourceNpmrcPath,\n                targetNpmrcPath,\n                logger }, options));\n        }\n        else if (fs.existsSync(targetNpmrcPath)) {\n            // If the source .npmrc doesn't exist and there is one in the target, delete the one in the target\n            logger.info(`Deleting ${targetNpmrcPath}`); // Verbose\n            fs.unlinkSync(targetNpmrcPath);\n        }\n    }\n    catch (e) {\n        throw new Error(`Error syncing .npmrc file: ${e}`);\n    }\n}\nexport function isVariableSetInNpmrcFile(sourceNpmrcFolder, variableKey, supportEnvVarFallbackSyntax) {\n    const sourceNpmrcPath = `${sourceNpmrcFolder}/.npmrc`;\n    //if .npmrc file does not exist, return false directly\n    if (!fs.existsSync(sourceNpmrcPath)) {\n        return false;\n    }\n    const trimmedNpmrcFile = _trimNpmrcFile({ sourceNpmrcPath, supportEnvVarFallbackSyntax });\n    const variableKeyRegExp = new RegExp(`^${variableKey}=`, 'm');\n    return trimmedNpmrcFile.match(variableKeyRegExp) !== null;\n}\n//# sourceMappingURL=npmrcUtilities.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Determines if two objects are deeply equal.\n */\nexport function objectsAreDeepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else {\n        const aType = typeof a;\n        const bType = typeof b;\n        if (aType !== bType) {\n            return false;\n        }\n        else {\n            if (aType === 'object') {\n                if (a === null || b === null) {\n                    // We already handled the case where a === b, so if either is null, they are not equal\n                    return false;\n                }\n                else if (Array.isArray(a)) {\n                    if (!Array.isArray(b) || a.length !== b.length) {\n                        return false;\n                    }\n                    else {\n                        for (let i = 0; i < a.length; ++i) {\n                            if (!objectsAreDeepEqual(a[i], b[i])) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                }\n                else {\n                    const aObjectProperties = new Set(Object.getOwnPropertyNames(a));\n                    const bObjectProperties = new Set(Object.getOwnPropertyNames(b));\n                    if (aObjectProperties.size !== bObjectProperties.size) {\n                        return false;\n                    }\n                    else {\n                        for (const property of aObjectProperties) {\n                            if (bObjectProperties.delete(property)) {\n                                if (!objectsAreDeepEqual(a[property], b[property])) {\n                                    return false;\n                                }\n                            }\n                            else {\n                                return false;\n                            }\n                        }\n                        return bObjectProperties.size === 0;\n                    }\n                }\n            }\n            else {\n                return false;\n            }\n        }\n    }\n}\nexport function cloneDeep(obj) {\n    return cloneDeepInner(obj, new Set());\n}\nexport function merge(base, other) {\n    if (typeof other === 'object' && other !== null && !Array.isArray(other)) {\n        for (const [key, value] of Object.entries(other)) {\n            if (key in base) {\n                const baseValue = base[key];\n                if (typeof baseValue === 'object' && baseValue !== null && !Array.isArray(baseValue)) {\n                    base[key] = merge(baseValue, value);\n                }\n                else {\n                    base[key] = value;\n                }\n            }\n            else {\n                base[key] = value;\n            }\n        }\n        return base;\n    }\n    else {\n        return other;\n    }\n}\nfunction cloneDeepInner(obj, seenObjects) {\n    if (seenObjects.has(obj)) {\n        throw new Error('Circular reference detected');\n    }\n    else if (typeof obj === 'object') {\n        if (obj === null) {\n            return null;\n        }\n        else {\n            seenObjects.add(obj);\n            if (Array.isArray(obj)) {\n                const result = [];\n                for (const item of obj) {\n                    result.push(cloneDeepInner(item, new Set(seenObjects)));\n                }\n                return result;\n            }\n            else {\n                const result = {};\n                for (const key of Object.getOwnPropertyNames(obj)) {\n                    const value = obj[key];\n                    result[key] = cloneDeepInner(value, new Set(seenObjects));\n                }\n                return result;\n            }\n        }\n    }\n    else {\n        return obj;\n    }\n}\n/**\n * Performs a partial deep comparison between `obj` and `source` to\n * determine if `obj` contains equivalent property values.\n */\nexport function isMatch(obj, source) {\n    return obj === source || (typeof obj === typeof source && isMatchInner(obj, source));\n}\nfunction isMatchInner(obj, source) {\n    if (obj === null || obj === undefined) {\n        return false;\n    }\n    for (const k of Object.keys(source)) {\n        const key = k;\n        const sourceValue = source[key];\n        if (isStrictComparable(sourceValue)) {\n            if (obj[key] !== sourceValue) {\n                return false;\n            }\n        }\n        else if (!isMatchInner(obj[key], sourceValue)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Check if `value` is suitable for strict equality comparisons, i.e. `===`.\n */\nfunction isStrictComparable(value) {\n    const type = typeof value;\n    return (\n    // eslint-disable-next-line no-self-compare\n    value === value && !(value !== null && value !== undefined && (type === 'object' || type === 'function')));\n}\n/**\n * Removes `undefined` and `null` direct properties from an object.\n *\n * @remarks\n * Note that this does not recurse through sub-objects.\n */\nexport function removeNullishProps(obj) {\n    const result = {};\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            if (obj[key] !== undefined && obj[key] !== null) {\n                result[key] = obj[key];\n            }\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=objectUtilities.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport { FileSystem, InternalError, NewlineKind } from '@rushstack/node-core-library';\nimport { Colorize } from '@rushstack/terminal';\nimport { Rush } from '../api/Rush';\n// Matches a well-formed BEGIN macro starting a block section.\n// Example:  /*[BEGIN \"DEMO\"]*/\n//\n// Group #1 is the indentation spaces before the macro\n// Group #2 is the section name\nconst BEGIN_MARCO_REGEXP = /^(\\s*)\\/\\*\\[BEGIN \"([A-Z]+)\"\\]\\s*\\*\\/\\s*$/;\n// Matches a well-formed END macro ending a block section.\n// Example:  /*[END \"DEMO\"]*/\n//\n// Group #1 is the indentation spaces before the macro\n// Group #2 is the section name\nconst END_MACRO_REGEXP = /^(\\s*)\\/\\*\\[END \"([A-Z]+)\"\\]\\s*\\*\\/\\s*$/;\n// Matches a well-formed single-line section, including the space character after it\n// if present.\n// Example:  /*[LINE \"HYPOTHETICAL\"]*/\n//\n// Group #1 is the section name\nconst LINE_MACRO_REGEXP = /\\/\\*\\[LINE \"([A-Z]+)\"\\]\\s*\\*\\/\\s?/;\n// Matches a variable expansion.\n// Example:  [%RUSH_VERSION%]\n//\n// Group #1 is the variable name including the dollar sign\nconst VARIABLE_MACRO_REGEXP = /\\[(%[A-Z0-9_]+%)\\]/;\n// Matches anything that starts with \"/*[\" and ends with \"]*/\"\n// Used to catch malformed macro expressions\nconst ANY_MACRO_REGEXP = /\\/\\*\\s*\\[.*\\]\\s*\\*\\//;\n// Copy the template from sourcePath, transform any macros, and write the output to destinationPath.\n//\n// We implement a simple template engine.  \"Single-line section\" macros have this form:\n//\n//     /*[LINE \"NAME\"]*/ (content goes here)\n//\n// ...and when commented out will look like this:\n//\n//     // (content goes here)\n//\n// \"Block section\" macros have this form:\n//\n//     /*[BEGIN \"NAME\"]*/\n//     (content goes\n//     here)\n//     /*[END \"NAME\"]*/\n//\n// ...and when commented out will look like this:\n//\n//     // (content goes\n//     // here)\n//\n// Lastly, a variable expansion has this form:\n//\n//     // The value is [%NAME%].\n//\n// ...and when expanded with e.g. \"123\" will look like this:\n//\n//     // The value is 123.\n//\n// The section names must be one of the predefined names used by \"rush init\".\n// A single-line section may appear inside a block section, in which case it will get\n// commented twice.\nexport async function copyTemplateFileAsync(sourcePath, destinationPath, overwrite, demo = false) {\n    const destinationFileExists = await FileSystem.existsAsync(destinationPath);\n    if (!overwrite) {\n        if (destinationFileExists) {\n            // eslint-disable-next-line no-console\n            console.log(Colorize.yellow('Not overwriting already existing file: ') + destinationPath);\n            return;\n        }\n    }\n    if (destinationFileExists) {\n        // eslint-disable-next-line no-console\n        console.log(Colorize.yellow(`Overwriting: ${destinationPath}`));\n    }\n    else {\n        // eslint-disable-next-line no-console\n        console.log(`Generating: ${destinationPath}`);\n    }\n    const outputLines = [];\n    const lines = (await FileSystem.readFileAsync(sourcePath, { convertLineEndings: NewlineKind.Lf })).split('\\n');\n    let activeBlockSectionName = undefined;\n    let activeBlockIndent = '';\n    for (const line of lines) {\n        let match;\n        // Check for a block section start\n        // Example:  /*[BEGIN \"DEMO\"]*/\n        match = line.match(BEGIN_MARCO_REGEXP);\n        if (match) {\n            if (activeBlockSectionName) {\n                // If this happens, please report a Rush bug\n                throw new InternalError(`The template contains an unmatched BEGIN macro for \"${activeBlockSectionName}\"`);\n            }\n            activeBlockSectionName = match[2];\n            activeBlockIndent = match[1];\n            // Remove the entire line containing the macro\n            continue;\n        }\n        // Check for a block section end\n        // Example:  /*[END \"DEMO\"]*/\n        match = line.match(END_MACRO_REGEXP);\n        if (match) {\n            if (activeBlockSectionName === undefined) {\n                // If this happens, please report a Rush bug\n                throw new InternalError(`The template contains an unmatched END macro for \"${activeBlockSectionName}\"`);\n            }\n            if (activeBlockSectionName !== match[2]) {\n                // If this happens, please report a Rush bug\n                throw new InternalError(`The template contains an mismatched END macro for \"${activeBlockSectionName}\"`);\n            }\n            if (activeBlockIndent !== match[1]) {\n                // If this happens, please report a Rush bug\n                throw new InternalError(`The template contains an inconsistently indented section \"${activeBlockSectionName}\"`);\n            }\n            activeBlockSectionName = undefined;\n            // Remove the entire line containing the macro\n            continue;\n        }\n        let transformedLine = line;\n        // Check for a single-line section\n        // Example:  /*[LINE \"HYPOTHETICAL\"]*/\n        match = transformedLine.match(LINE_MACRO_REGEXP);\n        if (match) {\n            const sectionName = match[1];\n            const replacement = _isSectionCommented(sectionName, demo) ? '// ' : '';\n            transformedLine = transformedLine.replace(LINE_MACRO_REGEXP, replacement);\n        }\n        // Check for variable expansions\n        // Example:  [%RUSH_VERSION%]\n        while ((match = transformedLine.match(VARIABLE_MACRO_REGEXP))) {\n            const variableName = match[1];\n            const replacement = _expandMacroVariable(variableName);\n            transformedLine = transformedLine.replace(VARIABLE_MACRO_REGEXP, replacement);\n        }\n        // Verify that all macros were handled\n        match = transformedLine.match(ANY_MACRO_REGEXP);\n        if (match) {\n            // If this happens, please report a Rush bug\n            throw new InternalError('The template contains a malformed macro expression: ' + JSON.stringify(match[0]));\n        }\n        // If we are inside a block section that is commented out, then insert the \"//\" after indentation\n        if (activeBlockSectionName !== undefined) {\n            if (_isSectionCommented(activeBlockSectionName, demo)) {\n                // Is the line indented properly?\n                if (transformedLine.substr(0, activeBlockIndent.length).trim().length > 0) {\n                    // If this happens, please report a Rush bug\n                    throw new InternalError(`The template contains inconsistently indented lines inside` +\n                        ` the \"${activeBlockSectionName}\" section`);\n                }\n                // Insert comment characters after the indentation\n                const contentAfterIndent = transformedLine.substr(activeBlockIndent.length);\n                transformedLine = activeBlockIndent + '// ' + contentAfterIndent;\n            }\n        }\n        outputLines.push(transformedLine);\n    }\n    // Write the output\n    await FileSystem.writeFileAsync(destinationPath, outputLines.join('\\n'), {\n        ensureFolderExists: true\n    });\n}\nfunction _isSectionCommented(sectionName, demo) {\n    // The \"HYPOTHETICAL\" sections are always commented out by \"rush init\".\n    // They are uncommented in the \"assets\" source folder so that we can easily validate\n    // that they conform to their JSON schema.\n    if (sectionName === 'HYPOTHETICAL')\n        return true;\n    if (sectionName === 'DEMO')\n        return demo;\n    // If this happens, please report a Rush bug\n    throw new InternalError(`The template references an undefined section name ${sectionName}`);\n}\nfunction _expandMacroVariable(variableName) {\n    switch (variableName) {\n        case '%RUSH_VERSION%':\n            return Rush.version;\n        default:\n            throw new InternalError(`The template references an undefined variable \"${variableName}\"`);\n    }\n}\n//# sourceMappingURL=templateUtilities.js.map"],"names":[],"sourceRoot":""}