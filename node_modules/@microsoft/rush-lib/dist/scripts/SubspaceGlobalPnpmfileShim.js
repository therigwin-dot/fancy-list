/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 16928:
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*************************************************************!*\
  !*** ./lib-esnext/logic/pnpm/SubspaceGlobalPnpmfileShim.js ***!
  \*************************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hooks: () => (/* binding */ hooks)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ 16928);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var _a;
// The "rush install" or "rush update" commands will copy this template to
// "common/temp-split/global-pnpmfile.js" so that it can implement Rush-specific features.
// It reads its input data from "common/temp/pnpmfileSettings.json". The pnpmfile is
// required directly by this shim and is called after Rush's transformations are applied.

let settings;
let userPnpmfile;
let semver;
// Initialize all external aspects of the pnpmfile shim. When using the shim, settings
// are always expected to be available. Init must be called before running any hook that
// depends on a resource obtained from or related to the settings, and will require modules
// once so they aren't repeatedly required in the hook functions.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function init(context) {
    // Sometimes PNPM may provide us a context arg that doesn't fit spec, ex.:
    // https://github.com/pnpm/pnpm/blob/97c64bae4d14a8c8f05803f1d94075ee29c2df2f/packages/get-context/src/index.ts#L134
    // So we need to normalize the context format before we move on
    if (typeof context !== 'object' || Array.isArray(context)) {
        context = {
            log: (message) => { },
            originalContext: context
        };
    }
    if (!settings) {
        // Initialize the settings from file
        if (!context.splitWorkspacePnpmfileShimSettings) {
            context.splitWorkspacePnpmfileShimSettings = require('./pnpmfileSettings.json');
        }
        settings = context.splitWorkspacePnpmfileShimSettings;
    }
    else if (!context.splitWorkspacePnpmfileShimSettings) {
        // Reuse the already initialized settings
        context.splitWorkspacePnpmfileShimSettings = settings;
    }
    // If a userPnpmfilePath is provided, we expect it to exist
    if (!userPnpmfile && settings.userPnpmfilePath) {
        userPnpmfile = require(settings.userPnpmfilePath);
    }
    // If a semverPath is provided, we expect it to exist
    if (!semver && settings.semverPath) {
        semver = require(settings.semverPath);
    }
    // Return the normalized context
    return context;
}
// Rewrite rush project referenced in split workspace.
// For example: "project-a": "workspace:*" --> "project-a": "link:../../project-a"
function rewriteRushProjectVersions(packageName, dependencies) {
    if (!dependencies) {
        return;
    }
    if (!settings) {
        throw new Error(`splitWorkspaceGlobalPnpmfileShimSettings not initialized`);
    }
    const workspaceProject = settings.subspaceProjects[packageName] || settings.workspaceProjects[packageName];
    if (!workspaceProject) {
        return;
    }
    for (const dependencyName of Object.keys(dependencies)) {
        const currentVersion = dependencies[dependencyName];
        if (currentVersion.startsWith('workspace:')) {
            const workspaceProjectInfo = settings.workspaceProjects[dependencyName];
            if (workspaceProjectInfo) {
                // Case 1. "<package_name>": "workspace:*"
                let workspaceVersionProtocol = 'link:';
                const injectedDependenciesSet = new Set(workspaceProject.injectedDependencies);
                if (injectedDependenciesSet.has(dependencyName)) {
                    workspaceVersionProtocol = 'file:';
                }
                let relativePath = path__WEBPACK_IMPORTED_MODULE_0___default().normalize(path__WEBPACK_IMPORTED_MODULE_0___default().relative(workspaceProject.projectRelativeFolder, workspaceProjectInfo.projectRelativeFolder));
                // convert path in posix style, otherwise pnpm install will fail in subspace case
                relativePath = relativePath.split((path__WEBPACK_IMPORTED_MODULE_0___default().sep)).join((path__WEBPACK_IMPORTED_MODULE_0___default().posix).sep);
                const newVersion = workspaceVersionProtocol + relativePath;
                dependencies[dependencyName] = newVersion;
            }
            else {
                // Case 2. "<alias>": "workspace:<aliased_package_name>@<version>"
                const packageSpec = currentVersion.slice('workspace:'.length);
                const nameEndsAt = packageSpec[0] === '@' ? packageSpec.slice(1).indexOf('@') + 1 : packageSpec.indexOf('@');
                const aliasedPackageName = nameEndsAt > 0 ? packageSpec.slice(0, nameEndsAt) : packageSpec;
                // const depVersion: string = nameEndsAt > 0 ? packageSpec.slice(nameEndsAt + 1) : '';
                const aliasedWorkspaceProjectInfo = settings.workspaceProjects[aliasedPackageName];
                if (aliasedWorkspaceProjectInfo) {
                    const relativePath = path__WEBPACK_IMPORTED_MODULE_0___default().normalize(path__WEBPACK_IMPORTED_MODULE_0___default().relative(workspaceProject.projectRelativeFolder, aliasedWorkspaceProjectInfo.projectRelativeFolder));
                    const newVersion = 'link:' + relativePath;
                    dependencies[dependencyName] = newVersion;
                }
            }
        }
        else if (currentVersion.startsWith('npm:')) {
            // Case 3. "<alias>": "npm:<package_name>@<dep_version>"
            const packageSpec = currentVersion.slice('npm:'.length);
            const nameEndsAt = packageSpec[0] === '@' ? packageSpec.slice(1).indexOf('@') + 1 : packageSpec.indexOf('@');
            const aliasedPackageName = nameEndsAt > 0 ? packageSpec.slice(0, nameEndsAt) : packageSpec;
            // const depVersion: string = nameEndsAt > 0 ? packageSpec.slice(nameEndsAt + 1) : '';
            const aliasedWorkspaceProjectInfo = settings.workspaceProjects[aliasedPackageName];
            if (aliasedWorkspaceProjectInfo) {
                const relativePath = path__WEBPACK_IMPORTED_MODULE_0___default().normalize(path__WEBPACK_IMPORTED_MODULE_0___default().relative(workspaceProject.projectRelativeFolder, aliasedWorkspaceProjectInfo.projectRelativeFolder));
                const newVersion = 'link:' + relativePath;
                dependencies[dependencyName] = newVersion;
            }
        }
    }
}
const hooks = {
    // Call the original pnpmfile (if it exists)
    afterAllResolved: (lockfile, context) => {
        var _a;
        context = init(context);
        return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.afterAllResolved)
            ? userPnpmfile.hooks.afterAllResolved(lockfile, context)
            : lockfile;
    },
    // Rewrite workspace protocol to link protocol for non split workspace projects
    readPackage: (pkg, context) => {
        var _a;
        context = init(context);
        rewriteRushProjectVersions(pkg.name, pkg.dependencies);
        rewriteRushProjectVersions(pkg.name, pkg.devDependencies);
        return ((_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.readPackage) ? userPnpmfile.hooks.readPackage(pkg, context) : pkg;
    },
    // Call the original pnpmfile (if it exists)
    filterLog: (_a = userPnpmfile === null || userPnpmfile === void 0 ? void 0 : userPnpmfile.hooks) === null || _a === void 0 ? void 0 : _a.filterLog
};
//# sourceMappingURL=SubspaceGlobalPnpmfileShim.js.map
})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=SubspaceGlobalPnpmfileShim.js.map