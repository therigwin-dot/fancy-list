// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * This is a tool for determining if a set of paths overlap. For example 'lib' and 'lib/x' overlap,
 * 'lib/x' and 'lib/y' do not.
 */
export class OverlappingPathAnalyzer {
    constructor() {
        this._root = {
            encounteredLabels: new Set(),
            paths: {}
        };
    }
    addPathAndGetFirstEncounteredLabels(path, label) {
        const pathParts = path.split('/');
        let currentNode = this._root;
        let currentNodeIsNew = false;
        let labelWasAlreadyPresentInCurrentNode = false;
        for (const pathPart of pathParts) {
            if (pathPart === '') {
                continue;
            }
            if (currentNode.label) {
                return [currentNode.label];
            }
            if (!currentNode.paths[pathPart]) {
                currentNodeIsNew = true;
                currentNode = currentNode.paths[pathPart] = {
                    encounteredLabels: new Set(),
                    paths: {}
                };
            }
            else {
                currentNodeIsNew = false;
                currentNode = currentNode.paths[pathPart];
            }
            labelWasAlreadyPresentInCurrentNode = currentNode.encounteredLabels.has(label);
            if (!labelWasAlreadyPresentInCurrentNode) {
                currentNode.encounteredLabels.add(label);
            }
        }
        if (currentNodeIsNew) {
            currentNode.label = label;
            return undefined;
        }
        else if (labelWasAlreadyPresentInCurrentNode) {
            return Array.from(currentNode.encounteredLabels);
        }
        else {
            const clonedEncounteredLabels = new Set(currentNode.encounteredLabels);
            clonedEncounteredLabels.delete(label);
            return Array.from(clonedEncounteredLabels);
        }
    }
}
//# sourceMappingURL=OverlappingPathAnalyzer.js.map