// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
// IMPORTANT - do not use any non-built-in libraries in this file
import * as fs from 'fs';
import * as path from 'path';
/**
 * This function reads the content for given .npmrc file path, and also trims
 * unusable lines from the .npmrc file.
 *
 * @returns
 * The text of the the .npmrc.
 */
// create a global _combinedNpmrc for cache purpose
const _combinedNpmrcMap = new Map();
function _trimNpmrcFile(options) {
    const { sourceNpmrcPath, linesToPrepend, linesToAppend, supportEnvVarFallbackSyntax } = options;
    const combinedNpmrcFromCache = _combinedNpmrcMap.get(sourceNpmrcPath);
    if (combinedNpmrcFromCache !== undefined) {
        return combinedNpmrcFromCache;
    }
    let npmrcFileLines = [];
    if (linesToPrepend) {
        npmrcFileLines.push(...linesToPrepend);
    }
    if (fs.existsSync(sourceNpmrcPath)) {
        npmrcFileLines.push(...fs.readFileSync(sourceNpmrcPath).toString().split('\n'));
    }
    if (linesToAppend) {
        npmrcFileLines.push(...linesToAppend);
    }
    npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());
    const resultLines = trimNpmrcFileLines(npmrcFileLines, process.env, supportEnvVarFallbackSyntax);
    const combinedNpmrc = resultLines.join('\n');
    //save the cache
    _combinedNpmrcMap.set(sourceNpmrcPath, combinedNpmrc);
    return combinedNpmrc;
}
/**
 *
 * @param npmrcFileLines The npmrc file's lines
 * @param env The environment variables object
 * @param supportEnvVarFallbackSyntax Whether to support fallback values in the form of `${VAR_NAME:-fallback}`
 * @returns
 */
export function trimNpmrcFileLines(npmrcFileLines, env, supportEnvVarFallbackSyntax) {
    var _a;
    const resultLines = [];
    // This finds environment variable tokens that look like "${VAR_NAME}"
    const expansionRegExp = /\$\{([^\}]+)\}/g;
    // Comment lines start with "#" or ";"
    const commentRegExp = /^\s*[#;]/;
    // Trim out lines that reference environment variables that aren't defined
    for (let line of npmrcFileLines) {
        let lineShouldBeTrimmed = false;
        //remove spaces before or after key and value
        line = line
            .split('=')
            .map((lineToTrim) => lineToTrim.trim())
            .join('=');
        // Ignore comment lines
        if (!commentRegExp.test(line)) {
            const environmentVariables = line.match(expansionRegExp);
            if (environmentVariables) {
                for (const token of environmentVariables) {
                    /**
                     * Remove the leading "${" and the trailing "}" from the token
                     *
                     * ${nameString}                  -> nameString
                     * ${nameString-fallbackString}   -> name-fallbackString
                     * ${nameString:-fallbackString}  -> name:-fallbackString
                     */
                    const nameWithFallback = token.substring(2, token.length - 1);
                    let environmentVariableName;
                    let fallback;
                    if (supportEnvVarFallbackSyntax) {
                        /**
                         * Get the environment variable name and fallback value.
                         *
                         *                                name          fallback
                         * nameString                 ->  nameString    undefined
                         * nameString-fallbackString  ->  nameString    fallbackString
                         * nameString:-fallbackString ->  nameString    fallbackString
                         */
                        const matched = nameWithFallback.match(/^([^:-]+)(?:\:?-(.+))?$/);
                        // matched: [originStr, variableName, fallback]
                        environmentVariableName = (_a = matched === null || matched === void 0 ? void 0 : matched[1]) !== null && _a !== void 0 ? _a : nameWithFallback;
                        fallback = matched === null || matched === void 0 ? void 0 : matched[2];
                    }
                    else {
                        environmentVariableName = nameWithFallback;
                    }
                    // Is the environment variable and fallback value defined.
                    if (!env[environmentVariableName] && !fallback) {
                        // No, so trim this line
                        lineShouldBeTrimmed = true;
                        break;
                    }
                }
            }
        }
        if (lineShouldBeTrimmed) {
            // Example output:
            // "; MISSING ENVIRONMENT VARIABLE: //my-registry.com/npm/:_authToken=${MY_AUTH_TOKEN}"
            resultLines.push('; MISSING ENVIRONMENT VARIABLE: ' + line);
        }
        else {
            resultLines.push(line);
        }
    }
    return resultLines;
}
function _copyAndTrimNpmrcFile(options) {
    const { logger, sourceNpmrcPath, targetNpmrcPath } = options;
    logger.info(`Transforming ${sourceNpmrcPath}`); // Verbose
    logger.info(`  --> "${targetNpmrcPath}"`);
    const combinedNpmrc = _trimNpmrcFile(options);
    fs.writeFileSync(targetNpmrcPath, combinedNpmrc);
    return combinedNpmrc;
}
export function syncNpmrc(options) {
    const { sourceNpmrcFolder, targetNpmrcFolder, useNpmrcPublish, logger = {
        // eslint-disable-next-line no-console
        info: console.log,
        // eslint-disable-next-line no-console
        error: console.error
    }, createIfMissing = false } = options;
    const sourceNpmrcPath = path.join(sourceNpmrcFolder, !useNpmrcPublish ? '.npmrc' : '.npmrc-publish');
    const targetNpmrcPath = path.join(targetNpmrcFolder, '.npmrc');
    try {
        if (fs.existsSync(sourceNpmrcPath) || createIfMissing) {
            // Ensure the target folder exists
            if (!fs.existsSync(targetNpmrcFolder)) {
                fs.mkdirSync(targetNpmrcFolder, { recursive: true });
            }
            return _copyAndTrimNpmrcFile(Object.assign({ sourceNpmrcPath,
                targetNpmrcPath,
                logger }, options));
        }
        else if (fs.existsSync(targetNpmrcPath)) {
            // If the source .npmrc doesn't exist and there is one in the target, delete the one in the target
            logger.info(`Deleting ${targetNpmrcPath}`); // Verbose
            fs.unlinkSync(targetNpmrcPath);
        }
    }
    catch (e) {
        throw new Error(`Error syncing .npmrc file: ${e}`);
    }
}
export function isVariableSetInNpmrcFile(sourceNpmrcFolder, variableKey, supportEnvVarFallbackSyntax) {
    const sourceNpmrcPath = `${sourceNpmrcFolder}/.npmrc`;
    //if .npmrc file does not exist, return false directly
    if (!fs.existsSync(sourceNpmrcPath)) {
        return false;
    }
    const trimmedNpmrcFile = _trimNpmrcFile({ sourceNpmrcPath, supportEnvVarFallbackSyntax });
    const variableKeyRegExp = new RegExp(`^${variableKey}=`, 'm');
    return trimmedNpmrcFile.match(variableKeyRegExp) !== null;
}
//# sourceMappingURL=npmrcUtilities.js.map