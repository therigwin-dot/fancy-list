{"version":3,"file":"WebClient.js","sourceRoot":"","sources":["../../src/utilities/WebClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as os from 'os';\nimport * as process from 'process';\nimport type * as http from 'http';\nimport { request as httpRequest, type IncomingMessage } from 'node:http';\nimport { request as httpsRequest, type RequestOptions } from 'node:https';\nimport { Import, LegacyAdapters } from '@rushstack/node-core-library';\n\nconst createHttpsProxyAgent: typeof import('https-proxy-agent') = Import.lazy('https-proxy-agent', require);\n\n/**\n * For use with {@link WebClient}.\n */\nexport interface IWebClientResponse {\n  ok: boolean;\n  status: number;\n  statusText?: string;\n  redirected: boolean;\n  headers: Record<string, string | string[] | undefined>;\n  getTextAsync: () => Promise<string>;\n  getJsonAsync: <TJson>() => Promise<TJson>;\n  getBufferAsync: () => Promise<Buffer>;\n}\n\n/**\n * For use with {@link WebClient}.\n */\nexport interface IWebFetchOptionsBase {\n  timeoutMs?: number;\n  headers?: Record<string, string>;\n  redirect?: 'follow' | 'error' | 'manual';\n  /**\n   * If true, the response will not be decoded if a Content-Encoding header is present.\n   */\n  noDecode?: boolean;\n}\n\n/**\n * For use with {@link WebClient}.\n */\nexport interface IGetFetchOptions extends IWebFetchOptionsBase {\n  verb: 'GET' | never;\n}\n\n/**\n * For use with {@link WebClient}.\n */\nexport interface IFetchOptionsWithBody extends IWebFetchOptionsBase {\n  verb: 'PUT' | 'POST' | 'PATCH';\n  body?: Buffer;\n}\n\n/**\n * For use with {@link WebClient}.\n */\nexport enum WebClientProxy {\n  None,\n  Detect,\n  Fiddler\n}\nexport interface IRequestOptions\n  extends RequestOptions,\n    Pick<IFetchOptionsWithBody, 'body' | 'redirect' | 'noDecode'> {}\n\nexport type FetchFn = (\n  url: string,\n  options: IRequestOptions,\n  isRedirect?: boolean\n) => Promise<IWebClientResponse>;\n\nconst DEFLATE_ENCODING: 'deflate' = 'deflate';\nconst GZIP_ENCODING: 'gzip' = 'gzip';\nconst BROTLI_ENCODING: 'br' = 'br';\nexport const AUTHORIZATION_HEADER_NAME: 'Authorization' = 'Authorization';\nconst ACCEPT_HEADER_NAME: 'accept' = 'accept';\nconst USER_AGENT_HEADER_NAME: 'user-agent' = 'user-agent';\nconst CONTENT_ENCODING_HEADER_NAME: 'content-encoding' = 'content-encoding';\n\nconst makeRequestAsync: FetchFn = async (\n  url: string,\n  options: IRequestOptions,\n  redirected: boolean = false\n) => {\n  const { body, redirect, noDecode } = options;\n\n  return await new Promise(\n    (resolve: (result: IWebClientResponse) => void, reject: (error: Error) => void) => {\n      const parsedUrl: URL = typeof url === 'string' ? new URL(url) : url;\n      const requestFunction: typeof httpRequest | typeof httpsRequest =\n        parsedUrl.protocol === 'https:' ? httpsRequest : httpRequest;\n\n      requestFunction(url, options, (response: IncomingMessage) => {\n        const responseBuffers: (Buffer | Uint8Array)[] = [];\n        response.on('data', (chunk: string | Buffer | Uint8Array) => {\n          responseBuffers.push(Buffer.from(chunk));\n        });\n        response.on('end', () => {\n          // Handle retries by calling the method recursively with the redirect URL\n          const statusCode: number | undefined = response.statusCode;\n          if (statusCode === 301 || statusCode === 302) {\n            switch (redirect) {\n              case 'follow': {\n                const redirectUrl: string | string[] | undefined = response.headers.location;\n                if (redirectUrl) {\n                  makeRequestAsync(redirectUrl, options, true).then(resolve).catch(reject);\n                } else {\n                  reject(\n                    new Error(`Received status code ${response.statusCode} with no location header: ${url}`)\n                  );\n                }\n\n                break;\n              }\n              case 'error':\n                reject(new Error(`Received status code ${response.statusCode}: ${url}`));\n                return;\n            }\n          }\n\n          const responseData: Buffer = Buffer.concat(responseBuffers);\n          const status: number = response.statusCode || 0;\n          const statusText: string | undefined = response.statusMessage;\n          const headers: Record<string, string | string[] | undefined> = response.headers;\n\n          let bodyString: string | undefined;\n          let bodyJson: unknown | undefined;\n          let decodedBuffer: Buffer | undefined;\n          const result: IWebClientResponse = {\n            ok: status >= 200 && status < 300,\n            status,\n            statusText,\n            redirected,\n            headers,\n            getTextAsync: async () => {\n              if (bodyString === undefined) {\n                const buffer: Buffer = await result.getBufferAsync();\n                // eslint-disable-next-line require-atomic-updates\n                bodyString = buffer.toString();\n              }\n\n              return bodyString;\n            },\n            getJsonAsync: async <TJson>() => {\n              if (bodyJson === undefined) {\n                const text: string = await result.getTextAsync();\n                // eslint-disable-next-line require-atomic-updates\n                bodyJson = JSON.parse(text);\n              }\n\n              return bodyJson as TJson;\n            },\n            getBufferAsync: async () => {\n              // Determine if the buffer is compressed and decode it if necessary\n              if (decodedBuffer === undefined) {\n                let encodings: string | string[] | undefined = headers[CONTENT_ENCODING_HEADER_NAME];\n                if (!noDecode && encodings !== undefined) {\n                  const zlib: typeof import('zlib') = await import('zlib');\n                  if (!Array.isArray(encodings)) {\n                    encodings = encodings.split(',');\n                  }\n\n                  let buffer: Buffer = responseData;\n                  for (const encoding of encodings) {\n                    let decompressFn: (buffer: Buffer, callback: import('zlib').CompressCallback) => void;\n                    switch (encoding.trim()) {\n                      case DEFLATE_ENCODING: {\n                        decompressFn = zlib.inflate.bind(zlib);\n                        break;\n                      }\n                      case GZIP_ENCODING: {\n                        decompressFn = zlib.gunzip.bind(zlib);\n                        break;\n                      }\n                      case BROTLI_ENCODING: {\n                        decompressFn = zlib.brotliDecompress.bind(zlib);\n                        break;\n                      }\n                      default: {\n                        throw new Error(`Unsupported content-encoding: ${encodings}`);\n                      }\n                    }\n\n                    buffer = await LegacyAdapters.convertCallbackToPromise(decompressFn, buffer);\n                  }\n\n                  // eslint-disable-next-line require-atomic-updates\n                  decodedBuffer = buffer;\n                } else {\n                  decodedBuffer = responseData;\n                }\n              }\n\n              return decodedBuffer;\n            }\n          };\n          resolve(result);\n        });\n      })\n        .on('error', (error: Error) => {\n          reject(error);\n        })\n        .end(body);\n    }\n  );\n};\n\n/**\n * A helper for issuing HTTP requests.\n */\nexport class WebClient {\n  private static _requestFn: FetchFn = makeRequestAsync;\n\n  public readonly standardHeaders: Record<string, string> = {};\n\n  public accept: string | undefined = '*/*';\n  public userAgent: string | undefined = `rush node/${process.version} ${os.platform()} ${os.arch()}`;\n\n  public proxy: WebClientProxy = WebClientProxy.Detect;\n\n  public static mockRequestFn(fn: FetchFn): void {\n    WebClient._requestFn = fn;\n  }\n\n  public static resetMockRequestFn(): void {\n    WebClient._requestFn = makeRequestAsync;\n  }\n\n  public static mergeHeaders(target: Record<string, string>, source: Record<string, string>): void {\n    for (const [name, value] of Object.entries(source)) {\n      target[name] = value;\n    }\n  }\n\n  public addBasicAuthHeader(userName: string, password: string): void {\n    this.standardHeaders[AUTHORIZATION_HEADER_NAME] =\n      'Basic ' + Buffer.from(userName + ':' + password).toString('base64');\n  }\n\n  public async fetchAsync(\n    url: string,\n    options?: IGetFetchOptions | IFetchOptionsWithBody\n  ): Promise<IWebClientResponse> {\n    const {\n      headers: optionsHeaders,\n      timeoutMs = 15 * 1000,\n      verb,\n      redirect,\n      body,\n      noDecode\n    } = (options as IFetchOptionsWithBody | undefined) ?? {};\n\n    const headers: Record<string, string> = {};\n\n    WebClient.mergeHeaders(headers, this.standardHeaders);\n\n    if (optionsHeaders) {\n      WebClient.mergeHeaders(headers, optionsHeaders);\n    }\n\n    if (this.userAgent) {\n      headers[USER_AGENT_HEADER_NAME] = this.userAgent;\n    }\n\n    if (this.accept) {\n      headers[ACCEPT_HEADER_NAME] = this.accept;\n    }\n\n    let proxyUrl: string = '';\n\n    switch (this.proxy) {\n      case WebClientProxy.Detect:\n        if (process.env.HTTPS_PROXY) {\n          proxyUrl = process.env.HTTPS_PROXY;\n        } else if (process.env.HTTP_PROXY) {\n          proxyUrl = process.env.HTTP_PROXY;\n        }\n        break;\n\n      case WebClientProxy.Fiddler:\n        // For debugging, disable cert validation\n        // eslint-disable-next-line\n        process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';\n        proxyUrl = 'http://localhost:8888/';\n        break;\n    }\n\n    let agent: http.Agent | undefined = undefined;\n    if (proxyUrl) {\n      agent = createHttpsProxyAgent(proxyUrl);\n    }\n\n    const requestInit: IRequestOptions = {\n      method: verb,\n      headers,\n      agent,\n      timeout: timeoutMs,\n      redirect,\n      body,\n      noDecode\n    };\n\n    return await WebClient._requestFn(url, requestInit);\n  }\n}\n"]}