// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
import * as os from 'os';
import * as process from 'process';
import { request as httpRequest } from 'node:http';
import { request as httpsRequest } from 'node:https';
import { Import, LegacyAdapters } from '@rushstack/node-core-library';
const createHttpsProxyAgent = Import.lazy('https-proxy-agent', require);
/**
 * For use with {@link WebClient}.
 */
export var WebClientProxy;
(function (WebClientProxy) {
    WebClientProxy[WebClientProxy["None"] = 0] = "None";
    WebClientProxy[WebClientProxy["Detect"] = 1] = "Detect";
    WebClientProxy[WebClientProxy["Fiddler"] = 2] = "Fiddler";
})(WebClientProxy || (WebClientProxy = {}));
const DEFLATE_ENCODING = 'deflate';
const GZIP_ENCODING = 'gzip';
const BROTLI_ENCODING = 'br';
export const AUTHORIZATION_HEADER_NAME = 'Authorization';
const ACCEPT_HEADER_NAME = 'accept';
const USER_AGENT_HEADER_NAME = 'user-agent';
const CONTENT_ENCODING_HEADER_NAME = 'content-encoding';
const makeRequestAsync = async (url, options, redirected = false) => {
    const { body, redirect, noDecode } = options;
    return await new Promise((resolve, reject) => {
        const parsedUrl = typeof url === 'string' ? new URL(url) : url;
        const requestFunction = parsedUrl.protocol === 'https:' ? httpsRequest : httpRequest;
        requestFunction(url, options, (response) => {
            const responseBuffers = [];
            response.on('data', (chunk) => {
                responseBuffers.push(Buffer.from(chunk));
            });
            response.on('end', () => {
                // Handle retries by calling the method recursively with the redirect URL
                const statusCode = response.statusCode;
                if (statusCode === 301 || statusCode === 302) {
                    switch (redirect) {
                        case 'follow': {
                            const redirectUrl = response.headers.location;
                            if (redirectUrl) {
                                makeRequestAsync(redirectUrl, options, true).then(resolve).catch(reject);
                            }
                            else {
                                reject(new Error(`Received status code ${response.statusCode} with no location header: ${url}`));
                            }
                            break;
                        }
                        case 'error':
                            reject(new Error(`Received status code ${response.statusCode}: ${url}`));
                            return;
                    }
                }
                const responseData = Buffer.concat(responseBuffers);
                const status = response.statusCode || 0;
                const statusText = response.statusMessage;
                const headers = response.headers;
                let bodyString;
                let bodyJson;
                let decodedBuffer;
                const result = {
                    ok: status >= 200 && status < 300,
                    status,
                    statusText,
                    redirected,
                    headers,
                    getTextAsync: async () => {
                        if (bodyString === undefined) {
                            const buffer = await result.getBufferAsync();
                            // eslint-disable-next-line require-atomic-updates
                            bodyString = buffer.toString();
                        }
                        return bodyString;
                    },
                    getJsonAsync: async () => {
                        if (bodyJson === undefined) {
                            const text = await result.getTextAsync();
                            // eslint-disable-next-line require-atomic-updates
                            bodyJson = JSON.parse(text);
                        }
                        return bodyJson;
                    },
                    getBufferAsync: async () => {
                        // Determine if the buffer is compressed and decode it if necessary
                        if (decodedBuffer === undefined) {
                            let encodings = headers[CONTENT_ENCODING_HEADER_NAME];
                            if (!noDecode && encodings !== undefined) {
                                const zlib = await import('zlib');
                                if (!Array.isArray(encodings)) {
                                    encodings = encodings.split(',');
                                }
                                let buffer = responseData;
                                for (const encoding of encodings) {
                                    let decompressFn;
                                    switch (encoding.trim()) {
                                        case DEFLATE_ENCODING: {
                                            decompressFn = zlib.inflate.bind(zlib);
                                            break;
                                        }
                                        case GZIP_ENCODING: {
                                            decompressFn = zlib.gunzip.bind(zlib);
                                            break;
                                        }
                                        case BROTLI_ENCODING: {
                                            decompressFn = zlib.brotliDecompress.bind(zlib);
                                            break;
                                        }
                                        default: {
                                            throw new Error(`Unsupported content-encoding: ${encodings}`);
                                        }
                                    }
                                    buffer = await LegacyAdapters.convertCallbackToPromise(decompressFn, buffer);
                                }
                                // eslint-disable-next-line require-atomic-updates
                                decodedBuffer = buffer;
                            }
                            else {
                                decodedBuffer = responseData;
                            }
                        }
                        return decodedBuffer;
                    }
                };
                resolve(result);
            });
        })
            .on('error', (error) => {
            reject(error);
        })
            .end(body);
    });
};
/**
 * A helper for issuing HTTP requests.
 */
export class WebClient {
    constructor() {
        this.standardHeaders = {};
        this.accept = '*/*';
        this.userAgent = `rush node/${process.version} ${os.platform()} ${os.arch()}`;
        this.proxy = WebClientProxy.Detect;
    }
    static mockRequestFn(fn) {
        WebClient._requestFn = fn;
    }
    static resetMockRequestFn() {
        WebClient._requestFn = makeRequestAsync;
    }
    static mergeHeaders(target, source) {
        for (const [name, value] of Object.entries(source)) {
            target[name] = value;
        }
    }
    addBasicAuthHeader(userName, password) {
        this.standardHeaders[AUTHORIZATION_HEADER_NAME] =
            'Basic ' + Buffer.from(userName + ':' + password).toString('base64');
    }
    async fetchAsync(url, options) {
        var _a;
        const { headers: optionsHeaders, timeoutMs = 15 * 1000, verb, redirect, body, noDecode } = (_a = options) !== null && _a !== void 0 ? _a : {};
        const headers = {};
        WebClient.mergeHeaders(headers, this.standardHeaders);
        if (optionsHeaders) {
            WebClient.mergeHeaders(headers, optionsHeaders);
        }
        if (this.userAgent) {
            headers[USER_AGENT_HEADER_NAME] = this.userAgent;
        }
        if (this.accept) {
            headers[ACCEPT_HEADER_NAME] = this.accept;
        }
        let proxyUrl = '';
        switch (this.proxy) {
            case WebClientProxy.Detect:
                if (process.env.HTTPS_PROXY) {
                    proxyUrl = process.env.HTTPS_PROXY;
                }
                else if (process.env.HTTP_PROXY) {
                    proxyUrl = process.env.HTTP_PROXY;
                }
                break;
            case WebClientProxy.Fiddler:
                // For debugging, disable cert validation
                // eslint-disable-next-line
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                proxyUrl = 'http://localhost:8888/';
                break;
        }
        let agent = undefined;
        if (proxyUrl) {
            agent = createHttpsProxyAgent(proxyUrl);
        }
        const requestInit = {
            method: verb,
            headers,
            agent,
            timeout: timeoutMs,
            redirect,
            body,
            noDecode
        };
        return await WebClient._requestFn(url, requestInit);
    }
}
WebClient._requestFn = makeRequestAsync;
//# sourceMappingURL=WebClient.js.map