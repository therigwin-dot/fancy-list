{"version":3,"file":"OverlappingPathAnalyzer.js","sourceRoot":"","sources":["../../src/utilities/OverlappingPathAnalyzer.ts"],"names":[],"mappings":"AAAA,4FAA4F;AAC5F,2DAA2D;AAQ3D;;;GAGG;AACH,MAAM,OAAO,uBAAuB;IAApC;QACmB,UAAK,GAA0B;YAC9C,iBAAiB,EAAE,IAAI,GAAG,EAAU;YACpC,KAAK,EAAE,EAAE;SACV,CAAC;IA4CJ,CAAC;IA1CQ,mCAAmC,CAAC,IAAY,EAAE,KAAa;QACpE,MAAM,SAAS,GAAa,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC5C,IAAI,WAAW,GAA0B,IAAI,CAAC,KAAK,CAAC;QACpD,IAAI,gBAAgB,GAAY,KAAK,CAAC;QACtC,IAAI,mCAAmC,GAAY,KAAK,CAAC;QACzD,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE,CAAC;YACjC,IAAI,QAAQ,KAAK,EAAE,EAAE,CAAC;gBACpB,SAAS;YACX,CAAC;YAED,IAAI,WAAW,CAAC,KAAK,EAAE,CAAC;gBACtB,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YAC7B,CAAC;YAED,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC;gBACjC,gBAAgB,GAAG,IAAI,CAAC;gBACxB,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG;oBAC1C,iBAAiB,EAAE,IAAI,GAAG,EAAU;oBACpC,KAAK,EAAE,EAAE;iBACV,CAAC;YACJ,CAAC;iBAAM,CAAC;gBACN,gBAAgB,GAAG,KAAK,CAAC;gBACzB,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YAC5C,CAAC;YAED,mCAAmC,GAAG,WAAW,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAC/E,IAAI,CAAC,mCAAmC,EAAE,CAAC;gBACzC,WAAW,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAC3C,CAAC;QACH,CAAC;QAED,IAAI,gBAAgB,EAAE,CAAC;YACrB,WAAW,CAAC,KAAK,GAAG,KAAK,CAAC;YAC1B,OAAO,SAAS,CAAC;QACnB,CAAC;aAAM,IAAI,mCAAmC,EAAE,CAAC;YAC/C,OAAO,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC;QACnD,CAAC;aAAM,CAAC;YACN,MAAM,uBAAuB,GAAgB,IAAI,GAAG,CAAS,WAAW,CAAC,iBAAiB,CAAC,CAAC;YAC5F,uBAAuB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACtC,OAAO,KAAK,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;QAC7C,CAAC;IACH,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\ninterface IPathTreeNode<TLabel> {\n  encounteredLabels: Set<TLabel>;\n  label?: TLabel;\n  paths: Record<string, IPathTreeNode<TLabel>>;\n}\n\n/**\n * This is a tool for determining if a set of paths overlap. For example 'lib' and 'lib/x' overlap,\n * 'lib/x' and 'lib/y' do not.\n */\nexport class OverlappingPathAnalyzer<TLabel> {\n  private readonly _root: IPathTreeNode<TLabel> = {\n    encounteredLabels: new Set<TLabel>(),\n    paths: {}\n  };\n\n  public addPathAndGetFirstEncounteredLabels(path: string, label: TLabel): TLabel[] | undefined {\n    const pathParts: string[] = path.split('/');\n    let currentNode: IPathTreeNode<TLabel> = this._root;\n    let currentNodeIsNew: boolean = false;\n    let labelWasAlreadyPresentInCurrentNode: boolean = false;\n    for (const pathPart of pathParts) {\n      if (pathPart === '') {\n        continue;\n      }\n\n      if (currentNode.label) {\n        return [currentNode.label];\n      }\n\n      if (!currentNode.paths[pathPart]) {\n        currentNodeIsNew = true;\n        currentNode = currentNode.paths[pathPart] = {\n          encounteredLabels: new Set<TLabel>(),\n          paths: {}\n        };\n      } else {\n        currentNodeIsNew = false;\n        currentNode = currentNode.paths[pathPart];\n      }\n\n      labelWasAlreadyPresentInCurrentNode = currentNode.encounteredLabels.has(label);\n      if (!labelWasAlreadyPresentInCurrentNode) {\n        currentNode.encounteredLabels.add(label);\n      }\n    }\n\n    if (currentNodeIsNew) {\n      currentNode.label = label;\n      return undefined;\n    } else if (labelWasAlreadyPresentInCurrentNode) {\n      return Array.from(currentNode.encounteredLabels);\n    } else {\n      const clonedEncounteredLabels: Set<TLabel> = new Set<TLabel>(currentNode.encounteredLabels);\n      clonedEncounteredLabels.delete(label);\n      return Array.from(clonedEncounteredLabels);\n    }\n  }\n}\n"]}