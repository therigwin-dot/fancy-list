// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
import * as semver from 'semver';
import { Enum } from '@rushstack/node-core-library';
import { VersionFormatForCommit, VersionFormatForPublish } from './VersionPolicyConfiguration';
import { cloneDeep } from '../utilities/objectUtilities';
/**
 * Type of version bumps
 * @public
 *
 * @internalRemarks
 * This is a copy of the semver ReleaseType enum, but with the `none` value added and
 * the `premajor` and `prepatch` omitted.
 * See {@link LockStepVersionPolicy._getReleaseType}.
 *
 * TODO: Consider supporting `premajor` and `prepatch` in the future.
 */
export var BumpType;
(function (BumpType) {
    // No version bump
    BumpType[BumpType["none"] = 0] = "none";
    // Prerelease version bump
    BumpType[BumpType["prerelease"] = 1] = "prerelease";
    // Patch version bump
    BumpType[BumpType["patch"] = 2] = "patch";
    // Preminor version bump
    BumpType[BumpType["preminor"] = 3] = "preminor";
    // Minor version bump
    BumpType[BumpType["minor"] = 4] = "minor";
    // Major version bump
    BumpType[BumpType["major"] = 5] = "major";
})(BumpType || (BumpType = {}));
/**
 * Version policy base type names
 * @public
 */
export var VersionPolicyDefinitionName;
(function (VersionPolicyDefinitionName) {
    VersionPolicyDefinitionName[VersionPolicyDefinitionName["lockStepVersion"] = 0] = "lockStepVersion";
    VersionPolicyDefinitionName[VersionPolicyDefinitionName["individualVersion"] = 1] = "individualVersion";
})(VersionPolicyDefinitionName || (VersionPolicyDefinitionName = {}));
/**
 * This is the base class for version policy which controls how versions get bumped.
 * @public
 */
export class VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        this.policyName = versionPolicyJson.policyName;
        this.definitionName = Enum.getValueByKey(VersionPolicyDefinitionName, versionPolicyJson.definitionName);
        this.exemptFromRushChange = versionPolicyJson.exemptFromRushChange || false;
        this.includeEmailInChangeFile = versionPolicyJson.includeEmailInChangeFile || false;
        const jsonDependencies = versionPolicyJson.dependencies || {};
        this._versionFormatForCommit = jsonDependencies.versionFormatForCommit || VersionFormatForCommit.original;
        this._versionFormatForPublish =
            jsonDependencies.versionFormatForPublish || VersionFormatForPublish.original;
    }
    /**
     * Loads from version policy json
     *
     * @param versionPolicyJson - version policy Json
     *
     * @internal
     */
    static load(versionPolicyJson) {
        const definition = Enum.getValueByKey(VersionPolicyDefinitionName, versionPolicyJson.definitionName);
        if (definition === VersionPolicyDefinitionName.lockStepVersion) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            return new LockStepVersionPolicy(versionPolicyJson);
        }
        else if (definition === VersionPolicyDefinitionName.individualVersion) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            return new IndividualVersionPolicy(versionPolicyJson);
        }
        return undefined;
    }
    /**
     * Whether it is a lockstepped version policy
     */
    get isLockstepped() {
        return this.definitionName === VersionPolicyDefinitionName.lockStepVersion;
    }
    /**
     * Tells the version policy to modify any dependencies in the target package
     * to values used for publishing.
     */
    setDependenciesBeforePublish(packageName, configuration) {
        if (this._versionFormatForPublish === VersionFormatForPublish.exact) {
            const project = configuration.getProjectByName(packageName);
            const packageJsonEditor = project.packageJsonEditor;
            for (const dependency of packageJsonEditor.dependencyList) {
                const rushDependencyProject = configuration.getProjectByName(dependency.name);
                if (rushDependencyProject) {
                    const dependencyVersion = rushDependencyProject.packageJson.version;
                    dependency.setVersion(dependencyVersion);
                }
            }
            packageJsonEditor.saveIfModified();
        }
    }
    /**
     * Tells the version policy to modify any dependencies in the target package
     * to values used for checked-in source.
     */
    setDependenciesBeforeCommit(packageName, configuration) {
        if (this._versionFormatForCommit === VersionFormatForCommit.wildcard) {
            const project = configuration.getProjectByName(packageName);
            const packageJsonEditor = project.packageJsonEditor;
            for (const dependency of packageJsonEditor.dependencyList) {
                const rushDependencyProject = configuration.getProjectByName(dependency.name);
                if (rushDependencyProject) {
                    dependency.setVersion('*');
                }
            }
            packageJsonEditor.saveIfModified();
        }
    }
}
/**
 * This policy indicates all related projects should use the same version.
 * @public
 */
export class LockStepVersionPolicy extends VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        super(versionPolicyJson);
        this._version = new semver.SemVer(versionPolicyJson.version);
        this.nextBump =
            versionPolicyJson.nextBump !== undefined
                ? Enum.getValueByKey(BumpType, versionPolicyJson.nextBump)
                : undefined;
        this.mainProject = versionPolicyJson.mainProject;
    }
    /**
     * The value of the lockstep version
     */
    get version() {
        return this._version.format();
    }
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json() {
        const json = {
            policyName: this.policyName,
            definitionName: VersionPolicyDefinitionName[this.definitionName],
            version: this.version
        };
        if (this.nextBump !== undefined) {
            json.nextBump = BumpType[this.nextBump];
        }
        if (this.mainProject !== undefined) {
            json.mainProject = this.mainProject;
        }
        return json;
    }
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project, force) {
        const packageVersion = new semver.SemVer(project.version);
        const compareResult = packageVersion.compare(this._version);
        if (compareResult === 0) {
            return undefined;
        }
        else if (compareResult > 0 && !force) {
            const errorMessage = `Version ${project.version} in package ${project.name}` +
                ` is higher than locked version ${this._version.format()}.`;
            throw new Error(errorMessage);
        }
        return this._updatePackageVersion(project, this._version);
    }
    /**
     * Bumps the version of the lockstep policy
     *
     * @param bumpType - Overwrite bump type in version-policy.json with the provided value.
     * @param identifier - Prerelease identifier if bump type is prerelease.
     */
    bump(bumpType, identifier) {
        const nextBump = bumpType !== null && bumpType !== void 0 ? bumpType : this.nextBump;
        if (nextBump === undefined) {
            // let change files drive version bump.
            return;
        }
        this._version.inc(this._getReleaseType(nextBump), identifier);
    }
    /**
     * Updates the version of the policy directly with a new value
     * @param newVersionString - New version
     */
    update(newVersionString) {
        const newVersion = new semver.SemVer(newVersionString);
        if (!newVersion || this._version === newVersion) {
            return false;
        }
        this._version = newVersion;
        return true;
    }
    /**
     * Validates the specified version and throws if the version does not satisfy lockstep version.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString, packageName) {
        const versionToTest = new semver.SemVer(versionString, false);
        if (this._version.compare(versionToTest) !== 0) {
            throw new Error(`Invalid version ${versionString} in ${packageName}`);
        }
    }
    _updatePackageVersion(project, newVersion) {
        const updatedProject = cloneDeep(project);
        updatedProject.version = newVersion.format();
        return updatedProject;
    }
    _getReleaseType(bumpType) {
        // Eventually we should just use ReleaseType and get rid of bump type.
        return BumpType[bumpType];
    }
}
/**
 * This policy indicates all related projects get version bump driven by their own changes.
 * @public
 */
export class IndividualVersionPolicy extends VersionPolicy {
    /**
     * @internal
     */
    constructor(versionPolicyJson) {
        super(versionPolicyJson);
        this.lockedMajor = versionPolicyJson.lockedMajor;
    }
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json() {
        const json = {
            policyName: this.policyName,
            definitionName: VersionPolicyDefinitionName[this.definitionName]
        };
        if (this.lockedMajor !== undefined) {
            json.lockedMajor = this.lockedMajor;
        }
        return json;
    }
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project, force) {
        if (this.lockedMajor) {
            const version = new semver.SemVer(project.version);
            if (version.major < this.lockedMajor) {
                const updatedProject = cloneDeep(project);
                updatedProject.version = `${this.lockedMajor}.0.0`;
                return updatedProject;
            }
            else if (version.major > this.lockedMajor) {
                const errorMessage = `Version ${project.version} in package ${project.name}` +
                    ` is higher than locked major version ${this.lockedMajor}.`;
                throw new Error(errorMessage);
            }
        }
        return undefined;
    }
    /**
     * Bumps version.
     * Individual version policy lets change files drive version bump. This method currently does not do anything.
     *
     * @param bumpType - bump type
     * @param identifier - prerelease id
     */
    bump(bumpType, identifier) {
        // individual version policy lets change files drive version bump.
    }
    /**
     * Validates the specified version and throws if the version does not satisfy the policy.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString, packageName) {
        const versionToTest = new semver.SemVer(versionString, false);
        if (this.lockedMajor !== undefined) {
            if (this.lockedMajor !== versionToTest.major) {
                throw new Error(`Invalid major version ${versionString} in ${packageName}`);
            }
        }
    }
}
//# sourceMappingURL=VersionPolicy.js.map