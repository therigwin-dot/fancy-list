// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
import { FileSystem, Import, InternalError } from '@rushstack/node-core-library';
import { BuiltInPluginLoader } from './PluginLoader/BuiltInPluginLoader';
import { AutoinstallerPluginLoader } from './PluginLoader/AutoinstallerPluginLoader';
import { Rush } from '../api/Rush';
export class PluginManager {
    constructor(options) {
        var _a, _b;
        this._loadedPluginNames = new Set();
        this._terminal = options.terminal;
        this._rushConfiguration = options.rushConfiguration;
        this._rushSession = options.rushSession;
        this._restrictConsoleOutput = options.restrictConsoleOutput;
        this._rushGlobalFolder = options.rushGlobalFolder;
        this._installedAutoinstallerNames = new Set();
        // Eventually we will require end users to explicitly configure all Rush plugins in use, regardless of
        // whether they are first party or third party plugins.  However, we're postponing that requirement
        // until after the plugin feature has stabilized and is fully documented.  In the meantime, Rush's
        // built-in plugins are dependencies of @microsoft/rush-lib and get loaded by default (without any
        // configuration).
        //
        // The plugins have devDependencies on Rush, which would create a circular dependency in our local
        // workspace if we added them to rush-lib/package.json.  Instead we put them in a special section
        // "publishOnlyDependencies" which gets moved into "dependencies" during publishing.
        const builtInPluginConfigurations = options.builtInPluginConfigurations;
        const ownPackageJsonDependencies = Rush._rushLibPackageJson.dependencies || {};
        function tryAddBuiltInPlugin(builtInPluginName, pluginPackageName) {
            if (!pluginPackageName) {
                pluginPackageName = `@rushstack/${builtInPluginName}`;
            }
            if (ownPackageJsonDependencies[pluginPackageName]) {
                builtInPluginConfigurations.push({
                    packageName: pluginPackageName,
                    pluginName: builtInPluginName,
                    pluginPackageFolder: Import.resolvePackage({
                        packageName: pluginPackageName,
                        baseFolderPath: __dirname
                    })
                });
            }
        }
        tryAddBuiltInPlugin('rush-amazon-s3-build-cache-plugin');
        tryAddBuiltInPlugin('rush-azure-storage-build-cache-plugin');
        tryAddBuiltInPlugin('rush-http-build-cache-plugin');
        // This is a secondary plugin inside the `@rushstack/rush-azure-storage-build-cache-plugin`
        // package. Because that package comes with Rush (for now), it needs to get registered here.
        // If the necessary config file doesn't exist, this plugin doesn't do anything.
        tryAddBuiltInPlugin('rush-azure-interactive-auth-plugin', '@rushstack/rush-azure-storage-build-cache-plugin');
        this._builtInPluginLoaders = builtInPluginConfigurations.map((pluginConfiguration) => {
            return new BuiltInPluginLoader({
                pluginConfiguration,
                rushConfiguration: this._rushConfiguration,
                terminal: this._terminal
            });
        });
        this._autoinstallerPluginLoaders = ((_b = (_a = this._rushConfiguration) === null || _a === void 0 ? void 0 : _a._rushPluginsConfiguration.configuration.plugins) !== null && _b !== void 0 ? _b : []).map((pluginConfiguration) => {
            return new AutoinstallerPluginLoader({
                pluginConfiguration,
                rushConfiguration: this._rushConfiguration,
                terminal: this._terminal,
                restrictConsoleOutput: this._restrictConsoleOutput,
                rushGlobalFolder: this._rushGlobalFolder
            });
        });
    }
    /**
     * If an error occurs while attempting to load plugins, it will be saved in this property.
     * Rush will attempt to continue and will report the error later by `BaseRushAction._throwPluginErrorIfNeed()`
     * (unless we are invoking a command that is used to fix plugin problems).
     */
    get error() {
        return this._error;
    }
    async updateAsync() {
        await this._preparePluginAutoinstallersAsync(this._autoinstallerPluginLoaders);
        const preparedAutoinstallerNames = new Set();
        for (const { autoinstaller } of this._autoinstallerPluginLoaders) {
            const storePath = AutoinstallerPluginLoader.getPluginAutoinstallerStorePath(autoinstaller);
            if (!preparedAutoinstallerNames.has(autoinstaller.name)) {
                FileSystem.ensureEmptyFolder(storePath);
                preparedAutoinstallerNames.add(autoinstaller.name);
            }
        }
        for (const pluginLoader of this._autoinstallerPluginLoaders) {
            pluginLoader.update();
        }
    }
    async reinitializeAllPluginsForCommandAsync(commandName) {
        this._error = undefined;
        await this.tryInitializeUnassociatedPluginsAsync();
        await this.tryInitializeAssociatedCommandPluginsAsync(commandName);
    }
    async _preparePluginAutoinstallersAsync(pluginLoaders) {
        for (const { autoinstaller } of pluginLoaders) {
            if (!this._installedAutoinstallerNames.has(autoinstaller.name)) {
                await autoinstaller.prepareAsync();
                this._installedAutoinstallerNames.add(autoinstaller.name);
            }
        }
    }
    async tryInitializeUnassociatedPluginsAsync() {
        try {
            const autoinstallerPluginLoaders = this._getUnassociatedPluginLoaders(this._autoinstallerPluginLoaders);
            await this._preparePluginAutoinstallersAsync(autoinstallerPluginLoaders);
            const builtInPluginLoaders = this._getUnassociatedPluginLoaders(this._builtInPluginLoaders);
            this._initializePlugins([...builtInPluginLoaders, ...autoinstallerPluginLoaders]);
        }
        catch (e) {
            this._error = e;
        }
    }
    async tryInitializeAssociatedCommandPluginsAsync(commandName) {
        try {
            const autoinstallerPluginLoaders = this._getPluginLoadersForCommand(commandName, this._autoinstallerPluginLoaders);
            await this._preparePluginAutoinstallersAsync(autoinstallerPluginLoaders);
            const builtInPluginLoaders = this._getPluginLoadersForCommand(commandName, this._builtInPluginLoaders);
            this._initializePlugins([...builtInPluginLoaders, ...autoinstallerPluginLoaders]);
        }
        catch (e) {
            this._error = e;
        }
    }
    tryGetCustomCommandLineConfigurationInfos() {
        const commandLineConfigurationInfos = [];
        for (const pluginLoader of this._autoinstallerPluginLoaders) {
            const commandLineConfiguration = pluginLoader.getCommandLineConfiguration();
            if (commandLineConfiguration) {
                commandLineConfigurationInfos.push({
                    commandLineConfiguration,
                    pluginLoader
                });
            }
        }
        return commandLineConfigurationInfos;
    }
    _initializePlugins(pluginLoaders) {
        for (const pluginLoader of pluginLoaders) {
            const pluginName = pluginLoader.pluginName;
            if (this._loadedPluginNames.has(pluginName)) {
                throw new Error(`Error applying plugin: A plugin with name "${pluginName}" has already been applied`);
            }
            const plugin = pluginLoader.load();
            this._loadedPluginNames.add(pluginName);
            if (plugin) {
                this._applyPlugin(plugin, pluginName);
            }
        }
    }
    _getUnassociatedPluginLoaders(pluginLoaders) {
        return pluginLoaders.filter((pluginLoader) => {
            return !pluginLoader.pluginManifest.associatedCommands;
        });
    }
    _getPluginLoadersForCommand(commandName, pluginLoaders) {
        return pluginLoaders.filter((pluginLoader) => {
            var _a;
            return (_a = pluginLoader.pluginManifest.associatedCommands) === null || _a === void 0 ? void 0 : _a.includes(commandName);
        });
    }
    _applyPlugin(plugin, pluginName) {
        try {
            plugin.apply(this._rushSession, this._rushConfiguration);
        }
        catch (e) {
            throw new InternalError(`Error applying "${pluginName}": ${e}`);
        }
    }
}
//# sourceMappingURL=PluginManager.js.map