{"version":3,"file":"InputsSnapshot.js","sourceRoot":"","sources":["../../../src/logic/incremental/InputsSnapshot.ts"],"names":[],"mappings":"AAAA,4FAA4F;AAC5F,2DAA2D;AAE3D,OAAO,KAAK,IAAI,MAAM,WAAW,CAAC;AAClC,OAAO,EAAE,UAAU,EAAa,MAAM,aAAa,CAAC;AAEpD,OAAO,MAAuB,MAAM,QAAQ,CAAC;AAE7C,OAAO,EAA8B,YAAY,EAAE,MAAM,2BAA2B,CAAC;AACrF,OAAO,EAAE,aAAa,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,8BAA8B,CAAC;AAIzE,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AAqGjD,MAAM,EAAE,aAAa,EAAE,GAAG,aAAa,CAAC;AA0CxC;;;;;;;;GAQG;AACH,MAAM,OAAO,cAAc;IA8BzB;;;;OAIG;IACH,YAAmB,MAAiC;QAClD,MAAM,EACJ,gBAAgB,EAChB,WAAW,qBAAQ,OAAO,CAAC,GAAG,CAAE,EAChC,qBAAqB,EACrB,MAAM,EACN,YAAY,EACZ,OAAO,EACR,GAAG,MAAM,CAAC;QACX,MAAM,kBAAkB,GAGpB,IAAI,GAAG,EAAE,CAAC;QACd,KAAK,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;YAClD,kBAAkB,CAAC,GAAG,CAAC,OAAO,EAAE,oBAAoB,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;QAClF,CAAC;QAED,sCAAsC;QACtC,KAAK,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,MAAM,EAAE,CAAC;YAClC,MAAM,OAAO,GAAqD,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YACnG,IAAI,CAAC,OAAO,EAAE,CAAC;gBACb,SAAS;YACX,CAAC;YAED,IAAI,MAAM,GAAuD,kBAAkB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACjG,IAAI,CAAC,MAAM,EAAE,CAAC;gBACZ,kBAAkB,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,MAAM,GAAG,oBAAoB,CAAC,OAAO,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;YAChG,CAAC;YAED,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAChC,CAAC;QAED,IAAI,sBAAuD,CAAC;QAC5D,IAAI,qBAAqB,EAAE,CAAC;YAC1B,sBAAsB,GAAG,IAAI,GAAG,EAAE,CAAC;YACnC,MAAM,qBAAqB,GAAa,KAAK,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC,IAAI,EAAE,CAAC;YACjF,KAAK,MAAM,IAAI,IAAI,qBAAqB,EAAE,CAAC;gBACzC,MAAM,IAAI,GAAuB,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBAClD,IAAI,CAAC,IAAI,EAAE,CAAC;oBACV,MAAM,IAAI,KAAK,CAAC,oCAAoC,IAAI,GAAG,CAAC,CAAC;gBAC/D,CAAC;gBACD,MAAM,aAAa,GACjB,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;gBACnC,IAAI,aAAa,EAAE,CAAC;oBAClB,MAAM,IAAI,aAAa,CACrB,qCAAqC,IAAI,6BAA6B,aAAa,CAAC,qBAAqB,0CAA0C,CACpJ,CAAC;gBACJ,CAAC;gBACD,sBAAsB,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YACzC,CAAC;QACH,CAAC;QAED,KAAK,MAAM,MAAM,IAAI,kBAAkB,CAAC,MAAM,EAAE,EAAE,CAAC;YACjD,0BAA0B;YAC1B,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAClC,CAAC;QAED,IAAI,CAAC,mBAAmB,GAAG,kBAAkB,CAAC;QAC9C,IAAI,CAAC,iBAAiB,GAAG,gBAAgB,CAAC;QAC1C,IAAI,CAAC,uBAAuB,GAAG,sBAAsB,CAAC;QACtD,gFAAgF;QAChF,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC;IAC/B,CAAC;IAED;;OAEG;IACI,gCAAgC,CACrC,OAA6C,EAC7C,aAAsB;;QAEtB,MAAM,MAAM,GAAuD,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACzG,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,MAAM,IAAI,aAAa,CAAC,2CAA2C,OAAO,CAAC,aAAa,EAAE,CAAC,CAAC;QAC9F,CAAC;QAED,MAAM,EAAE,yBAAyB,EAAE,GAAG,MAAM,CAAC;QAC7C,IAAI,MAAM,GAAoC,yBAAyB,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;QAC3F,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;YACnB,yBAAyB,CAAC,GAAG,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;YACrD,2DAA2D;YAC3D,MAAM,MAAM,GAAkC,wBAAwB,CAAC,MAAM,CAAC,CAAC;YAE/E,IAAI,eAAiD,CAAC;YAEtD,IAAI,aAAa,EAAE,CAAC;gBAClB,MAAM,iBAAiB,GACrB,MAAA,MAAM,CAAC,aAAa,0CAAE,gCAAgC,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;gBAE5E,MAAM,iBAAiB,GAAyB,iBAAiB,aAAjB,iBAAiB,uBAAjB,iBAAiB,CAAE,iBAAiB,CAAC;gBACrF,IAAI,iBAAiB,EAAE,CAAC;oBACtB,MAAM,EAAE,cAAc,EAAE,GAAG,MAAM,CAAC;oBAClC,eAAe,GAAG,IAAI,YAAY,EAAE,CAAC;oBACrC,KAAK,MAAM,UAAU,IAAI,iBAAiB,EAAE,CAAC;wBAC3C,eAAe,CAAC,OAAO,CAAC,GAAG,cAAc,IAAI,UAAU,EAAE,EAAE,UAAU,CAAC,CAAC;oBACzE,CAAC;gBACH,CAAC;gBAED,2HAA2H;gBAC3H,MAAM,2BAA2B,GAC/B,MAAA,MAAM,CAAC,8BAA8B,0CAAE,GAAG,CAAC,aAAa,CAAC,CAAC;gBAC5D,IAAI,2BAA2B,EAAE,CAAC;oBAChC,KAAK,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,2BAA2B,CAAC,EAAE,CAAC;wBAChF,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;oBAC7B,CAAC;gBACH,CAAC;YACH,CAAC;YAED,MAAM,EAAE,uBAAuB,EAAE,sBAAsB,EAAE,GAAG,IAAI,CAAC;YACjE,IAAI,sBAAsB,EAAE,CAAC;gBAC3B,KAAK,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,sBAAsB,EAAE,CAAC;oBAClD,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBAChC,CAAC;YACH,CAAC;YAED,8BAA8B;YAC9B,KAAK,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC;gBAC7C,IAAI,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;oBACrB,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;gBAC7B,CAAC;gBAED,8FAA8F;gBAC9F,0FAA0F;gBAC1F,+CAA+C;gBAC/C,MAAM,WAAW,GAAuB,eAAe,aAAf,eAAe,uBAAf,eAAe,CAAE,aAAa,CAAC,QAAQ,CAAC,CAAC;gBACjF,IAAI,WAAW,EAAE,CAAC;oBAChB,MAAM,IAAI,KAAK,CACb,6BAA6B,WAAW,oBAAoB,aAAa,iBAAiB,OAAO,CAAC,qBAAqB,kCAAkC,QAAQ,IAAI;wBACnK,kNAAkN;wBAClN,0GAA0G,CAC7G,CAAC;gBACJ,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,wBAAwB,CAC7B,OAA6C,EAC7C,aAAsB;;QAEtB,MAAM,MAAM,GAAuD,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACzG,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,MAAM,IAAI,KAAK,CAAC,2CAA2C,OAAO,CAAC,aAAa,EAAE,CAAC,CAAC;QACtF,CAAC;QAED,MAAM,EAAE,mBAAmB,EAAE,GAAG,MAAM,CAAC;QACvC,IAAI,IAAI,GAAuB,mBAAmB,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;QACtE,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,MAAM,MAAM,GAAgC,IAAI,CAAC,gCAAgC,CAC/E,OAAO,EACP,aAAa,CACd,CAAC;YAEF,MAAM,MAAM,GAAS,UAAU,CAAC,MAAM,CAAC,CAAC;YACxC,wEAAwE;YACxE,IAAI,aAAa,EAAE,CAAC;gBAClB,MAAM,iBAAiB,GACrB,MAAA,MAAM,CAAC,aAAa,0CAAE,gCAAgC,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;gBAC5E,IAAI,iBAAiB,EAAE,CAAC;oBACtB,MAAM,EAAE,gBAAgB,EAAE,iBAAiB,EAAE,GAAG,iBAAiB,CAAC;oBAClE,IAAI,gBAAgB,EAAE,CAAC;wBACrB,kGAAkG;wBAClG,oHAAoH;wBACpH,KAAK,MAAM,MAAM,IAAI,gBAAgB,EAAE,CAAC;4BACtC,MAAM,CAAC,MAAM,CAAC,GAAG,aAAa,IAAI,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;wBACjF,CAAC;oBACH,CAAC;oBAED,IAAI,iBAAiB,EAAE,CAAC;wBACtB,MAAM,CAAC,MAAM,CAAC,GAAG,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;oBACxE,CAAC;gBACH,CAAC;YACH,CAAC;YAED,8BAA8B;YAC9B,KAAK,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,IAAI,MAAM,EAAE,CAAC;gBAC1C,MAAM,CAAC,MAAM,CAAC,GAAG,aAAa,GAAG,QAAQ,GAAG,aAAa,GAAG,QAAQ,EAAE,CAAC,CAAC;YAC1E,CAAC;YAED,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAE5B,mBAAmB,CAAC,GAAG,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;QAC/C,CAAC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAEO,CAAC,cAAc,CAAC,SAA2B;;QACjD,MAAM,EAAE,MAAM,EAAE,iBAAiB,EAAE,GAAG,IAAI,CAAC;QAE3C,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE,CAAC;YACjC,MAAM,IAAI,GAAuB,MAAA,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,mCAAI,iBAAiB,aAAjB,iBAAiB,uBAAjB,iBAAiB,CAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;YAC1F,IAAI,CAAC,IAAI,EAAE,CAAC;gBACV,MAAM,IAAI,KAAK,CAAC,sCAAsC,QAAQ,GAAG,CAAC,CAAC;YACrE,CAAC;YACD,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QACzB,CAAC;IACH,CAAC;CACF;AAED,SAAS,wBAAwB,CAC/B,MAA8C;;IAE9C,IAAI,CAAC,MAAM,CAAC,qBAAqB,EAAE,CAAC;QAClC,MAAM,YAAY,GAAkC,MAAA,MAAM,CAAC,aAAa,0CAAE,4BAA4B,CAAC;QACvG,IAAI,CAAC,YAAY,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC/C,MAAM,CAAC,qBAAqB,GAAG,UAAU,CAAC;QAC5C,CAAC;aAAM,CAAC;YACN,MAAM,OAAO,GAAW,MAAM,EAAE,CAAC;YACjC,OAAO,CAAC,GAAG,CAAC,YAAwB,CAAC,CAAC;YACtC,MAAM,YAAY,GAAW,MAAM,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;YAC9D,MAAM,CAAC,qBAAqB,GAAG,SAAS,qBAAqB,CAAC,QAAgB;gBAC5E,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC;YACxD,CAAC,CAAC;QACJ,CAAC;IACH,CAAC;IAED,OAAO,MAAM,CAAC,qBAAqB,CAAC;AACtC,CAAC;AAED,SAAS,oBAAoB,CAC3B,OAA6C,EAC7C,UAAsD,EACtD,OAAe;IAEf,OAAO;QACL,uBAAuB;QACvB,aAAa,EAAE,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,aAAa;QACxC,8BAA8B,EAAE,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,8BAA8B;QAE1E,SAAS;QACT,MAAM,EAAE,IAAI,GAAG,EAAE;QACjB,mBAAmB,EAAE,IAAI,GAAG,EAAE;QAC9B,yBAAyB,EAAE,IAAI,GAAG,EAAE;QACpC,cAAc,EAAE,iBAAiB,CAAC,OAAO,EAAE,OAAO,CAAC;KACpD,CAAC;AACJ,CAAC;AAED,SAAS,iBAAiB,CAAC,OAA6C,EAAE,OAAe;IACvF,OAAO,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC;AAC9E,CAAC;AAED,SAAS,UAAU,CAAC,QAAgB;IAClC,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'node:path';\nimport { createHash, type Hash } from 'node:crypto';\n\nimport ignore, { type Ignore } from 'ignore';\n\nimport { type IReadonlyLookupByPath, LookupByPath } from '@rushstack/lookup-by-path';\nimport { InternalError, Path, Sort } from '@rushstack/node-core-library';\n\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport type { IOperationSettings, RushProjectConfiguration } from '../../api/RushProjectConfiguration';\nimport { RushConstants } from '../RushConstants';\n\n/**\n * @beta\n */\nexport type IRushConfigurationProjectForSnapshot = Pick<\n  RushConfigurationProject,\n  'projectFolder' | 'projectRelativeFolder'\n>;\n\n/**\n * @internal\n */\nexport interface IInputsSnapshotProjectMetadata {\n  /**\n   * The contents of rush-project.json for the project, if available\n   */\n  projectConfig?: RushProjectConfiguration;\n  /**\n   * A map of operation name to additional files that should be included in the hash for that operation.\n   */\n  additionalFilesByOperationName?: ReadonlyMap<string, ReadonlySet<string>>;\n}\n\ninterface IInternalInputsSnapshotProjectMetadata extends IInputsSnapshotProjectMetadata {\n  /**\n   * Cached filter of files that are not ignored by the project's `incrementalBuildIgnoredGlobs`.\n   * @param filePath - The path to the file to check\n   * @returns true if the file path is an input to all operations in the project, false otherwise\n   */\n  projectFilePathFilter?: (filePath: string) => boolean;\n  /**\n   * The cached Git hashes for all files in the project folder.\n   */\n  hashes: Map<string, string>;\n  /**\n   * Cached hashes for all files in the project folder, including additional files.\n   * Upon calculating this map, input-output file collisions are detected.\n   */\n  fileHashesByOperationName: Map<string | undefined, Map<string, string>>;\n  /**\n   * The flattened state hash for each operation name, where the key \"undefined\" represents no particular operation.\n   */\n  hashByOperationName: Map<string | undefined, string>;\n  /**\n   * The project relative folder, which is a prefix in all relative paths.\n   */\n  relativePrefix: string;\n}\n\nexport type IRushSnapshotProjectMetadataMap = ReadonlyMap<\n  IRushConfigurationProjectForSnapshot,\n  IInputsSnapshotProjectMetadata\n>;\n\n/**\n * Function that computes a new snapshot of the current state of the repository as of the current moment.\n * Rush-level configuration state will have been bound during creation of the function.\n * Captures the state of the environment, tracked files, and additional files.\n *\n * @beta\n */\nexport type GetInputsSnapshotAsyncFn = () => Promise<IInputsSnapshot | undefined>;\n\n/**\n * The parameters for constructing an {@link InputsSnapshot}.\n * @internal\n */\nexport interface IInputsSnapshotParameters {\n  /**\n   * Hashes for files selected by `dependsOnAdditionalFiles`.\n   * Separated out to prevent being auto-assigned to a project.\n   */\n  additionalHashes?: ReadonlyMap<string, string>;\n  /**\n   * The environment to use for `dependsOnEnvVars`. By default performs a snapshot of process.env upon construction.\n   * @defaultValue \\{ ...process.env \\}\n   */\n  environment?: Record<string, string | undefined>;\n  /**\n   * File paths (keys into additionalHashes or hashes) to be included as part of every operation's dependencies.\n   */\n  globalAdditionalFiles?: Iterable<string>;\n  /**\n   * The hashes of all tracked files in the repository.\n   */\n  hashes: ReadonlyMap<string, string>;\n  /**\n   * Optimized lookup engine used to route `hashes` to individual projects.\n   */\n  lookupByPath: IReadonlyLookupByPath<IRushConfigurationProjectForSnapshot>;\n  /**\n   * Metadata for each project.\n   */\n  projectMap: IRushSnapshotProjectMetadataMap;\n  /**\n   * The directory that all relative paths are relative to.\n   */\n  rootDir: string;\n}\n\nconst { hashDelimiter } = RushConstants;\n\n/**\n * Represents a synchronously-queryable in-memory snapshot of the state of the inputs to a Rush repository.\n *\n * The methods on this interface are idempotent and will return the same result regardless of when they are executed.\n * @beta\n */\nexport interface IInputsSnapshot {\n  /**\n   * The raw hashes of all tracked files in the repository.\n   */\n  readonly hashes: ReadonlyMap<string, string>;\n\n  /**\n   * The directory that all paths in `hashes` are relative to.\n   */\n  readonly rootDirectory: string;\n\n  /**\n   * Gets the map of file paths to Git hashes that will be used to compute the local state hash of the operation.\n   * Exposed separately from the final state hash to facilitate detailed change detection.\n   *\n   * @param project - The Rush project to get hashes for\n   * @param operationName - The name of the operation (phase) to get hashes for. If omitted, returns a default set for the project, as used for bulk commands.\n   * @returns A map of file name to Git hash. For local files paths will be relative. Configured additional files may be absolute paths.\n   */\n  getTrackedFileHashesForOperation(\n    project: IRushConfigurationProjectForSnapshot,\n    operationName?: string\n  ): ReadonlyMap<string, string>;\n\n  /**\n   * Gets the state hash for the files owned by this operation, including the resolutions of package.json dependencies. This will later be combined with the hash of\n   * the command being executed and the final hashes of the operation's dependencies to compute the final hash for the operation.\n   * @param project - The Rush project to compute the state hash for\n   * @param operationName - The name of the operation (phase) to get hashes for. If omitted, returns a generic hash for the whole project, as used for bulk commands.\n   * @returns The local state hash for the project. This is a hash of the environment, the project's tracked files, and any additional files.\n   */\n  getOperationOwnStateHash(project: IRushConfigurationProjectForSnapshot, operationName?: string): string;\n}\n\n/**\n * Represents a synchronously-queryable in-memory snapshot of the state of the inputs to a Rush repository.\n * Any asynchronous work needs to be performed by the caller and the results passed to the constructor.\n *\n * @remarks\n * All operations on this class will return the same result regardless of when they are executed.\n *\n * @internal\n */\nexport class InputsSnapshot implements IInputsSnapshot {\n  /**\n   * {@inheritdoc IInputsSnapshot.hashes}\n   */\n  public readonly hashes: ReadonlyMap<string, string>;\n  /**\n   * {@inheritdoc IInputsSnapshot.rootDirectory}\n   */\n  public readonly rootDirectory: string;\n\n  /**\n   * The metadata for each project. This is a superset of the information in `projectMap` and includes caching of queries.\n   */\n  private readonly _projectMetadataMap: Map<\n    IRushConfigurationProjectForSnapshot,\n    IInternalInputsSnapshotProjectMetadata\n  >;\n  /**\n   * Hashes of files to be included in all result sets.\n   */\n  private readonly _globalAdditionalHashes: ReadonlyMap<string, string> | undefined;\n  /**\n   * Hashes for files selected by `dependsOnAdditionalFiles`.\n   */\n  private readonly _additionalHashes: ReadonlyMap<string, string> | undefined;\n  /**\n   * The environment to use for `dependsOnEnvVars`.\n   */\n  private readonly _environment: Record<string, string | undefined>;\n\n  /**\n   *\n   * @param params - The parameters for the snapshot\n   * @internal\n   */\n  public constructor(params: IInputsSnapshotParameters) {\n    const {\n      additionalHashes,\n      environment = { ...process.env },\n      globalAdditionalFiles,\n      hashes,\n      lookupByPath,\n      rootDir\n    } = params;\n    const projectMetadataMap: Map<\n      IRushConfigurationProjectForSnapshot,\n      IInternalInputsSnapshotProjectMetadata\n    > = new Map();\n    for (const [project, record] of params.projectMap) {\n      projectMetadataMap.set(project, createInternalRecord(project, record, rootDir));\n    }\n\n    // Route hashes to individual projects\n    for (const [file, hash] of hashes) {\n      const project: IRushConfigurationProjectForSnapshot | undefined = lookupByPath.findChildPath(file);\n      if (!project) {\n        continue;\n      }\n\n      let record: IInternalInputsSnapshotProjectMetadata | undefined = projectMetadataMap.get(project);\n      if (!record) {\n        projectMetadataMap.set(project, (record = createInternalRecord(project, undefined, rootDir)));\n      }\n\n      record.hashes.set(file, hash);\n    }\n\n    let globalAdditionalHashes: Map<string, string> | undefined;\n    if (globalAdditionalFiles) {\n      globalAdditionalHashes = new Map();\n      const sortedAdditionalFiles: string[] = Array.from(globalAdditionalFiles).sort();\n      for (const file of sortedAdditionalFiles) {\n        const hash: string | undefined = hashes.get(file);\n        if (!hash) {\n          throw new Error(`Hash not found for global file: \"${file}\"`);\n        }\n        const owningProject: IRushConfigurationProjectForSnapshot | undefined =\n          lookupByPath.findChildPath(file);\n        if (owningProject) {\n          throw new InternalError(\n            `Requested global additional file \"${file}\" is owned by project in \"${owningProject.projectRelativeFolder}\". Declare a project dependency instead.`\n          );\n        }\n        globalAdditionalHashes.set(file, hash);\n      }\n    }\n\n    for (const record of projectMetadataMap.values()) {\n      // Ensure stable ordering.\n      Sort.sortMapKeys(record.hashes);\n    }\n\n    this._projectMetadataMap = projectMetadataMap;\n    this._additionalHashes = additionalHashes;\n    this._globalAdditionalHashes = globalAdditionalHashes;\n    // Snapshot the environment so that queries are not impacted by when they happen\n    this._environment = environment;\n    this.hashes = hashes;\n    this.rootDirectory = rootDir;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public getTrackedFileHashesForOperation(\n    project: IRushConfigurationProjectForSnapshot,\n    operationName?: string\n  ): ReadonlyMap<string, string> {\n    const record: IInternalInputsSnapshotProjectMetadata | undefined = this._projectMetadataMap.get(project);\n    if (!record) {\n      throw new InternalError(`No information available for project at ${project.projectFolder}`);\n    }\n\n    const { fileHashesByOperationName } = record;\n    let hashes: Map<string, string> | undefined = fileHashesByOperationName.get(operationName);\n    if (!hashes) {\n      hashes = new Map();\n      fileHashesByOperationName.set(operationName, hashes);\n      // TODO: Support incrementalBuildIgnoredGlobs per-operation\n      const filter: (filePath: string) => boolean = getOrCreateProjectFilter(record);\n\n      let outputValidator: LookupByPath<string> | undefined;\n\n      if (operationName) {\n        const operationSettings: Readonly<IOperationSettings> | undefined =\n          record.projectConfig?.operationSettingsByOperationName.get(operationName);\n\n        const outputFolderNames: string[] | undefined = operationSettings?.outputFolderNames;\n        if (outputFolderNames) {\n          const { relativePrefix } = record;\n          outputValidator = new LookupByPath();\n          for (const folderName of outputFolderNames) {\n            outputValidator.setItem(`${relativePrefix}/${folderName}`, folderName);\n          }\n        }\n\n        // Hash any additional files (files outside of a project, untracked project files, or even files outside of the repository)\n        const additionalFilesForOperation: ReadonlySet<string> | undefined =\n          record.additionalFilesByOperationName?.get(operationName);\n        if (additionalFilesForOperation) {\n          for (const [filePath, hash] of this._resolveHashes(additionalFilesForOperation)) {\n            hashes.set(filePath, hash);\n          }\n        }\n      }\n\n      const { _globalAdditionalHashes: globalAdditionalHashes } = this;\n      if (globalAdditionalHashes) {\n        for (const [file, hash] of globalAdditionalHashes) {\n          record.hashes.set(file, hash);\n        }\n      }\n\n      // Hash the base project files\n      for (const [filePath, hash] of record.hashes) {\n        if (filter(filePath)) {\n          hashes.set(filePath, hash);\n        }\n\n        // Ensure that the configured output folders for this operation do not contain any input files\n        // This should be reworked to operate on a global file origin map to ensure a hashed input\n        // is not a declared output of *any* operation.\n        const outputMatch: string | undefined = outputValidator?.findChildPath(filePath);\n        if (outputMatch) {\n          throw new Error(\n            `Configured output folder \"${outputMatch}\" for operation \"${operationName}\" in project \"${project.projectRelativeFolder}\" contains tracked input file \"${filePath}\".` +\n              ` If it is intended that this operation modifies its own input files, modify the build process to emit a warning if the output version differs from the input, and remove the directory from \"outputFolderNames\".` +\n              ` This will ensure cache correctness. Otherwise, change the build process to output to a disjoint folder.`\n          );\n        }\n      }\n    }\n\n    return hashes;\n  }\n\n  /**\n   * {@inheritdoc}\n   */\n  public getOperationOwnStateHash(\n    project: IRushConfigurationProjectForSnapshot,\n    operationName?: string\n  ): string {\n    const record: IInternalInputsSnapshotProjectMetadata | undefined = this._projectMetadataMap.get(project);\n    if (!record) {\n      throw new Error(`No information available for project at ${project.projectFolder}`);\n    }\n\n    const { hashByOperationName } = record;\n    let hash: string | undefined = hashByOperationName.get(operationName);\n    if (!hash) {\n      const hashes: ReadonlyMap<string, string> = this.getTrackedFileHashesForOperation(\n        project,\n        operationName\n      );\n\n      const hasher: Hash = createHash('sha1');\n      // If this is for a specific operation, apply operation-specific options\n      if (operationName) {\n        const operationSettings: Readonly<IOperationSettings> | undefined =\n          record.projectConfig?.operationSettingsByOperationName.get(operationName);\n        if (operationSettings) {\n          const { dependsOnEnvVars, outputFolderNames } = operationSettings;\n          if (dependsOnEnvVars) {\n            // As long as we enumerate environment variables in a consistent order, we will get a stable hash.\n            // Changing the order in rush-project.json will change the hash anyway since the file contents are part of the hash.\n            for (const envVar of dependsOnEnvVars) {\n              hasher.update(`${hashDelimiter}$${envVar}=${this._environment[envVar] || ''}`);\n            }\n          }\n\n          if (outputFolderNames) {\n            hasher.update(`${hashDelimiter}${JSON.stringify(outputFolderNames)}`);\n          }\n        }\n      }\n\n      // Hash the base project files\n      for (const [filePath, fileHash] of hashes) {\n        hasher.update(`${hashDelimiter}${filePath}${hashDelimiter}${fileHash}`);\n      }\n\n      hash = hasher.digest('hex');\n\n      hashByOperationName.set(operationName, hash);\n    }\n\n    return hash;\n  }\n\n  private *_resolveHashes(filePaths: Iterable<string>): Generator<[string, string]> {\n    const { hashes, _additionalHashes } = this;\n\n    for (const filePath of filePaths) {\n      const hash: string | undefined = hashes.get(filePath) ?? _additionalHashes?.get(filePath);\n      if (!hash) {\n        throw new Error(`Could not find hash for file path \"${filePath}\"`);\n      }\n      yield [filePath, hash];\n    }\n  }\n}\n\nfunction getOrCreateProjectFilter(\n  record: IInternalInputsSnapshotProjectMetadata\n): (filePath: string) => boolean {\n  if (!record.projectFilePathFilter) {\n    const ignoredGlobs: readonly string[] | undefined = record.projectConfig?.incrementalBuildIgnoredGlobs;\n    if (!ignoredGlobs || ignoredGlobs.length === 0) {\n      record.projectFilePathFilter = noopFilter;\n    } else {\n      const ignorer: Ignore = ignore();\n      ignorer.add(ignoredGlobs as string[]);\n      const prefixLength: number = record.relativePrefix.length + 1;\n      record.projectFilePathFilter = function projectFilePathFilter(filePath: string): boolean {\n        return !ignorer.ignores(filePath.slice(prefixLength));\n      };\n    }\n  }\n\n  return record.projectFilePathFilter;\n}\n\nfunction createInternalRecord(\n  project: IRushConfigurationProjectForSnapshot,\n  baseRecord: IInputsSnapshotProjectMetadata | undefined,\n  rootDir: string\n): IInternalInputsSnapshotProjectMetadata {\n  return {\n    // Data from the caller\n    projectConfig: baseRecord?.projectConfig,\n    additionalFilesByOperationName: baseRecord?.additionalFilesByOperationName,\n\n    // Caches\n    hashes: new Map(),\n    hashByOperationName: new Map(),\n    fileHashesByOperationName: new Map(),\n    relativePrefix: getRelativePrefix(project, rootDir)\n  };\n}\n\nfunction getRelativePrefix(project: IRushConfigurationProjectForSnapshot, rootDir: string): string {\n  return Path.convertToSlashes(path.relative(rootDir, project.projectFolder));\n}\n\nfunction noopFilter(filePath: string): boolean {\n  return true;\n}\n"]}