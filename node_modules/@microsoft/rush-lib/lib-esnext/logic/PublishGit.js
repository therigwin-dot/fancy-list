// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
import { PublishUtilities } from './PublishUtilities';
import { Utilities } from '../utilities/Utilities';
const DUMMY_BRANCH_NAME = '-branch-name-';
export class PublishGit {
    constructor(git, targetBranch) {
        this._targetBranch = targetBranch;
        this._gitPath = git.getGitPathOrThrow();
        this._gitTagSeparator = git.getTagSeparator();
    }
    async checkoutAsync(branchName, createBranch = false) {
        const params = ['checkout'];
        if (createBranch) {
            params.push('-b');
        }
        params.push(branchName || DUMMY_BRANCH_NAME);
        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, params);
    }
    async mergeAsync(branchName, verify = false) {
        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, [
            'merge',
            branchName,
            '--no-edit',
            ...(verify ? [] : ['--no-verify'])
        ]);
    }
    async deleteBranchAsync(branchName, hasRemote = true, verify = false) {
        if (!branchName) {
            branchName = DUMMY_BRANCH_NAME;
        }
        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, [
            'branch',
            '-d',
            branchName
        ]);
        if (hasRemote) {
            await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, [
                'push',
                'origin',
                '--delete',
                branchName,
                ...(verify ? [] : ['--no-verify'])
            ]);
        }
    }
    async pullAsync(verify = false) {
        const params = ['pull', 'origin'];
        if (this._targetBranch) {
            params.push(this._targetBranch);
        }
        if (!verify) {
            params.push('--no-verify');
        }
        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, params);
    }
    async fetchAsync() {
        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, ['fetch', 'origin']);
    }
    async addChangesAsync(pathspec, workingDirectory) {
        const files = pathspec ? pathspec : '.';
        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, ['add', files], workingDirectory ? workingDirectory : process.cwd());
    }
    async addTagAsync(shouldExecute, packageName, packageVersion, commitId, preReleaseName) {
        // Tagging only happens if we're publishing to real NPM and committing to git.
        const tagName = PublishUtilities.createTagname(packageName, packageVersion, this._gitTagSeparator);
        await PublishUtilities.execCommandAsync(!!this._targetBranch && shouldExecute, this._gitPath, [
            'tag',
            '-a',
            preReleaseName ? `${tagName}-${preReleaseName}` : tagName,
            '-m',
            preReleaseName
                ? `${packageName} v${packageVersion}-${preReleaseName}`
                : `${packageName} v${packageVersion}`,
            ...(commitId ? [commitId] : [])
        ]);
    }
    async hasTagAsync(packageConfig) {
        const tagName = PublishUtilities.createTagname(packageConfig.packageName, packageConfig.packageJson.version, this._gitTagSeparator);
        const tagOutput = (await Utilities.executeCommandAndCaptureOutputAsync(this._gitPath, ['tag', '-l', tagName], packageConfig.projectFolder, PublishUtilities.getEnvArgs(), true)).replace(/(\r\n|\n|\r)/gm, '');
        return tagOutput === tagName;
    }
    async commitAsync(commitMessage, verify = false) {
        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, [
            'commit',
            '-m',
            commitMessage,
            ...(verify ? [] : ['--no-verify'])
        ]);
    }
    async pushAsync(branchName, verify = false) {
        await PublishUtilities.execCommandAsync(!!this._targetBranch, this._gitPath, 
        // We append "--no-verify" to prevent Git hooks from running.  For example, people may
        // want to invoke "rush change -v" as a pre-push hook.
        [
            'push',
            'origin',
            `HEAD:${branchName || DUMMY_BRANCH_NAME}`,
            '--follow-tags',
            '--verbose',
            ...(verify ? [] : ['--no-verify'])
        ]);
    }
}
//# sourceMappingURL=PublishGit.js.map