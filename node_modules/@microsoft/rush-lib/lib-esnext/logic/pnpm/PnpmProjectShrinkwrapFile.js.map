{"version":3,"file":"PnpmProjectShrinkwrapFile.js","sourceRoot":"","sources":["../../../src/logic/pnpm/PnpmProjectShrinkwrapFile.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as crypto from 'crypto';\nimport { InternalError, JsonFile } from '@rushstack/node-core-library';\n\nimport { BaseProjectShrinkwrapFile } from '../base/BaseProjectShrinkwrapFile';\nimport type {\n  PnpmShrinkwrapFile,\n  IPnpmShrinkwrapDependencyYaml,\n  IPnpmVersionSpecifier\n} from './PnpmShrinkwrapFile';\nimport type { DependencySpecifier } from '../DependencySpecifier';\nimport { RushConstants } from '../RushConstants';\nimport type { Subspace } from '../../api/Subspace';\n\n/**\n *\n */\nexport class PnpmProjectShrinkwrapFile extends BaseProjectShrinkwrapFile<PnpmShrinkwrapFile> {\n  /**\n   * Generate and write the project shrinkwrap file to <project>/.rush/temp/shrinkwrap-deps.json.\n   * @returns True if the project shrinkwrap was created or updated, false otherwise.\n   */\n  public async updateProjectShrinkwrapAsync(): Promise<void> {\n    const projectShrinkwrapMap: Map<string, string> | undefined = this.generateProjectShrinkwrapMap();\n\n    return projectShrinkwrapMap ? this.saveAsync(projectShrinkwrapMap) : this.deleteIfExistsAsync();\n  }\n\n  public hasChanges(otherShrinkwrap: PnpmProjectShrinkwrapFile): boolean {\n    if (\n      !otherShrinkwrap.shrinkwrapFile.isWorkspaceCompatible &&\n      !otherShrinkwrap.shrinkwrapFile.getTempProjectDependencyKey(this.project.tempProjectName)\n    ) {\n      // The project is new to the shrinkwrap file.\n      return true;\n    }\n\n    const otherMap: Map<string, string> | undefined = otherShrinkwrap.generateProjectShrinkwrapMap();\n    const thisMap: Map<string, string> | undefined = this.generateProjectShrinkwrapMap();\n\n    if (!thisMap || !otherMap) {\n      // Handle one or both being undefined.\n      return !!(thisMap || otherMap);\n    }\n\n    if (thisMap.size !== otherMap.size) {\n      // Entries added or removed\n      return true;\n    }\n\n    for (const [key, value] of thisMap) {\n      if (otherMap.get(key) !== value) {\n        // A dependency changed or was added/removed\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Generate the project shrinkwrap file content\n   */\n  protected generateProjectShrinkwrapMap(): Map<string, string> | undefined {\n    const projectShrinkwrapMap: Map<string, string> | undefined = this.shrinkwrapFile.isWorkspaceCompatible\n      ? this.generateWorkspaceProjectShrinkwrapMap()\n      : this.generateLegacyProjectShrinkwrapMap();\n\n    return projectShrinkwrapMap;\n  }\n\n  protected generateWorkspaceProjectShrinkwrapMap(): Map<string, string> | undefined {\n    // Obtain the workspace importer from the shrinkwrap, which lists resolved dependencies\n    const subspace: Subspace = this.project.subspace;\n\n    const importerKey: string = this.shrinkwrapFile.getImporterKeyByPath(\n      subspace.getSubspaceTempFolderPath(),\n      this.project.projectFolder\n    );\n\n    const projectShrinkwrapMap: Map<string, string> | undefined =\n      this.shrinkwrapFile.getIntegrityForImporter(importerKey);\n\n    return projectShrinkwrapMap;\n  }\n\n  protected generateLegacyProjectShrinkwrapMap(): Map<string, string> {\n    const tempProjectDependencyKey: string | undefined = this.shrinkwrapFile.getTempProjectDependencyKey(\n      this.project.tempProjectName\n    );\n    if (!tempProjectDependencyKey) {\n      throw new Error(`Cannot get dependency key for temp project: ${this.project.tempProjectName}`);\n    }\n    const parentShrinkwrapEntry: IPnpmShrinkwrapDependencyYaml =\n      this.shrinkwrapFile.getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey)!;\n\n    const allDependencies: [string, IPnpmVersionSpecifier][] = [\n      ...Object.entries(parentShrinkwrapEntry.dependencies || {}),\n      ...Object.entries(parentShrinkwrapEntry.optionalDependencies || {})\n    ];\n\n    const projectShrinkwrapMap: Map<string, string> = new Map();\n    for (const [name, version] of allDependencies) {\n      if (name.indexOf(`${RushConstants.rushTempNpmScope}/`) < 0) {\n        // Only select the shrinkwrap dependencies that are non-local since we already handle local\n        // project changes\n        this._addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry);\n      }\n    }\n\n    // Since peer dependencies within on external packages may be hoisted up to the top-level package,\n    // we need to resolve and add these dependencies directly\n    this._resolveAndAddPeerDependencies(projectShrinkwrapMap, parentShrinkwrapEntry);\n\n    return projectShrinkwrapMap;\n  }\n\n  private _addDependencyRecursive(\n    projectShrinkwrapMap: Map<string, string>,\n    name: string,\n    version: IPnpmVersionSpecifier,\n    parentShrinkwrapEntry: IPnpmShrinkwrapDependencyYaml,\n    throwIfShrinkwrapEntryMissing: boolean = true\n  ): void {\n    const specifier: string = `${name}@${version}`;\n    if (projectShrinkwrapMap.has(specifier)) {\n      // getShrinkwrapEntry is idempotent with respect to name and version\n      return;\n    }\n\n    const shrinkwrapEntry: IPnpmShrinkwrapDependencyYaml | undefined = this.shrinkwrapFile.getShrinkwrapEntry(\n      name,\n      version\n    );\n\n    if (!shrinkwrapEntry) {\n      if (throwIfShrinkwrapEntryMissing) {\n        throw new InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);\n      }\n      return;\n    }\n\n    let integrity: string | undefined = shrinkwrapEntry.resolution?.integrity;\n    if (!integrity) {\n      // git dependency specifiers do not have an integrity entry. Instead, they specify the tarball field.\n      // So instead, we will hash the contents of the dependency entry and use that as the integrity hash.\n      // Ex:\n      // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:\n      //   ...\n      //   resolution:\n      //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'\n      const sha256Digest: string = crypto\n        .createHash('sha256')\n        .update(JSON.stringify(shrinkwrapEntry))\n        .digest('hex');\n      integrity = `${name}@${version}:${sha256Digest}:`;\n    }\n\n    // Add the current dependency\n    projectShrinkwrapMap.set(specifier, integrity);\n\n    // Add the dependencies of the dependency\n    for (const [dependencyName, dependencyVersion] of Object.entries(shrinkwrapEntry.dependencies || {})) {\n      this._addDependencyRecursive(projectShrinkwrapMap, dependencyName, dependencyVersion, shrinkwrapEntry);\n    }\n\n    // Add the optional dependencies of the dependency, and don't blow up if they don't exist\n    for (const [dependencyName, dependencyVersion] of Object.entries(\n      shrinkwrapEntry.optionalDependencies || {}\n    )) {\n      this._addDependencyRecursive(\n        projectShrinkwrapMap,\n        dependencyName,\n        dependencyVersion,\n        shrinkwrapEntry,\n        /* throwIfShrinkwrapEntryMissing */ false\n      );\n    }\n\n    // When using workspaces, hoisting of peer dependencies to a singular top-level project is not possible.\n    // Therefore, all packages that are consumed should be specified in the dependency tree. Given this, there\n    // is no need to look for peer dependencies, since it is simply a constraint to be validated by the\n    // package manager.\n    if (!this.shrinkwrapFile.isWorkspaceCompatible) {\n      this._resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry);\n    }\n  }\n\n  private _resolveAndAddPeerDependencies(\n    projectShrinkwrapMap: Map<string, string>,\n    shrinkwrapEntry: IPnpmShrinkwrapDependencyYaml,\n    parentShrinkwrapEntry?: IPnpmShrinkwrapDependencyYaml\n  ): void {\n    for (const peerDependencyName of Object.keys(shrinkwrapEntry.peerDependencies || {})) {\n      // Skip peer dependency resolution of local package peer dependencies\n      if (peerDependencyName.indexOf(RushConstants.rushTempNpmScope) !== -1) {\n        continue;\n      }\n\n      // Check to see if the peer dependency is satisfied with the current shrinkwrap\n      // entry. If not, check the parent shrinkwrap entry. Finally, if neither have\n      // the specified dependency, check that the parent mentions the dependency in\n      // it's own peer dependencies. If it is, we can rely on the package manager and\n      // make the assumption that we've already found it further up the stack.\n      if (\n        shrinkwrapEntry.dependencies?.hasOwnProperty(peerDependencyName) ||\n        parentShrinkwrapEntry?.dependencies?.hasOwnProperty(peerDependencyName) ||\n        parentShrinkwrapEntry?.peerDependencies?.hasOwnProperty(peerDependencyName)\n      ) {\n        continue;\n      }\n\n      // As a last attempt, check if it's been hoisted up as a top-level dependency. If\n      // we can't find it, we can assume that it's already been provided somewhere up the\n      // dependency tree.\n      const topLevelDependencySpecifier: DependencySpecifier | undefined =\n        this.shrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);\n\n      if (topLevelDependencySpecifier) {\n        this._addDependencyRecursive(\n          projectShrinkwrapMap,\n          peerDependencyName,\n          this.shrinkwrapFile.getTopLevelDependencyKey(peerDependencyName)!,\n          shrinkwrapEntry\n        );\n      }\n    }\n  }\n\n  /**\n   * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json\n   */\n  protected async saveAsync(projectShrinkwrapMap: Map<string, string>): Promise<void> {\n    const file: { [specifier: string]: string } = {};\n    const keys: string[] = Array.from(projectShrinkwrapMap.keys()).sort();\n    for (const key of keys) {\n      file[key] = projectShrinkwrapMap.get(key)!;\n    }\n    await JsonFile.saveAsync(file, this.projectShrinkwrapFilePath, { ensureFolderExists: true });\n  }\n}\n"]}