// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
import * as path from 'path';
import { FileSystem, Import, JsonFile } from '@rushstack/node-core-library';
import { subspacePnpmfileShimFilename, scriptsFolderPath } from '../../utilities/PathConstants';
import { RushConstants } from '../RushConstants';
/**
 * Loads PNPM's pnpmfile.js configuration, and invokes it to preprocess package.json files,
 * optionally utilizing a pnpmfile shim to inject preferred versions.
 */
export class SubspacePnpmfileConfiguration {
    /**
     * Split workspace use global pnpmfile, because in split workspace, user may set `shared-workspace-lockfile=false`.
     * That means each project owns their individual pnpmfile under project folder. While the global pnpmfile could be
     * under the common/temp-split/ folder and be used by all split workspace projects.
     */
    static async writeCommonTempSubspaceGlobalPnpmfileAsync(rushConfiguration, subspace, variant) {
        if (rushConfiguration.packageManager !== 'pnpm') {
            throw new Error(`PnpmfileConfiguration cannot be used with package manager "${rushConfiguration.packageManager}"`);
        }
        const targetDir = subspace.getSubspaceTempFolderPath();
        const subspaceGlobalPnpmfilePath = path.join(targetDir, RushConstants.pnpmfileGlobalFilename);
        // Write the shim itself
        await FileSystem.copyFileAsync({
            sourcePath: `${scriptsFolderPath}/${subspacePnpmfileShimFilename}`,
            destinationPath: subspaceGlobalPnpmfilePath
        });
        const subspaceGlobalPnpmfileShimSettings = SubspacePnpmfileConfiguration.getSubspacePnpmfileShimSettings(rushConfiguration, subspace, variant);
        // Write the settings file used by the shim
        await JsonFile.saveAsync(subspaceGlobalPnpmfileShimSettings, path.join(targetDir, 'pnpmfileSettings.json'), {
            ensureFolderExists: true
        });
    }
    static getSubspacePnpmfileShimSettings(rushConfiguration, subspace, variant) {
        const workspaceProjects = {};
        const subspaceProjects = {};
        const projectNameToInjectedDependenciesMap = SubspacePnpmfileConfiguration._getProjectNameToInjectedDependenciesMap(rushConfiguration, subspace);
        for (const project of rushConfiguration.projects) {
            const { packageName, projectRelativeFolder, packageJson } = project;
            const workspaceProjectInfo = {
                packageName,
                projectRelativeFolder,
                packageVersion: packageJson.version,
                injectedDependencies: Array.from(projectNameToInjectedDependenciesMap.get(packageName) || [])
            };
            (subspace.contains(project) ? subspaceProjects : workspaceProjects)[packageName] = workspaceProjectInfo;
        }
        const settings = {
            workspaceProjects,
            subspaceProjects,
            semverPath: Import.resolveModule({ modulePath: 'semver', baseFolderPath: __dirname })
        };
        // common/config/subspaces/<subspace_name>/.pnpmfile.cjs
        const userPnpmfilePath = path.join(subspace.getVariantDependentSubspaceConfigFolderPath(variant), rushConfiguration.packageManagerWrapper.pnpmfileFilename);
        if (FileSystem.exists(userPnpmfilePath)) {
            settings.userPnpmfilePath = userPnpmfilePath;
        }
        return settings;
    }
    static _getProjectNameToInjectedDependenciesMap(rushConfiguration, subspace) {
        var _a, _b, _c, _d;
        const projectNameToInjectedDependenciesMap = new Map();
        const workspaceProjectsMap = new Map();
        const subspaceProjectsMap = new Map();
        for (const project of rushConfiguration.projects) {
            if (subspace.contains(project)) {
                subspaceProjectsMap.set(project.packageName, project);
            }
            else {
                workspaceProjectsMap.set(project.packageName, project);
            }
            projectNameToInjectedDependenciesMap.set(project.packageName, new Set());
        }
        const processTransitiveInjectedInstallQueue = [];
        for (const subspaceProject of subspaceProjectsMap.values()) {
            const injectedDependencySet = new Set();
            const dependenciesMeta = subspaceProject.packageJson.dependenciesMeta;
            if (dependenciesMeta) {
                for (const [dependencyName, { injected }] of Object.entries(dependenciesMeta)) {
                    if (injected) {
                        injectedDependencySet.add(dependencyName);
                        (_a = projectNameToInjectedDependenciesMap.get(subspaceProject.packageName)) === null || _a === void 0 ? void 0 : _a.add(dependencyName);
                        //if this dependency is in the same subspace, leave as it is, PNPM will handle it
                        //if this dependency is in another subspace, then it is transitive injected installation
                        //so, we need to let all the workspace dependencies along the dependency chain to use injected installation
                        if (!subspaceProjectsMap.has(dependencyName)) {
                            processTransitiveInjectedInstallQueue.push(workspaceProjectsMap.get(dependencyName));
                        }
                    }
                }
            }
            // if alwaysInjectDependenciesFromOtherSubspaces policy is true in pnpm-config.json
            // and the dependency is not injected yet
            // and the dependency is in another subspace
            // then, make this dependency as injected dependency
            const pnpmOptions = subspace.getPnpmOptions() || rushConfiguration.pnpmOptions;
            if (pnpmOptions && pnpmOptions.alwaysInjectDependenciesFromOtherSubspaces) {
                const dependencyProjects = subspaceProject.dependencyProjects;
                for (const dependencyProject of dependencyProjects) {
                    const dependencyName = dependencyProject.packageName;
                    if (!injectedDependencySet.has(dependencyName) && !subspaceProjectsMap.has(dependencyName)) {
                        (_b = projectNameToInjectedDependenciesMap.get(subspaceProject.packageName)) === null || _b === void 0 ? void 0 : _b.add(dependencyName);
                        // process transitive injected installation
                        processTransitiveInjectedInstallQueue.push(workspaceProjectsMap.get(dependencyName));
                    }
                }
            }
        }
        // rewrite all workspace dependencies to injected install all for transitive injected installation case
        while (processTransitiveInjectedInstallQueue.length > 0) {
            const currentProject = processTransitiveInjectedInstallQueue.shift();
            const dependencies = (_c = currentProject === null || currentProject === void 0 ? void 0 : currentProject.packageJson) === null || _c === void 0 ? void 0 : _c.dependencies;
            const optionalDependencies = (_d = currentProject === null || currentProject === void 0 ? void 0 : currentProject.packageJson) === null || _d === void 0 ? void 0 : _d.optionalDependencies;
            if (currentProject) {
                if (dependencies) {
                    SubspacePnpmfileConfiguration._processDependenciesForTransitiveInjectedInstall(projectNameToInjectedDependenciesMap, processTransitiveInjectedInstallQueue, dependencies, currentProject, rushConfiguration);
                }
                if (optionalDependencies) {
                    SubspacePnpmfileConfiguration._processDependenciesForTransitiveInjectedInstall(projectNameToInjectedDependenciesMap, processTransitiveInjectedInstallQueue, optionalDependencies, currentProject, rushConfiguration);
                }
            }
        }
        return projectNameToInjectedDependenciesMap;
    }
    static _processDependenciesForTransitiveInjectedInstall(projectNameToInjectedDependencies, processTransitiveInjectedInstallQueue, dependencies, currentProject, rushConfiguration) {
        var _a;
        for (const dependencyName in dependencies) {
            if (dependencies[dependencyName].startsWith('workspace:')) {
                (_a = projectNameToInjectedDependencies.get(currentProject.packageName)) === null || _a === void 0 ? void 0 : _a.add(dependencyName);
                const nextProject = rushConfiguration.getProjectByName(dependencyName);
                if (nextProject) {
                    processTransitiveInjectedInstallQueue.push(nextProject);
                }
            }
        }
    }
}
//# sourceMappingURL=SubspacePnpmfileConfiguration.js.map