// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/**
 * Fork https://github.com/pnpm/pnpm/blob/main/lockfile/fs/src/lockfileFormatConverters.ts
 *
 * Pnpm lockfile v9 have some breaking changes on the lockfile format. For Example, the "packages" field has been split into "packages" and "snapshots" two parts.
 * Rush should not parse the lockfile by itself, but should rely on pnpm to parse the lockfile.
 * To ensure consistency with pnpm's parsing logic, I copied the relevant logic from @pnpm/lockfile.fs to this file.
 *
 * There are some reasons for copying the relevant logic instead of depending on @pnpm/lockfile.fs directly:
 * 1. @pnpm/lockfile.fs has a exports filed in package.json, which will cause convertLockfileV9ToLockfileObject cannot be imported directly.
 * 2. @pnpm/lockfile.fs only provides asynchronous read methods, while rush requires synchronous reading of the lockfile file.
 * Perhaps this file will be deleted in the future and instead depend on @pnpm/lockfile.fs directly.
 */
import { removeSuffix } from '@pnpm/dependency-path';
import { removeNullishProps } from '../../utilities/objectUtilities';
// eslint-disable-next-line @typescript-eslint/typedef
const DEPENDENCIES_FIELDS = ['optionalDependencies', 'dependencies', 'devDependencies'];
function revertProjectSnapshot(from) {
    const specifiers = {};
    function moveSpecifiers(fromDep) {
        const resolvedDependencies = {};
        for (const [depName, { specifier, version }] of Object.entries(fromDep)) {
            const existingValue = specifiers[depName];
            if (existingValue != null && existingValue !== specifier) {
                throw new Error(`Project snapshot lists the same dependency more than once with conflicting versions: ${depName}`);
            }
            specifiers[depName] = specifier;
            resolvedDependencies[depName] = version;
        }
        return resolvedDependencies;
    }
    const dependencies = from.dependencies == null ? from.dependencies : moveSpecifiers(from.dependencies);
    const devDependencies = from.devDependencies == null ? from.devDependencies : moveSpecifiers(from.devDependencies);
    const optionalDependencies = from.optionalDependencies == null ? from.optionalDependencies : moveSpecifiers(from.optionalDependencies);
    return Object.assign(Object.assign({}, removeNullishProps(Object.assign(Object.assign({}, from), { dependencies,
        devDependencies,
        optionalDependencies }))), { specifiers });
}
function convertFromLockfileFileMutable(lockfileFile) {
    if (typeof (lockfileFile === null || lockfileFile === void 0 ? void 0 : lockfileFile.importers) === 'undefined') {
        lockfileFile.importers = {
            '.': {
                dependenciesMeta: lockfileFile.dependenciesMeta,
                publishDirectory: lockfileFile.publishDirectory
            }
        };
        for (const depType of DEPENDENCIES_FIELDS) {
            if (lockfileFile[depType] != null) {
                lockfileFile.importers['.'][depType] = lockfileFile[depType];
                delete lockfileFile[depType];
            }
        }
    }
    return lockfileFile;
}
function mapValues(obj, mapper) {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
        result[key] = mapper(value, key);
    }
    return result;
}
/**
 * Convert lockfile v9 object to standard lockfile object.
 *
 * This function will mutate the lockfile object. It will:
 * 1. Ensure importers['.'] exists.
 * 2. Merge snapshots and packages into packages.
 * 3. Extract specifier from importers['xxx'] into the specifiers field.
 */
export function convertLockfileV9ToLockfileObject(lockfile) {
    var _a, _b;
    const _c = convertFromLockfileFileMutable(lockfile), { importers } = _c, rest = __rest(_c, ["importers"]);
    const packages = {};
    for (const [depPath, pkg] of Object.entries((_a = lockfile.snapshots) !== null && _a !== void 0 ? _a : {})) {
        const pkgId = removeSuffix(depPath);
        packages[depPath] = Object.assign(pkg, (_b = lockfile.packages) === null || _b === void 0 ? void 0 : _b[pkgId]);
    }
    return Object.assign(Object.assign({}, rest), { packages, importers: mapValues(importers !== null && importers !== void 0 ? importers : {}, revertProjectSnapshot) });
}
//# sourceMappingURL=PnpmShrinkWrapFileConverters.js.map