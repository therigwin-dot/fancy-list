// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
import * as path from 'path';
import { FileConstants, FileSystem, JsonFile, LockFile } from '@rushstack/node-core-library';
import { Colorize } from '@rushstack/terminal';
import { LastInstallFlag } from '../../api/LastInstallFlag';
import { Utilities } from '../../utilities/Utilities';
import { merge } from '../../utilities/objectUtilities';
import { RushConstants } from '../RushConstants';
import * as semver from 'semver';
export class InstallHelpers {
    static generateCommonPackageJson(rushConfiguration, subspace, dependencies = new Map(), terminal) {
        const commonPackageJson = {
            dependencies: {},
            description: 'Temporary file generated by the Rush tool',
            name: 'rush-common',
            private: true,
            version: '0.0.0'
        };
        if (rushConfiguration.isPnpm) {
            const pnpmOptions = subspace.getPnpmOptions() || rushConfiguration.pnpmOptions;
            if (!commonPackageJson.pnpm) {
                commonPackageJson.pnpm = {};
            }
            if (pnpmOptions.globalOverrides) {
                commonPackageJson.pnpm.overrides = pnpmOptions.globalOverrides;
            }
            if (pnpmOptions.globalPackageExtensions) {
                commonPackageJson.pnpm.packageExtensions = pnpmOptions.globalPackageExtensions;
            }
            if (pnpmOptions.globalPeerDependencyRules) {
                commonPackageJson.pnpm.peerDependencyRules = pnpmOptions.globalPeerDependencyRules;
            }
            if (pnpmOptions.globalNeverBuiltDependencies) {
                commonPackageJson.pnpm.neverBuiltDependencies = pnpmOptions.globalNeverBuiltDependencies;
            }
            if (pnpmOptions.globalIgnoredOptionalDependencies) {
                if (rushConfiguration.rushConfigurationJson.pnpmVersion !== undefined &&
                    semver.lt(rushConfiguration.rushConfigurationJson.pnpmVersion, '9.0.0')) {
                    terminal.writeWarningLine(Colorize.yellow(`Your version of pnpm (${rushConfiguration.rushConfigurationJson.pnpmVersion}) ` +
                        `doesn't support the "globalIgnoredOptionalDependencies" field in ` +
                        `${rushConfiguration.commonRushConfigFolder}/${RushConstants.pnpmConfigFilename}. ` +
                        'Remove this field or upgrade to pnpm 9.'));
                }
                commonPackageJson.pnpm.ignoredOptionalDependencies = pnpmOptions.globalIgnoredOptionalDependencies;
            }
            if (pnpmOptions.globalAllowedDeprecatedVersions) {
                commonPackageJson.pnpm.allowedDeprecatedVersions = pnpmOptions.globalAllowedDeprecatedVersions;
            }
            if (pnpmOptions.globalPatchedDependencies) {
                commonPackageJson.pnpm.patchedDependencies = pnpmOptions.globalPatchedDependencies;
            }
            if (pnpmOptions.unsupportedPackageJsonSettings) {
                merge(commonPackageJson, pnpmOptions.unsupportedPackageJsonSettings);
            }
        }
        // Add any preferred versions to the top of the commonPackageJson
        // do this in alphabetical order for simpler debugging
        for (const dependency of Array.from(dependencies.keys()).sort()) {
            commonPackageJson.dependencies[dependency] = dependencies.get(dependency);
        }
        // Example: "C:\MyRepo\common\temp\package.json"
        const commonPackageJsonFilename = path.join(subspace.getSubspaceTempFolderPath(), FileConstants.PackageJson);
        // Don't update the file timestamp unless the content has changed, since "rush install"
        // will consider this timestamp
        JsonFile.save(commonPackageJson, commonPackageJsonFilename, { onlyIfChanged: true });
    }
    static getPackageManagerEnvironment(rushConfiguration, options = {}) {
        let configurationEnvironment = undefined;
        if (rushConfiguration.packageManager === 'npm') {
            if (rushConfiguration.npmOptions && rushConfiguration.npmOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.npmOptions.environmentVariables;
            }
        }
        else if (rushConfiguration.isPnpm) {
            if (rushConfiguration.pnpmOptions && rushConfiguration.pnpmOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.pnpmOptions.environmentVariables;
            }
        }
        else if (rushConfiguration.packageManager === 'yarn') {
            if (rushConfiguration.yarnOptions && rushConfiguration.yarnOptions.environmentVariables) {
                configurationEnvironment = rushConfiguration.yarnOptions.environmentVariables;
            }
        }
        return InstallHelpers._mergeEnvironmentVariables(process.env, configurationEnvironment, options);
    }
    /**
     * If the "(p)npm-local" symlink hasn't been set up yet, this creates it, installing the
     * specified (P)npm version in the user's home directory if needed.
     */
    static async ensureLocalPackageManagerAsync(rushConfiguration, rushGlobalFolder, maxInstallAttempts, restrictConsoleOutput) {
        let logIfConsoleOutputIsNotRestricted;
        if (restrictConsoleOutput) {
            logIfConsoleOutputIsNotRestricted = () => {
                /* noop */
            };
        }
        else {
            logIfConsoleOutputIsNotRestricted = (message) => {
                // eslint-disable-next-line no-console
                console.log(message);
            };
        }
        // Example: "C:\Users\YourName\.rush"
        const rushUserFolder = rushGlobalFolder.nodeSpecificPath;
        if (!FileSystem.exists(rushUserFolder)) {
            logIfConsoleOutputIsNotRestricted('Creating ' + rushUserFolder);
            FileSystem.ensureFolder(rushUserFolder);
        }
        const packageManager = rushConfiguration.packageManager;
        const packageManagerVersion = rushConfiguration.packageManagerToolVersion;
        const packageManagerAndVersion = `${packageManager}-${packageManagerVersion}`;
        // Example: "C:\Users\YourName\.rush\pnpm-1.2.3"
        const packageManagerToolFolder = path.join(rushUserFolder, packageManagerAndVersion);
        const packageManagerMarker = new LastInstallFlag(packageManagerToolFolder, {
            node: process.versions.node
        });
        logIfConsoleOutputIsNotRestricted(`Trying to acquire lock for ${packageManagerAndVersion}`);
        const lock = await LockFile.acquireAsync(rushUserFolder, packageManagerAndVersion);
        logIfConsoleOutputIsNotRestricted(`Acquired lock for ${packageManagerAndVersion}`);
        if (!(await packageManagerMarker.isValidAsync()) || lock.dirtyWhenAcquired) {
            logIfConsoleOutputIsNotRestricted(Colorize.bold(`Installing ${packageManager} version ${packageManagerVersion}\n`));
            // note that this will remove the last-install flag from the directory
            await Utilities.installPackageInDirectoryAsync({
                directory: packageManagerToolFolder,
                packageName: packageManager,
                version: rushConfiguration.packageManagerToolVersion,
                tempPackageTitle: `${packageManager}-local-install`,
                maxInstallAttempts: maxInstallAttempts,
                // This is using a local configuration to install a package in a shared global location.
                // Generally that's a bad practice, but in this case if we can successfully install
                // the package at all, we can reasonably assume it's good for all the repositories.
                // In particular, we'll assume that two different NPM registries cannot have two
                // different implementations of the same version of the same package.
                // This was needed for: https://github.com/microsoft/rushstack/issues/691
                commonRushConfigFolder: rushConfiguration.commonRushConfigFolder
            });
            logIfConsoleOutputIsNotRestricted(`Successfully installed ${packageManager} version ${packageManagerVersion}`);
        }
        else {
            logIfConsoleOutputIsNotRestricted(`Found ${packageManager} version ${packageManagerVersion} in ${packageManagerToolFolder}`);
        }
        await packageManagerMarker.createAsync();
        // Example: "C:\MyRepo\common\temp"
        FileSystem.ensureFolder(rushConfiguration.commonTempFolder);
        // Example: "C:\MyRepo\common\temp\pnpm-local"
        const localPackageManagerToolFolder = path.join(rushConfiguration.commonTempFolder, `${packageManager}-local`);
        logIfConsoleOutputIsNotRestricted(`\nSymlinking "${localPackageManagerToolFolder}"`);
        logIfConsoleOutputIsNotRestricted(`  --> "${packageManagerToolFolder}"`);
        // We cannot use FileSystem.exists() to test the existence of a symlink, because it will
        // return false for broken symlinks.  There is no way to test without catching an exception.
        try {
            FileSystem.deleteFolder(localPackageManagerToolFolder);
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
        }
        FileSystem.createSymbolicLinkJunction({
            linkTargetPath: packageManagerToolFolder,
            newLinkPath: localPackageManagerToolFolder
        });
        lock.release();
    }
    // Helper for getPackageManagerEnvironment
    static _mergeEnvironmentVariables(baseEnv, environmentVariables, options = {}) {
        const packageManagerEnv = baseEnv;
        if (environmentVariables) {
            // eslint-disable-next-line guard-for-in
            for (const envVar in environmentVariables) {
                let setEnvironmentVariable = true;
                // eslint-disable-next-line no-console
                console.log(`\nProcessing definition for environment variable: ${envVar}`);
                if (baseEnv.hasOwnProperty(envVar)) {
                    setEnvironmentVariable = false;
                    // eslint-disable-next-line no-console
                    console.log(`Environment variable already defined:`);
                    // eslint-disable-next-line no-console
                    console.log(`  Name: ${envVar}`);
                    // eslint-disable-next-line no-console
                    console.log(`  Existing value: ${baseEnv[envVar]}`);
                    // eslint-disable-next-line no-console
                    console.log(`  Value set in ${RushConstants.rushJsonFilename}: ${environmentVariables[envVar].value}`);
                    if (environmentVariables[envVar].override) {
                        setEnvironmentVariable = true;
                        // eslint-disable-next-line no-console
                        console.log(`Overriding the environment variable with the value set in ${RushConstants.rushJsonFilename}.`);
                    }
                    else {
                        // eslint-disable-next-line no-console
                        console.log(Colorize.yellow(`WARNING: Not overriding the value of the environment variable.`));
                    }
                }
                if (setEnvironmentVariable) {
                    if (options.debug) {
                        // eslint-disable-next-line no-console
                        console.log(`Setting environment variable for package manager.`);
                        // eslint-disable-next-line no-console
                        console.log(`  Name: ${envVar}`);
                        // eslint-disable-next-line no-console
                        console.log(`  Value: ${environmentVariables[envVar].value}`);
                    }
                    packageManagerEnv[envVar] = environmentVariables[envVar].value;
                }
            }
        }
        return packageManagerEnv;
    }
}
//# sourceMappingURL=InstallHelpers.js.map