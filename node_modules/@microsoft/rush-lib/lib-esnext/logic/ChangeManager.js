// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
import { PublishUtilities } from './PublishUtilities';
import { ChangeFiles } from './ChangeFiles';
import { PrereleaseToken } from './PrereleaseToken';
import { ChangelogGenerator } from './ChangelogGenerator';
/**
 * The class manages change files and controls how changes logged by change files
 * can be applied to package.json and change logs.
 */
export class ChangeManager {
    constructor(rushConfiguration, projectsToExclude) {
        this._rushConfiguration = rushConfiguration;
        this._projectsToExclude = projectsToExclude;
    }
    /**
     * Load changes from change files
     * @param changesPath - location of change files
     * @param prereleaseToken - prerelease token
     * @param includeCommitDetails - whether commit details need to be included in changes
     */
    async loadAsync(changesPath, prereleaseToken = new PrereleaseToken(), includeCommitDetails = false) {
        this._allPackages = this._rushConfiguration.projectsByName;
        this._prereleaseToken = prereleaseToken;
        this._changeFiles = new ChangeFiles(changesPath);
        this._allChanges = await PublishUtilities.findChangeRequestsAsync(this._allPackages, this._rushConfiguration, this._changeFiles, includeCommitDetails, this._prereleaseToken, this._projectsToExclude);
        this._orderedChanges = PublishUtilities.sortChangeRequests(this._allChanges.packageChanges);
    }
    hasChanges() {
        return ((this._orderedChanges && this._orderedChanges.length > 0) ||
            (this._allChanges && this._allChanges.versionPolicyChanges.size > 0));
    }
    get packageChanges() {
        return this._orderedChanges;
    }
    get allPackages() {
        return this._allPackages;
    }
    validateChanges(versionConfig) {
        this._allChanges.packageChanges.forEach((change, projectName) => {
            const projectInfo = this._rushConfiguration.getProjectByName(projectName);
            if (projectInfo) {
                if (projectInfo.versionPolicy) {
                    projectInfo.versionPolicy.validate(change.newVersion, projectName);
                }
            }
        });
    }
    /**
     * Apply changes to package.json
     * @param shouldCommit - If the value is true, package.json will be updated.
     * If the value is false, package.json and change logs will not be updated. It will only do a dry-run.
     */
    apply(shouldCommit) {
        if (!this.hasChanges()) {
            return;
        }
        // Update all the changed version policies
        this._allChanges.versionPolicyChanges.forEach((versionPolicyChange, versionPolicyName) => {
            this._rushConfiguration.versionPolicyConfiguration.update(versionPolicyName, versionPolicyChange.newVersion, shouldCommit);
        });
        // Apply all changes to package.json files.
        const updatedPackages = PublishUtilities.updatePackages(this._allChanges, this._allPackages, this._rushConfiguration, shouldCommit, this._prereleaseToken, this._projectsToExclude);
        return updatedPackages;
    }
    async updateChangelogAsync(shouldCommit) {
        // Do not update changelog or delete the change files for prerelease.
        // Save them for the official release.
        if (!this._prereleaseToken.hasValue) {
            // Update changelogs.
            const updatedChangelogs = ChangelogGenerator.updateChangelogs(this._allChanges, this._allPackages, this._rushConfiguration, shouldCommit);
            // Remove the change request files only if "-a" was provided.
            await this._changeFiles.deleteAllAsync(shouldCommit, updatedChangelogs);
        }
    }
}
//# sourceMappingURL=ChangeManager.js.map