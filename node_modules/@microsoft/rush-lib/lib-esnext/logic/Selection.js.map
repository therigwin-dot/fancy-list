{"version":3,"file":"Selection.js","sourceRoot":"","sources":["../../src/logic/Selection.ts"],"names":[],"mappings":"AAAA,4FAA4F;AAC5F,2DAA2D;AAY3D;;GAEG;AACH,MAAM,OAAO,SAAS;IACpB;;OAEG;IACI,MAAM,CAAC,YAAY,CAAI,KAAkB,EAAE,GAAG,IAAsB;QACzE,OAAO,IAAI,GAAG,CAAC,oBAAoB,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;IACvD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,KAAK,CAAI,GAAG,IAAmB;QAC3C,OAAO,IAAI,GAAG,CAAC,qBAAqB,CAAI,GAAG,IAAI,CAAC,CAAC,CAAC;IACpD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,qBAAqB,CAA+B,KAAkB;QAClF,OAAO,SAAS,CAAC,KAAK,EAAE,sBAAsB,CAAC,CAAC;IAClD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,kBAAkB,CAA+B,KAAkB;QAC/E,OAAO,SAAS,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;IAC3C,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,CAAC,oBAAoB,CAA+B,KAAkB;QAClF,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;YACzB,KAAK,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC;QACjC,CAAC;IACH,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,CAAC,iBAAiB,CAA+B,KAAkB;QAC/E,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;YACzB,KAAK,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC;QAChC,CAAC;IACH,CAAC;CACF;AASD,QAAQ,CAAC,CAAC,oBAAoB,CAAI,KAAkB,EAAE,GAAG,IAAsB;IAC7E,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,GAAmB,EAAE,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;YACvD,MAAM,IAAI,CAAC;QACb,CAAC;IACH,CAAC;AACH,CAAC;AAED,QAAQ,CAAC,CAAC,qBAAqB,CAAI,GAAG,IAAmB;IACvD,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC;QACvB,KAAK,CAAC,CAAC,GAAG,CAAC;IACb,CAAC;AACH,CAAC;AAED;;GAEG;AACH,SAAS,sBAAsB,CAA+B,OAAU,EAAE,SAAiB;IACzF,KAAK,MAAM,GAAG,IAAI,OAAO,CAAC,kBAAkB,EAAE,CAAC;QAC7C,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACrB,CAAC;AACH,CAAC;AACD;;GAEG;AACH,SAAS,eAAe,CAA+B,OAAU,EAAE,SAAiB;IAClF,KAAK,MAAM,GAAG,IAAI,OAAO,CAAC,iBAAiB,EAAE,CAAC;QAC5C,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACrB,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,SAAS,SAAS,CAAI,KAAkB,EAAE,UAAqC;IAC7E,MAAM,MAAM,GAAW,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC;IACtC,KAAK,MAAM,IAAI,IAAI,MAAM,EAAE,CAAC;QAC1B,UAAU,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAC3B,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * Minimal subset of RushConfigurationProject needed for graph manipulation.\n * Used to facilitate type safety in unit tests.\n * @internal\n */\nexport interface IPartialProject<T extends IPartialProject<T>> {\n  dependencyProjects: ReadonlySet<T>;\n  consumingProjects: ReadonlySet<T>;\n}\n\n/**\n * This namespace contains functions for manipulating sets of projects\n */\nexport class Selection {\n  /**\n   * Computes the intersection of two or more sets.\n   */\n  public static intersection<T>(first: Iterable<T>, ...rest: ReadonlySet<T>[]): Set<T> {\n    return new Set(generateIntersection(first, ...rest));\n  }\n\n  /**\n   * Computes the union of two or more sets.\n   */\n  public static union<T>(...sets: Iterable<T>[]): Set<T> {\n    return new Set(generateConcatenation<T>(...sets));\n  }\n\n  /**\n   * Computes a set that contains the input projects and all the direct and indirect dependencies thereof.\n   */\n  public static expandAllDependencies<T extends IPartialProject<T>>(input: Iterable<T>): Set<T> {\n    return expandAll(input, expandDependenciesStep);\n  }\n\n  /**\n   * Computes a set that contains the input projects and all projects that directly or indirectly depend on them.\n   */\n  public static expandAllConsumers<T extends IPartialProject<T>>(input: Iterable<T>): Set<T> {\n    return expandAll(input, expandConsumers);\n  }\n\n  /**\n   * Iterates the direct dependencies of the listed projects. May contain duplicates.\n   */\n  public static *directDependenciesOf<T extends IPartialProject<T>>(input: Iterable<T>): Iterable<T> {\n    for (const item of input) {\n      yield* item.dependencyProjects;\n    }\n  }\n\n  /**\n   * Iterates the projects that declare any of the listed projects as a dependency. May contain duplicates.\n   */\n  public static *directConsumersOf<T extends IPartialProject<T>>(input: Iterable<T>): Iterable<T> {\n    for (const item of input) {\n      yield* item.consumingProjects;\n    }\n  }\n}\n\n/**\n * Function used for incremental mutation of a set, e.g. when expanding dependencies or dependents\n */\ninterface IExpansionStepFunction<T> {\n  (project: T, targetSet: Set<T>): void;\n}\n\nfunction* generateIntersection<T>(first: Iterable<T>, ...rest: ReadonlySet<T>[]): Iterable<T> {\n  for (const item of first) {\n    if (rest.every((set: ReadonlySet<T>) => set.has(item))) {\n      yield item;\n    }\n  }\n}\n\nfunction* generateConcatenation<T>(...sets: Iterable<T>[]): Iterable<T> {\n  for (const set of sets) {\n    yield* set;\n  }\n}\n\n/**\n * Adds all dependencies of the specified project to the target set.\n */\nfunction expandDependenciesStep<T extends IPartialProject<T>>(project: T, targetSet: Set<T>): void {\n  for (const dep of project.dependencyProjects) {\n    targetSet.add(dep);\n  }\n}\n/**\n * Adds all projects that declare the specified project as a dependency to the target set.\n */\nfunction expandConsumers<T extends IPartialProject<T>>(project: T, targetSet: Set<T>): void {\n  for (const dep of project.consumingProjects) {\n    targetSet.add(dep);\n  }\n}\n\n/**\n * Computes a set derived from the input by cloning it, then iterating over every member of the new set and\n * calling a step function that may add more elements to the set.\n */\nfunction expandAll<T>(input: Iterable<T>, expandStep: IExpansionStepFunction<T>): Set<T> {\n  const result: Set<T> = new Set(input);\n  for (const item of result) {\n    expandStep(item, result);\n  }\n  return result;\n}\n"]}