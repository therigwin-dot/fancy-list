{"version":3,"file":"ShellOperationRunner.js","sourceRoot":"","sources":["../../../src/logic/operations/ShellOperationRunner.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type * as child_process from 'node:child_process';\n\nimport { Text } from '@rushstack/node-core-library';\nimport { type ITerminal, type ITerminalProvider, TerminalProviderSeverity } from '@rushstack/terminal';\n\nimport type { IPhase } from '../../api/CommandLineConfiguration';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport { Utilities } from '../../utilities/Utilities';\nimport type { IOperationRunner, IOperationRunnerContext } from './IOperationRunner';\nimport { OperationError } from './OperationError';\nimport { OperationStatus } from './OperationStatus';\n\nexport interface IShellOperationRunnerOptions {\n  phase: IPhase;\n  rushProject: RushConfigurationProject;\n  displayName: string;\n  commandToRun: string;\n  commandForHash: string;\n}\n\n/**\n * An `IOperationRunner` subclass that performs an operation via a shell command.\n * Currently contains the build cache logic, pending extraction as separate operations.\n * Supports skipping an operation if allowed and it is already up-to-date.\n */\nexport class ShellOperationRunner implements IOperationRunner {\n  public readonly name: string;\n\n  public readonly reportTiming: boolean = true;\n  public readonly silent: boolean = false;\n  public readonly cacheable: boolean = true;\n  public readonly warningsAreAllowed: boolean;\n  public readonly commandToRun: string;\n\n  private readonly _commandForHash: string;\n\n  private readonly _rushProject: RushConfigurationProject;\n\n  public constructor(options: IShellOperationRunnerOptions) {\n    const { phase } = options;\n\n    this.name = options.displayName;\n    this.warningsAreAllowed =\n      EnvironmentConfiguration.allowWarningsInSuccessfulBuild || phase.allowWarningsOnSuccess || false;\n    this._rushProject = options.rushProject;\n    this.commandToRun = options.commandToRun;\n    this._commandForHash = options.commandForHash;\n  }\n\n  public async executeAsync(context: IOperationRunnerContext): Promise<OperationStatus> {\n    try {\n      return await this._executeAsync(context);\n    } catch (error) {\n      throw new OperationError('executing', (error as Error).message);\n    }\n  }\n\n  public getConfigHash(): string {\n    return this._commandForHash;\n  }\n\n  private async _executeAsync(context: IOperationRunnerContext): Promise<OperationStatus> {\n    return await context.runWithTerminalAsync(\n      async (terminal: ITerminal, terminalProvider: ITerminalProvider) => {\n        let hasWarningOrError: boolean = false;\n\n        // Run the operation\n        terminal.writeLine(`Invoking: ${this.commandToRun}`);\n\n        const { rushConfiguration, projectFolder } = this._rushProject;\n\n        const { environment: initialEnvironment } = context;\n\n        const subProcess: child_process.ChildProcess = Utilities.executeLifecycleCommandAsync(\n          this.commandToRun,\n          {\n            rushConfiguration: rushConfiguration,\n            workingDirectory: projectFolder,\n            initCwd: rushConfiguration.commonTempFolder,\n            handleOutput: true,\n            environmentPathOptions: {\n              includeProjectBin: true\n            },\n            initialEnvironment\n          }\n        );\n\n        // Hook into events, in order to get live streaming of the log\n        subProcess.stdout?.on('data', (data: Buffer) => {\n          const text: string = data.toString();\n          terminalProvider.write(text, TerminalProviderSeverity.log);\n        });\n        subProcess.stderr?.on('data', (data: Buffer) => {\n          const text: string = data.toString();\n          terminalProvider.write(text, TerminalProviderSeverity.error);\n          hasWarningOrError = true;\n        });\n\n        const status: OperationStatus = await new Promise(\n          (resolve: (status: OperationStatus) => void, reject: (error: OperationError) => void) => {\n            subProcess.on('close', (exitCode: number | null, signal: NodeJS.Signals | null) => {\n              try {\n                // Do NOT reject here immediately, give a chance for other logic to suppress the error\n                if (signal) {\n                  context.error = new OperationError('error', `Terminated by signal: ${signal}`);\n                  resolve(OperationStatus.Failure);\n                } else if (exitCode !== 0) {\n                  context.error = new OperationError('error', `Returned error code: ${exitCode}`);\n                  resolve(OperationStatus.Failure);\n                } else if (hasWarningOrError) {\n                  resolve(OperationStatus.SuccessWithWarning);\n                } else {\n                  resolve(OperationStatus.Success);\n                }\n              } catch (error) {\n                context.error = error as OperationError;\n                reject(error as OperationError);\n              }\n            });\n          }\n        );\n\n        return status;\n      },\n      {\n        createLogFile: true\n      }\n    );\n  }\n}\n\n/**\n * When running a command from the \"scripts\" block in package.json, if the command\n * contains Unix-style path slashes and the OS is Windows, the package managers will\n * convert slashes to backslashes.  This is a complicated undertaking.  For example, they\n * need to convert \"node_modules/bin/this && ./scripts/that --name keep/this\"\n * to \"node_modules\\bin\\this && .\\scripts\\that --name keep/this\", and they don't want to\n * convert ANY of the slashes in \"cmd.exe /c echo a/b\".  NPM and PNPM use npm-lifecycle for this,\n * but it unfortunately has a dependency on the entire node-gyp kitchen sink.  Yarn has a\n * simplified implementation in fix-cmd-win-slashes.js, but it's not exposed as a library.\n *\n * Fundamentally NPM's whole feature seems misguided:  They start by inviting people to write\n * shell scripts that will be executed by wildly different shell languages (e.g. cmd.exe and Bash).\n * It's very tricky for a developer to guess what's safe to do without testing every OS.\n * Even simple path separators are not portable, so NPM added heuristics to figure out which\n * slashes are part of a path or not, and convert them.  These workarounds end up having tons\n * of special cases.  They probably could have implemented their own entire minimal cross-platform\n * shell language with less code and less confusion than npm-lifecycle's approach.\n *\n * We've deprecated shell operators inside package.json.  Instead, we advise people to move their\n * scripts into conventional script files, and put only a file path in package.json.  So, for\n * Rush's workaround here, we really only care about supporting the small set of cases seen in the\n * unit tests.  For anything that doesn't fit those patterns, we leave the string untouched\n * (i.e. err on the side of not breaking anything).  We could revisit this later if someone\n * complains about it, but so far nobody has.  :-)\n */\nexport function convertSlashesForWindows(command: string): string {\n  // The first group will match everything up to the first space, \"&\", \"|\", \"<\", \">\", or quote.\n  // The second group matches the remainder.\n  const commandRegExp: RegExp = /^([^\\s&|<>\"]+)(.*)$/;\n\n  const match: RegExpMatchArray | null = commandRegExp.exec(command);\n  if (match) {\n    // Example input: \"bin/blarg --path ./config/blah.json && a/b\"\n    // commandPart=\"bin/blarg\"\n    // remainder=\" --path ./config/blah.json && a/b\"\n    const commandPart: string = match[1];\n    const remainder: string = match[2];\n\n    // If the command part already contains a backslash, then leave it alone\n    if (commandPart.indexOf('\\\\') < 0) {\n      // Replace all the slashes with backslashes, e.g. to produce:\n      // \"bin\\blarg --path ./config/blah.json && a/b\"\n      //\n      // NOTE: we don't attempt to process the path parameter or stuff after \"&&\"\n      return Text.replaceAll(commandPart, '/', '\\\\') + remainder;\n    }\n  }\n\n  // Don't change anything\n  return command;\n}\n"]}