{"version":3,"file":"OperationExecutionManager.js","sourceRoot":"","sources":["../../../src/logic/operations/OperationExecutionManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport {\n  type TerminalWritable,\n  StdioWritable,\n  TextRewriterTransform,\n  Colorize,\n  ConsoleTerminalProvider,\n  TerminalChunkKind\n} from '@rushstack/terminal';\nimport { StreamCollator, type CollatedTerminal, type CollatedWriter } from '@rushstack/stream-collator';\nimport { NewlineKind, Async, InternalError, AlreadyReportedError } from '@rushstack/node-core-library';\n\nimport { AsyncOperationQueue, type IOperationSortFunction } from './AsyncOperationQueue';\nimport type { Operation } from './Operation';\nimport { OperationStatus } from './OperationStatus';\nimport { type IOperationExecutionRecordContext, OperationExecutionRecord } from './OperationExecutionRecord';\nimport type { IExecutionResult } from './IOperationExecutionResult';\nimport type { IEnvironment } from '../../utilities/Utilities';\n\nexport interface IOperationExecutionManagerOptions {\n  quietMode: boolean;\n  debugMode: boolean;\n  parallelism: number;\n  changedProjectsOnly: boolean;\n  destination?: TerminalWritable;\n\n  beforeExecuteOperationAsync?: (operation: OperationExecutionRecord) => Promise<OperationStatus | undefined>;\n  afterExecuteOperationAsync?: (operation: OperationExecutionRecord) => Promise<void>;\n  createEnvironmentForOperation?: (operation: OperationExecutionRecord) => IEnvironment;\n  onOperationStatusChangedAsync?: (record: OperationExecutionRecord) => void;\n  beforeExecuteOperationsAsync?: (records: Map<Operation, OperationExecutionRecord>) => Promise<void>;\n}\n\n/**\n * Format \"======\" lines for a shell window with classic 80 columns\n */\nconst ASCII_HEADER_WIDTH: number = 79;\n\nconst prioritySort: IOperationSortFunction = (\n  a: OperationExecutionRecord,\n  b: OperationExecutionRecord\n): number => {\n  return a.criticalPathLength! - b.criticalPathLength!;\n};\n\n/**\n * A class which manages the execution of a set of tasks with interdependencies.\n * Initially, and at the end of each task execution, all unblocked tasks\n * are added to a ready queue which is then executed. This is done continually until all\n * tasks are complete, or prematurely fails if any of the tasks fail.\n */\nexport class OperationExecutionManager {\n  private readonly _changedProjectsOnly: boolean;\n  private readonly _executionRecords: Map<Operation, OperationExecutionRecord>;\n  private readonly _quietMode: boolean;\n  private readonly _parallelism: number;\n  private readonly _totalOperations: number;\n\n  private readonly _outputWritable: TerminalWritable;\n  private readonly _colorsNewlinesTransform: TextRewriterTransform;\n  private readonly _streamCollator: StreamCollator;\n\n  private readonly _terminal: CollatedTerminal;\n\n  private readonly _beforeExecuteOperation?: (\n    operation: OperationExecutionRecord\n  ) => Promise<OperationStatus | undefined>;\n  private readonly _afterExecuteOperation?: (operation: OperationExecutionRecord) => Promise<void>;\n  private readonly _onOperationStatusChanged?: (record: OperationExecutionRecord) => void;\n  private readonly _beforeExecuteOperations?: (\n    records: Map<Operation, OperationExecutionRecord>\n  ) => Promise<void>;\n  private readonly _createEnvironmentForOperation?: (operation: OperationExecutionRecord) => IEnvironment;\n\n  // Variables for current status\n  private _hasAnyFailures: boolean;\n  private _hasAnyNonAllowedWarnings: boolean;\n  private _completedOperations: number;\n  private _executionQueue: AsyncOperationQueue;\n\n  public constructor(operations: Set<Operation>, options: IOperationExecutionManagerOptions) {\n    const {\n      quietMode,\n      debugMode,\n      parallelism,\n      changedProjectsOnly,\n      beforeExecuteOperationAsync: beforeExecuteOperation,\n      afterExecuteOperationAsync: afterExecuteOperation,\n      onOperationStatusChangedAsync: onOperationStatusChanged,\n      beforeExecuteOperationsAsync: beforeExecuteOperations,\n      createEnvironmentForOperation\n    } = options;\n    this._completedOperations = 0;\n    this._quietMode = quietMode;\n    this._hasAnyFailures = false;\n    this._hasAnyNonAllowedWarnings = false;\n    this._changedProjectsOnly = changedProjectsOnly;\n    this._parallelism = parallelism;\n\n    this._beforeExecuteOperation = beforeExecuteOperation;\n    this._afterExecuteOperation = afterExecuteOperation;\n    this._beforeExecuteOperations = beforeExecuteOperations;\n    this._createEnvironmentForOperation = createEnvironmentForOperation;\n    this._onOperationStatusChanged = (record: OperationExecutionRecord) => {\n      if (record.status === OperationStatus.Ready) {\n        this._executionQueue.assignOperations();\n      }\n      onOperationStatusChanged?.(record);\n    };\n\n    // TERMINAL PIPELINE:\n    //\n    // streamCollator --> colorsNewlinesTransform --> StdioWritable\n    //\n    this._outputWritable = options.destination || StdioWritable.instance;\n    this._colorsNewlinesTransform = new TextRewriterTransform({\n      destination: this._outputWritable,\n      normalizeNewlines: NewlineKind.OsDefault,\n      removeColors: !ConsoleTerminalProvider.supportsColor\n    });\n    this._streamCollator = new StreamCollator({\n      destination: this._colorsNewlinesTransform,\n      onWriterActive: this._streamCollator_onWriterActive\n    });\n    this._terminal = this._streamCollator.terminal;\n\n    // Convert the developer graph to the mutable execution graph\n    const executionRecordContext: IOperationExecutionRecordContext = {\n      streamCollator: this._streamCollator,\n      onOperationStatusChanged: this._onOperationStatusChanged,\n      createEnvironment: this._createEnvironmentForOperation,\n      debugMode,\n      quietMode\n    };\n\n    let totalOperations: number = 0;\n    const executionRecords: Map<Operation, OperationExecutionRecord> = (this._executionRecords = new Map());\n    for (const operation of operations) {\n      const executionRecord: OperationExecutionRecord = new OperationExecutionRecord(\n        operation,\n        executionRecordContext\n      );\n\n      executionRecords.set(operation, executionRecord);\n      if (!executionRecord.silent) {\n        // Only count non-silent operations\n        totalOperations++;\n      }\n    }\n    this._totalOperations = totalOperations;\n\n    for (const [operation, consumer] of executionRecords) {\n      for (const dependency of operation.dependencies) {\n        const dependencyRecord: OperationExecutionRecord | undefined = executionRecords.get(dependency);\n        if (!dependencyRecord) {\n          throw new Error(\n            `Operation \"${consumer.name}\" declares a dependency on operation \"${dependency.name}\" that is not in the set of operations to execute.`\n          );\n        }\n        consumer.dependencies.add(dependencyRecord);\n        dependencyRecord.consumers.add(consumer);\n      }\n    }\n\n    const executionQueue: AsyncOperationQueue = new AsyncOperationQueue(\n      this._executionRecords.values(),\n      prioritySort\n    );\n    this._executionQueue = executionQueue;\n  }\n\n  private _streamCollator_onWriterActive = (writer: CollatedWriter | undefined): void => {\n    if (writer) {\n      this._completedOperations++;\n\n      // Format a header like this\n      //\n      // ==[ @rushstack/the-long-thing ]=================[ 1 of 1000 ]==\n\n      // leftPart: \"==[ @rushstack/the-long-thing \"\n      const leftPart: string = Colorize.gray('==[') + ' ' + Colorize.cyan(writer.taskName) + ' ';\n      const leftPartLength: number = 4 + writer.taskName.length + 1;\n\n      // rightPart: \" 1 of 1000 ]==\"\n      const completedOfTotal: string = `${this._completedOperations} of ${this._totalOperations}`;\n      const rightPart: string = ' ' + Colorize.white(completedOfTotal) + ' ' + Colorize.gray(']==');\n      const rightPartLength: number = 1 + completedOfTotal.length + 4;\n\n      // middlePart: \"]=================[\"\n      const twoBracketsLength: number = 2;\n      const middlePartLengthMinusTwoBrackets: number = Math.max(\n        ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength),\n        0\n      );\n\n      const middlePart: string = Colorize.gray(']' + '='.repeat(middlePartLengthMinusTwoBrackets) + '[');\n\n      this._terminal.writeStdoutLine('\\n' + leftPart + middlePart + rightPart);\n\n      if (!this._quietMode) {\n        this._terminal.writeStdoutLine('');\n      }\n    }\n  };\n\n  /**\n   * Executes all operations which have been registered, returning a promise which is resolved when all the\n   * operations are completed successfully, or rejects when any operation fails.\n   */\n  public async executeAsync(): Promise<IExecutionResult> {\n    this._completedOperations = 0;\n    const totalOperations: number = this._totalOperations;\n\n    if (!this._quietMode) {\n      const plural: string = totalOperations === 1 ? '' : 's';\n      this._terminal.writeStdoutLine(`Selected ${totalOperations} operation${plural}:`);\n      const nonSilentOperations: string[] = [];\n      for (const record of this._executionRecords.values()) {\n        if (!record.silent) {\n          nonSilentOperations.push(record.name);\n        }\n      }\n      nonSilentOperations.sort();\n      for (const name of nonSilentOperations) {\n        this._terminal.writeStdoutLine(`  ${name}`);\n      }\n      this._terminal.writeStdoutLine('');\n    }\n\n    this._terminal.writeStdoutLine(`Executing a maximum of ${this._parallelism} simultaneous processes...`);\n\n    const maxParallelism: number = Math.min(totalOperations, this._parallelism);\n\n    await this._beforeExecuteOperations?.(this._executionRecords);\n\n    // This function is a callback because it may write to the collatedWriter before\n    // operation.executeAsync returns (and cleans up the writer)\n    const onOperationCompleteAsync: (record: OperationExecutionRecord) => Promise<void> = async (\n      record: OperationExecutionRecord\n    ) => {\n      try {\n        await this._afterExecuteOperation?.(record);\n      } catch (e) {\n        this._reportOperationErrorIfAny(record);\n        record.error = e;\n        record.status = OperationStatus.Failure;\n      }\n      this._onOperationComplete(record);\n    };\n\n    const onOperationStartAsync: (\n      record: OperationExecutionRecord\n    ) => Promise<OperationStatus | undefined> = async (record: OperationExecutionRecord) => {\n      return await this._beforeExecuteOperation?.(record);\n    };\n\n    await Async.forEachAsync(\n      this._executionQueue,\n      async (record: OperationExecutionRecord) => {\n        await record.executeAsync({\n          onStart: onOperationStartAsync,\n          onResult: onOperationCompleteAsync\n        });\n      },\n      {\n        concurrency: maxParallelism,\n        weighted: true\n      }\n    );\n\n    const status: OperationStatus = this._hasAnyFailures\n      ? OperationStatus.Failure\n      : this._hasAnyNonAllowedWarnings\n        ? OperationStatus.SuccessWithWarning\n        : OperationStatus.Success;\n\n    return {\n      operationResults: this._executionRecords,\n      status\n    };\n  }\n\n  private _reportOperationErrorIfAny(record: OperationExecutionRecord): void {\n    // Failed operations get reported, even if silent.\n    // Generally speaking, silent operations shouldn't be able to fail, so this is a safety measure.\n    let message: string | undefined = undefined;\n    if (record.error) {\n      if (!(record.error instanceof AlreadyReportedError)) {\n        message = record.error.message;\n      }\n    }\n\n    if (message) {\n      // This creates the writer, so don't do this until needed\n      record.collatedWriter.terminal.writeStderrLine(message);\n      // Ensure that the summary isn't blank if we have an error message\n      // If the summary already contains max lines of stderr, this will get dropped, so we hope those lines\n      // are more useful than the final exit code.\n      record.stdioSummarizer.writeChunk({\n        text: `${message}\\n`,\n        kind: TerminalChunkKind.Stdout\n      });\n    }\n  }\n\n  /**\n   * Handles the result of the operation and propagates any relevant effects.\n   */\n  private _onOperationComplete(record: OperationExecutionRecord): void {\n    const { runner, name, status, silent } = record;\n\n    switch (status) {\n      /**\n       * This operation failed. Mark it as such and all reachable dependents as blocked.\n       */\n      case OperationStatus.Failure: {\n        // Failed operations get reported, even if silent.\n        // Generally speaking, silent operations shouldn't be able to fail, so this is a safety measure.\n        this._reportOperationErrorIfAny(record);\n\n        // This creates the writer, so don't do this globally\n        const { terminal } = record.collatedWriter;\n        terminal.writeStderrLine(Colorize.red(`\"${name}\" failed to build.`));\n        const blockedQueue: Set<OperationExecutionRecord> = new Set(record.consumers);\n\n        for (const blockedRecord of blockedQueue) {\n          if (blockedRecord.status === OperationStatus.Waiting) {\n            // Now that we have the concept of architectural no-ops, we could implement this by replacing\n            // {blockedRecord.runner} with a no-op that sets status to Blocked and logs the blocking\n            // operations. However, the existing behavior is a bit simpler, so keeping that for now.\n            if (!blockedRecord.silent) {\n              terminal.writeStdoutLine(`\"${blockedRecord.name}\" is blocked by \"${name}\".`);\n            }\n            blockedRecord.status = OperationStatus.Blocked;\n\n            this._executionQueue.complete(blockedRecord);\n            if (!blockedRecord.silent) {\n              // Only increment the count if the operation is not silent to avoid confusing the user.\n              // The displayed total is the count of non-silent operations.\n              this._completedOperations++;\n            }\n\n            for (const dependent of blockedRecord.consumers) {\n              blockedQueue.add(dependent);\n            }\n          } else if (blockedRecord.status !== OperationStatus.Blocked) {\n            // It shouldn't be possible for operations to be in any state other than Waiting or Blocked\n            throw new InternalError(\n              `Blocked operation ${blockedRecord.name} is in an unexpected state: ${blockedRecord.status}`\n            );\n          }\n        }\n        this._hasAnyFailures = true;\n        break;\n      }\n\n      /**\n       * This operation was restored from the build cache.\n       */\n      case OperationStatus.FromCache: {\n        if (!silent) {\n          record.collatedWriter.terminal.writeStdoutLine(\n            Colorize.green(`\"${name}\" was restored from the build cache.`)\n          );\n        }\n        break;\n      }\n\n      /**\n       * This operation was skipped via legacy change detection.\n       */\n      case OperationStatus.Skipped: {\n        if (!silent) {\n          record.collatedWriter.terminal.writeStdoutLine(Colorize.green(`\"${name}\" was skipped.`));\n        }\n        break;\n      }\n\n      /**\n       * This operation intentionally didn't do anything.\n       */\n      case OperationStatus.NoOp: {\n        if (!silent) {\n          record.collatedWriter.terminal.writeStdoutLine(Colorize.gray(`\"${name}\" did not define any work.`));\n        }\n        break;\n      }\n\n      case OperationStatus.Success: {\n        if (!silent) {\n          record.collatedWriter.terminal.writeStdoutLine(\n            Colorize.green(`\"${name}\" completed successfully in ${record.stopwatch.toString()}.`)\n          );\n        }\n        break;\n      }\n\n      case OperationStatus.SuccessWithWarning: {\n        if (!silent) {\n          record.collatedWriter.terminal.writeStderrLine(\n            Colorize.yellow(`\"${name}\" completed with warnings in ${record.stopwatch.toString()}.`)\n          );\n        }\n        this._hasAnyNonAllowedWarnings = this._hasAnyNonAllowedWarnings || !runner.warningsAreAllowed;\n        break;\n      }\n    }\n\n    if (record.isTerminal) {\n      // If the operation was not remote, then we can notify queue that it is complete\n      this._executionQueue.complete(record);\n    } else {\n      this._executionQueue.assignOperations();\n    }\n  }\n}\n"]}