{"version":3,"file":"OperationMetadataManager.js","sourceRoot":"","sources":["../../../src/logic/operations/OperationMetadataManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as fs from 'fs';\nimport { Async, FileSystem, type IFileSystemCopyFileOptions } from '@rushstack/node-core-library';\nimport {\n  type ITerminalChunk,\n  TerminalChunkKind,\n  TerminalProviderSeverity,\n  type ITerminal,\n  type ITerminalProvider\n} from '@rushstack/terminal';\n\nimport { OperationStateFile } from './OperationStateFile';\nimport { RushConstants } from '../RushConstants';\n\nimport type { IPhase } from '../../api/CommandLineConfiguration';\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport type { IOperationStateJson } from './OperationStateFile';\nimport type { Operation } from './Operation';\n\n/**\n * @internal\n */\nexport interface IOperationMetadataManagerOptions {\n  rushProject: RushConfigurationProject;\n  phase: IPhase;\n  operation: Operation;\n}\n\n/**\n * @internal\n */\nexport interface IOperationMetaData {\n  durationInSeconds: number;\n  logPath: string;\n  errorLogPath: string;\n  logChunksPath: string;\n  cobuildContextId: string | undefined;\n  cobuildRunnerId: string | undefined;\n}\n\nexport interface ILogChunkStorage {\n  chunks: ITerminalChunk[];\n}\n\n/**\n * A helper class for managing the meta files of a operation.\n *\n * @internal\n */\nexport class OperationMetadataManager {\n  public readonly stateFile: OperationStateFile;\n  public readonly logFilenameIdentifier: string;\n  private readonly _metadataFolderPath: string;\n  private readonly _logPath: string;\n  private readonly _errorLogPath: string;\n  private readonly _logChunksPath: string;\n\n  public constructor(options: IOperationMetadataManagerOptions) {\n    const {\n      rushProject,\n      operation: { logFilenameIdentifier }\n    } = options;\n    const { projectFolder } = rushProject;\n\n    this.logFilenameIdentifier = logFilenameIdentifier;\n\n    const metadataFolderPath: string = `${RushConstants.projectRushFolderName}/${RushConstants.rushTempFolderName}/operation/${logFilenameIdentifier}`;\n\n    this.stateFile = new OperationStateFile({\n      projectFolder: projectFolder,\n      metadataFolder: metadataFolderPath\n    });\n\n    this._metadataFolderPath = metadataFolderPath;\n    this._logPath = `${projectFolder}/${metadataFolderPath}/all.log`;\n    this._errorLogPath = `${projectFolder}/${metadataFolderPath}/error.log`;\n    this._logChunksPath = `${projectFolder}/${metadataFolderPath}/log-chunks.jsonl`;\n  }\n\n  /**\n   * Returns the relative paths of the metadata files to project folder.\n   *\n   * Example: `.rush/temp/operation/_phase_build/state.json`\n   * Example: `.rush/temp/operation/_phase_build/all.log`\n   * Example: `.rush/temp/operation/_phase_build/error.log`\n   */\n  public get metadataFolderPath(): string {\n    return this._metadataFolderPath;\n  }\n\n  public async saveAsync({\n    durationInSeconds,\n    cobuildContextId,\n    cobuildRunnerId,\n    logPath,\n    errorLogPath,\n    logChunksPath\n  }: IOperationMetaData): Promise<void> {\n    const state: IOperationStateJson = {\n      nonCachedDurationMs: durationInSeconds * 1000,\n      cobuildContextId,\n      cobuildRunnerId\n    };\n    await this.stateFile.writeAsync(state);\n\n    const copyFileOptions: IFileSystemCopyFileOptions[] = [\n      {\n        sourcePath: logPath,\n        destinationPath: this._logPath\n      },\n      {\n        sourcePath: errorLogPath,\n        destinationPath: this._errorLogPath\n      },\n      {\n        sourcePath: logChunksPath,\n        destinationPath: this._logChunksPath\n      }\n    ];\n\n    // Try to copy log files\n    await Async.forEachAsync(copyFileOptions, async (options) => {\n      try {\n        await FileSystem.copyFileAsync(options);\n      } catch (e) {\n        if (!FileSystem.isNotExistError(e)) {\n          throw e;\n        }\n      }\n    });\n  }\n\n  public async tryRestoreAsync({\n    terminal,\n    terminalProvider,\n    errorLogPath\n  }: {\n    terminalProvider: ITerminalProvider;\n    terminal: ITerminal;\n    errorLogPath: string;\n  }): Promise<void> {\n    await this.stateFile.tryRestoreAsync();\n\n    try {\n      const rawLogChunks: string = await FileSystem.readFileAsync(this._logChunksPath);\n      const chunks: ITerminalChunk[] = [];\n      for (const chunk of rawLogChunks.split('\\n')) {\n        if (chunk) {\n          chunks.push(JSON.parse(chunk));\n        }\n      }\n      for (const { kind, text } of chunks) {\n        if (kind === TerminalChunkKind.Stderr) {\n          terminalProvider.write(text, TerminalProviderSeverity.error);\n        } else {\n          terminalProvider.write(text, TerminalProviderSeverity.log);\n        }\n      }\n    } catch (e) {\n      if (FileSystem.isNotExistError(e)) {\n        // Log chunks file doesn't exist, try to restore log file\n        await restoreFromLogFile(terminal, this._logPath);\n      } else {\n        throw e;\n      }\n    }\n\n    // Try to restore cached error log as error log file\n    try {\n      await FileSystem.copyFileAsync({\n        sourcePath: this._errorLogPath,\n        destinationPath: errorLogPath\n      });\n    } catch (e) {\n      if (!FileSystem.isNotExistError(e)) {\n        throw e;\n      }\n    }\n  }\n}\n\nasync function restoreFromLogFile(terminal: ITerminal, path: string): Promise<void> {\n  let logReadStream: fs.ReadStream | undefined;\n\n  try {\n    logReadStream = fs.createReadStream(path, {\n      encoding: 'utf-8'\n    });\n    for await (const data of logReadStream) {\n      terminal.write(data);\n    }\n  } catch (logReadStreamError) {\n    if (!FileSystem.isNotExistError(logReadStreamError)) {\n      throw logReadStreamError;\n    }\n  } finally {\n    // Close the read stream\n    logReadStream?.close();\n  }\n}\n"]}