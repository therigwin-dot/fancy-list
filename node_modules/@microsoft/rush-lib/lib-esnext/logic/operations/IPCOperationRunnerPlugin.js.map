{"version":3,"file":"IPCOperationRunnerPlugin.js","sourceRoot":"","sources":["../../../src/logic/operations/IPCOperationRunnerPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { IPhase } from '../../api/CommandLineConfiguration';\nimport type {\n  ICreateOperationsContext,\n  IPhasedCommandPlugin,\n  PhasedCommandHooks\n} from '../../pluginFramework/PhasedCommandHooks';\nimport type { IOperationExecutionResult } from './IOperationExecutionResult';\nimport { IPCOperationRunner } from './IPCOperationRunner';\nimport type { Operation } from './Operation';\nimport { OperationStatus } from './OperationStatus';\nimport {\n  PLUGIN_NAME as ShellOperationPluginName,\n  formatCommand,\n  getCustomParameterValuesByPhase,\n  getDisplayName\n} from './ShellOperationRunnerPlugin';\n\nconst PLUGIN_NAME: 'IPCOperationRunnerPlugin' = 'IPCOperationRunnerPlugin';\n\n/**\n * Plugin that implements compatible phases via IPC to a long-lived watch process.\n */\nexport class IPCOperationRunnerPlugin implements IPhasedCommandPlugin {\n  public apply(hooks: PhasedCommandHooks): void {\n    // Workaround until the operation graph persists for the lifetime of the watch process\n    const runnerCache: Map<string, IPCOperationRunner> = new Map();\n\n    const operationStatesByRunner: WeakMap<IPCOperationRunner, IOperationExecutionResult> = new WeakMap();\n\n    let currentContext: ICreateOperationsContext | undefined;\n\n    hooks.createOperations.tapPromise(\n      {\n        name: PLUGIN_NAME,\n        before: ShellOperationPluginName\n      },\n      async (operations: Set<Operation>, context: ICreateOperationsContext) => {\n        const { isWatch, isInitial } = context;\n        if (!isWatch) {\n          return operations;\n        }\n\n        currentContext = context;\n\n        const getCustomParameterValuesForPhase: (phase: IPhase) => ReadonlyArray<string> =\n          getCustomParameterValuesByPhase();\n\n        for (const operation of operations) {\n          const { associatedPhase: phase, associatedProject: project, runner } = operation;\n\n          if (runner || !phase || !project) {\n            continue;\n          }\n\n          const { scripts } = project.packageJson;\n          if (!scripts) {\n            continue;\n          }\n\n          const { name: phaseName } = phase;\n\n          const rawScript: string | undefined =\n            (!isInitial ? scripts[`${phaseName}:incremental:ipc`] : undefined) ?? scripts[`${phaseName}:ipc`];\n\n          if (!rawScript) {\n            continue;\n          }\n\n          // This is the command that will be used to identify the cache entry for this operation, to allow\n          // for this operation (or downstream operations) to be restored from the build cache.\n          const commandForHash: string | undefined = phase.shellCommand ?? scripts?.[phaseName];\n\n          const customParameterValues: ReadonlyArray<string> = getCustomParameterValuesForPhase(phase);\n          const commandToRun: string = formatCommand(rawScript, customParameterValues);\n\n          const operationName: string = getDisplayName(phase, project);\n          let maybeIpcOperationRunner: IPCOperationRunner | undefined = runnerCache.get(operationName);\n          if (!maybeIpcOperationRunner) {\n            const ipcOperationRunner: IPCOperationRunner = (maybeIpcOperationRunner = new IPCOperationRunner({\n              phase,\n              project,\n              name: operationName,\n              commandToRun,\n              commandForHash,\n              persist: true,\n              requestRun: (requestor?: string) => {\n                const operationState: IOperationExecutionResult | undefined =\n                  operationStatesByRunner.get(ipcOperationRunner);\n                if (!operationState) {\n                  return;\n                }\n\n                const status: OperationStatus = operationState.status;\n                if (\n                  status === OperationStatus.Waiting ||\n                  status === OperationStatus.Ready ||\n                  status === OperationStatus.Queued\n                ) {\n                  // Already pending. No-op.\n                  return;\n                }\n\n                currentContext?.invalidateOperation?.(operation, requestor || 'IPC');\n              }\n            }));\n            runnerCache.set(operationName, ipcOperationRunner);\n          }\n\n          operation.runner = maybeIpcOperationRunner;\n        }\n\n        return operations;\n      }\n    );\n\n    hooks.beforeExecuteOperations.tap(\n      PLUGIN_NAME,\n      (records: Map<Operation, IOperationExecutionResult>, context: ICreateOperationsContext) => {\n        currentContext = context;\n        for (const [{ runner }, result] of records) {\n          if (runner instanceof IPCOperationRunner) {\n            operationStatesByRunner.set(runner, result);\n          }\n        }\n      }\n    );\n\n    hooks.shutdownAsync.tapPromise(PLUGIN_NAME, async () => {\n      await Promise.all(Array.from(runnerCache.values(), (runner) => runner.shutdownAsync()));\n    });\n  }\n}\n"]}