{"version":3,"file":"ShellOperationRunnerPlugin.js","sourceRoot":"","sources":["../../../src/logic/operations/ShellOperationRunnerPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { IPhase } from '../../api/CommandLineConfiguration';\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport { RushConstants } from '../RushConstants';\nimport { NullOperationRunner } from './NullOperationRunner';\nimport { convertSlashesForWindows, ShellOperationRunner } from './ShellOperationRunner';\nimport { OperationStatus } from './OperationStatus';\nimport type {\n  ICreateOperationsContext,\n  IPhasedCommandPlugin,\n  PhasedCommandHooks\n} from '../../pluginFramework/PhasedCommandHooks';\nimport type { Operation } from './Operation';\nimport type { RushConfiguration } from '../../api/RushConfiguration';\nimport type { IOperationRunner } from './IOperationRunner';\n\nexport const PLUGIN_NAME: 'ShellOperationRunnerPlugin' = 'ShellOperationRunnerPlugin';\n\n/**\n * Core phased command plugin that provides the functionality for executing an operation via shell command.\n */\nexport class ShellOperationRunnerPlugin implements IPhasedCommandPlugin {\n  public apply(hooks: PhasedCommandHooks): void {\n    hooks.createOperations.tap(\n      PLUGIN_NAME,\n      function createShellOperations(\n        operations: Set<Operation>,\n        context: ICreateOperationsContext\n      ): Set<Operation> {\n        const { rushConfiguration, isInitial } = context;\n\n        const getCustomParameterValuesForPhase: (phase: IPhase) => ReadonlyArray<string> =\n          getCustomParameterValuesByPhase();\n        for (const operation of operations) {\n          const { associatedPhase: phase, associatedProject: project } = operation;\n\n          if (phase && project && !operation.runner) {\n            // This is a shell command. In the future, may consider having a property on the initial operation\n            // to specify a runner type requested in rush-project.json\n            const customParameterValues: ReadonlyArray<string> = getCustomParameterValuesForPhase(phase);\n\n            const displayName: string = getDisplayName(phase, project);\n            const { name: phaseName, shellCommand } = phase;\n\n            const { scripts } = project.packageJson;\n\n            // This is the command that will be used to identify the cache entry for this operation\n            const commandForHash: string | undefined = shellCommand ?? scripts?.[phaseName];\n\n            // For execution of non-initial runs, prefer the `:incremental` script if it exists.\n            // However, the `shellCommand` value still takes precedence per the spec for that feature.\n            const commandToRun: string | undefined =\n              shellCommand ??\n              (!isInitial ? scripts?.[`${phaseName}:incremental`] : undefined) ??\n              scripts?.[phaseName];\n\n            operation.runner = initializeShellOperationRunner({\n              phase,\n              project,\n              displayName,\n              commandForHash,\n              commandToRun,\n              customParameterValues,\n              rushConfiguration\n            });\n          }\n        }\n\n        return operations;\n      }\n    );\n  }\n}\n\nexport function initializeShellOperationRunner(options: {\n  phase: IPhase;\n  project: RushConfigurationProject;\n  displayName: string;\n  rushConfiguration: RushConfiguration;\n  commandToRun: string | undefined;\n  commandForHash?: string;\n  customParameterValues: ReadonlyArray<string>;\n}): IOperationRunner {\n  const { phase, project, commandToRun: rawCommandToRun, displayName } = options;\n\n  if (typeof rawCommandToRun !== 'string' && phase.missingScriptBehavior === 'error') {\n    throw new Error(\n      `The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`\n    );\n  }\n\n  if (rawCommandToRun) {\n    const { commandForHash: rawCommandForHash, customParameterValues } = options;\n\n    const commandToRun: string = formatCommand(rawCommandToRun, customParameterValues);\n    const commandForHash: string = rawCommandForHash\n      ? formatCommand(rawCommandForHash, customParameterValues)\n      : commandToRun;\n\n    return new ShellOperationRunner({\n      commandToRun,\n      commandForHash,\n      displayName,\n      phase,\n      rushProject: project\n    });\n  } else {\n    // Empty build script indicates a no-op, so use a no-op runner\n    return new NullOperationRunner({\n      name: displayName,\n      result: OperationStatus.NoOp,\n      silent: phase.missingScriptBehavior === 'silent'\n    });\n  }\n}\n\n/**\n * Memoizer for custom parameter values by phase\n * @returns A function that returns the custom parameter values for a given phase\n */\nexport function getCustomParameterValuesByPhase(): (phase: IPhase) => ReadonlyArray<string> {\n  const customParametersByPhase: Map<IPhase, string[]> = new Map();\n\n  function getCustomParameterValuesForPhase(phase: IPhase): ReadonlyArray<string> {\n    let customParameterValues: string[] | undefined = customParametersByPhase.get(phase);\n    if (!customParameterValues) {\n      customParameterValues = [];\n      for (const tsCommandLineParameter of phase.associatedParameters) {\n        tsCommandLineParameter.appendToArgList(customParameterValues);\n      }\n\n      customParametersByPhase.set(phase, customParameterValues);\n    }\n\n    return customParameterValues;\n  }\n\n  return getCustomParameterValuesForPhase;\n}\n\nexport function formatCommand(rawCommand: string, customParameterValues: ReadonlyArray<string>): string {\n  if (!rawCommand) {\n    return '';\n  } else {\n    const fullCommand: string = `${rawCommand} ${customParameterValues.join(' ')}`;\n    return process.platform === 'win32' ? convertSlashesForWindows(fullCommand) : fullCommand;\n  }\n}\n\nexport function getDisplayName(phase: IPhase, project: RushConfigurationProject): string {\n  if (phase.isSynthetic) {\n    // Because this is a synthetic phase, just use the project name because there aren't any other phases\n    return project.packageName;\n  } else {\n    const phaseNameWithoutPrefix: string = phase.name.slice(RushConstants.phaseNamePrefix.length);\n    return `${project.packageName} (${phaseNameWithoutPrefix})`;\n  }\n}\n"]}