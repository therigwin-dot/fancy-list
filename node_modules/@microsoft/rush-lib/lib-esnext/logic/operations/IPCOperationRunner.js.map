{"version":3,"file":"IPCOperationRunner.js","sourceRoot":"","sources":["../../../src/logic/operations/IPCOperationRunner.ts"],"names":[],"mappings":"AAAA,4FAA4F;AAC5F,2DAA2D;AAG3D,OAAO,EAAE,IAAI,EAAE,MAAM,aAAa,CAAC;AASnC,OAAO,EAAE,wBAAwB,EAA0C,MAAM,qBAAqB,CAAC;AAGvG,OAAO,EAAE,wBAAwB,EAAE,MAAM,oCAAoC,CAAC;AAE9E,OAAO,EAAE,SAAS,EAAE,MAAM,2BAA2B,CAAC;AAEtD,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AAYpD,SAAS,0BAA0B,CAAC,OAAgB;IAClD,OAAO,OAAO,OAAO,KAAK,QAAQ,IAAK,OAAqC,CAAC,KAAK,KAAK,eAAe,CAAC;AACzG,CAAC;AAED,SAAS,wBAAwB,CAAC,OAAgB;IAChD,OAAO,OAAO,OAAO,KAAK,QAAQ,IAAK,OAAmC,CAAC,KAAK,KAAK,YAAY,CAAC;AACpG,CAAC;AAED,SAAS,kBAAkB,CAAC,OAAgB;IAC1C,OAAO,OAAO,OAAO,KAAK,QAAQ,IAAK,OAA6B,CAAC,KAAK,KAAK,MAAM,CAAC;AACxF,CAAC;AAED;;GAEG;AACH,MAAM,OAAO,kBAAkB;IAgB7B,YAAmB,OAAmC;QAdtC,cAAS,GAAY,KAAK,CAAC;QAC3B,iBAAY,GAAY,IAAI,CAAC;QAC7B,WAAM,GAAY,KAAK,CAAC;QAatC,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;QACzB,IAAI,CAAC,kBAAkB;YACrB,wBAAwB,CAAC,8BAA8B;gBACvD,OAAO,CAAC,KAAK,CAAC,sBAAsB;gBACpC,KAAK,CAAC;QACR,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,OAAO,CAAC;QACpC,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,YAAY,CAAC;QAC1C,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,cAAc,CAAC;QAE9C,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,OAAO,CAAC;QAChC,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,UAAU,CAAC;IACxC,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,OAAgC;QACxD,OAAO,MAAM,OAAO,CAAC,oBAAoB,CACvC,KAAK,EAAE,QAAmB,EAAE,gBAAmC,EAA4B,EAAE;;YAC3F,IAAI,WAAW,GAAY,KAAK,CAAC;YACjC,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,QAAQ,KAAK,QAAQ,EAAE,CAAC;gBACvE,oBAAoB;gBACpB,QAAQ,CAAC,SAAS,CAAC,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC;gBAEtD,MAAM,EAAE,iBAAiB,EAAE,aAAa,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC;gBAE/D,MAAM,EAAE,WAAW,EAAE,kBAAkB,EAAE,GAAG,OAAO,CAAC;gBAEpD,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC,4BAA4B,CAAC,IAAI,CAAC,aAAa,EAAE;oBAC5E,iBAAiB;oBACjB,gBAAgB,EAAE,aAAa;oBAC/B,OAAO,EAAE,iBAAiB,CAAC,gBAAgB;oBAC3C,YAAY,EAAE,IAAI;oBAClB,sBAAsB,EAAE;wBACtB,iBAAiB,EAAE,IAAI;qBACxB;oBACD,GAAG,EAAE,IAAI;oBACT,2BAA2B,EAAE,IAAI;oBACjC,kBAAkB;iBACnB,CAAC,CAAC;gBAEH,IAAI,mBAAgC,CAAC;gBAErC,IAAI,CAAC,oBAAoB,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;oBACxD,mBAAmB,GAAG,OAAO,CAAC;gBAChC,CAAC,CAAC,CAAC;gBAEH,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,OAAgB,EAAE,EAAE;oBAClD,IAAI,wBAAwB,CAAC,OAAO,CAAC,EAAE,CAAC;wBACtC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;oBACtC,CAAC;yBAAM,IAAI,kBAAkB,CAAC,OAAO,CAAC,EAAE,CAAC;wBACvC,mBAAmB,EAAE,CAAC;oBACxB,CAAC;gBACH,CAAC,CAAC,CAAC;YACL,CAAC;iBAAM,CAAC;gBACN,QAAQ,CAAC,SAAS,CAAC,uCAAuC,CAAC,CAAC;YAC9D,CAAC;YACD,MAAM,UAAU,GAAiB,IAAI,CAAC,WAAW,CAAC;YAClD,IAAI,iBAAiB,GAAY,KAAK,CAAC;YAEvC,SAAS,QAAQ,CAAC,IAAY;gBAC5B,MAAM,IAAI,GAAW,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACrC,gBAAgB,CAAC,KAAK,CAAC,IAAI,EAAE,wBAAwB,CAAC,GAAG,CAAC,CAAC;YAC7D,CAAC;YACD,SAAS,QAAQ,CAAC,IAAY;gBAC5B,MAAM,IAAI,GAAW,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACrC,gBAAgB,CAAC,KAAK,CAAC,IAAI,EAAE,wBAAwB,CAAC,KAAK,CAAC,CAAC;gBAC7D,iBAAiB,GAAG,IAAI,CAAC;YAC3B,CAAC;YAED,8DAA8D;YAC9D,MAAA,UAAU,CAAC,MAAM,0CAAE,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;YACxC,MAAA,UAAU,CAAC,MAAM,0CAAE,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;YAExC,MAAM,MAAM,GAAoB,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACpE,SAAS,aAAa,CAAC,OAAgB;;oBACrC,IAAI,0BAA0B,CAAC,OAAO,CAAC,EAAE,CAAC;wBACxC,QAAQ,CAAC,SAAS,CAAC,8BAA8B,CAAC,CAAC;wBACnD,MAAA,UAAU,CAAC,MAAM,0CAAE,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;wBACzC,MAAA,UAAU,CAAC,MAAM,0CAAE,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;wBACzC,UAAU,CAAC,GAAG,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;wBACzC,UAAU,CAAC,GAAG,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;wBAChC,UAAU,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;wBAC/B,QAAQ,CAAC,SAAS,CAAC,+BAA+B,CAAC,CAAC;wBACpD,yEAAyE;wBACzE,OAAO,CAAC,OAAO,CAAC,MAAoC,CAAC,CAAC;oBACxD,CAAC;gBACH,CAAC;gBAED,SAAS,MAAM,CAAC,QAAuB,EAAE,MAA6B;oBACpE,IAAI,CAAC;wBACH,IAAI,MAAM,EAAE,CAAC;4BACX,OAAO,CAAC,KAAK,GAAG,IAAI,cAAc,CAAC,OAAO,EAAE,yBAAyB,MAAM,EAAE,CAAC,CAAC;4BAC/E,OAAO,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;wBACnC,CAAC;6BAAM,IAAI,QAAQ,KAAK,CAAC,EAAE,CAAC;4BAC1B,sFAAsF;4BACtF,OAAO,CAAC,KAAK,GAAG,IAAI,cAAc,CAAC,OAAO,EAAE,wBAAwB,QAAQ,EAAE,CAAC,CAAC;4BAChF,OAAO,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;wBACnC,CAAC;6BAAM,IAAI,iBAAiB,EAAE,CAAC;4BAC7B,OAAO,CAAC,eAAe,CAAC,kBAAkB,CAAC,CAAC;wBAC9C,CAAC;6BAAM,CAAC;4BACN,OAAO,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;wBACnC,CAAC;oBACH,CAAC;oBAAC,OAAO,KAAK,EAAE,CAAC;wBACf,MAAM,CAAC,KAAuB,CAAC,CAAC;oBAClC,CAAC;gBACH,CAAC;gBAED,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;gBACxC,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;gBAC/B,UAAU,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;gBAE9B,IAAI,CAAC,oBAAqB,CAAC,IAAI,CAAC,GAAG,EAAE;oBACnC,WAAW,GAAG,IAAI,CAAC;oBACnB,QAAQ,CAAC,SAAS,CAAC,uDAAuD,CAAC,CAAC;oBAC5E,MAAM,UAAU,GAAuB;wBACrC,OAAO,EAAE,KAAK;qBACf,CAAC;oBACF,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBAC9B,CAAC,EAAE,MAAM,CAAC,CAAC;YACb,CAAC,CAAC,CAAC;YAEH,IAAI,WAAW,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAClC,MAAM,IAAI,CAAC,aAAa,EAAE,CAAC;YAC7B,CAAC;YAED,yFAAyF;YACzF,oFAAoF;YACpF,OAAO,MAAM,KAAK,eAAe,CAAC,OAAO,IAAI,iBAAiB;gBAC5D,CAAC,CAAC,eAAe,CAAC,kBAAkB;gBACpC,CAAC,CAAC,MAAM,CAAC;QACb,CAAC,EACD;YACE,aAAa,EAAE,IAAI;SACpB,CACF,CAAC;IACJ,CAAC;IAEM,aAAa;QAClB,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;IAEM,KAAK,CAAC,aAAa;QACxB,MAAM,EAAE,WAAW,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC;QACzC,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,OAAO;QACT,CAAC;QAED,IAAI,UAAU,CAAC,SAAS,EAAE,CAAC;YACzB,MAAM,WAAW,GAAwB;gBACvC,OAAO,EAAE,MAAM;aAChB,CAAC;YACF,UAAU,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAC7B,MAAM,IAAI,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;QACjC,CAAC;IACH,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { ChildProcess } from 'node:child_process';\nimport { once } from 'node:events';\n\nimport type {\n  IAfterExecuteEventMessage,\n  IRequestRunEventMessage,\n  ISyncEventMessage,\n  IRunCommandMessage,\n  IExitCommandMessage\n} from '@rushstack/operation-graph';\nimport { TerminalProviderSeverity, type ITerminal, type ITerminalProvider } from '@rushstack/terminal';\n\nimport type { IPhase } from '../../api/CommandLineConfiguration';\nimport { EnvironmentConfiguration } from '../../api/EnvironmentConfiguration';\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport { Utilities } from '../../utilities/Utilities';\nimport type { IOperationRunner, IOperationRunnerContext } from './IOperationRunner';\nimport { OperationError } from './OperationError';\nimport { OperationStatus } from './OperationStatus';\n\nexport interface IIPCOperationRunnerOptions {\n  phase: IPhase;\n  project: RushConfigurationProject;\n  name: string;\n  commandToRun: string;\n  commandForHash: string;\n  persist: boolean;\n  requestRun: (requestor?: string) => void;\n}\n\nfunction isAfterExecuteEventMessage(message: unknown): message is IAfterExecuteEventMessage {\n  return typeof message === 'object' && (message as IAfterExecuteEventMessage).event === 'after-execute';\n}\n\nfunction isRequestRunEventMessage(message: unknown): message is IRequestRunEventMessage {\n  return typeof message === 'object' && (message as IRequestRunEventMessage).event === 'requestRun';\n}\n\nfunction isSyncEventMessage(message: unknown): message is ISyncEventMessage {\n  return typeof message === 'object' && (message as ISyncEventMessage).event === 'sync';\n}\n\n/**\n * Runner that hosts a long-lived process to which it communicates via IPC.\n */\nexport class IPCOperationRunner implements IOperationRunner {\n  public readonly name: string;\n  public readonly cacheable: boolean = false;\n  public readonly reportTiming: boolean = true;\n  public readonly silent: boolean = false;\n  public readonly warningsAreAllowed: boolean;\n\n  private readonly _rushProject: RushConfigurationProject;\n  private readonly _commandToRun: string;\n  private readonly _commandForHash: string;\n  private readonly _persist: boolean;\n  private readonly _requestRun: (requestor?: string) => void;\n\n  private _ipcProcess: ChildProcess | undefined;\n  private _processReadyPromise: Promise<void> | undefined;\n\n  public constructor(options: IIPCOperationRunnerOptions) {\n    this.name = options.name;\n    this.warningsAreAllowed =\n      EnvironmentConfiguration.allowWarningsInSuccessfulBuild ||\n      options.phase.allowWarningsOnSuccess ||\n      false;\n    this._rushProject = options.project;\n    this._commandToRun = options.commandToRun;\n    this._commandForHash = options.commandForHash;\n\n    this._persist = options.persist;\n    this._requestRun = options.requestRun;\n  }\n\n  public async executeAsync(context: IOperationRunnerContext): Promise<OperationStatus> {\n    return await context.runWithTerminalAsync(\n      async (terminal: ITerminal, terminalProvider: ITerminalProvider): Promise<OperationStatus> => {\n        let isConnected: boolean = false;\n        if (!this._ipcProcess || typeof this._ipcProcess.exitCode === 'number') {\n          // Run the operation\n          terminal.writeLine('Invoking: ' + this._commandToRun);\n\n          const { rushConfiguration, projectFolder } = this._rushProject;\n\n          const { environment: initialEnvironment } = context;\n\n          this._ipcProcess = Utilities.executeLifecycleCommandAsync(this._commandToRun, {\n            rushConfiguration,\n            workingDirectory: projectFolder,\n            initCwd: rushConfiguration.commonTempFolder,\n            handleOutput: true,\n            environmentPathOptions: {\n              includeProjectBin: true\n            },\n            ipc: true,\n            connectSubprocessTerminator: true,\n            initialEnvironment\n          });\n\n          let resolveReadyPromise!: () => void;\n\n          this._processReadyPromise = new Promise<void>((resolve) => {\n            resolveReadyPromise = resolve;\n          });\n\n          this._ipcProcess.on('message', (message: unknown) => {\n            if (isRequestRunEventMessage(message)) {\n              this._requestRun(message.requestor);\n            } else if (isSyncEventMessage(message)) {\n              resolveReadyPromise();\n            }\n          });\n        } else {\n          terminal.writeLine(`Connecting to existing IPC process...`);\n        }\n        const subProcess: ChildProcess = this._ipcProcess;\n        let hasWarningOrError: boolean = false;\n\n        function onStdout(data: Buffer): void {\n          const text: string = data.toString();\n          terminalProvider.write(text, TerminalProviderSeverity.log);\n        }\n        function onStderr(data: Buffer): void {\n          const text: string = data.toString();\n          terminalProvider.write(text, TerminalProviderSeverity.error);\n          hasWarningOrError = true;\n        }\n\n        // Hook into events, in order to get live streaming of the log\n        subProcess.stdout?.on('data', onStdout);\n        subProcess.stderr?.on('data', onStderr);\n\n        const status: OperationStatus = await new Promise((resolve, reject) => {\n          function finishHandler(message: unknown): void {\n            if (isAfterExecuteEventMessage(message)) {\n              terminal.writeLine('Received finish notification');\n              subProcess.stdout?.off('data', onStdout);\n              subProcess.stderr?.off('data', onStderr);\n              subProcess.off('message', finishHandler);\n              subProcess.off('error', reject);\n              subProcess.off('exit', onExit);\n              terminal.writeLine('Disconnected from IPC process');\n              // These types are currently distinct but have the same underlying values\n              resolve(message.status as unknown as OperationStatus);\n            }\n          }\n\n          function onExit(exitCode: number | null, signal: NodeJS.Signals | null): void {\n            try {\n              if (signal) {\n                context.error = new OperationError('error', `Terminated by signal: ${signal}`);\n                resolve(OperationStatus.Failure);\n              } else if (exitCode !== 0) {\n                // Do NOT reject here immediately, give a chance for other logic to suppress the error\n                context.error = new OperationError('error', `Returned error code: ${exitCode}`);\n                resolve(OperationStatus.Failure);\n              } else if (hasWarningOrError) {\n                resolve(OperationStatus.SuccessWithWarning);\n              } else {\n                resolve(OperationStatus.Success);\n              }\n            } catch (error) {\n              reject(error as OperationError);\n            }\n          }\n\n          subProcess.on('message', finishHandler);\n          subProcess.on('error', reject);\n          subProcess.on('exit', onExit);\n\n          this._processReadyPromise!.then(() => {\n            isConnected = true;\n            terminal.writeLine('Child supports IPC protocol. Sending \"run\" command...');\n            const runCommand: IRunCommandMessage = {\n              command: 'run'\n            };\n            subProcess.send(runCommand);\n          }, reject);\n        });\n\n        if (isConnected && !this._persist) {\n          await this.shutdownAsync();\n        }\n\n        // @rushstack/operation-graph does not currently have a concept of \"Success with Warning\"\n        // To match existing ShellOperationRunner behavior we treat any stderr as a warning.\n        return status === OperationStatus.Success && hasWarningOrError\n          ? OperationStatus.SuccessWithWarning\n          : status;\n      },\n      {\n        createLogFile: true\n      }\n    );\n  }\n\n  public getConfigHash(): string {\n    return this._commandForHash;\n  }\n\n  public async shutdownAsync(): Promise<void> {\n    const { _ipcProcess: subProcess } = this;\n    if (!subProcess) {\n      return;\n    }\n\n    if (subProcess.connected) {\n      const exitCommand: IExitCommandMessage = {\n        command: 'exit'\n      };\n      subProcess.send(exitCommand);\n      await once(subProcess, 'exit');\n    }\n  }\n}\n"]}