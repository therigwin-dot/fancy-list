{"version":3,"file":"Operation.js","sourceRoot":"","sources":["../../../src/logic/operations/Operation.ts"],"names":[],"mappings":"AAAA,4FAA4F;AAC5F,2DAA2D;AAuC3D;;;;;;;;GAQG;AACH,MAAM,OAAO,SAAS;IA4DpB,YAAmB,OAA0B;QAjD7C;;WAEG;QACa,cAAS,GAA2B,IAAI,GAAG,EAAa,CAAC;QAEzE;;WAEG;QACa,iBAAY,GAA2B,IAAI,GAAG,EAAa,CAAC;QAS5E;;;WAGG;QACI,WAAM,GAAiC,SAAS,CAAC;QAExD;;;;;;;;;;WAUG;QACI,WAAM,GAAW,CAAC,CAAC;QAE1B;;;WAGG;QACI,aAAQ,GAAmC,SAAS,CAAC;QAU1D,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,qBAAqB,EAAE,GAAG,OAAO,CAAC;QAC5E,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;QAC7B,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC;QACjC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;QACnD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;IACtB,CAAC;IAED;;OAEG;IACH,IAAW,IAAI;;QACb,OAAO,MAAA,IAAI,CAAC,MAAM,0CAAE,IAAI,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,IAAW,MAAM;;QACf,OAAO,CAAC,CAAC,CAAA,MAAA,IAAI,CAAC,MAAM,0CAAE,MAAM,CAAA,CAAC;IAC/B,CAAC;IAED;;OAEG;IACI,aAAa,CAAC,UAAqB;QACxC,0DAA0D;QACzD,IAAI,CAAC,YAA+B,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QACrD,UAAU,CAAC,SAA4B,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACrD,CAAC;IAED;;OAEG;IACI,gBAAgB,CAAC,UAAqB;QAC3C,0DAA0D;QACzD,IAAI,CAAC,YAA+B,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;QACxD,UAAU,CAAC,SAA4B,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACxD,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport type { IPhase } from '../../api/CommandLineConfiguration';\nimport type { IOperationRunner } from './IOperationRunner';\nimport type { IOperationSettings } from '../../api/RushProjectConfiguration';\n\n/**\n * Options for constructing a new Operation.\n * @alpha\n */\nexport interface IOperationOptions {\n  /**\n   * The Rush phase associated with this Operation, if any\n   */\n  phase?: IPhase | undefined;\n\n  /**\n   * The Rush project associated with this Operation, if any\n   */\n  project?: RushConfigurationProject | undefined;\n\n  /**\n   * When the scheduler is ready to process this `Operation`, the `runner` implements the actual work of\n   * running the operation.\n   */\n  runner?: IOperationRunner | undefined;\n\n  /**\n   * Settings defined in the project configuration for this operation, can be overridden.\n   */\n  settings?: IOperationSettings | undefined;\n\n  /**\n   * {@inheritDoc Operation.logFilenameIdentifier}\n   */\n  logFilenameIdentifier: string;\n}\n\n/**\n * The `Operation` class is a node in the dependency graph of work that needs to be scheduled by the\n * `OperationExecutionManager`. Each `Operation` has a `runner` member of type `IOperationRunner`, whose\n * implementation manages the actual process of running a single operation.\n *\n * The graph of `Operation` instances will be cloned into a separate execution graph after processing.\n *\n * @alpha\n */\nexport class Operation {\n  /**\n   * The Rush phase associated with this Operation, if any\n   */\n  public readonly associatedPhase: IPhase | undefined;\n\n  /**\n   * The Rush project associated with this Operation, if any\n   */\n  public readonly associatedProject: RushConfigurationProject | undefined;\n\n  /**\n   * A set of all operations which depend on this operation.\n   */\n  public readonly consumers: ReadonlySet<Operation> = new Set<Operation>();\n\n  /**\n   * A set of all dependencies which must be executed before this operation is complete.\n   */\n  public readonly dependencies: ReadonlySet<Operation> = new Set<Operation>();\n\n  /**\n   * This property is used in the name of the filename for the logs generated by this\n   * operation. This is a filesystem-safe version of the phase name. For example,\n   * an operation for a phase with name `_phase:compile` has a `logFilenameIdentifier` of `_phase_compile`.\n   */\n  public logFilenameIdentifier: string;\n\n  /**\n   * When the scheduler is ready to process this `Operation`, the `runner` implements the actual work of\n   * running the operation.\n   */\n  public runner: IOperationRunner | undefined = undefined;\n\n  /**\n   * The weight for this operation. This scalar is the contribution of this operation to the\n   * `criticalPathLength` calculation above. Modify to indicate the following:\n   * - `weight` === 1: indicates that this operation has an average duration\n   * - `weight` &gt; 1: indicates that this operation takes longer than average and so the scheduler\n   *     should try to favor starting it over other, shorter operations. An example might be an operation that\n   *     bundles an entire application and runs whole-program optimization.\n   * - `weight` &lt; 1: indicates that this operation takes less time than average and so the scheduler\n   *     should favor other, longer operations over it. An example might be an operation to unpack a cached\n   *     output, or an operation using NullOperationRunner, which might use a value of 0.\n   */\n  public weight: number = 1;\n\n  /**\n   * Get the operation settings for this operation, defaults to the values defined in\n   *  the project configuration.\n   */\n  public settings: IOperationSettings | undefined = undefined;\n\n  /**\n   * If set to false, this operation will be skipped during evaluation (return OperationStatus.Skipped).\n   * This is useful for plugins to alter the scope of the operation graph across executions,\n   * e.g. to enable or disable unit test execution, or to include or exclude dependencies.\n   */\n  public enabled: boolean;\n\n  public constructor(options: IOperationOptions) {\n    const { phase, project, runner, settings, logFilenameIdentifier } = options;\n    this.associatedPhase = phase;\n    this.associatedProject = project;\n    this.runner = runner;\n    this.settings = settings;\n    this.logFilenameIdentifier = logFilenameIdentifier;\n    this.enabled = true;\n  }\n\n  /**\n   * The name of this operation, for logging.\n   */\n  public get name(): string | undefined {\n    return this.runner?.name;\n  }\n\n  /**\n   * If set to true, this operation is considered a no-op and can be considered always skipped for analysis purposes.\n   */\n  public get isNoOp(): boolean {\n    return !!this.runner?.isNoOp;\n  }\n\n  /**\n   * Adds the specified operation as a dependency and updates the consumer list.\n   */\n  public addDependency(dependency: Operation): void {\n    // Cast internally to avoid adding the overhead of getters\n    (this.dependencies as Set<Operation>).add(dependency);\n    (dependency.consumers as Set<Operation>).add(this);\n  }\n\n  /**\n   * Deletes the specified operation as a dependency and updates the consumer list.\n   */\n  public deleteDependency(dependency: Operation): void {\n    // Cast internally to avoid adding the overhead of getters\n    (this.dependencies as Set<Operation>).delete(dependency);\n    (dependency.consumers as Set<Operation>).delete(this);\n  }\n}\n"]}