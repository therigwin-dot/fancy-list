// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * This file contains a set of helper functions that are unit tested and used with the PublishAction,
 * which itself is a thin wrapper around these helpers.
 */
import * as path from 'path';
import * as semver from 'semver';
import { execSync } from 'child_process';
import { JsonFile, FileConstants, Text, Enum, InternalError } from '@rushstack/node-core-library';
import { ChangeType } from '../api/ChangeManagement';
import { Utilities } from '../utilities/Utilities';
import { DependencySpecifier, DependencySpecifierType } from './DependencySpecifier';
import { Git, DEFAULT_GIT_TAG_SEPARATOR } from './Git';
const MAGIC_SPECIFIERS = new Set(['*', '^', '~']);
export class PublishUtilities {
    /**
     * Finds change requests in the given folder.
     * @param changesPath Path to the changes folder.
     * @returns Dictionary of all change requests, keyed by package name.
     */
    static async findChangeRequestsAsync(allPackages, rushConfiguration, changeFiles, includeCommitDetails, prereleaseToken, projectsToExclude) {
        const allChanges = {
            packageChanges: new Map(),
            versionPolicyChanges: new Map()
        };
        // eslint-disable-next-line no-console
        console.log(`Finding changes in: ${changeFiles.getChangesPath()}`);
        const files = await changeFiles.getFilesAsync();
        // Add the minimum changes defined by the change descriptions.
        for (const changeFilePath of files) {
            const changeRequest = JsonFile.load(changeFilePath);
            if (includeCommitDetails) {
                const git = new Git(rushConfiguration);
                PublishUtilities._updateCommitDetails(git, changeFilePath, changeRequest.changes);
            }
            for (const change of changeRequest.changes) {
                PublishUtilities._addChange({
                    change,
                    changeFilePath,
                    allChanges,
                    allPackages,
                    rushConfiguration,
                    prereleaseToken,
                    projectsToExclude
                });
            }
        }
        // keep resolving downstream dependency changes and version policy changes
        // until no more changes are detected
        let hasChanges;
        do {
            hasChanges = false;
            // For each requested package change, ensure downstream dependencies are also updated.
            allChanges.packageChanges.forEach((change, packageName) => {
                hasChanges =
                    PublishUtilities._updateDownstreamDependencies(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;
            });
            // Bump projects affected by the version policy changes.
            allPackages.forEach((project) => {
                const versionPolicyChange = project.versionPolicyName !== undefined
                    ? allChanges.versionPolicyChanges.get(project.versionPolicyName)
                    : undefined;
                if (versionPolicyChange === undefined) {
                    return;
                }
                const projectHasChanged = this._addChange({
                    change: {
                        packageName: project.packageName,
                        changeType: versionPolicyChange.changeType,
                        newVersion: versionPolicyChange.newVersion // enforce the specific policy version
                    },
                    allChanges,
                    allPackages,
                    rushConfiguration,
                    prereleaseToken,
                    projectsToExclude
                });
                if (projectHasChanged) {
                    // eslint-disable-next-line no-console
                    console.log(`\n* APPLYING: update ${project.packageName} to version ${versionPolicyChange.newVersion}`);
                }
                hasChanges = projectHasChanged || hasChanges;
            });
        } while (hasChanges);
        // Update orders so that downstreams are marked to come after upstreams.
        allChanges.packageChanges.forEach((change, packageName) => {
            const project = allPackages.get(packageName);
            const packageJson = project.packageJson;
            const deps = project.consumingProjects;
            // Write the new version expected for the change.
            const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);
            if (skipVersionBump) {
                change.newVersion = packageJson.version;
            }
            else {
                // For hotfix changes, do not re-write new version
                change.newVersion =
                    change.changeType >= ChangeType.patch
                        ? semver.inc(packageJson.version, PublishUtilities._getReleaseType(change.changeType))
                        : change.changeType === ChangeType.hotfix
                            ? change.newVersion
                            : packageJson.version;
            }
            if (deps) {
                for (const dep of deps) {
                    const depChange = allChanges.packageChanges.get(dep.packageName);
                    if (depChange) {
                        depChange.order = Math.max(change.order + 1, depChange.order);
                    }
                }
            }
        });
        return allChanges;
    }
    /**
     * Given the changes hash, flattens them into a sorted array based on their dependency order.
     * @params packageChanges - hash of change requests.
     * @returns Sorted array of change requests.
     */
    static sortChangeRequests(packageChanges) {
        return [...packageChanges.values()].sort((a, b) => a.order === b.order ? a.packageName.localeCompare(b.packageName) : a.order < b.order ? -1 : 1);
    }
    /**
     * Given a single change request, updates the package json file with updated versions on disk.
     */
    static updatePackages(allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude) {
        const updatedPackages = new Map();
        allChanges.packageChanges.forEach((change, packageName) => {
            const updatedPackage = PublishUtilities._writePackageChanges(change, allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude);
            updatedPackages.set(updatedPackage.name, updatedPackage);
        });
        return updatedPackages;
    }
    /**
     * Returns the generated tagname to use for a published commit, given package name and version.
     */
    static createTagname(packageName, version, separator = DEFAULT_GIT_TAG_SEPARATOR) {
        return packageName + `${separator}v` + version;
    }
    static isRangeDependency(version) {
        const LOOSE_PKG_REGEX = />=?(?:\d+\.){2}\d+(\-[0-9A-Za-z-.]*)?\s+<(?:\d+\.){2}\d+/;
        return LOOSE_PKG_REGEX.test(version);
    }
    static getEnvArgs() {
        const env = {};
        // Copy existing process.env values (for nodist)
        Object.keys(process.env).forEach((key) => {
            env[key] = process.env[key];
        });
        return env;
    }
    /**
     * @param secretSubstring -- if specified, a substring to be replaced by `<<SECRET>>` to avoid printing secrets
     * on the console
     */
    static async execCommandAsync(shouldExecute, command, args = [], workingDirectory = process.cwd(), environment, secretSubstring) {
        let relativeDirectory = path.relative(process.cwd(), workingDirectory);
        if (relativeDirectory) {
            relativeDirectory = `(${relativeDirectory})`;
        }
        let commandArgs = args.join(' ');
        if (secretSubstring && secretSubstring.length > 0) {
            // Avoid printing the NPM publish token on the console when displaying the commandArgs
            commandArgs = Text.replaceAll(commandArgs, secretSubstring, '<<SECRET>>');
        }
        // eslint-disable-next-line no-console
        console.log(`\n* ${shouldExecute ? 'EXECUTING' : 'DRYRUN'}: ${command} ${commandArgs} ${relativeDirectory}`);
        if (shouldExecute) {
            await Utilities.executeCommandAsync({
                command,
                args,
                workingDirectory,
                environment,
                suppressOutput: false,
                keepEnvironment: true
            });
        }
    }
    static getNewDependencyVersion(dependencies, dependencyName, newProjectVersion) {
        const currentDependencySpecifier = new DependencySpecifier(dependencyName, dependencies[dependencyName]);
        const currentDependencyVersion = currentDependencySpecifier.versionSpecifier;
        let newDependencyVersion;
        if (MAGIC_SPECIFIERS.has(currentDependencyVersion)) {
            // pnpm and yarn support `workspace:*', `workspace:~`, and `workspace:^` as valid version specifiers
            // These translate as `current`, `~current`, and `^current` when published
            newDependencyVersion = currentDependencyVersion;
        }
        else if (PublishUtilities.isRangeDependency(currentDependencyVersion)) {
            newDependencyVersion = PublishUtilities._getNewRangeDependency(newProjectVersion);
        }
        else if (currentDependencyVersion.lastIndexOf('~', 0) === 0) {
            newDependencyVersion = '~' + newProjectVersion;
        }
        else if (currentDependencyVersion.lastIndexOf('^', 0) === 0) {
            newDependencyVersion = '^' + newProjectVersion;
        }
        else {
            newDependencyVersion = newProjectVersion;
        }
        return currentDependencySpecifier.specifierType === DependencySpecifierType.Workspace
            ? `workspace:${newDependencyVersion}`
            : newDependencyVersion;
    }
    static _getReleaseType(changeType) {
        switch (changeType) {
            case ChangeType.major:
                return 'major';
            case ChangeType.minor:
                return 'minor';
            case ChangeType.patch:
                return 'patch';
            case ChangeType.hotfix:
                return 'prerelease';
            default:
                throw new Error(`Wrong change type ${changeType}`);
        }
    }
    static _getNewRangeDependency(newVersion) {
        let upperLimit = newVersion;
        if (semver.prerelease(newVersion)) {
            // Remove the prerelease first, then bump major.
            upperLimit = semver.inc(newVersion, 'patch');
        }
        upperLimit = semver.inc(upperLimit, 'major');
        return `>=${newVersion} <${upperLimit}`;
    }
    static _shouldSkipVersionBump(project, prereleaseToken, projectsToExclude) {
        // Suffix does not bump up the version.
        // Excluded projects do not bump up version.
        return ((prereleaseToken && prereleaseToken.isSuffix) ||
            (projectsToExclude && projectsToExclude.has(project.packageName)) ||
            !project.shouldPublish);
    }
    static _updateCommitDetails(git, filename, changes) {
        try {
            const gitPath = git.getGitPathOrThrow();
            const fileLog = execSync(`${gitPath} log -n 1 ${filename}`, {
                cwd: path.dirname(filename)
            }).toString();
            const author = fileLog.match(/Author: (.*)/)[1];
            const commit = fileLog.match(/commit (.*)/)[1];
            changes.forEach((change) => {
                change.author = author;
                change.commit = commit;
            });
        }
        catch (e) {
            /* no-op, best effort. */
        }
    }
    static _writePackageChanges(change, allChanges, allPackages, rushConfiguration, shouldCommit, prereleaseToken, projectsToExclude) {
        const project = allPackages.get(change.packageName);
        const packageJson = project.packageJson;
        const shouldSkipVersionBump = !project.shouldPublish || (!!projectsToExclude && projectsToExclude.has(change.packageName));
        const newVersion = shouldSkipVersionBump
            ? packageJson.version
            : PublishUtilities._getChangeInfoNewVersion(change, prereleaseToken);
        if (!shouldSkipVersionBump) {
            // eslint-disable-next-line no-console
            console.log(`\n* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: ${ChangeType[change.changeType]} update ` +
                `for ${change.packageName} to ${newVersion}`);
        }
        else {
            // eslint-disable-next-line no-console
            console.log(`\n* ${shouldCommit ? 'APPLYING' : 'DRYRUN'}: update for ${change.packageName} at ${newVersion}`);
        }
        const packagePath = path.join(project.projectFolder, FileConstants.PackageJson);
        packageJson.version = newVersion;
        // Update the package's dependencies.
        PublishUtilities._updateDependencies(packageJson.name, packageJson.dependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
        // Update the package's dev dependencies.
        PublishUtilities._updateDependencies(packageJson.name, packageJson.devDependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
        // Update the package's peer dependencies.
        PublishUtilities._updateDependencies(packageJson.name, packageJson.peerDependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude);
        change.changes.forEach((subChange) => {
            if (subChange.comment) {
                // eslint-disable-next-line no-console
                console.log(` - [${ChangeType[subChange.changeType]}] ${subChange.comment}`);
            }
        });
        if (shouldCommit) {
            JsonFile.save(packageJson, packagePath, { updateExistingFile: true });
        }
        return packageJson;
    }
    static _isCyclicDependency(allPackages, packageName, dependencyName) {
        const packageConfig = allPackages.get(packageName);
        return !!packageConfig && packageConfig.decoupledLocalDependencies.has(dependencyName);
    }
    static _updateDependencies(packageName, dependencies, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {
        if (dependencies) {
            Object.keys(dependencies).forEach((depName) => {
                if (!PublishUtilities._isCyclicDependency(allPackages, packageName, depName)) {
                    const depChange = allChanges.packageChanges.get(depName);
                    if (!depChange) {
                        return;
                    }
                    const depProject = allPackages.get(depName);
                    if (!depProject.shouldPublish || (projectsToExclude && projectsToExclude.has(depName))) {
                        // No version change.
                        return;
                    }
                    else if (prereleaseToken &&
                        prereleaseToken.hasValue &&
                        prereleaseToken.isPartialPrerelease &&
                        depChange.changeType < ChangeType.hotfix) {
                        // For partial prereleases, do not version bump dependencies with the `prereleaseToken`
                        // value unless an actual change (hotfix, patch, minor, major) has occurred
                        return;
                    }
                    else if (depChange && prereleaseToken && prereleaseToken.hasValue) {
                        // TODO: treat prerelease version the same as non-prerelease version.
                        // For prerelease, the newVersion needs to be appended with prerelease name.
                        // And dependency should specify the specific prerelease version.
                        const currentSpecifier = new DependencySpecifier(depName, dependencies[depName]);
                        const newVersion = PublishUtilities._getChangeInfoNewVersion(depChange, prereleaseToken);
                        dependencies[depName] =
                            currentSpecifier.specifierType === DependencySpecifierType.Workspace
                                ? `workspace:${newVersion}`
                                : newVersion;
                    }
                    else if (depChange && depChange.changeType >= ChangeType.hotfix) {
                        PublishUtilities._updateDependencyVersion(packageName, dependencies, depName, depChange, allChanges, allPackages, rushConfiguration);
                    }
                }
            });
        }
    }
    /**
     * Gets the new version from the ChangeInfo.
     * The value of newVersion in ChangeInfo remains unchanged when the change type is dependency,
     * However, for pre-release build, it won't pick up the updated pre-released dependencies. That is why
     * this function should return a pre-released patch for that case. The exception to this is when we're
     * running a partial pre-release build. In this case, only user-changed packages should update.
     */
    static _getChangeInfoNewVersion(change, prereleaseToken) {
        let newVersion = change.newVersion;
        if (prereleaseToken && prereleaseToken.hasValue) {
            if (prereleaseToken.isPartialPrerelease && change.changeType <= ChangeType.hotfix) {
                return newVersion;
            }
            if (prereleaseToken.isPrerelease && change.changeType === ChangeType.dependency) {
                newVersion = semver.inc(newVersion, 'patch');
            }
            return `${newVersion}-${prereleaseToken.name}`;
        }
        else {
            return newVersion;
        }
    }
    /**
     * Adds the given change to the packageChanges map.
     *
     * @returns true if the change caused the dependency change type to increase.
     */
    static _addChange({ change, changeFilePath, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude }) {
        var _a, _b, _c;
        let hasChanged = false;
        const packageName = change.packageName;
        const project = allPackages.get(packageName);
        if (!project) {
            // eslint-disable-next-line no-console
            console.log(`The package ${packageName} was requested for publishing but does not exist. Skip this change.`);
            return false;
        }
        const packageJson = project.packageJson;
        // If the given change does not have a changeType, derive it from the "type" string.
        if (change.changeType === undefined) {
            change.changeType = Enum.tryGetValueByKey(ChangeType, change.type);
            if (change.changeType === undefined) {
                if (changeFilePath) {
                    throw new Error(`Invalid change type ${JSON.stringify(change.type)} in ${changeFilePath}`);
                }
                else {
                    throw new InternalError(`Invalid change type ${JSON.stringify(change.type)}`);
                }
            }
        }
        let currentChange = allChanges.packageChanges.get(packageName);
        if (currentChange === undefined) {
            hasChanged = true;
            currentChange = {
                packageName,
                changeType: change.changeType,
                order: 0,
                changes: [change]
            };
            allChanges.packageChanges.set(packageName, currentChange);
        }
        else {
            const oldChangeType = currentChange.changeType;
            if (oldChangeType === ChangeType.hotfix && change.changeType > oldChangeType) {
                throw new Error(`Cannot apply ${this._getReleaseType(change.changeType)} change after hotfix on same package`);
            }
            if (change.changeType === ChangeType.hotfix && oldChangeType > change.changeType) {
                throw new Error(`Cannot apply hotfix alongside ${this._getReleaseType(oldChangeType)} change on same package`);
            }
            currentChange.changeType = Math.max(currentChange.changeType, change.changeType);
            currentChange.changes.push(change);
            hasChanged = hasChanged || oldChangeType !== currentChange.changeType;
            hasChanged =
                hasChanged ||
                    (change.newVersion !== undefined &&
                        currentChange.newVersion !== undefined &&
                        semver.gt(change.newVersion, currentChange.newVersion));
        }
        const skipVersionBump = PublishUtilities._shouldSkipVersionBump(project, prereleaseToken, projectsToExclude);
        if (skipVersionBump) {
            currentChange.newVersion = (_a = change.newVersion) !== null && _a !== void 0 ? _a : packageJson.version;
            hasChanged = false;
            currentChange.changeType = ChangeType.none;
        }
        else {
            if (change.changeType === ChangeType.hotfix) {
                const prereleaseComponents = semver.prerelease(packageJson.version);
                if (!rushConfiguration.hotfixChangeEnabled) {
                    throw new Error(`Cannot add hotfix change; hotfixChangeEnabled is false in configuration.`);
                }
                currentChange.newVersion = (_b = change.newVersion) !== null && _b !== void 0 ? _b : packageJson.version;
                if (!prereleaseComponents) {
                    currentChange.newVersion += '-hotfix';
                }
                currentChange.newVersion = semver.inc(currentChange.newVersion, 'prerelease');
            }
            else {
                // When there are multiple changes of this package, the final value of new version
                // should not depend on the order of the changes.
                let packageVersion = (_c = change.newVersion) !== null && _c !== void 0 ? _c : packageJson.version;
                if (currentChange.newVersion && semver.gt(currentChange.newVersion, packageVersion)) {
                    packageVersion = currentChange.newVersion;
                }
                const shouldBump = change.newVersion === undefined && change.changeType >= ChangeType.hotfix;
                currentChange.newVersion = shouldBump
                    ? semver.inc(packageVersion, PublishUtilities._getReleaseType(currentChange.changeType))
                    : packageVersion;
                // set versionpolicy version to the current version
                if (hasChanged &&
                    project.versionPolicyName !== undefined &&
                    project.versionPolicy !== undefined &&
                    project.versionPolicy.isLockstepped) {
                    const projectVersionPolicy = project.versionPolicy;
                    const currentVersionPolicyChange = allChanges.versionPolicyChanges.get(project.versionPolicyName);
                    if (projectVersionPolicy.nextBump === undefined &&
                        (currentVersionPolicyChange === undefined ||
                            semver.gt(currentChange.newVersion, currentVersionPolicyChange.newVersion))) {
                        allChanges.versionPolicyChanges.set(project.versionPolicyName, {
                            versionPolicyName: project.versionPolicyName,
                            changeType: currentChange.changeType,
                            newVersion: currentChange.newVersion
                        });
                    }
                }
            }
            // If hotfix change, force new range dependency to be the exact new version
            currentChange.newRangeDependency =
                change.changeType === ChangeType.hotfix
                    ? currentChange.newVersion
                    : PublishUtilities._getNewRangeDependency(currentChange.newVersion);
        }
        return hasChanged;
    }
    static _updateDownstreamDependencies(change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {
        let hasChanges = false;
        const packageName = change.packageName;
        const downstream = allPackages.get(packageName).consumingProjects;
        // Iterate through all downstream dependencies for the package.
        if (downstream) {
            if (change.changeType >= ChangeType.hotfix || (prereleaseToken && prereleaseToken.hasValue)) {
                for (const dependency of downstream) {
                    const packageJson = dependency.packageJson;
                    hasChanges =
                        PublishUtilities._updateDownstreamDependency(packageJson.name, packageJson.dependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;
                    hasChanges =
                        PublishUtilities._updateDownstreamDependency(packageJson.name, packageJson.devDependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;
                }
            }
        }
        return hasChanges;
    }
    static _updateDownstreamDependency(parentPackageName, dependencies, change, allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) {
        let hasChanges = false;
        if (dependencies &&
            dependencies[change.packageName] &&
            !PublishUtilities._isCyclicDependency(allPackages, parentPackageName, change.packageName)) {
            const requiredVersion = new DependencySpecifier(change.packageName, dependencies[change.packageName]);
            const isWorkspaceWildcardVersion = requiredVersion.specifierType === DependencySpecifierType.Workspace &&
                MAGIC_SPECIFIERS.has(requiredVersion.versionSpecifier);
            const isPrerelease = !!prereleaseToken && prereleaseToken.hasValue && !allChanges.packageChanges.has(parentPackageName);
            // If the version range exists and has not yet been updated to this version, update it.
            if (isPrerelease ||
                isWorkspaceWildcardVersion ||
                requiredVersion.versionSpecifier !== change.newRangeDependency) {
                let changeType;
                // Propagate hotfix changes to dependencies
                if (change.changeType === ChangeType.hotfix) {
                    changeType = ChangeType.hotfix;
                }
                else {
                    // Either it already satisfies the new version, or doesn't.
                    // If not, the downstream dep needs to be republished.
                    // The downstream dep will also need to be republished if using `workspace:*` as this will publish
                    // as the exact version.
                    changeType =
                        !isWorkspaceWildcardVersion &&
                            semver.satisfies(change.newVersion, requiredVersion.versionSpecifier)
                            ? ChangeType.dependency
                            : ChangeType.patch;
                }
                hasChanges = PublishUtilities._addChange({
                    change: {
                        packageName: parentPackageName,
                        changeType
                    },
                    allChanges,
                    allPackages,
                    rushConfiguration,
                    prereleaseToken,
                    projectsToExclude
                });
                if (hasChanges || isPrerelease) {
                    // Only re-evaluate downstream dependencies if updating the parent package's dependency
                    // caused a version bump.
                    hasChanges =
                        PublishUtilities._updateDownstreamDependencies(allChanges.packageChanges.get(parentPackageName), allChanges, allPackages, rushConfiguration, prereleaseToken, projectsToExclude) || hasChanges;
                }
            }
        }
        return hasChanges;
    }
    static _getPublishDependencyVersion(specifier, newVersion) {
        if (specifier.specifierType === DependencySpecifierType.Workspace) {
            const { versionSpecifier } = specifier;
            switch (versionSpecifier) {
                case '*':
                    return newVersion;
                case '~':
                case '^':
                    return `${versionSpecifier}${newVersion}`;
            }
        }
        return newVersion;
    }
    static _updateDependencyVersion(packageName, dependencies, dependencyName, dependencyChange, allChanges, allPackages, rushConfiguration) {
        let currentDependencyVersion = dependencies[dependencyName];
        let newDependencyVersion = PublishUtilities.getNewDependencyVersion(dependencies, dependencyName, dependencyChange.newVersion);
        dependencies[dependencyName] = newDependencyVersion;
        // "*", "~", and "^" are special cases for workspace ranges, since it will publish using the exact
        // version of the local dependency, so we need to modify what we write for our change
        // comment
        const currentDependencySpecifier = new DependencySpecifier(dependencyName, currentDependencyVersion);
        currentDependencyVersion =
            currentDependencySpecifier.specifierType === DependencySpecifierType.Workspace &&
                MAGIC_SPECIFIERS.has(currentDependencySpecifier.versionSpecifier)
                ? undefined
                : currentDependencySpecifier.versionSpecifier;
        const newDependencySpecifier = new DependencySpecifier(dependencyName, newDependencyVersion);
        newDependencyVersion = PublishUtilities._getPublishDependencyVersion(newDependencySpecifier, dependencyChange.newVersion);
        // Add dependency version update comment.
        PublishUtilities._addChange({
            change: {
                packageName: packageName,
                changeType: ChangeType.dependency,
                comment: `Updating dependency "${dependencyName}" ` +
                    (currentDependencyVersion ? `from \`${currentDependencyVersion}\` ` : '') +
                    `to \`${newDependencyVersion}\``
            },
            allChanges,
            allPackages,
            rushConfiguration
        });
    }
}
//# sourceMappingURL=PublishUtilities.js.map