{"version":3,"file":"BaseWorkspaceFile.js","sourceRoot":"","sources":["../../../src/logic/base/BaseWorkspaceFile.ts"],"names":[],"mappings":"AAAA,4FAA4F;AAC5F,2DAA2D;AAE3D,OAAO,EAAE,UAAU,EAAE,MAAM,8BAA8B,CAAC;AAgB1D;;GAEG;AACH,MAAM,OAAgB,iBAAiB;IAAvC;QACY,wBAAmB,GAAgB,IAAI,GAAG,EAAU,CAAC;IA2CjE,CAAC;IAzCC;;OAEG;IACI,IAAI,CAAC,QAAgB,EAAE,OAAkC;QAC9D,iDAAiD;QACjD,IAAI,SAAS,GAAuB,SAAS,CAAC;QAC9C,IAAI,OAAO,CAAC,aAAa,IAAI,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;YACzD,IAAI,CAAC;gBACH,SAAS,GAAG,UAAU,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;YACpD,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,4FAA4F;gBAC5F,iBAAiB;YACnB,CAAC;QACH,CAAC;QAED,MAAM,OAAO,GAAW,IAAI,CAAC,SAAS,EAAE,CAAC;QAEzC,MAAM,SAAS,GAAW,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,6BAA6B;QAE7E,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC;YAC1B,wBAAwB;YACxB,IAAI,SAAS,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC5D,+CAA+C;gBAC/C,OAAO;YACT,CAAC;QACH,CAAC;QAED,UAAU,CAAC,SAAS,CAAC,QAAQ,EAAE,SAAS,CAAC,QAAQ,EAAE,EAAE;YACnD,kBAAkB,EAAE,OAAO,CAAC,kBAAkB;SAC/C,CAAC,CAAC;IACL,CAAC;CAWF","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { FileSystem } from '@rushstack/node-core-library';\n\nexport interface IWorkspaceFileSaveOptions {\n  /**\n   * If there is an existing file, and the contents have not changed, then\n   * don't write anything; this preserves the old timestamp.\n   */\n  onlyIfChanged?: boolean;\n\n  /**\n   * Creates the folder recursively using FileSystem.ensureFolder()\n   * Defaults to false.\n   */\n  ensureFolderExists?: boolean;\n}\n\n/**\n * This class is a parser for pnpm's pnpm-workspace.yaml file format.\n */\nexport abstract class BaseWorkspaceFile {\n  protected _alreadyWarnedSpecs: Set<string> = new Set<string>();\n\n  /**\n   * Serializes and saves the workspace file to specified location\n   */\n  public save(filePath: string, options: IWorkspaceFileSaveOptions): void {\n    // Do we need to read the previous file contents?\n    let oldBuffer: Buffer | undefined = undefined;\n    if (options.onlyIfChanged && FileSystem.exists(filePath)) {\n      try {\n        oldBuffer = FileSystem.readFileToBuffer(filePath);\n      } catch (error) {\n        // Ignore this error, and try writing a new file.  If that fails, then we should report that\n        // error instead.\n      }\n    }\n\n    const newYaml: string = this.serialize();\n\n    const newBuffer: Buffer = Buffer.from(newYaml); // utf8 encoding happens here\n\n    if (options.onlyIfChanged) {\n      // Has the file changed?\n      if (oldBuffer && Buffer.compare(newBuffer, oldBuffer) === 0) {\n        // Nothing has changed, so don't touch the file\n        return;\n      }\n    }\n\n    FileSystem.writeFile(filePath, newBuffer.toString(), {\n      ensureFolderExists: options.ensureFolderExists\n    });\n  }\n\n  /**\n   * Adds a package path to the workspace file.\n   *\n   * @virtual\n   */\n  public abstract addPackage(packagePath: string): void;\n\n  /** @virtual */\n  protected abstract serialize(): string;\n}\n"]}