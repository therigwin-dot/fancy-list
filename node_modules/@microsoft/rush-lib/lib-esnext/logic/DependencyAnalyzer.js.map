{"version":3,"file":"DependencyAnalyzer.js","sourceRoot":"","sources":["../../src/logic/DependencyAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as semver from 'semver';\nimport type { CommonVersionsConfiguration } from '../api/CommonVersionsConfiguration';\nimport { DependencyType, type PackageJsonDependency } from '../api/PackageJsonEditor';\nimport type { RushConfiguration } from '../api/RushConfiguration';\nimport type { RushConfigurationProject } from '../api/RushConfigurationProject';\nimport type { Subspace } from '../api/Subspace';\n\nexport interface IDependencyAnalysis {\n  /**\n   * The common versions configuration from the repo's rush configuration.\n   */\n  commonVersionsConfiguration: CommonVersionsConfiguration;\n\n  /**\n   * A map of all direct dependencies that only have a single semantic version specifier,\n   * unless the {@link CommonVersionsConfiguration.implicitlyPreferredVersions} option\n   * set to `false`.\n   */\n  implicitlyPreferredVersionByPackageName: Map<string, string>;\n\n  /**\n   * A map of dependency name to the set of version specifiers used in the repo.\n   */\n  allVersionsByPackageName: Map<string, Set<string>>;\n}\n\nexport class DependencyAnalyzer {\n  private static _dependencyAnalyzerByRushConfiguration:\n    | WeakMap<RushConfiguration, DependencyAnalyzer>\n    | undefined;\n\n  private _rushConfiguration: RushConfiguration;\n  private _analysisByVariantBySubspace: Map<string, WeakMap<Subspace, IDependencyAnalysis>> | undefined;\n\n  private constructor(rushConfiguration: RushConfiguration) {\n    this._rushConfiguration = rushConfiguration;\n  }\n\n  public static forRushConfiguration(rushConfiguration: RushConfiguration): DependencyAnalyzer {\n    if (!DependencyAnalyzer._dependencyAnalyzerByRushConfiguration) {\n      DependencyAnalyzer._dependencyAnalyzerByRushConfiguration = new WeakMap();\n    }\n\n    let analyzer: DependencyAnalyzer | undefined =\n      DependencyAnalyzer._dependencyAnalyzerByRushConfiguration.get(rushConfiguration);\n    if (!analyzer) {\n      analyzer = new DependencyAnalyzer(rushConfiguration);\n      DependencyAnalyzer._dependencyAnalyzerByRushConfiguration.set(rushConfiguration, analyzer);\n    }\n\n    return analyzer;\n  }\n\n  public getAnalysis(\n    subspace: Subspace | undefined,\n    variant: string | undefined,\n    addAction: boolean\n  ): IDependencyAnalysis {\n    // Use an empty string as the key when no variant provided. Anything else would possibly conflict\n    // with a variant created by the user\n    const variantKey: string = variant || '';\n\n    if (!this._analysisByVariantBySubspace) {\n      this._analysisByVariantBySubspace = new Map();\n    }\n\n    const subspaceToAnalyze: Subspace = subspace || this._rushConfiguration.defaultSubspace;\n    let analysisForVariant: WeakMap<Subspace, IDependencyAnalysis> | undefined =\n      this._analysisByVariantBySubspace.get(variantKey);\n\n    if (!analysisForVariant) {\n      analysisForVariant = new WeakMap();\n      this._analysisByVariantBySubspace.set(variantKey, analysisForVariant);\n    }\n\n    let analysisForSubspace: IDependencyAnalysis | undefined = analysisForVariant.get(subspaceToAnalyze);\n    if (!analysisForSubspace) {\n      analysisForSubspace = this._getAnalysisInternal(subspaceToAnalyze, variant, addAction);\n\n      analysisForVariant.set(subspaceToAnalyze, analysisForSubspace);\n    }\n\n    return analysisForSubspace;\n  }\n\n  /**\n   * Generates the {@link IDependencyAnalysis}.\n   *\n   * @remarks\n   * The result of this function is not cached.\n   */\n  private _getAnalysisInternal(\n    subspace: Subspace,\n    variant: string | undefined,\n    addAction: boolean\n  ): IDependencyAnalysis {\n    const commonVersionsConfiguration: CommonVersionsConfiguration = subspace.getCommonVersions(variant);\n    const allVersionsByPackageName: Map<string, Set<string>> = new Map();\n    const allowedAlternativeVersions: Map<\n      string,\n      ReadonlyArray<string>\n    > = commonVersionsConfiguration.allowedAlternativeVersions;\n\n    let projectsToProcess: RushConfigurationProject[] = this._rushConfiguration.projects;\n    if (addAction && this._rushConfiguration.subspacesFeatureEnabled) {\n      projectsToProcess = subspace.getProjects();\n    }\n\n    for (const project of projectsToProcess) {\n      const dependencies: PackageJsonDependency[] = [\n        ...project.packageJsonEditor.dependencyList,\n        ...project.packageJsonEditor.devDependencyList\n      ];\n      for (const { name: dependencyName, version: dependencyVersion, dependencyType } of dependencies) {\n        if (dependencyType === DependencyType.Peer) {\n          // If this is a peer dependency, it isn't a real dependency in this context, so it shouldn't\n          // be included in the list of dependency versions.\n          continue;\n        }\n\n        // Is it a local project?\n        const localProject: RushConfigurationProject | undefined =\n          this._rushConfiguration.getProjectByName(dependencyName);\n        if (localProject) {\n          if (\n            !project.decoupledLocalDependencies.has(dependencyName) &&\n            semver.satisfies(localProject.packageJson.version, dependencyVersion)\n          ) {\n            // For now, ignore local dependencies (that aren't cyclic dependencies).\n            continue;\n          }\n        }\n\n        let allVersionForDependency: Set<string> | undefined = allVersionsByPackageName.get(dependencyName);\n        if (!allVersionForDependency) {\n          allVersionForDependency = new Set<string>();\n          allVersionsByPackageName.set(dependencyName, allVersionForDependency);\n        }\n\n        allVersionForDependency.add(dependencyVersion);\n      }\n    }\n\n    const implicitlyPreferredVersionByPackageName: Map<string, string> = new Map();\n    // Only generate implicitly preferred versions when requested\n    const useImplicitlyPreferredVersions: boolean =\n      commonVersionsConfiguration.implicitlyPreferredVersions ?? true;\n    if (useImplicitlyPreferredVersions) {\n      for (const [dependencyName, versions] of allVersionsByPackageName) {\n        // For each dependency, we're collecting the set of all version specifiers that appear across the repo.\n        // If there is only one version specifier, then that's the \"preferred\" one.\n\n        const alternativesForThisDependency: ReadonlySet<string> = new Set(\n          allowedAlternativeVersions.get(dependencyName)\n        );\n\n        let implicitlyPreferredVersion: string | undefined = undefined;\n        for (const version of versions) {\n          // Versions listed in the common-versions.json's \"allowedAlternativeVersions\" property\n          // can be safely ignored in determining the set of implicitly preferred versions.\n          // (Even if it's the only version specifier anywhere in the repo, we still ignore it, because\n          // otherwise the rule would be difficult to explain.)\n          if (!alternativesForThisDependency.has(version)) {\n            if (implicitlyPreferredVersion === undefined) {\n              // There isn't a candidate for an implicitly preferred version yet. Set this value as a candidate.\n              implicitlyPreferredVersion = version;\n            } else {\n              // There was already another version that was a candidate. Clear that out and break.\n              // This dependency does not have an implicitly preferred version because there are at least\n              // two candidates.\n              implicitlyPreferredVersion = undefined;\n              break;\n            }\n          }\n        }\n\n        if (implicitlyPreferredVersion !== undefined) {\n          implicitlyPreferredVersionByPackageName.set(dependencyName, implicitlyPreferredVersion);\n        }\n      }\n    }\n\n    return {\n      commonVersionsConfiguration,\n      implicitlyPreferredVersionByPackageName,\n      allVersionsByPackageName\n    };\n  }\n}\n"]}