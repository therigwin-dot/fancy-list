{"version":3,"file":"ProjectWatcher.js","sourceRoot":"","sources":["../../src/logic/ProjectWatcher.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as readline from 'readline';\nimport { once } from 'events';\nimport { getRepoRoot } from '@rushstack/package-deps-hash';\nimport { AlreadyReportedError, Path, type FileSystemStats, FileSystem } from '@rushstack/node-core-library';\nimport { Colorize, type ITerminal } from '@rushstack/terminal';\n\nimport { Git } from './Git';\nimport type { IInputsSnapshot, GetInputsSnapshotAsyncFn } from './incremental/InputsSnapshot';\nimport type { RushConfiguration } from '../api/RushConfiguration';\nimport type { RushConfigurationProject } from '../api/RushConfigurationProject';\n\nexport interface IProjectWatcherOptions {\n  getInputsSnapshotAsync: GetInputsSnapshotAsyncFn;\n  debounceMs?: number;\n  rushConfiguration: RushConfiguration;\n  projectsToWatch: ReadonlySet<RushConfigurationProject>;\n  terminal: ITerminal;\n  initialSnapshot?: IInputsSnapshot | undefined;\n}\n\nexport interface IProjectChangeResult {\n  /**\n   * The set of projects that have changed since the last iteration\n   */\n  changedProjects: ReadonlySet<RushConfigurationProject>;\n  /**\n   * Contains the git hashes for all tracked files in the repo\n   */\n  inputsSnapshot: IInputsSnapshot;\n}\n\nexport interface IPromptGeneratorFunction {\n  (isPaused: boolean): Iterable<string>;\n}\n\ninterface IPathWatchOptions {\n  recurse: boolean;\n}\n\n/**\n * This class is for incrementally watching a set of projects in the repository for changes.\n *\n * We are manually using fs.watch() instead of `chokidar` because all we want from the file system watcher is a boolean\n * signal indicating that \"at least 1 file in a watched project changed\". We then defer to getInputsSnapshotAsync (which\n * is responsible for change detection in all incremental builds) to determine what actually chanaged.\n *\n * Calling `waitForChange()` will return a promise that resolves when the package-deps of one or\n * more projects differ from the value the previous time it was invoked. The first time will always resolve with the full selection.\n */\nexport class ProjectWatcher {\n  private readonly _getInputsSnapshotAsync: GetInputsSnapshotAsyncFn;\n  private readonly _debounceMs: number;\n  private readonly _repoRoot: string;\n  private readonly _rushConfiguration: RushConfiguration;\n  private readonly _projectsToWatch: ReadonlySet<RushConfigurationProject>;\n  private readonly _terminal: ITerminal;\n\n  private _initialSnapshot: IInputsSnapshot | undefined;\n  private _previousSnapshot: IInputsSnapshot | undefined;\n  private _forceChangedProjects: Map<RushConfigurationProject, string> = new Map();\n  private _resolveIfChanged: undefined | (() => Promise<void>);\n  private _getPromptLines: undefined | IPromptGeneratorFunction;\n\n  private _renderedStatusLines: number;\n\n  public isPaused: boolean = false;\n\n  public constructor(options: IProjectWatcherOptions) {\n    const {\n      getInputsSnapshotAsync: snapshotProvider,\n      debounceMs = 1000,\n      rushConfiguration,\n      projectsToWatch,\n      terminal,\n      initialSnapshot: initialState\n    } = options;\n\n    this._debounceMs = debounceMs;\n    this._rushConfiguration = rushConfiguration;\n    this._projectsToWatch = projectsToWatch;\n    this._terminal = terminal;\n\n    const gitPath: string = new Git(rushConfiguration).getGitPathOrThrow();\n    this._repoRoot = Path.convertToSlashes(getRepoRoot(rushConfiguration.rushJsonFolder, gitPath));\n\n    this._initialSnapshot = initialState;\n    this._previousSnapshot = initialState;\n\n    this._renderedStatusLines = 0;\n    this._getPromptLines = undefined;\n    this._getInputsSnapshotAsync = snapshotProvider;\n  }\n\n  public pause(): void {\n    this.isPaused = true;\n    this._setStatus('Project watcher paused.');\n  }\n\n  public resume(): void {\n    this.isPaused = false;\n    this._setStatus('Project watcher resuming...');\n    if (this._resolveIfChanged) {\n      this._resolveIfChanged().catch(() => {\n        // Suppress unhandled promise rejection error\n      });\n    }\n  }\n\n  public invalidateProject(project: RushConfigurationProject, reason: string): boolean {\n    if (this._forceChangedProjects.has(project)) {\n      return false;\n    }\n\n    this._forceChangedProjects.set(project, reason);\n    return true;\n  }\n\n  public invalidateAll(reason: string): void {\n    for (const project of this._projectsToWatch) {\n      this.invalidateProject(project, reason);\n    }\n  }\n\n  public clearStatus(): void {\n    this._renderedStatusLines = 0;\n  }\n\n  public setPromptGenerator(promptGenerator: IPromptGeneratorFunction): void {\n    this._getPromptLines = promptGenerator;\n  }\n\n  /**\n   * Waits for a change to the package-deps of one or more of the selected projects, since the previous invocation.\n   * Will return immediately the first time it is invoked, since no state has been recorded.\n   * If no change is currently present, watches the source tree of all selected projects for file changes.\n   * `waitForChange` is not allowed to be called multiple times concurrently.\n   */\n  public async waitForChangeAsync(onWatchingFiles?: () => void): Promise<IProjectChangeResult> {\n    const initialChangeResult: IProjectChangeResult = await this._computeChangedAsync();\n    // Ensure that the new state is recorded so that we don't loop infinitely\n    this._commitChanges(initialChangeResult.inputsSnapshot);\n    if (initialChangeResult.changedProjects.size) {\n      // We can't call `clear()` here due to the async tick in the end of _computeChanged\n      for (const project of initialChangeResult.changedProjects) {\n        this._forceChangedProjects.delete(project);\n      }\n      // TODO: _forceChangedProjects might be non-empty here, which will result in an immediate rerun after the next\n      // run finishes. This is suboptimal, but the latency of _computeChanged is probably high enough that in practice\n      // all invalidations will have been picked up already.\n      return initialChangeResult;\n    }\n\n    const previousState: IInputsSnapshot = initialChangeResult.inputsSnapshot;\n    const repoRoot: string = Path.convertToSlashes(this._rushConfiguration.rushJsonFolder);\n\n    // Map of path to whether config for the path\n    const pathsToWatch: Map<string, IPathWatchOptions> = new Map();\n\n    // Node 12 supports the \"recursive\" parameter to fs.watch only on win32 and OSX\n    // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_caveats\n    const useNativeRecursiveWatch: boolean = os.platform() === 'win32' || os.platform() === 'darwin';\n\n    if (useNativeRecursiveWatch) {\n      // Watch the root non-recursively\n      pathsToWatch.set(repoRoot, { recurse: false });\n\n      // Watch the rush config folder non-recursively\n      pathsToWatch.set(Path.convertToSlashes(this._rushConfiguration.commonRushConfigFolder), {\n        recurse: false\n      });\n\n      for (const project of this._projectsToWatch) {\n        // Use recursive watch in individual project folders\n        pathsToWatch.set(Path.convertToSlashes(project.projectFolder), { recurse: true });\n      }\n    } else {\n      for (const project of this._projectsToWatch) {\n        const projectState: ReadonlyMap<string, string> =\n          previousState.getTrackedFileHashesForOperation(project);\n\n        const prefixLength: number = project.projectFolder.length - repoRoot.length - 1;\n        // Watch files in the root of the project, or\n        for (const pathToWatch of ProjectWatcher._enumeratePathsToWatch(projectState.keys(), prefixLength)) {\n          pathsToWatch.set(`${this._repoRoot}/${pathToWatch}`, { recurse: true });\n        }\n      }\n    }\n\n    const watchers: Map<string, fs.FSWatcher> = new Map();\n\n    const watchedResult: IProjectChangeResult = await new Promise(\n      (resolve: (result: IProjectChangeResult) => void, reject: (err: Error) => void) => {\n        let timeout: NodeJS.Timeout | undefined;\n        let terminated: boolean = false;\n\n        const terminal: ITerminal = this._terminal;\n\n        const debounceMs: number = this._debounceMs;\n\n        this.clearStatus();\n\n        const resolveIfChanged: () => Promise<void> = (this._resolveIfChanged = async (): Promise<void> => {\n          timeout = undefined;\n          if (terminated) {\n            return;\n          }\n\n          try {\n            if (this.isPaused) {\n              this._setStatus(`Project watcher paused.`);\n              return;\n            }\n\n            this._setStatus(`Evaluating changes to tracked files...`);\n            const result: IProjectChangeResult = await this._computeChangedAsync();\n            this._setStatus(`Finished analyzing.`);\n\n            // Need an async tick to allow for more file system events to be handled\n            process.nextTick(() => {\n              if (timeout) {\n                // If another file has changed, wait for another pass.\n                this._setStatus(`More file changes detected, aborting.`);\n                return;\n              }\n\n              // Since there are multiple async ticks since the projects were enumerated in _computeChanged,\n              // more could have been added in the interaval. Check and debounce.\n              for (const project of this._forceChangedProjects.keys()) {\n                if (!result.changedProjects.has(project)) {\n                  this._setStatus(`More invalidations occurred, aborting.`);\n                  timeout = setTimeout(resolveIfChanged, debounceMs);\n                  return;\n                }\n              }\n\n              this._commitChanges(result.inputsSnapshot);\n\n              const hasForcedChanges: boolean = this._forceChangedProjects.size > 0;\n              if (hasForcedChanges) {\n                this._setStatus(\n                  `Projects were invalidated: ${Array.from(new Set(this._forceChangedProjects.values())).join(\n                    ', '\n                  )}`\n                );\n                this.clearStatus();\n              }\n              this._forceChangedProjects.clear();\n\n              if (result.changedProjects.size) {\n                terminated = true;\n                terminal.writeLine();\n                resolve(result);\n              } else {\n                this._setStatus(`No changes detected to tracked files.`);\n              }\n            });\n          } catch (err) {\n            // eslint-disable-next-line require-atomic-updates\n            terminated = true;\n            terminal.writeLine();\n            reject(err as NodeJS.ErrnoException);\n          }\n        });\n\n        for (const [pathToWatch, { recurse }] of pathsToWatch) {\n          addWatcher(pathToWatch, recurse);\n        }\n\n        if (onWatchingFiles) {\n          onWatchingFiles();\n        }\n\n        this._setStatus(`Waiting for changes...`);\n\n        function onError(err: Error): void {\n          if (terminated) {\n            return;\n          }\n\n          terminated = true;\n          terminal.writeLine();\n          reject(err);\n        }\n\n        function addWatcher(watchedPath: string, recursive: boolean): void {\n          if (watchers.has(watchedPath)) {\n            return;\n          }\n          const listener: fs.WatchListener<string> = changeListener(watchedPath, recursive);\n          const watcher: fs.FSWatcher = fs.watch(\n            watchedPath,\n            {\n              encoding: 'utf-8',\n              recursive: recursive && useNativeRecursiveWatch\n            },\n            listener\n          );\n          watchers.set(watchedPath, watcher);\n          watcher.on('error', (err) => {\n            watchers.delete(watchedPath);\n            onError(err);\n          });\n        }\n\n        function innerListener(\n          root: string,\n          recursive: boolean,\n          event: string,\n          fileName: string | null\n        ): void {\n          try {\n            if (terminated) {\n              return;\n            }\n\n            if (fileName === '.git' || fileName === 'node_modules') {\n              return;\n            }\n\n            // Handling for added directories\n            if (recursive && !useNativeRecursiveWatch) {\n              const decodedName: string = fileName ? fileName.toString() : '';\n              const normalizedName: string = decodedName && Path.convertToSlashes(decodedName);\n              const fullName: string = normalizedName && `${root}/${normalizedName}`;\n\n              if (fullName && !watchers.has(fullName)) {\n                try {\n                  const stat: FileSystemStats = FileSystem.getStatistics(fullName);\n                  if (stat.isDirectory()) {\n                    addWatcher(fullName, true);\n                  }\n                } catch (err) {\n                  const code: string | undefined = (err as NodeJS.ErrnoException).code;\n\n                  if (code !== 'ENOENT' && code !== 'ENOTDIR') {\n                    throw err;\n                  }\n                }\n              }\n            }\n\n            // Use a timeout to debounce changes, e.g. bulk copying files into the directory while the watcher is running.\n            if (timeout) {\n              clearTimeout(timeout);\n            }\n\n            timeout = setTimeout(resolveIfChanged, debounceMs);\n          } catch (err) {\n            terminated = true;\n            terminal.writeLine();\n            reject(err as NodeJS.ErrnoException);\n          }\n        }\n\n        function changeListener(root: string, recursive: boolean): fs.WatchListener<string> {\n          return innerListener.bind(0, root, recursive);\n        }\n      }\n    ).finally(() => {\n      this._resolveIfChanged = undefined;\n    });\n\n    const closePromises: Promise<void>[] = [];\n    for (const [watchedPath, watcher] of watchers) {\n      closePromises.push(\n        once(watcher, 'close').then(() => {\n          watchers.delete(watchedPath);\n        })\n      );\n      watcher.close();\n    }\n\n    await Promise.all(closePromises);\n\n    return watchedResult;\n  }\n\n  private _setStatus(status: string): void {\n    const statusLines: string[] = [\n      `[${this.isPaused ? 'PAUSED' : 'WATCHING'}] Watch Status: ${status}`,\n      ...(this._getPromptLines?.(this.isPaused) ?? [])\n    ];\n\n    if (this._renderedStatusLines > 0) {\n      readline.cursorTo(process.stdout, 0);\n      readline.moveCursor(process.stdout, 0, -this._renderedStatusLines);\n      readline.clearScreenDown(process.stdout);\n    }\n    this._renderedStatusLines = statusLines.length;\n\n    this._terminal.writeLine(Colorize.bold(Colorize.cyan(statusLines.join('\\n'))));\n  }\n\n  /**\n   * Determines which, if any, projects (within the selection) have new hashes for files that are not in .gitignore\n   */\n  private async _computeChangedAsync(): Promise<IProjectChangeResult> {\n    const currentSnapshot: IInputsSnapshot | undefined = await this._getInputsSnapshotAsync();\n\n    if (!currentSnapshot) {\n      throw new AlreadyReportedError();\n    }\n\n    const previousSnapshot: IInputsSnapshot | undefined = this._previousSnapshot;\n\n    if (!previousSnapshot) {\n      return {\n        changedProjects: this._projectsToWatch,\n        inputsSnapshot: currentSnapshot\n      };\n    }\n\n    const changedProjects: Set<RushConfigurationProject> = new Set();\n    for (const project of this._projectsToWatch) {\n      const previous: ReadonlyMap<string, string> | undefined =\n        previousSnapshot.getTrackedFileHashesForOperation(project);\n      const current: ReadonlyMap<string, string> | undefined =\n        currentSnapshot.getTrackedFileHashesForOperation(project);\n\n      if (ProjectWatcher._haveProjectDepsChanged(previous, current)) {\n        // May need to detect if the nature of the change will break the process, e.g. changes to package.json\n        changedProjects.add(project);\n      }\n    }\n\n    for (const project of this._forceChangedProjects.keys()) {\n      changedProjects.add(project);\n    }\n\n    return {\n      changedProjects,\n      inputsSnapshot: currentSnapshot\n    };\n  }\n\n  private _commitChanges(state: IInputsSnapshot): void {\n    this._previousSnapshot = state;\n    if (!this._initialSnapshot) {\n      this._initialSnapshot = state;\n    }\n  }\n\n  /**\n   * Tests for inequality of the passed Maps. Order invariant.\n   *\n   * @returns `true` if the maps are different, `false` otherwise\n   */\n  private static _haveProjectDepsChanged(\n    prev: ReadonlyMap<string, string> | undefined,\n    next: ReadonlyMap<string, string> | undefined\n  ): boolean {\n    if (!prev && !next) {\n      return false;\n    }\n\n    if (!prev || !next) {\n      return true;\n    }\n\n    if (prev.size !== next.size) {\n      return true;\n    }\n\n    for (const [key, value] of prev) {\n      if (next.get(key) !== value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static *_enumeratePathsToWatch(paths: Iterable<string>, prefixLength: number): Iterable<string> {\n    for (const path of paths) {\n      const rootSlashIndex: number = path.indexOf('/', prefixLength);\n\n      if (rootSlashIndex < 0) {\n        yield path;\n        return;\n      }\n\n      yield path.slice(0, rootSlashIndex);\n\n      let slashIndex: number = path.indexOf('/', rootSlashIndex + 1);\n      while (slashIndex >= 0) {\n        yield path.slice(0, slashIndex);\n        slashIndex = path.indexOf('/', slashIndex + 1);\n      }\n    }\n  }\n}\n"]}