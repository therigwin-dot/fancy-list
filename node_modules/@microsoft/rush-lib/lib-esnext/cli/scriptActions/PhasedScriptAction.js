// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
import { AlreadyReportedError, InternalError } from '@rushstack/node-core-library';
import { Terminal, Colorize } from '@rushstack/terminal';
import { PhasedCommandHooks } from '../../pluginFramework/PhasedCommandHooks';
import { SetupChecks } from '../../logic/SetupChecks';
import { Stopwatch, StopwatchState } from '../../utilities/Stopwatch';
import { BaseScriptAction } from './BaseScriptAction';
import { OperationExecutionManager } from '../../logic/operations/OperationExecutionManager';
import { RushConstants } from '../../logic/RushConstants';
import { EnvironmentVariableNames } from '../../api/EnvironmentConfiguration';
import { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';
import { SelectionParameterSet } from '../parsing/SelectionParameterSet';
import { PhasedOperationPlugin } from '../../logic/operations/PhasedOperationPlugin';
import { ShellOperationRunnerPlugin } from '../../logic/operations/ShellOperationRunnerPlugin';
import { Event } from '../../api/EventHooks';
import { ProjectChangeAnalyzer } from '../../logic/ProjectChangeAnalyzer';
import { OperationStatus } from '../../logic/operations/OperationStatus';
import { OperationResultSummarizerPlugin } from '../../logic/operations/OperationResultSummarizerPlugin';
import { parseParallelism } from '../parsing/ParseParallelism';
import { CobuildConfiguration } from '../../api/CobuildConfiguration';
import { CacheableOperationPlugin } from '../../logic/operations/CacheableOperationPlugin';
import { RushProjectConfiguration } from '../../api/RushProjectConfiguration';
import { LegacySkipPlugin } from '../../logic/operations/LegacySkipPlugin';
import { ValidateOperationsPlugin } from '../../logic/operations/ValidateOperationsPlugin';
import { ShardedPhasedOperationPlugin } from '../../logic/operations/ShardedPhaseOperationPlugin';
import { FlagFile } from '../../api/FlagFile';
import { WeightedOperationPlugin } from '../../logic/operations/WeightedOperationPlugin';
import { getVariantAsync, VARIANT_PARAMETER } from '../../api/Variants';
import { Selection } from '../../logic/Selection';
import { NodeDiagnosticDirPlugin } from '../../logic/operations/NodeDiagnosticDirPlugin';
/**
 * This class implements phased commands which are run individually for each project in the repo,
 * possibly in parallel, and which may define multiple phases.
 *
 * @remarks
 * Phased commands can be defined via common/config/command-line.json.  Rush's predefined "build"
 * and "rebuild" commands are also modeled as phased commands with a single phase that invokes the npm
 * "build" script for each project.
 */
export class PhasedScriptAction extends BaseScriptAction {
    constructor(options) {
        var _a;
        super(options);
        this._enableParallelism = options.enableParallelism;
        this._isIncrementalBuildAllowed = options.incremental;
        this._disableBuildCache = options.disableBuildCache;
        this._originalPhases = options.originalPhases;
        this._initialPhases = options.initialPhases;
        this._watchPhases = options.watchPhases;
        this._watchDebounceMs = (_a = options.watchDebounceMs) !== null && _a !== void 0 ? _a : RushConstants.defaultWatchDebounceMs;
        this._alwaysWatch = options.alwaysWatch;
        this._alwaysInstall = options.alwaysInstall;
        this._runsBeforeInstall = false;
        this._knownPhases = options.phases;
        this.hooks = new PhasedCommandHooks();
        const terminal = new Terminal(this.rushSession.terminalProvider);
        this._terminal = terminal;
        // Generates the default operation graph
        new PhasedOperationPlugin().apply(this.hooks);
        // Splices in sharded phases to the operation graph.
        new ShardedPhasedOperationPlugin().apply(this.hooks);
        // Applies the Shell Operation Runner to selected operations
        new ShellOperationRunnerPlugin().apply(this.hooks);
        new WeightedOperationPlugin().apply(this.hooks);
        new ValidateOperationsPlugin(terminal).apply(this.hooks);
        if (this._enableParallelism) {
            this._parallelismParameter = this.defineStringParameter({
                parameterLongName: '--parallelism',
                parameterShortName: '-p',
                argumentName: 'COUNT',
                environmentVariable: EnvironmentVariableNames.RUSH_PARALLELISM,
                description: 'Specifies the maximum number of concurrent processes to launch during a build.' +
                    ' The COUNT should be a positive integer, a percentage value (eg. "50%%") or the word "max"' +
                    ' to specify a count that is equal to the number of CPU cores. If this parameter is omitted,' +
                    ' then the default value depends on the operating system and number of CPU cores.'
            });
        }
        this._timelineParameter = this.defineFlagParameter({
            parameterLongName: '--timeline',
            description: 'After the build is complete, print additional statistics and CPU usage information,' +
                ' including an ASCII chart of the start and stop times for each operation.'
        });
        this._cobuildPlanParameter = this.defineFlagParameter({
            parameterLongName: '--log-cobuild-plan',
            description: '(EXPERIMENTAL) Before the build starts, log information about the cobuild state. This will include information about ' +
                'clusters and the projects that are part of each cluster.'
        });
        this._selectionParameters = new SelectionParameterSet(this.rushConfiguration, this, {
            gitOptions: {
                // Include lockfile processing since this expands the selection, and we need to select
                // at least the same projects selected with the same query to "rush build"
                includeExternalDependencies: true,
                // Enable filtering to reduce evaluation cost
                enableFiltering: true
            },
            includeSubspaceSelector: false
        });
        this._verboseParameter = this.defineFlagParameter({
            parameterLongName: '--verbose',
            parameterShortName: '-v',
            description: 'Display the logs during the build, rather than just displaying the build status summary'
        });
        this._includePhaseDeps = this.defineFlagParameter({
            parameterLongName: '--include-phase-deps',
            description: 'If the selected projects are "unsafe" (missing some dependencies), add the minimal set of phase dependencies. For example, ' +
                `"--from A" normally might include the "_phase:test" phase for A's dependencies, even though changes to A can't break those tests. ` +
                `Using "--impacted-by A --include-phase-deps" avoids that work by performing "_phase:test" only for downstream projects.`
        });
        if (this._isIncrementalBuildAllowed) {
            this._changedProjectsOnly = this.defineFlagParameter({
                parameterLongName: '--changed-projects-only',
                parameterShortName: '-c',
                description: 'Normally the incremental build logic will rebuild changed projects as well as' +
                    ' any projects that directly or indirectly depend on a changed project. Specify "--changed-projects-only"' +
                    ' to ignore dependent projects, only rebuilding those projects whose files were changed.' +
                    ' Note that this parameter is "unsafe"; it is up to the developer to ensure that the ignored projects' +
                    ' are okay to ignore.'
            });
        }
        this._ignoreHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-hooks',
            description: `Skips execution of the "eventHooks" scripts defined in ${RushConstants.rushJsonFilename}. ` +
                'Make sure you know what you are skipping.'
        });
        if (this._watchPhases.size > 0 && !this._alwaysWatch) {
            // Only define the parameter if it has an effect.
            this._watchParameter = this.defineFlagParameter({
                parameterLongName: '--watch',
                description: `Starts a file watcher after initial execution finishes. Will run the following phases on affected projects: ${Array.from(this._watchPhases, (phase) => phase.name).join(', ')}`
            });
        }
        // If `this._alwaysInstall === undefined`, Rush does not define the parameter
        // but a repository may still define a custom parameter with the same name.
        if (this._alwaysInstall === false) {
            this._installParameter = this.defineFlagParameter({
                parameterLongName: '--install',
                description: 'Normally a phased command expects "rush install" to have been manually run first. If this flag is specified, ' +
                    'Rush will automatically perform an install before processing the current command.'
            });
        }
        if (this._alwaysInstall !== undefined) {
            this._variantParameter = this.defineStringParameter(VARIANT_PARAMETER);
        }
        if (this._watchPhases.size > 0 &&
            this.rushConfiguration.experimentsConfiguration.configuration.useIPCScriptsInWatchMode) {
            this._noIPCParameter = this.defineFlagParameter({
                parameterLongName: '--no-ipc',
                description: 'Disables the IPC feature for the current command (if applicable to selected operations). Operations will not look for a ":ipc" suffixed script.' +
                    'This feature only applies in watch mode and is enabled by default.'
            });
        }
        this._nodeDiagnosticDirParameter = this.defineStringParameter({
            parameterLongName: '--node-diagnostic-dir',
            argumentName: 'DIRECTORY',
            description: 'Specifies the directory where Node.js diagnostic reports will be written. ' +
                'This directory will contain a subdirectory for each project and phase.'
        });
        this.defineScriptParameters();
        for (const [{ associatedPhases }, tsCommandLineParameter] of this.customParameters) {
            if (associatedPhases) {
                for (const phaseName of associatedPhases) {
                    const phase = this._knownPhases.get(phaseName);
                    if (!phase) {
                        throw new InternalError(`Could not find a phase matching ${phaseName}.`);
                    }
                    phase.associatedParameters.add(tsCommandLineParameter);
                }
            }
        }
    }
    async runAsync() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (this._alwaysInstall || ((_a = this._installParameter) === null || _a === void 0 ? void 0 : _a.value)) {
            const { doBasicInstallAsync } = await import(
            /* webpackChunkName: 'doBasicInstallAsync' */
            '../../logic/installManager/doBasicInstallAsync');
            const variant = await getVariantAsync(this._variantParameter, this.rushConfiguration, true);
            await doBasicInstallAsync({
                terminal: this._terminal,
                rushConfiguration: this.rushConfiguration,
                rushGlobalFolder: this.rushGlobalFolder,
                isDebug: this.parser.isDebug,
                variant,
                beforeInstallAsync: (subspace) => this.rushSession.hooks.beforeInstall.promise(this, subspace, variant),
                afterInstallAsync: (subspace) => this.rushSession.hooks.afterInstall.promise(this, subspace, variant),
                // Eventually we may want to allow a subspace to be selected here
                subspace: this.rushConfiguration.defaultSubspace
            });
        }
        if (!this._runsBeforeInstall) {
            // TODO: Replace with last-install.flag when "rush link" and "rush unlink" are removed
            const lastLinkFlag = new FlagFile(this.rushConfiguration.defaultSubspace.getSubspaceTempFolderPath(), RushConstants.lastLinkFlagFilename, {});
            // Only check for a valid link flag when subspaces is not enabled
            if (!(await lastLinkFlag.isValidAsync()) && !this.rushConfiguration.subspacesFeatureEnabled) {
                const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;
                if (useWorkspaces) {
                    throw new Error('Link flag invalid.\nDid you run "rush install" or "rush update"?');
                }
                else {
                    throw new Error('Link flag invalid.\nDid you run "rush link"?');
                }
            }
        }
        this._doBeforeTask();
        // if this is parallelizable, then use the value from the flag (undefined or a number),
        // if parallelism is not enabled, then restrict to 1 core
        const parallelism = this._enableParallelism
            ? parseParallelism((_b = this._parallelismParameter) === null || _b === void 0 ? void 0 : _b.value)
            : 1;
        const terminal = this._terminal;
        const stopwatch = Stopwatch.start();
        const showTimeline = this._timelineParameter ? this._timelineParameter.value : false;
        if (showTimeline) {
            const { ConsoleTimelinePlugin } = await import(
            /* webpackChunkName: 'ConsoleTimelinePlugin' */
            '../../logic/operations/ConsoleTimelinePlugin');
            new ConsoleTimelinePlugin(terminal).apply(this.hooks);
        }
        const includePhaseDeps = (_d = (_c = this._includePhaseDeps) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : false;
        const diagnosticDir = this._nodeDiagnosticDirParameter.value;
        if (diagnosticDir) {
            new NodeDiagnosticDirPlugin({
                diagnosticDir
            }).apply(this.hooks);
        }
        // Enable the standard summary
        new OperationResultSummarizerPlugin(terminal).apply(this.hooks);
        const { hooks: sessionHooks } = this.rushSession;
        if (sessionHooks.runAnyPhasedCommand.isUsed()) {
            // Avoid the cost of compiling the hook if it wasn't tapped.
            await sessionHooks.runAnyPhasedCommand.promise(this);
        }
        const hookForAction = sessionHooks.runPhasedCommand.get(this.actionName);
        if (hookForAction) {
            // Run the more specific hook for a command with this name after the general hook
            await hookForAction.promise(this);
        }
        const isQuietMode = !this._verboseParameter.value;
        const changedProjectsOnly = !!((_e = this._changedProjectsOnly) === null || _e === void 0 ? void 0 : _e.value);
        let buildCacheConfiguration;
        let cobuildConfiguration;
        if (!this._disableBuildCache) {
            buildCacheConfiguration = await BuildCacheConfiguration.tryLoadAsync(terminal, this.rushConfiguration, this.rushSession);
            cobuildConfiguration = await CobuildConfiguration.tryLoadAsync(terminal, this.rushConfiguration, this.rushSession);
            await (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.createLockProviderAsync(terminal));
        }
        try {
            const projectSelection = await this._selectionParameters.getSelectedProjectsAsync(terminal);
            if (!projectSelection.size) {
                terminal.writeLine(Colorize.yellow(`The command line selection parameters did not match any projects.`));
                return;
            }
            const isWatch = ((_f = this._watchParameter) === null || _f === void 0 ? void 0 : _f.value) || this._alwaysWatch;
            if (isWatch && ((_g = this._noIPCParameter) === null || _g === void 0 ? void 0 : _g.value) === false) {
                new (await import(
                /* webpackChunkName: 'IPCOperationRunnerPlugin' */ '../../logic/operations/IPCOperationRunnerPlugin')).IPCOperationRunnerPlugin().apply(this.hooks);
            }
            const customParametersByName = new Map();
            for (const [configParameter, parserParameter] of this.customParameters) {
                customParametersByName.set(configParameter.longName, parserParameter);
            }
            if (buildCacheConfiguration === null || buildCacheConfiguration === void 0 ? void 0 : buildCacheConfiguration.buildCacheEnabled) {
                terminal.writeVerboseLine(`Incremental strategy: cache restoration`);
                new CacheableOperationPlugin({
                    allowWarningsInSuccessfulBuild: !!this.rushConfiguration.experimentsConfiguration.configuration
                        .buildCacheWithAllowWarningsInSuccessfulBuild,
                    buildCacheConfiguration,
                    cobuildConfiguration,
                    terminal
                }).apply(this.hooks);
            }
            else if (!this._disableBuildCache) {
                terminal.writeVerboseLine(`Incremental strategy: output preservation`);
                // Explicitly disabling the build cache also disables legacy skip detection.
                new LegacySkipPlugin({
                    allowWarningsInSuccessfulBuild: this.rushConfiguration.experimentsConfiguration.configuration
                        .buildSkipWithAllowWarningsInSuccessfulBuild,
                    terminal,
                    changedProjectsOnly,
                    isIncrementalBuildAllowed: this._isIncrementalBuildAllowed
                }).apply(this.hooks);
            }
            else {
                terminal.writeVerboseLine(`Incremental strategy: none (full rebuild)`);
            }
            const showBuildPlan = (_j = (_h = this._cobuildPlanParameter) === null || _h === void 0 ? void 0 : _h.value) !== null && _j !== void 0 ? _j : false;
            if (showBuildPlan) {
                if (!(buildCacheConfiguration === null || buildCacheConfiguration === void 0 ? void 0 : buildCacheConfiguration.buildCacheEnabled)) {
                    throw new Error('You must have build cache enabled to use this option.');
                }
                const { BuildPlanPlugin } = await import('../../logic/operations/BuildPlanPlugin');
                new BuildPlanPlugin(terminal).apply(this.hooks);
            }
            const { configuration: experiments } = this.rushConfiguration.experimentsConfiguration;
            if (((_k = this.rushConfiguration) === null || _k === void 0 ? void 0 : _k.isPnpm) && (experiments === null || experiments === void 0 ? void 0 : experiments.usePnpmSyncForInjectedDependencies)) {
                const { PnpmSyncCopyOperationPlugin } = await import('../../logic/operations/PnpmSyncCopyOperationPlugin');
                new PnpmSyncCopyOperationPlugin(terminal).apply(this.hooks);
            }
            const relevantProjects = Selection.expandAllDependencies(projectSelection);
            const projectConfigurations = this
                ._runsBeforeInstall
                ? new Map()
                : await RushProjectConfiguration.tryLoadForProjectsAsync(relevantProjects, terminal);
            const initialCreateOperationsContext = {
                buildCacheConfiguration,
                cobuildConfiguration,
                customParameters: customParametersByName,
                isIncrementalBuildAllowed: this._isIncrementalBuildAllowed,
                isInitial: true,
                isWatch,
                rushConfiguration: this.rushConfiguration,
                phaseOriginal: new Set(this._originalPhases),
                phaseSelection: new Set(this._initialPhases),
                includePhaseDeps,
                projectSelection,
                projectConfigurations,
                projectsInUnknownState: projectSelection
            };
            const executionManagerOptions = {
                quietMode: isQuietMode,
                debugMode: this.parser.isDebug,
                parallelism,
                changedProjectsOnly,
                beforeExecuteOperationAsync: async (record) => {
                    return await this.hooks.beforeExecuteOperation.promise(record);
                },
                afterExecuteOperationAsync: async (record) => {
                    await this.hooks.afterExecuteOperation.promise(record);
                },
                createEnvironmentForOperation: this.hooks.createEnvironmentForOperation.isUsed()
                    ? (record) => {
                        return this.hooks.createEnvironmentForOperation.call(Object.assign({}, process.env), record);
                    }
                    : undefined,
                onOperationStatusChangedAsync: (record) => {
                    this.hooks.onOperationStatusChanged.call(record);
                }
            };
            const initialInternalOptions = {
                initialCreateOperationsContext,
                executionManagerOptions,
                stopwatch,
                terminal
            };
            const internalOptions = await this._runInitialPhasesAsync(initialInternalOptions);
            if (isWatch) {
                if (buildCacheConfiguration) {
                    // Cache writes are not supported during watch mode, only reads.
                    buildCacheConfiguration.cacheWriteEnabled = false;
                }
                await this._runWatchPhasesAsync(internalOptions);
            }
        }
        finally {
            await (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.destroyLockProviderAsync());
        }
    }
    async _runInitialPhasesAsync(options) {
        const { initialCreateOperationsContext, executionManagerOptions: partialExecutionManagerOptions, stopwatch, terminal } = options;
        const { projectConfigurations } = initialCreateOperationsContext;
        const { projectSelection } = initialCreateOperationsContext;
        const operations = await this.hooks.createOperations.promise(new Set(), initialCreateOperationsContext);
        terminal.write('Analyzing repo state... ');
        const repoStateStopwatch = new Stopwatch();
        repoStateStopwatch.start();
        const analyzer = new ProjectChangeAnalyzer(this.rushConfiguration);
        const getInputsSnapshotAsync = await analyzer._tryGetSnapshotProviderAsync(projectConfigurations, terminal, 
        // We need to include all dependencies, otherwise build cache id calculation will be incorrect
        Selection.expandAllDependencies(projectSelection));
        const initialSnapshot = await (getInputsSnapshotAsync === null || getInputsSnapshotAsync === void 0 ? void 0 : getInputsSnapshotAsync());
        repoStateStopwatch.stop();
        terminal.writeLine(`DONE (${repoStateStopwatch.toString()})`);
        terminal.writeLine();
        const initialExecuteOperationsContext = Object.assign(Object.assign({}, initialCreateOperationsContext), { inputsSnapshot: initialSnapshot });
        const executionManagerOptions = Object.assign(Object.assign({}, partialExecutionManagerOptions), { beforeExecuteOperationsAsync: async (records) => {
                await this.hooks.beforeExecuteOperations.promise(records, initialExecuteOperationsContext);
            } });
        const initialOptions = {
            executeOperationsContext: initialExecuteOperationsContext,
            ignoreHooks: false,
            operations,
            stopwatch,
            executionManagerOptions,
            terminal
        };
        await this._executeOperationsAsync(initialOptions);
        return Object.assign(Object.assign({}, options), { executionManagerOptions,
            getInputsSnapshotAsync,
            initialSnapshot });
    }
    _registerWatchModeInterface(projectWatcher) {
        const toggleWatcherKey = 'w';
        const buildOnceKey = 'b';
        const invalidateKey = 'i';
        const shutdownKey = 'x';
        const terminal = this._terminal;
        projectWatcher.setPromptGenerator((isPaused) => {
            var _a;
            const promptLines = [
                `  Press <${toggleWatcherKey}> to ${isPaused ? 'resume' : 'pause'}.`,
                `  Press <${invalidateKey}> to invalidate all projects.`
            ];
            if (isPaused) {
                promptLines.push(`  Press <${buildOnceKey}> to build once.`);
            }
            if (((_a = this._noIPCParameter) === null || _a === void 0 ? void 0 : _a.value) === false) {
                promptLines.push(`  Press <${shutdownKey}> to reset child processes.`);
            }
            return promptLines;
        });
        process.stdin.setRawMode(true);
        process.stdin.resume();
        process.stdin.setEncoding('utf8');
        process.stdin.on('data', (key) => {
            switch (key) {
                case toggleWatcherKey:
                    if (projectWatcher.isPaused) {
                        projectWatcher.resume();
                    }
                    else {
                        projectWatcher.pause();
                    }
                    break;
                case buildOnceKey:
                    if (projectWatcher.isPaused) {
                        projectWatcher.clearStatus();
                        terminal.writeLine(`Building once...`);
                        projectWatcher.resume();
                        projectWatcher.pause();
                    }
                    break;
                case invalidateKey:
                    projectWatcher.clearStatus();
                    terminal.writeLine(`Invalidating all operations...`);
                    projectWatcher.invalidateAll('manual trigger');
                    if (!projectWatcher.isPaused) {
                        projectWatcher.resume();
                    }
                    break;
                case shutdownKey:
                    projectWatcher.clearStatus();
                    terminal.writeLine(`Shutting down long-lived child processes...`);
                    // TODO: Inject this promise into the execution queue somewhere so that it gets waited on between runs
                    void this.hooks.shutdownAsync.promise();
                    break;
                case '\u0003':
                    process.kill(process.pid, 'SIGINT');
                    break;
            }
        });
    }
    /**
     * Runs the command in watch mode. Fundamentally is a simple loop:
     * 1) Wait for a change to one or more projects in the selection
     * 2) Invoke the command on the changed projects, and, if applicable, impacted projects
     *    Uses the same algorithm as --impacted-by
     * 3) Goto (1)
     */
    async _runWatchPhasesAsync(options) {
        const { getInputsSnapshotAsync, initialSnapshot, initialCreateOperationsContext, executionManagerOptions, stopwatch, terminal } = options;
        const phaseOriginal = new Set(this._watchPhases);
        const phaseSelection = new Set(this._watchPhases);
        const { projectSelection: projectsToWatch } = initialCreateOperationsContext;
        if (!getInputsSnapshotAsync || !initialSnapshot) {
            terminal.writeErrorLine(`Cannot watch for changes if the Rush repo is not in a Git repository, exiting.`);
            throw new AlreadyReportedError();
        }
        // Use async import so that we don't pay the cost for sync builds
        const { ProjectWatcher } = await import(
        /* webpackChunkName: 'ProjectWatcher' */
        '../../logic/ProjectWatcher');
        const projectWatcher = new ProjectWatcher({
            getInputsSnapshotAsync,
            initialSnapshot,
            debounceMs: this._watchDebounceMs,
            rushConfiguration: this.rushConfiguration,
            projectsToWatch,
            terminal
        });
        // Ensure process.stdin allows interactivity before using TTY-only APIs
        if (process.stdin.isTTY) {
            this._registerWatchModeInterface(projectWatcher);
        }
        const onWaitingForChanges = () => {
            // Allow plugins to display their own messages when waiting for changes.
            this.hooks.waitingForChanges.call();
            // Report so that the developer can always see that it is in watch mode as the latest console line.
            terminal.writeLine(`Watching for changes to ${projectsToWatch.size} ${projectsToWatch.size === 1 ? 'project' : 'projects'}. Press Ctrl+C to exit.`);
        };
        function invalidateOperation(operation, reason) {
            const { associatedProject } = operation;
            if (associatedProject) {
                // Since ProjectWatcher only tracks entire projects, widen the operation to its project
                // Revisit when migrating to @rushstack/operation-graph and we have a long-lived operation graph
                projectWatcher.invalidateProject(associatedProject, `${operation.name} (${reason})`);
            }
        }
        // Loop until Ctrl+C
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // On the initial invocation, this promise will return immediately with the full set of projects
            const { changedProjects, inputsSnapshot: state } = await projectWatcher.waitForChangeAsync(onWaitingForChanges);
            if (stopwatch.state === StopwatchState.Stopped) {
                // Clear and reset the stopwatch so that we only report time from a single execution at a time
                stopwatch.reset();
                stopwatch.start();
            }
            terminal.writeLine(`Detected changes in ${changedProjects.size} project${changedProjects.size === 1 ? '' : 's'}:`);
            const names = [...changedProjects].map((x) => x.packageName).sort();
            for (const name of names) {
                terminal.writeLine(`    ${Colorize.cyan(name)}`);
            }
            // Account for consumer relationships
            const executeOperationsContext = Object.assign(Object.assign({}, initialCreateOperationsContext), { isInitial: false, inputsSnapshot: state, projectsInUnknownState: changedProjects, phaseOriginal,
                phaseSelection,
                invalidateOperation });
            const operations = await this.hooks.createOperations.promise(new Set(), executeOperationsContext);
            const executeOptions = {
                executeOperationsContext,
                // For now, don't run pre-build or post-build in watch mode
                ignoreHooks: true,
                operations,
                stopwatch,
                executionManagerOptions: Object.assign(Object.assign({}, executionManagerOptions), { beforeExecuteOperationsAsync: async (records) => {
                        await this.hooks.beforeExecuteOperations.promise(records, executeOperationsContext);
                    } }),
                terminal
            };
            try {
                // Delegate the the underlying command, for only the projects that need reprocessing
                await this._executeOperationsAsync(executeOptions);
            }
            catch (err) {
                // In watch mode, we want to rebuild even if the original build failed.
                if (!(err instanceof AlreadyReportedError)) {
                    throw err;
                }
            }
        }
    }
    /**
     * Runs a set of operations and reports the results.
     */
    async _executeOperationsAsync(options) {
        const { executionManagerOptions, ignoreHooks, operations, stopwatch, terminal } = options;
        const executionManager = new OperationExecutionManager(operations, executionManagerOptions);
        const { isInitial, isWatch, cobuildConfiguration } = options.executeOperationsContext;
        let success = false;
        let result;
        try {
            result = await executionManager.executeAsync();
            success = result.status === OperationStatus.Success;
            await this.hooks.afterExecuteOperations.promise(result, options.executeOperationsContext);
            stopwatch.stop();
            const message = `rush ${this.actionName} (${stopwatch.toString()})`;
            if (result.status === OperationStatus.Success) {
                terminal.writeLine(Colorize.green(message));
            }
            else {
                terminal.writeLine(message);
            }
        }
        catch (error) {
            success = false;
            stopwatch.stop();
            if (error instanceof AlreadyReportedError) {
                terminal.writeLine(`rush ${this.actionName} (${stopwatch.toString()})`);
            }
            else {
                if (error && error.message) {
                    if (this.parser.isDebug) {
                        terminal.writeErrorLine('Error: ' + error.stack);
                    }
                    else {
                        terminal.writeErrorLine('Error: ' + error.message);
                    }
                }
                terminal.writeErrorLine(Colorize.red(`rush ${this.actionName} - Errors! (${stopwatch.toString()})`));
            }
        }
        if (!ignoreHooks) {
            this._doAfterTask();
        }
        if (this.parser.telemetry) {
            const jsonOperationResults = {};
            const extraData = Object.assign(Object.assign(Object.assign({}, this._selectionParameters.getTelemetry()), this.getParameterStringMap()), { isWatch,
                // Fields specific to the current operation set
                isInitial, countAll: 0, countSuccess: 0, countSuccessWithWarnings: 0, countFailure: 0, countBlocked: 0, countFromCache: 0, countSkipped: 0, countNoOp: 0 });
            if (result) {
                const { operationResults } = result;
                const nonSilentDependenciesByOperation = new Map();
                function getNonSilentDependencies(operation) {
                    let realDependencies = nonSilentDependenciesByOperation.get(operation);
                    if (!realDependencies) {
                        realDependencies = new Set();
                        nonSilentDependenciesByOperation.set(operation, realDependencies);
                        for (const dependency of operation.dependencies) {
                            const dependencyRecord = operationResults.get(dependency);
                            if (dependencyRecord === null || dependencyRecord === void 0 ? void 0 : dependencyRecord.silent) {
                                for (const deepDependency of getNonSilentDependencies(dependency)) {
                                    realDependencies.add(deepDependency);
                                }
                            }
                            else {
                                realDependencies.add(dependency.name);
                            }
                        }
                    }
                    return realDependencies;
                }
                for (const [operation, operationResult] of operationResults) {
                    if (operationResult.silent) {
                        // Architectural operation. Ignore.
                        continue;
                    }
                    const { startTime, endTime } = operationResult.stopwatch;
                    jsonOperationResults[operation.name] = {
                        startTimestampMs: startTime,
                        endTimestampMs: endTime,
                        nonCachedDurationMs: operationResult.nonCachedDurationMs,
                        wasExecutedOnThisMachine: !operationResult.cobuildRunnerId ||
                            operationResult.cobuildRunnerId === (cobuildConfiguration === null || cobuildConfiguration === void 0 ? void 0 : cobuildConfiguration.cobuildRunnerId),
                        result: operationResult.status,
                        dependencies: Array.from(getNonSilentDependencies(operation)).sort()
                    };
                    extraData.countAll++;
                    switch (operationResult.status) {
                        case OperationStatus.Success:
                            extraData.countSuccess++;
                            break;
                        case OperationStatus.SuccessWithWarning:
                            extraData.countSuccessWithWarnings++;
                            break;
                        case OperationStatus.Failure:
                            extraData.countFailure++;
                            break;
                        case OperationStatus.Blocked:
                            extraData.countBlocked++;
                            break;
                        case OperationStatus.FromCache:
                            extraData.countFromCache++;
                            break;
                        case OperationStatus.Skipped:
                            extraData.countSkipped++;
                            break;
                        case OperationStatus.NoOp:
                            extraData.countNoOp++;
                            break;
                        default:
                            // Do nothing.
                            break;
                    }
                }
            }
            const logEntry = {
                name: this.actionName,
                durationInSeconds: stopwatch.duration,
                result: success ? 'Succeeded' : 'Failed',
                extraData,
                operationResults: jsonOperationResults
            };
            this.hooks.beforeLog.call(logEntry);
            this.parser.telemetry.log(logEntry);
            this.parser.flushTelemetry();
        }
        if (!success && !isWatch) {
            throw new AlreadyReportedError();
        }
    }
    _doBeforeTask() {
        if (this.actionName !== RushConstants.buildCommandName &&
            this.actionName !== RushConstants.rebuildCommandName) {
            // Only collects information for built-in commands like build or rebuild.
            return;
        }
        SetupChecks.validate(this.rushConfiguration);
        this.eventHooksManager.handle(Event.preRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);
    }
    _doAfterTask() {
        if (this.actionName !== RushConstants.buildCommandName &&
            this.actionName !== RushConstants.rebuildCommandName) {
            // Only collects information for built-in commands like build or rebuild.
            return;
        }
        this.eventHooksManager.handle(Event.postRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);
    }
}
//# sourceMappingURL=PhasedScriptAction.js.map