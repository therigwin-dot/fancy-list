"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SPBuildRig: function() {
        return SPBuildRig;
    },
    postCopy: function() {
        return postCopy;
    },
    preCopy: function() {
        return preCopy;
    }
});
const _fs = /*#__PURE__*/ _interop_require_wildcard(require("fs"));
const _yargs = /*#__PURE__*/ _interop_require_wildcard(require("yargs"));
const _semver = /*#__PURE__*/ _interop_require_wildcard(require("semver"));
const _gulpcorebuild = /*#__PURE__*/ _interop_require_wildcard(require("@microsoft/gulp-core-build"));
const _gulpcorebuildtypescript = require("@microsoft/gulp-core-build-typescript");
const _BuildRigConstants = require("./BuildRigConstants");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const preCopy = new _gulpcorebuild.CopyTask();
const postCopy = new _gulpcorebuild.CopyTask();
class SPBuildRig {
    initialize(gulp) {
        if (!_semver.satisfies(process.version, this.nodeSupportedVersionRange)) {
            const nodeVersionMessage = `Your dev environment is running NodeJS version ${process.version} which does` + ' not meet the requirements for running this tool. This tool requires a version of NodeJS' + ` that matches "${this.nodeSupportedVersionRange}".`;
            if (process.env.SPFX_OVERRIDE_NODE_VERSION_CHECK === 'true') {
                // This environment variable is when testing new versions of NodeJS for compatibility.
                // eslint-disable-next-line no-console
                console.warn(nodeVersionMessage + ' Proceeding with execution due to override.');
            } else {
                throw new Error(nodeVersionMessage);
            }
        }
        // Initialize yargs & figure out which command we are running
        const yargsArgs = this.getYargs();
        const command = yargsArgs.argv._[0];
        this.args = yargsArgs.argv;
        // Collect the tasks which need to be registered
        const tasks = this.getTasks();
        // Reset the args and reconfigure based on the selected command
        yargsArgs.reset();
        if (tasks.has(command)) {
            const task = tasks.get(command);
            if (task && task.arguments) {
                task.arguments(yargsArgs);
            }
        }
        // Note this overrides the getters for ship and production on args
        this.args.ship = this.args.production = this.args.production || this.args.ship;
        // Since gulp-core-build doesn't recognize the --ship flag, ensure it gets the right state
        _gulpcorebuild.mergeConfig({
            production: this.args.ship,
            shouldWarningsFailBuild: this.args.ship
        });
        // Register all the tasks with gulp-core-build
        tasks.forEach((definition, name)=>{
            _gulpcorebuild.task(name, definition.executable);
        });
        // If they are just looking for the task list, save time by not reading config files
        if (!this.args.tasks) {
            // Configure tasks for a normal build
            // eslint-disable-next-line no-console
            console.log('Build target: ' + (this.args.ship ? _BuildRigConstants.BuildRigConstants.flavors.ship.toUpperCase() : _BuildRigConstants.BuildRigConstants.flavors.debug.toUpperCase()));
            this.setupSharedConfig();
        }
        _gulpcorebuild.initialize(gulp);
        // Try to ensure the casing of the rootPath is correct
        try {
            const originalRootPath = _gulpcorebuild.getConfig().rootPath;
            const normalizedRootPath = _fs.realpathSync.native(originalRootPath);
            if (normalizedRootPath !== originalRootPath) {
                _gulpcorebuild.mergeConfig({
                    rootPath: normalizedRootPath
                });
                // eslint-disable-next-line no-console
                console.log(`Normalized project rootPath from "${originalRootPath}" to ${normalizedRootPath}`);
            }
        } catch (e) {
            // eslint-disable-next-line no-console
            console.error(`An error occurred when normalizing the project root path: ${e}`);
        }
        // If they are just looking for the task list, save time by not reading config files
        if (!this.args.tasks) {
            this.finalizeSharedConfig();
        }
    }
    /**
   * Register additional telemetry sub-tasks to run at the end of the sequence
   */ addPostTelemetryTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postTelemetryTask);
    }
    /**
   * Register additional telemetry sub-tasks to run at the beginning of the sequence
   */ addPreTelemetryTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._preTelemetryTask);
    }
    /**
   * Register additional sub-tasks to run before the typescript subtask.
   * Note, this is meant to be used in a gulpfile.js to inject one-off subtasks
   */ addPreBuildTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._preBuildTasks);
    }
    /**
   * Register additional sub-tasks to run after the typescript subtask.
   * Note, this is meant to be used in a gulpfile.js to inject one-off subtasks
   */ addPostTypescriptTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postTypescriptTasks);
    }
    /**
   * Register additional sub-tasks to run after the typescript subtask.
   * @deprecated - Use {@link addPostTypescriptTask} instead
   */ addBuildTasks(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postTypescriptTasks);
    }
    /**
   * Register additional sub-tasks to run after the entire build.
   * Note, this is meant to be used in a gulpfile.js to inject one-off subtasks
   */ addPostBuildTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postBuildTasks);
    }
    /**
   * Override this function to register more top-level command line arguments (i.e. not task-specific).
   * Ideally, extend the ICoreBuildArgs when hooking into this function
   *
   * Registers the command line arguments which are available for this rig
   */ getYargs() {
        return _yargs.usage().option('production', {
            alias: 'p',
            describe: 'build in ship mode with full localization and minimization',
            boolean: true
        }).option('ship', {
            alias: 'p',
            describe: 'build in ship mode with full localization and minimization',
            boolean: true
        }).option('verbose', {
            describe: 'run the build with verbose logging'
        }).option('tasks', {
            alias: [
                'T',
                'tasks-simple'
            ],
            describe: 'shows the list of tasks which can be run'
        }).help('h').global([
            'production',
            'verbose',
            'h'
        ]).option('locale', {
            describe: 'override the default culture (e.g. "fr-fr")',
            type: 'string'
        }).option('lite', {
            alias: 'l',
            describe: 'Speeds up the build by running the minimal set of tasks required to produce an executable output',
            type: 'boolean'
        }).command(_BuildRigConstants.BuildRigConstants.tasks.build, 'build the project').command(_BuildRigConstants.BuildRigConstants.tasks.default, 'equivalent to bundle');
    }
    /**
   * Override this function to create new top-level tasks which can be executed via the command line
   *
   * Register 2 tasks, build and default, which simply copy files, then run typescript and tslint
   */ getTasks() {
        const result = new Map();
        result.set(_BuildRigConstants.BuildRigConstants.tasks.build, {
            executable: this.getBuildTask()
        });
        result.set(_BuildRigConstants.BuildRigConstants.tasks.default, {
            executable: this.getBuildTask()
        });
        return result;
    }
    /**
   * Override this function to overwrite the "build" task
   */ getBuildTask() {
        return _gulpcorebuild.serial(preCopy, _gulpcorebuild.serial(this._preBuildTasks), this.getCoreBuildTask(), _gulpcorebuild.serial(this._postBuildTasks), postCopy);
    }
    /**
   * Override this function to redefine the core build loop
   */ getCoreBuildTask() {
        return _gulpcorebuild.parallel(_gulpcorebuildtypescript.lintCmd, _gulpcorebuild.serial(_gulpcorebuild.serial(_gulpcorebuildtypescript.tscCmd, _gulpcorebuildtypescript.apiExtractor), _gulpcorebuild.serial(...this._postTypescriptTasks)));
    }
    /**
   * Override this function to do configuration before the configuration .json files have been loaded
   */ setupSharedConfig() {
        preCopy.name = 'pre-copy';
        postCopy.name = 'post-copy';
        // adding release folder to the list of folders to be removed during the clean task run
        _gulpcorebuild.clean.getCleanMatch = ()=>[
                'release'
            ];
    }
    /**
   * Override this function to do configuration after the configuration .json files have been loaded
   *
   * This function cleans up the shared config by populating task config properties that depend on other tasks'
   *  user-defined properties.
   */ finalizeSharedConfig() {
        if (this.args.lite) {
            this._disableTasks(_gulpcorebuildtypescript.lintCmd);
        }
    }
    addTaskOrListOfTasks(tasks, array) {
        if (tasks.length) {
            array.push(...tasks);
        } else {
            array.push(tasks);
        }
    }
    _disableTasks(...tasks) {
        tasks.forEach((task)=>{
            task.isEnabled = ()=>false;
            _gulpcorebuild.verbose(`Disabling task: ${task.name}`);
        });
    }
    constructor(){
        _define_property(this, "_preBuildTasks", []);
        _define_property(this, "_postTypescriptTasks", []);
        _define_property(this, "_postBuildTasks", []);
        _define_property(this, "_postTelemetryTask", []);
        _define_property(this, "_preTelemetryTask", []);
        _define_property(this, "args", void 0);
        _define_property(this, "nodeSupportedVersionRange", '>=18.17.1 <19.0.0 || >=20.11.0 <21.0.0 || >=22.14.0 <23.0.0');
    }
}

//#sourceMappingUrl=./SPBuildRig.js.map