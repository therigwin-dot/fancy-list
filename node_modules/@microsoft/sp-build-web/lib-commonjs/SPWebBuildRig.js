"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SPWebBuildRig: function() {
        return SPWebBuildRig;
    },
    serveWatchFilter: function() {
        return serveWatchFilter;
    }
});
const _gulpcorebuildsass = /*#__PURE__*/ _interop_require_default(require("@microsoft/gulp-core-build-sass"));
const _gulpcorebuildserve = require("@microsoft/gulp-core-build-serve");
const _gulpcorebuild = require("@microsoft/gulp-core-build");
const _gulpcorebuildwebpack = require("@microsoft/gulp-core-build-webpack");
const _spbuildcoretasks = /*#__PURE__*/ _interop_require_wildcard(require("@microsoft/sp-build-core-tasks"));
const _ConfigureWebpackTask = require("@microsoft/sp-build-core-tasks/lib/webpack/ConfigureWebpackTask");
const _gulpcorebuildtypescript = require("@microsoft/gulp-core-build-typescript");
const _WebBuildRigConstants = require("./WebBuildRigConstants");
const _SPBuildRig = require("./SPBuildRig");
const _BuildRigConstants = require("./BuildRigConstants");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const serveWatchFilter = [
    'src/**/*.{ts,tsx,scss,resx,js,json,html}',
    '!src/**/*.{scss.ts,resx.ts}',
    'node_modules/*/*/dist/*.manifest.json'
];
class SPWebBuildRig extends _SPBuildRig.SPBuildRig {
    addPostBundleTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postBundleTasks);
    }
    getYargs() {
        return super.getYargs().option('debug', {
            describe: 'runs tests in unit mode'
        }).option('upgrade', {
            describe: 'upgrades outdated files in the project'
        }).command(_WebBuildRigConstants.WebBuildRigConstants.tasks.bundle, 'build, localize, and bundle the project').command(_WebBuildRigConstants.WebBuildRigConstants.tasks.deployAzureStorage, 'upload the assets to a development CDN').command(_WebBuildRigConstants.WebBuildRigConstants.tasks.packageSolution, 'package the project into a SPPKG').command(_WebBuildRigConstants.WebBuildRigConstants.tasks.test, 'build, localize, and bundle the project and run tests, and verify the coverage').command(_WebBuildRigConstants.WebBuildRigConstants.tasks.testOnly, 'run the tests without running the build').command(_WebBuildRigConstants.WebBuildRigConstants.tasks.serve, 'build and bundle the project and run the development server').command(_WebBuildRigConstants.WebBuildRigConstants.tasks.trustDevCert, "generates and trusts a development certificate if one isn't already present").command(_WebBuildRigConstants.WebBuildRigConstants.tasks.untrustDevCert, 'untrusts and deletes the development certificate if it exists').command('default', 'equivalent to bundle and test').option('entry', {
            describe: 'Select which entries should be bundled. This can match the GUID or the alias of the entry.',
            string: true
        });
    }
    setupSharedConfig() {
        super.setupSharedConfig();
        _gulpcorebuildwebpack.webpack.taskConfig.webpack = require('webpack');
        _gulpcorebuildsass.default.mergeConfig({
            preamble: '',
            postamble: '',
            sassMatch: [
                'src/**/*.scss',
                'src/**/*.sass'
            ],
            useCSSModules: false,
            warnOnCssInvalidPropertyName: true,
            dropCssFiles: true,
            warnOnNonCSSModules: true,
            // Cast is needed due to autoprefixer types mismatch due to workspace install in odsp-web
            autoprefixerOptions: {
                overrideBrowserslist: [
                    '> 1%',
                    'ie >= 11'
                ]
            }
        });
        _spbuildcoretasks.configureWebpack.mergeConfig({
            webpack: _gulpcorebuildwebpack.webpack,
            singleLocale: this.args.locale,
            useLegacyExternals: true
        });
        _gulpcorebuild.copyStaticAssets.setConfig({
            includeExtensions: [
                ..._ConfigureWebpackTask.FILE_LOADER_EXTENSIONS,
                'resx'
            ]
        });
        _gulpcorebuildtypescript.tscCmd.mergeConfig({
            allowBuiltinCompiler: true
        });
        _gulpcorebuildtypescript.lintCmd.mergeConfig({
            allowBuiltinCompiler: true
        });
        _gulpcorebuildtypescript.apiExtractor.mergeConfig({
            allowBuiltinCompiler: true
        });
        _gulpcorebuild.jest.mergeConfig({
            writeNUnitResults: this.args.writeNUnitResults
        });
    }
    finalizeSharedConfig() {
        super.finalizeSharedConfig();
        if (this.args.lite || this.args.notest) {
            this._disableTasks(_gulpcorebuild.jest);
        }
    }
    getTasks() {
        const result = super.getTasks();
        result.set(_BuildRigConstants.BuildRigConstants.tasks.build, {
            executable: this.getBuildTask()
        });
        result.set(_WebBuildRigConstants.WebBuildRigConstants.tasks.bundle, {
            executable: this.getBundleTask()
        });
        result.set(_WebBuildRigConstants.WebBuildRigConstants.tasks.deployAzureStorage, {
            executable: _spbuildcoretasks.deployAzureStorage
        });
        result.set(_WebBuildRigConstants.WebBuildRigConstants.tasks.packageSolution, {
            executable: _spbuildcoretasks.packageSolution
        });
        // @todo VSO #167343
        result.set(_WebBuildRigConstants.WebBuildRigConstants.tasks.test, {
            executable: this.getTestTask(),
            arguments: (yargs)=>{
                return yargs.option('debug', {
                    describe: 'run tests in debug mode'
                }).option('match', {
                    describe: 'regular expression. Only run tests that match',
                    string: true
                }).option('notest', {
                    describe: 'run the build without running the test'
                });
            }
        });
        result.set(_WebBuildRigConstants.WebBuildRigConstants.tasks.serve, {
            executable: (0, _gulpcorebuild.serial)(_spbuildcoretasks.serve, (0, _gulpcorebuild.watch)(serveWatchFilter, (0, _gulpcorebuild.serial)(this._preTelemetryTask, // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            result.get(_WebBuildRigConstants.WebBuildRigConstants.tasks.bundle).executable, _gulpcorebuildserve.reload, this._postTelemetryTask))),
            arguments: (yargs)=>{
                return yargs.option('port', {
                    description: 'the port to serve on should be the next argument (e.g. "--port 80")'
                }).option('nobrowser', {
                    description: "don't open a browser after initial bundle"
                }).option('config', {
                    description: 'use this option to specify which configuration to use in the serve.json file'
                });
            }
        });
        result.set(_WebBuildRigConstants.WebBuildRigConstants.tasks.trustDevCert, {
            executable: _gulpcorebuildserve.trustDevCert
        });
        result.set(_WebBuildRigConstants.WebBuildRigConstants.tasks.untrustDevCert, {
            executable: _gulpcorebuildserve.untrustDevCert
        });
        result.set(_WebBuildRigConstants.WebBuildRigConstants.tasks.testOnly, {
            executable: this.getTestOnlyTask(),
            arguments: (yargs)=>{
                return yargs.option('writeNUnitResults', {
                    description: 'write the jest results to an nunit test results file',
                    boolean: true
                });
            }
        });
        result.forEach((taskDefinition, name)=>{
            result.set(name, {
                executable: (0, _gulpcorebuild.serial)((0, _gulpcorebuild.serial)(this._preTelemetryTask), taskDefinition.executable, (0, _gulpcorebuild.serial)(this._postTelemetryTask)),
                arguments: taskDefinition.arguments
            });
        });
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        result.set(_BuildRigConstants.BuildRigConstants.tasks.default, result.get(_WebBuildRigConstants.WebBuildRigConstants.tasks.bundle));
        return result;
    }
    getTestTask() {
        return (0, _gulpcorebuild.serial)(this.getBundleTask(), _gulpcorebuild.jest);
    }
    getTestOnlyTask() {
        return (0, _gulpcorebuild.serial)(_gulpcorebuild.jest);
    }
    getCoreBuildTask() {
        return (0, _gulpcorebuild.parallel)((0, _gulpcorebuild.serial)(_gulpcorebuildsass.default, super.getCoreBuildTask()), _gulpcorebuild.copyStaticAssets);
    }
    getBundleTask() {
        return (0, _gulpcorebuild.serial)(this.getBuildTask(), this.getPreWebpackTasks(), _spbuildcoretasks.configureWebpack, _gulpcorebuildwebpack.webpack, this.getPreCopyAssetsTasks(), (0, _gulpcorebuild.parallel)(this._postBundleTasks));
    }
    getPreWebpackTasks() {
        return (0, _gulpcorebuild.serial)();
    }
    getPreCopyAssetsTasks() {
        return (0, _gulpcorebuild.serial)();
    }
    constructor(...args){
        super(...args);
        _define_property(this, "args", void 0);
        _define_property(this, "_postBundleTasks", []);
    }
}

//#sourceMappingUrl=./SPWebBuildRig.js.map