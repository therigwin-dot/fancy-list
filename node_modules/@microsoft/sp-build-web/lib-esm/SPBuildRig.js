function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import * as fs from 'fs';
import * as yargs from 'yargs';
import * as semver from 'semver';
import * as coreBuild from '@microsoft/gulp-core-build';
import { tscCmd, lintCmd, apiExtractor } from '@microsoft/gulp-core-build-typescript';
import { BuildRigConstants } from './BuildRigConstants';
export const preCopy = new coreBuild.CopyTask();
export const postCopy = new coreBuild.CopyTask();
/**
 * This class represents the basic shared build rig for all SPFx Rigs. It defines a few
 * simple sub-tasks, and only registers a "build" task.
 */ export class SPBuildRig {
    initialize(gulp) {
        if (!semver.satisfies(process.version, this.nodeSupportedVersionRange)) {
            const nodeVersionMessage = `Your dev environment is running NodeJS version ${process.version} which does` + ' not meet the requirements for running this tool. This tool requires a version of NodeJS' + ` that matches "${this.nodeSupportedVersionRange}".`;
            if (process.env.SPFX_OVERRIDE_NODE_VERSION_CHECK === 'true') {
                // This environment variable is when testing new versions of NodeJS for compatibility.
                // eslint-disable-next-line no-console
                console.warn(nodeVersionMessage + ' Proceeding with execution due to override.');
            } else {
                throw new Error(nodeVersionMessage);
            }
        }
        // Initialize yargs & figure out which command we are running
        const yargsArgs = this.getYargs();
        const command = yargsArgs.argv._[0];
        this.args = yargsArgs.argv;
        // Collect the tasks which need to be registered
        const tasks = this.getTasks();
        // Reset the args and reconfigure based on the selected command
        yargsArgs.reset();
        if (tasks.has(command)) {
            const task = tasks.get(command);
            if (task && task.arguments) {
                task.arguments(yargsArgs);
            }
        }
        // Note this overrides the getters for ship and production on args
        this.args.ship = this.args.production = this.args.production || this.args.ship;
        // Since gulp-core-build doesn't recognize the --ship flag, ensure it gets the right state
        coreBuild.mergeConfig({
            production: this.args.ship,
            shouldWarningsFailBuild: this.args.ship
        });
        // Register all the tasks with gulp-core-build
        tasks.forEach((definition, name)=>{
            coreBuild.task(name, definition.executable);
        });
        // If they are just looking for the task list, save time by not reading config files
        if (!this.args.tasks) {
            // Configure tasks for a normal build
            // eslint-disable-next-line no-console
            console.log('Build target: ' + (this.args.ship ? BuildRigConstants.flavors.ship.toUpperCase() : BuildRigConstants.flavors.debug.toUpperCase()));
            this.setupSharedConfig();
        }
        coreBuild.initialize(gulp);
        // Try to ensure the casing of the rootPath is correct
        try {
            const originalRootPath = coreBuild.getConfig().rootPath;
            const normalizedRootPath = fs.realpathSync.native(originalRootPath);
            if (normalizedRootPath !== originalRootPath) {
                coreBuild.mergeConfig({
                    rootPath: normalizedRootPath
                });
                // eslint-disable-next-line no-console
                console.log(`Normalized project rootPath from "${originalRootPath}" to ${normalizedRootPath}`);
            }
        } catch (e) {
            // eslint-disable-next-line no-console
            console.error(`An error occurred when normalizing the project root path: ${e}`);
        }
        // If they are just looking for the task list, save time by not reading config files
        if (!this.args.tasks) {
            this.finalizeSharedConfig();
        }
    }
    /**
   * Register additional telemetry sub-tasks to run at the end of the sequence
   */ addPostTelemetryTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postTelemetryTask);
    }
    /**
   * Register additional telemetry sub-tasks to run at the beginning of the sequence
   */ addPreTelemetryTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._preTelemetryTask);
    }
    /**
   * Register additional sub-tasks to run before the typescript subtask.
   * Note, this is meant to be used in a gulpfile.js to inject one-off subtasks
   */ addPreBuildTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._preBuildTasks);
    }
    /**
   * Register additional sub-tasks to run after the typescript subtask.
   * Note, this is meant to be used in a gulpfile.js to inject one-off subtasks
   */ addPostTypescriptTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postTypescriptTasks);
    }
    /**
   * Register additional sub-tasks to run after the typescript subtask.
   * @deprecated - Use {@link addPostTypescriptTask} instead
   */ addBuildTasks(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postTypescriptTasks);
    }
    /**
   * Register additional sub-tasks to run after the entire build.
   * Note, this is meant to be used in a gulpfile.js to inject one-off subtasks
   */ addPostBuildTask(tasks) {
        this.addTaskOrListOfTasks(tasks, this._postBuildTasks);
    }
    /**
   * Override this function to register more top-level command line arguments (i.e. not task-specific).
   * Ideally, extend the ICoreBuildArgs when hooking into this function
   *
   * Registers the command line arguments which are available for this rig
   */ getYargs() {
        return yargs.usage().option('production', {
            alias: 'p',
            describe: 'build in ship mode with full localization and minimization',
            boolean: true
        }).option('ship', {
            alias: 'p',
            describe: 'build in ship mode with full localization and minimization',
            boolean: true
        }).option('verbose', {
            describe: 'run the build with verbose logging'
        }).option('tasks', {
            alias: [
                'T',
                'tasks-simple'
            ],
            describe: 'shows the list of tasks which can be run'
        }).help('h').global([
            'production',
            'verbose',
            'h'
        ]).option('locale', {
            describe: 'override the default culture (e.g. "fr-fr")',
            type: 'string'
        }).option('lite', {
            alias: 'l',
            describe: 'Speeds up the build by running the minimal set of tasks required to produce an executable output',
            type: 'boolean'
        }).command(BuildRigConstants.tasks.build, 'build the project').command(BuildRigConstants.tasks.default, 'equivalent to bundle');
    }
    /**
   * Override this function to create new top-level tasks which can be executed via the command line
   *
   * Register 2 tasks, build and default, which simply copy files, then run typescript and tslint
   */ getTasks() {
        const result = new Map();
        result.set(BuildRigConstants.tasks.build, {
            executable: this.getBuildTask()
        });
        result.set(BuildRigConstants.tasks.default, {
            executable: this.getBuildTask()
        });
        return result;
    }
    /**
   * Override this function to overwrite the "build" task
   */ getBuildTask() {
        return coreBuild.serial(preCopy, coreBuild.serial(this._preBuildTasks), this.getCoreBuildTask(), coreBuild.serial(this._postBuildTasks), postCopy);
    }
    /**
   * Override this function to redefine the core build loop
   */ getCoreBuildTask() {
        return coreBuild.parallel(lintCmd, coreBuild.serial(coreBuild.serial(tscCmd, apiExtractor), coreBuild.serial(...this._postTypescriptTasks)));
    }
    /**
   * Override this function to do configuration before the configuration .json files have been loaded
   */ setupSharedConfig() {
        preCopy.name = 'pre-copy';
        postCopy.name = 'post-copy';
        // adding release folder to the list of folders to be removed during the clean task run
        coreBuild.clean.getCleanMatch = ()=>[
                'release'
            ];
    }
    /**
   * Override this function to do configuration after the configuration .json files have been loaded
   *
   * This function cleans up the shared config by populating task config properties that depend on other tasks'
   *  user-defined properties.
   */ finalizeSharedConfig() {
        if (this.args.lite) {
            this._disableTasks(lintCmd);
        }
    }
    addTaskOrListOfTasks(tasks, array) {
        if (tasks.length) {
            array.push(...tasks);
        } else {
            array.push(tasks);
        }
    }
    _disableTasks(...tasks) {
        tasks.forEach((task)=>{
            task.isEnabled = ()=>false;
            coreBuild.verbose(`Disabling task: ${task.name}`);
        });
    }
    constructor(){
        _define_property(this, "_preBuildTasks", []);
        _define_property(this, "_postTypescriptTasks", []);
        _define_property(this, "_postBuildTasks", []);
        _define_property(this, "_postTelemetryTask", []);
        _define_property(this, "_preTelemetryTask", []);
        _define_property(this, "args", void 0);
        _define_property(this, "nodeSupportedVersionRange", '>=18.17.1 <19.0.0 || >=20.11.0 <21.0.0 || >=22.14.0 <23.0.0');
    }
}

//#sourceMappingUrl=./SPBuildRig.js.map