"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebpackTask = void 0;
const colors = require("colors");
const gulp_core_build_1 = require("@microsoft/gulp-core-build");
const os_1 = require("os");
function normalizeWebpackError(error) {
    if (typeof error === 'string') {
        return error;
    }
    else {
        const { loc, moduleName, moduleIdentifier } = error;
        const modulePath = moduleName !== null && moduleName !== void 0 ? moduleName : moduleIdentifier;
        if (modulePath) {
            if (loc) {
                return `${modulePath}:${loc}: ${error.message}`;
            }
            else {
                return `${modulePath}: ${error.message}`;
            }
        }
        else {
            return error.message;
        }
    }
}
/**
 * @public
 */
class WebpackTask extends gulp_core_build_1.GulpTask {
    constructor(extendedName, extendedConfig) {
        super(extendedName || 'webpack', Object.assign({ configPath: './webpack.config.js', suppressWarnings: [], printStats: true }, extendedConfig) // eslint-disable-line @typescript-eslint/no-explicit-any
        );
    }
    get resources() {
        if (!this._resources) {
            this._resources = {
                webpack: this.taskConfig.webpack || require('webpack')
            };
        }
        return this._resources;
    }
    isEnabled(buildConfig) {
        return super.isEnabled(buildConfig) && this.taskConfig.configPath !== null;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    loadSchema() {
        return require('./webpack.schema.json');
    }
    executeTask(gulp, completeCallback) {
        // eslint-disable-next-line
        const path = require('path');
        let webpackConfig; // eslint-disable-line @typescript-eslint/no-explicit-any
        if (this.taskConfig.configPath && this.fileExists(this.taskConfig.configPath)) {
            try {
                webpackConfig = require(this.resolvePath(this.taskConfig.configPath));
            }
            catch (err) {
                completeCallback(`Error parsing webpack config: ${this.taskConfig.configPath}: ${err}`);
                return;
            }
        }
        else if (this.taskConfig.config) {
            webpackConfig = this.taskConfig.config;
        }
        else {
            this._logMissingConfigWarning();
            completeCallback();
            return;
        }
        if (webpackConfig) {
            const webpack = this.taskConfig.webpack || require('webpack');
            if (parseInt(webpack.version) !== 5) {
                this.logWarning(`This version of gulp-core-build-webpack is designed to work with webpack 5. ` +
                    `You are currently using webpack ${webpack.version}.`);
            }
            const startTime = new Date().getTime();
            const outputDir = this.buildConfig.distFolder;
            webpack(webpackConfig, (error, stats) => {
                if (!this.buildConfig.properties) {
                    this.buildConfig.properties = {};
                }
                // eslint-disable-next-line dot-notation
                this.buildConfig.properties['webpackStats'] = stats;
                let statsResult;
                try {
                    statsResult = stats === null || stats === void 0 ? void 0 : stats.toJson({
                        hash: false,
                        source: false
                    });
                }
                catch (e) {
                    this.logError(`Error processing webpack stats: ${e}`);
                    if (error) {
                        // Log this here in case we didn't get a stats object because of an error. Otherwise log errors
                        // from the stats object.
                        this.logError(`Webpack error: ${error}`);
                    }
                }
                if (statsResult) {
                    if (statsResult.errors && statsResult.errors.length) {
                        const errorTexts = [];
                        for (const error of statsResult.errors) {
                            errorTexts.push(normalizeWebpackError(error));
                        }
                        this.logError(`'${outputDir}':` + os_1.EOL + errorTexts.join(os_1.EOL) + os_1.EOL);
                    }
                    if (statsResult.warnings && statsResult.warnings.length) {
                        const unsuppressedWarnings = [];
                        const warningSuppressionRegexes = (this.taskConfig.suppressWarnings || []).map((regex) => {
                            return new RegExp(regex);
                        });
                        for (const warning of statsResult.warnings) {
                            let suppressed = false;
                            for (let i = 0; i < warningSuppressionRegexes.length; i++) {
                                const suppressionRegex = warningSuppressionRegexes[i];
                                if (warning.message.match(suppressionRegex)) {
                                    suppressed = true;
                                    break;
                                }
                            }
                            if (!suppressed) {
                                unsuppressedWarnings.push(warning);
                            }
                        }
                        if (unsuppressedWarnings.length > 0) {
                            const warningTexts = [];
                            for (const warning of unsuppressedWarnings) {
                                warningTexts.push(normalizeWebpackError(warning));
                            }
                            this.logWarning(`'${outputDir}':` + os_1.EOL + warningTexts.join(os_1.EOL) + os_1.EOL);
                        }
                    }
                    if (this.taskConfig.printStats) {
                        const duration = new Date().getTime() - startTime;
                        const statsResultChildren = statsResult.children
                            ? statsResult.children
                            : [statsResult];
                        for (const child of statsResultChildren) {
                            if (child.chunks) {
                                for (const chunk of child.chunks) {
                                    if (chunk.files) {
                                        for (const file of chunk.files) {
                                            this.log(`Bundled: '${colors.cyan(path.basename(file))}', ` +
                                                `size: ${colors.magenta(chunk.size.toString())} bytes, ` +
                                                `took ${colors.magenta(duration.toString(10))} ms.`);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                completeCallback();
            }); // endwebpack callback
        }
    }
    _logMissingConfigWarning() {
        this.logWarning('No webpack config has been provided. ' +
            'Create a webpack.config.js file ' +
            `or call webpack.setConfig({ configPath: null }) in your gulpfile.`);
    }
}
exports.WebpackTask = WebpackTask;
//# sourceMappingURL=WebpackTask.js.map