"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ConfigureWebpackTask: function() {
        return ConfigureWebpackTask;
    },
    FILE_LOADER_EXTENSIONS: function() {
        return FILE_LOADER_EXTENSIONS;
    }
});
const _path = /*#__PURE__*/ _interop_require_wildcard(require("path"));
const _spfxheftplugins = require("@microsoft/spfx-heft-plugins");
const _nodecorelibrary = require("@rushstack/node-core-library");
const _terminal = require("@rushstack/terminal");
const _OdspGulpTask = require("../OdspGulpTask");
const _GulpTaskTerminalProvider = require("../utilities/GulpTaskTerminalProvider");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const FILE_LOADER_EXTENSIONS = [
    'jpg',
    'png',
    'woff',
    'eot',
    'ttf',
    'svg',
    'gif',
    'dds'
];
const UPGRADE_PARAM_NAME = 'upgrade';
class ConfigureWebpackTask extends _OdspGulpTask.OdspGulpTask {
    loadSchema() {
        return _nodecorelibrary.JsonFile.load(_path.join(__dirname, 'configure-webpack.schema.json'));
    }
    setConfig(config) {
        if (config.webpack && config.webpack.name !== 'webpack') {
            this.logWarning('Setting webpack property to non-"@microsoft/gulp-core-build-webpack"-type will ' + 'prevent configuration');
        }
        super.mergeConfig(config);
    }
    async executeTask() {
        if (!this.taskConfig.webpack) {
            this.logWarning('"webpack" is not defined in the task configuration. Nothing to configure.');
            return;
        }
        const configJson = await this._getConfigJsonAsync();
        const terminal = new _terminal.Terminal(new _GulpTaskTerminalProvider.GulpTaskTerminalProvider(this));
        let legacyExternals;
        if (this.taskConfig.useLegacyExternals) {
            legacyExternals = new _spfxheftplugins._LegacyExternals({
                terminal,
                selectedLocales: this.taskConfig.singleLocale ? [
                    this.taskConfig.singleLocale
                ] : undefined,
                configJson: configJson,
                buildFolder: this.buildConfig.rootPath,
                serveMode: !!this.properties.serveMode,
                production: this.buildConfig.production,
                hashSalt: '1'
            });
        }
        const packageJson = _nodecorelibrary.PackageJsonLookup.instance.tryLoadPackageJsonFor(this.buildConfig.rootPath);
        if (!packageJson) {
            throw new Error('Unable to find package.json. Was the tool invoked in a project folder?');
        }
        let config = await _spfxheftplugins.WebpackConfigurationGenerator.generateWebpackConfigurationAsync({
            configJson: configJson,
            folders: {
                buildFolder: this.buildConfig.rootPath,
                tempFolder: _path.join(this.buildConfig.rootPath, _spfxheftplugins.DEFAULT_TEMP_FOLDER),
                releaseFolder: _path.join(this.buildConfig.rootPath, 'release'),
                outputFolder: _path.join(this.buildConfig.rootPath, 'dist')
            },
            terminal,
            production: this.buildConfig.production,
            serveMode: !!this.properties.serveMode,
            projectPackageJson: packageJson,
            getLocalization: this.taskConfig.getLocalization,
            selectedLocales: this.taskConfig.singleLocale ? [
                this.taskConfig.singleLocale
            ] : undefined,
            linkedExternalsToBundle: this.taskConfig.linkedExternalsToBundle,
            disableAsyncComponentLoading: this.taskConfig.disableAsyncComponentLoading,
            assetsAreVersioned: this.taskConfig.assetsAreVersioned,
            loadThemedStylesImportPath: this.taskConfig.loadThemedStylesImportPath,
            generateCssClassName: this.taskConfig.generateCssClassName || // if not specified, the Heft plugin will try to add an extra hash to the class name,
            // but for 3p, the sass plugin already does this.
            ((name)=>{
                return name;
            }),
            releaseManifestFolderName: this.taskConfig.releaseManifestFolderName,
            emitStats: false
        });
        if (config) {
            this.taskConfig.webpack.isEnabled = ()=>true;
            legacyExternals?.updateWebpackConfiguration(config);
            if (this.taskConfig.additionalConfiguration) {
                config = this.taskConfig.additionalConfiguration(config);
            }
        } else {
            this.taskConfig.webpack.isEnabled = ()=>false;
        }
        this._setWebpackConfig(config);
    }
    _setWebpackConfig(config) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const webpackTask = this.taskConfig.webpack;
        const sourceMapWarningSuppression = /Cannot find SourceMap \'.+\'\: Error\:/;
        // Disable Performance hints.
        const performanceHintSuppression = /(asset|entrypoint) size limit.*/;
        const performanceRecommendationSuppression = /webpack performance recommendations.*/;
        const suppressedWarnings = webpackTask.taskConfig.suppressWarnings || [];
        if (webpackTask) {
            webpackTask.setConfig({
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                config: config,
                // (unsetting configPath requires "null")
                // eslint-disable-next-line @rushstack/no-null, @typescript-eslint/no-non-null-assertion
                configPath: null,
                suppressWarnings: suppressedWarnings.concat([
                    sourceMapWarningSuppression,
                    performanceHintSuppression,
                    performanceRecommendationSuppression
                ])
            });
        }
    }
    async _getConfigJsonAsync() {
        const configFilePath = _path.join(this.buildConfig.rootPath, 'config', 'config.json');
        const configResult = await (0, _spfxheftplugins._readConfigFileAsync)(this.logVerbose.bind(this), configFilePath);
        if (configResult.missingFile) {
            this.logWarning('Missing config.json file. If this is a non-web project, consider using a non-web build rig ' + 'like @microsoft/sp-build-node');
        }
        if (configResult.readError) {
            throw new Error(`Error reading config.json file: ${configResult.readError}`);
        }
        if (!configResult.isLatestVersion) {
            if (this.buildConfig.args[UPGRADE_PARAM_NAME]) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                (0, _spfxheftplugins._migrateToLatestVersion)(this.logWarning.bind(this), configResult.configData);
                _nodecorelibrary.JsonFile.save(configResult.configData, configFilePath, {
                    prettyFormatting: true
                });
            } else {
                this.logWarning(`This project is using an old config.json file version (${configResult.version}). Run the ` + `build again with the --${UPGRADE_PARAM_NAME} (gulp --${UPGRADE_PARAM_NAME}) flag to ` + 'upgrade the config.json file to the latest version.');
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return configResult.configData;
    }
    constructor(){
        super('configure-webpack', {
            webpack: undefined,
            additionalConfiguration: undefined
        });
    }
}

//#sourceMappingUrl=./ConfigureWebpackTask.js.map