import * as path from 'path';
import { WebpackConfigurationGenerator, _readConfigFileAsync as readConfigFileAsync, _migrateToLatestVersion as migrateToLatestVersion, _LegacyExternals as LegacyExternals, DEFAULT_TEMP_FOLDER } from '@microsoft/spfx-heft-plugins';
import { JsonFile, PackageJsonLookup } from '@rushstack/node-core-library';
import { Terminal } from '@rushstack/terminal';
import { OdspGulpTask } from '../OdspGulpTask';
import { GulpTaskTerminalProvider } from '../utilities/GulpTaskTerminalProvider';
export const FILE_LOADER_EXTENSIONS = [
    'jpg',
    'png',
    'woff',
    'eot',
    'ttf',
    'svg',
    'gif',
    'dds'
];
const UPGRADE_PARAM_NAME = 'upgrade';
/**
 * Configures the \@microsoft/gulp-core-build-webpack task with some smart defaults based on the package configuration.
 */ export class ConfigureWebpackTask extends OdspGulpTask {
    loadSchema() {
        return JsonFile.load(path.join(__dirname, 'configure-webpack.schema.json'));
    }
    setConfig(config) {
        if (config.webpack && config.webpack.name !== 'webpack') {
            this.logWarning('Setting webpack property to non-"@microsoft/gulp-core-build-webpack"-type will ' + 'prevent configuration');
        }
        super.mergeConfig(config);
    }
    async executeTask() {
        if (!this.taskConfig.webpack) {
            this.logWarning('"webpack" is not defined in the task configuration. Nothing to configure.');
            return;
        }
        const configJson = await this._getConfigJsonAsync();
        const terminal = new Terminal(new GulpTaskTerminalProvider(this));
        let legacyExternals;
        if (this.taskConfig.useLegacyExternals) {
            legacyExternals = new LegacyExternals({
                terminal,
                selectedLocales: this.taskConfig.singleLocale ? [
                    this.taskConfig.singleLocale
                ] : undefined,
                configJson: configJson,
                buildFolder: this.buildConfig.rootPath,
                serveMode: !!this.properties.serveMode,
                production: this.buildConfig.production,
                hashSalt: '1'
            });
        }
        const packageJson = PackageJsonLookup.instance.tryLoadPackageJsonFor(this.buildConfig.rootPath);
        if (!packageJson) {
            throw new Error('Unable to find package.json. Was the tool invoked in a project folder?');
        }
        let config = await WebpackConfigurationGenerator.generateWebpackConfigurationAsync({
            configJson: configJson,
            folders: {
                buildFolder: this.buildConfig.rootPath,
                tempFolder: path.join(this.buildConfig.rootPath, DEFAULT_TEMP_FOLDER),
                releaseFolder: path.join(this.buildConfig.rootPath, 'release'),
                outputFolder: path.join(this.buildConfig.rootPath, 'dist')
            },
            terminal,
            production: this.buildConfig.production,
            serveMode: !!this.properties.serveMode,
            projectPackageJson: packageJson,
            getLocalization: this.taskConfig.getLocalization,
            selectedLocales: this.taskConfig.singleLocale ? [
                this.taskConfig.singleLocale
            ] : undefined,
            linkedExternalsToBundle: this.taskConfig.linkedExternalsToBundle,
            disableAsyncComponentLoading: this.taskConfig.disableAsyncComponentLoading,
            assetsAreVersioned: this.taskConfig.assetsAreVersioned,
            loadThemedStylesImportPath: this.taskConfig.loadThemedStylesImportPath,
            generateCssClassName: this.taskConfig.generateCssClassName || // if not specified, the Heft plugin will try to add an extra hash to the class name,
            // but for 3p, the sass plugin already does this.
            ((name)=>{
                return name;
            }),
            releaseManifestFolderName: this.taskConfig.releaseManifestFolderName,
            emitStats: false
        });
        if (config) {
            this.taskConfig.webpack.isEnabled = ()=>true;
            legacyExternals?.updateWebpackConfiguration(config);
            if (this.taskConfig.additionalConfiguration) {
                config = this.taskConfig.additionalConfiguration(config);
            }
        } else {
            this.taskConfig.webpack.isEnabled = ()=>false;
        }
        this._setWebpackConfig(config);
    }
    _setWebpackConfig(config) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const webpackTask = this.taskConfig.webpack;
        const sourceMapWarningSuppression = /Cannot find SourceMap \'.+\'\: Error\:/;
        // Disable Performance hints.
        const performanceHintSuppression = /(asset|entrypoint) size limit.*/;
        const performanceRecommendationSuppression = /webpack performance recommendations.*/;
        const suppressedWarnings = webpackTask.taskConfig.suppressWarnings || [];
        if (webpackTask) {
            webpackTask.setConfig({
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                config: config,
                // (unsetting configPath requires "null")
                // eslint-disable-next-line @rushstack/no-null, @typescript-eslint/no-non-null-assertion
                configPath: null,
                suppressWarnings: suppressedWarnings.concat([
                    sourceMapWarningSuppression,
                    performanceHintSuppression,
                    performanceRecommendationSuppression
                ])
            });
        }
    }
    async _getConfigJsonAsync() {
        const configFilePath = path.join(this.buildConfig.rootPath, 'config', 'config.json');
        const configResult = await readConfigFileAsync(this.logVerbose.bind(this), configFilePath);
        if (configResult.missingFile) {
            this.logWarning('Missing config.json file. If this is a non-web project, consider using a non-web build rig ' + 'like @microsoft/sp-build-node');
        }
        if (configResult.readError) {
            throw new Error(`Error reading config.json file: ${configResult.readError}`);
        }
        if (!configResult.isLatestVersion) {
            if (this.buildConfig.args[UPGRADE_PARAM_NAME]) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                migrateToLatestVersion(this.logWarning.bind(this), configResult.configData);
                JsonFile.save(configResult.configData, configFilePath, {
                    prettyFormatting: true
                });
            } else {
                this.logWarning(`This project is using an old config.json file version (${configResult.version}). Run the ` + `build again with the --${UPGRADE_PARAM_NAME} (gulp --${UPGRADE_PARAM_NAME}) flag to ` + 'upgrade the config.json file to the latest version.');
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return configResult.configData;
    }
    constructor(){
        super('configure-webpack', {
            webpack: undefined,
            additionalConfiguration: undefined
        });
    }
}

//#sourceMappingUrl=./ConfigureWebpackTask.js.map