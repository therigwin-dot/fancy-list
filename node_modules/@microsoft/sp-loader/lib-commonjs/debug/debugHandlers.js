"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dangerouslyEnableDebug = exports.evaluateAssembliesAsync = exports.createFrameToEvaluateAssembliesAsync = exports.loadAndRegisterManifestsFileAsync = exports.getDebugScripts = exports.checkEvaluateAssembliesAsync = exports.handleDebugDataAsync = exports.handleTestMode = exports.handleNonTestModeDebug = void 0;
var tslib_1 = require("tslib");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var ManifestStore_1 = tslib_1.__importDefault(require("../stores/ManifestStore"));
var resolveAddress_1 = tslib_1.__importDefault(require("../utilities/resolveAddress"));
var DebugManager_1 = require("./DebugManager");
var DebugManager_resx_1 = tslib_1.__importDefault(require("./DebugManager.resx"));
var showDebugError_1 = tslib_1.__importDefault(require("./showDebugError"));
var DebugStatus_1 = require("./DebugStatus");
var killSwitches_1 = require("../tiny/common/killSwitches");
var SPStarter_1 = require("../starter/SPStarter");
/**
 * The ?evalDebugAssemblies query parameter. This is used to evaluate debug assemblies in the context of the page.
 */
var EVAL_DEBUG_ASSEMBLIES_QUERY_PARAM_NAME = 'evalDebugAssemblies';
/**
 * The ?livereload query parameter. This enabled automatic reloading when using gulp serve
 */
var LIVERELOAD_QUERY_PARAM_NAME = 'livereload';
var LOADER_EXPORTS_NAME = 'spModuleLoader';
function handleNonTestModeDebug(componentLoader, spfxDebugSessionData, debugManifestsFileUrl, debugLoaderUrl, queryParameters, isSpfxDebugEnabled, resolveDebugData) {
    DebugStatus_1.DebugStatus.confirmDebugAllowedAsync({
        loaderRequested: !!debugLoaderUrl,
        manifestsRequested: !!debugManifestsFileUrl,
        loaderDebugAlreadyAllowed: !!spfxDebugSessionData.loaderUrl && debugLoaderUrl === spfxDebugSessionData.loaderUrl,
        manifestsDebugAlreadyAllowed: !!spfxDebugSessionData.manifestsFileUrl &&
            debugManifestsFileUrl === spfxDebugSessionData.manifestsFileUrl
    })
        .then(function (allowed) {
        if (allowed) {
            var liveReload_1 = isSpfxDebugEnabled
                ? queryParameters.get(LIVERELOAD_QUERY_PARAM_NAME) === 'true' ||
                    spfxDebugSessionData.liveReload ||
                    false
                : false;
            void new Promise(function (resolve) {
                saveSpfxDebugSessionData(spfxDebugSessionData, debugLoaderUrl, debugManifestsFileUrl, liveReload_1);
                return getDebugScripts(componentLoader, spfxDebugSessionData, resolve, false);
            }).then(function (debugData) {
                resolveDebugData(debugData);
            });
        }
        else {
            resolveDebugData(DebugManager_1.EMPTY_DEBUG_LOAD_RESULT);
        }
    })
        // eslint-disable-next-line no-console
        .catch(console.error);
}
exports.handleNonTestModeDebug = handleNonTestModeDebug;
function handleTestMode(componentLoader, spfxDebugSessionData, resolve) {
    getDebugScripts(componentLoader, spfxDebugSessionData, resolve, false);
}
exports.handleTestMode = handleTestMode;
function handleDebugDataAsync(componentLoader, debugData, currentUrl) {
    var _a = debugData.debugManifests, debugManifests = _a === void 0 ? [] : _a, liveReload = debugData.liveReload, registerAsNonDebug = debugData.registerAsNonDebug;
    DebugStatus_1.DebugStatus.dangerouslyEnableDebug();
    registerManifests(debugManifests, registerAsNonDebug);
    if (liveReload) {
        enableLiveReload(componentLoader);
    }
    if ((0, killSwitches_1.isCatchDebugEvalErrorsKSActivated)()) {
        return Promise.resolve(DebugManager_1.EMPTY_DEBUG_LOAD_RESULT);
    }
    else {
        return checkEvaluateAssembliesAsync(componentLoader, debugManifests, currentUrl);
    }
}
exports.handleDebugDataAsync = handleDebugDataAsync;
function checkEvaluateAssembliesAsync(loader, manifests, currentUrl) {
    var shouldEvaluateAssemblies = !!currentUrl.searchParams.get(EVAL_DEBUG_ASSEMBLIES_QUERY_PARAM_NAME);
    var spfxDebugSessionData = (0, DebugManager_1.getSPFxDebugSessionData)();
    var isPlaywright = spfxDebugSessionData.isPlaywright;
    var isTest = isPlaywright || sessionStorage.getItem('_isRunningTABTest') === 'true';
    if (!shouldEvaluateAssemblies) {
        // Don't run during CI as there is a dedicated test for this
        if (!isTest) {
            createFrameToEvaluateAssembliesAsync(currentUrl);
        }
        return Promise.resolve(DebugManager_1.EMPTY_DEBUG_LOAD_RESULT);
    }
    return evaluateAssembliesAsync(loader, manifests, isTest).then(function () { return DebugManager_1.EMPTY_DEBUG_LOAD_RESULT; });
}
exports.checkEvaluateAssembliesAsync = checkEvaluateAssembliesAsync;
function getDebugScripts(componentLoader, spfxDebugSessionData, resolve, registerAsNonDebug) {
    var liveReload = spfxDebugSessionData.liveReload, loaderUrl = spfxDebugSessionData.loaderUrl, manifestsFileUrl = spfxDebugSessionData.manifestsFileUrl;
    var debugLoaderPromise = loaderUrl
        ? loadLoaderAsync(componentLoader, loaderUrl)
        : Promise.resolve(undefined);
    var debugManifestsFilePromise = manifestsFileUrl
        ? loadAndRegisterManifestsFileAsync(componentLoader, manifestsFileUrl, registerAsNonDebug)
        : Promise.resolve(undefined);
    // Wrap errors so we know where the error came from
    debugLoaderPromise = debugLoaderPromise.catch(function (error) {
        // eslint-disable-next-line no-throw-literal
        throw { errorSource: 'loader', error: error };
    });
    debugManifestsFilePromise = debugManifestsFilePromise.catch(function (error) {
        // eslint-disable-next-line no-throw-literal
        throw { errorSource: 'manifestsFile', error: error };
    });
    Promise.all([debugLoaderPromise, debugManifestsFilePromise])
        .then(function (_a) {
        var debugLoader = _a[0], debugManifests = _a[1];
        resolve({ debugLoader: debugLoader, debugManifests: debugManifests, liveReload: !!liveReload, registerAsNonDebug: registerAsNonDebug });
    })
        .catch(function (error) {
        if (error instanceof Error) {
            (0, showDebugError_1.default)(error, DebugManager_resx_1.default.errorLoadingDebugScriptUnknown, DebugManager_resx_1.default.errorLoadingUnknownTitle
            // eslint-disable-next-line no-console
            ).catch(console.error);
        }
        else {
            var errorText = DebugManager_resx_1.default.errorLoadingDebugScriptUnknown;
            var title = DebugManager_resx_1.default.errorLoadingUnknownTitle;
            switch (error.errorSource) {
                case 'loader':
                    errorText = getUrlErrorText(loaderUrl || '', DebugManager_1.LOADER_QUERY_PARAM_NAME);
                    title = DebugManager_resx_1.default.errorLoadingDebugLoaderTitle;
                    break;
                case 'manifestsFile':
                    errorText = getUrlErrorText(manifestsFileUrl || '', DebugManager_1.DEBUG_MANIFESTS_FILE_QUERY_PARAM_NAME);
                    title = DebugManager_resx_1.default.errorLoadingDebugManifestTitle;
                    break;
            }
            // eslint-disable-next-line no-console
            (0, showDebugError_1.default)(error.error, errorText, title).catch(console.error);
        }
    });
}
exports.getDebugScripts = getDebugScripts;
function loadAndRegisterManifestsFileAsync(componentLoader, manifestsFileUrl, registerAsNonDebug) {
    return componentLoader
        .loadScript(manifestsFileUrl)
        .then(function (manifestScript) {
        var _a, _b;
        var manifests = manifestScript.getManifests();
        var allowFirstParty = (_a = manifestScript._metadata) === null || _a === void 0 ? void 0 : _a.isFirstParty;
        var filteredManifests;
        if (allowFirstParty) {
            filteredManifests = manifests;
        }
        else {
            filteredManifests = [];
            for (var _i = 0, manifests_1 = manifests; _i < manifests_1.length; _i++) {
                var manifest = manifests_1[_i];
                var manifestIsInternal = manifest.isInternal || ((_b = ManifestStore_1.default.instance.tryGetManifest(manifest.id)) === null || _b === void 0 ? void 0 : _b.isInternal);
                if (!manifestIsInternal) {
                    filteredManifests.push(manifest);
                }
            }
        }
        registerManifests(filteredManifests, registerAsNonDebug);
        return filteredManifests;
    });
}
exports.loadAndRegisterManifestsFileAsync = loadAndRegisterManifestsFileAsync;
function createFrameToEvaluateAssembliesAsync(currentUrl) {
    // Creating an iframe for loading the debug assemblies so that they don't interfere with the current page
    var testFrame = document.createElement('iframe');
    currentUrl.searchParams.append(EVAL_DEBUG_ASSEMBLIES_QUERY_PARAM_NAME, 'true');
    testFrame.src = currentUrl.href;
    testFrame.hidden = true;
    var handler = function (event) {
        if (typeof event.data === 'object') {
            var evalMessage = event.data;
            if (evalMessage.isEvalResponse) {
                if (evalMessage.error) {
                    window.removeEventListener('message', handler);
                    self.location.href = "/_layouts/15/error.aspx?ErrorText='Error in assembly evaluation'&ErrorDetails='".concat(encodeURIComponent(evalMessage.error), "'&ErrorCategory=spfx");
                }
                else {
                    window.removeEventListener('message', handler);
                    document.body.removeChild(testFrame);
                }
            }
        }
    };
    window.addEventListener('message', handler);
    document.body.appendChild(testFrame);
}
exports.createFrameToEvaluateAssembliesAsync = createFrameToEvaluateAssembliesAsync;
function evaluateAssembliesAsync(loader, manifests, isTest) {
    // Save global loader export
    var originalExport = window[LOADER_EXPORTS_NAME];
    // Save the original webpackJsonp globals
    var originalJsonp = Object.keys(window).filter(function (key) { return key.match(/^webpackJsonp/i); });
    // Uninitialize experiments, flights, and kill switches to emulate eval time behavior
    _modifyInitializationForDebug();
    var loadedAssemblies = [];
    for (var _i = 0, manifests_2 = manifests; _i < manifests_2.length; _i++) {
        var manifest = manifests_2[_i];
        if (manifest.rootComponentId) {
            var assemblyUrl = (0, resolveAddress_1.default)(manifest, manifest.loaderConfig.entryModuleId).path;
            loadedAssemblies.push(loader.loadScript(assemblyUrl, { globalExportsName: manifest.id }).then(function () {
                removeGlobalJsonpVariables(originalJsonp);
            }));
        }
    }
    return Promise.all(loadedAssemblies)
        .catch(function (e) {
        if (!isTest) {
            window.parent.postMessage({ isEvalResponse: true, error: e }, window.location.origin);
        }
        throw e;
    })
        .then(function () {
        window[LOADER_EXPORTS_NAME] = originalExport;
        // Reinitialize experiments, flights, and kill switches
        _modifyInitializationForDebug(true);
        if (!isTest) {
            window.parent.postMessage({ isEvalResponse: true }, window.location.origin);
            return Promise.reject(new Error(SPStarter_1.EVAL_FRAME_FLAG));
        }
    });
}
exports.evaluateAssembliesAsync = evaluateAssembliesAsync;
function dangerouslyEnableDebug() {
    DebugStatus_1.DebugStatus.dangerouslyEnableDebug();
}
exports.dangerouslyEnableDebug = dangerouslyEnableDebug;
/**
 * RESERVED FOR INTERNAL USAGE. ONLY FOR DEBUGGING PURPOSES.
 * DO NOT USE THIS METHOD IN YOUR APPLICATION CODE.
 */
function _modifyInitializationForDebug(isInitialized) {
    if (isInitialized === void 0) { isInitialized = false; }
    // Emulate eval time behavior by disabling experiments, flights, and kill switches during debug load
    /* eslint-disable dot-notation */
    sp_core_library_1._SPExperiment['_isInitialized'] = isInitialized;
    sp_core_library_1._SPFlight['_isInitialized'] = isInitialized;
    sp_core_library_1._EcsFlight['_isInitialized'] = isInitialized;
    sp_core_library_1._SPKillSwitch['_isInitialized'] = isInitialized;
    /* eslint-enable dot-notation */
}
function getUrlErrorText(url, paramName) {
    var isMalformed = !url.match(/^https?\:\/\//);
    var isHttps = !isMalformed && !!url.match(/^https/);
    return isMalformed
        ? sp_core_library_1.Text.format(DebugManager_resx_1.default.errorLoadingDebugScriptMalformed, url)
        : sp_core_library_1.Text.format(isHttps ? DebugManager_resx_1.default.errorLoadingDebugScriptHTTPS : DebugManager_resx_1.default.errorLoadingDebugScriptHTTP, paramName);
}
function registerManifests(manifests, registerAsNonDebug) {
    if (registerAsNonDebug) {
        ManifestStore_1.default.instance.registerManifests(manifests, false);
    }
    else {
        ManifestStore_1.default.instance.registerDebugManifests(manifests);
    }
}
function enableLiveReload(componentLoader) {
    try {
        // This is the default port and default location of the livereload script from gulp-connect
        // We don't override these in the sp-client build chain. Once we have proper Hot Module Replacement
        // from react/webpack-dev-server this code will be made redundant.
        componentLoader.loadScript('https://localhost:35729/livereload.js').catch(function () {
            /* no-op */
        });
    }
    catch (_a) {
        /* no-op */
    }
}
function loadLoaderAsync(componentLoader, loaderUrl) {
    // This deletes the variable window.spModuleLoader created by the assembly
    delete window[LOADER_EXPORTS_NAME];
    removeGlobalJsonpVariables();
    return componentLoader.loadScript(loaderUrl, { globalExportsName: LOADER_EXPORTS_NAME });
}
/**
 * Use to remove all global Jsonp variables from the window object.
 *
 * @param exclude - Option list of global Jsonp names to exclude from deletion
 */
function removeGlobalJsonpVariables(exclude) {
    if (exclude === void 0) { exclude = []; }
    for (var _i = 0, _a = Object.keys(window); _i < _a.length; _i++) {
        var globalName = _a[_i];
        if (globalName.match(/^webpackJsonp/i) && !exclude.includes(globalName)) {
            delete window[globalName];
        }
    }
}
function saveSpfxDebugSessionData(spfxDebugSessionData, loaderUrl, manifestsFileUrl, liveReload) {
    spfxDebugSessionData.liveReload = liveReload;
    spfxDebugSessionData.loaderUrl = loaderUrl;
    spfxDebugSessionData.manifestsFileUrl = manifestsFileUrl;
    try {
        var serializedDebugSessionData = JSON.stringify(spfxDebugSessionData);
        if (serializedDebugSessionData !== '{}') {
            sessionStorage.setItem(DebugManager_1.SPFX_DEBUG_SESSION_VAR_ID, serializedDebugSessionData);
        }
        else {
            sessionStorage.removeItem(DebugManager_1.SPFX_DEBUG_SESSION_VAR_ID);
        }
    }
    catch (e) {
        // If we get an error saving the debug session data, don't interrupt the rest of the initialization flow
    }
}
//# sourceMappingURL=debugHandlers.js.map