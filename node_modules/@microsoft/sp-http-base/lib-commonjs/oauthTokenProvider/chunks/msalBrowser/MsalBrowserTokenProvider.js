"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsalBrowserTokenProvider = void 0;
var tslib_1 = require("tslib");
var msal_browser_1p_1 = require("@azure/msal-browser-1p");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var AadConstants_1 = tslib_1.__importDefault(require("../../AadConstants"));
var AadErrorHandler_1 = require("../../AadErrorHandler");
var AadFlights_1 = require("../../AadFlights");
var AadTokenProvider_1 = tslib_1.__importStar(require("../../AadTokenProvider"));
var ITokenProvider_1 = require("../../ITokenProvider");
var MsalRedirectManager_1 = require("./MsalRedirectManager");
var MsalUtilities_1 = require("./MsalUtilities");
var MsalBrowserClientManager_1 = require("./MsalBrowserClientManager");
var MsalSessionIdManager_1 = require("./MsalSessionIdManager");
var NonceManager_1 = require("../../../nonceManager/NonceManager");
var sp_diagnostics_1 = require("@microsoft/sp-diagnostics");
var AadKillSwitches_1 = require("../../AadKillSwitches");
var SPA_RT_COOKIE_BASE_KEY = 'SPA_RT';
var SPA_RT_COOKIE_CHUNK_SIZE = 4000;
var SPA_REFRESH_TOKEN_EXP_STORAGE_KEY = 'spa_refresh_token_exp';
var SUCCESSFUL_REDIRECT_TIMEFRAME = 10000;
var POP_SUPPORT_TIMEFRAME_LIMIT = 5;
var popNotSupported = new Map();
// we have to account for both spellings b/c the error is spelled differently across MSAL and OneAuth libraries
var USER_CANCELLED_ERROR_RESULT_CODES = ['user_canceled', 'user_cancelled'];
/**
 * List of different login hint strategies that should be tried (generally in order) for ssoSilent.
 * AAD's recommended order is LOGIN_HINT_CLAIM -\> SESSION_ID -\> UPN.
 *
 * If none are available, ssoSilent may be tried with no login hint. It will be successful when
 * exactly one valid session exists in AAD for that user.
 * @Internal
 */
var MsalBrowserLoginHint;
(function (MsalBrowserLoginHint) {
    MsalBrowserLoginHint[MsalBrowserLoginHint["LOGIN_HINT_CLAIM"] = 0] = "LOGIN_HINT_CLAIM";
    MsalBrowserLoginHint[MsalBrowserLoginHint["SESSION_ID"] = 1] = "SESSION_ID";
    MsalBrowserLoginHint[MsalBrowserLoginHint["UPN"] = 2] = "UPN";
    MsalBrowserLoginHint[MsalBrowserLoginHint["NONE"] = 3] = "NONE";
})(MsalBrowserLoginHint || (MsalBrowserLoginHint = {}));
/**
 * Class that wraps the MSAL Browser's authentication class in order to acquire tokens.
 *
 * MsalBrowserTokenProvider provides two methods to acquire tokens:
 *   1. getToken: returns a promise containing only the access token string.
 *   2. getTokenData: returns a promise containing the entire token object.
 *
 * @internal
 */
var MsalBrowserTokenProvider = /** @class */ (function () {
    function MsalBrowserTokenProvider(configuration) {
        this._ALLOWED_NETWORK_RETRY_ATTEMPTS = 1;
        this._defaultConfiguration = configuration;
        this._redirectManager = new MsalRedirectManager_1.MsalRedirectManager(this._getAuthority(), this._getClientId(), true);
        this._shouldPrintDebugLogs = (0, MsalUtilities_1.shouldPrintMsalLogsToConsole)();
        MsalBrowserClientManager_1.MsalBrowserClientManager.registerMsalBrowserClient(this._getAuthority(), this._getClientId(), this._getRedirectUri(), this._defaultConfiguration.isNaaSupported ? true : false, this._defaultConfiguration.isPairwiseBrokerEnabled ? true : false);
        MsalSessionIdManager_1.MsalSessionIdManager.initialize();
    }
    MsalBrowserTokenProvider.prototype.getToken = function (resourceEndpoint, optionsOrUseCachedToken) {
        var options = optionsOrUseCachedToken && typeof optionsOrUseCachedToken === 'object'
            ? tslib_1.__assign({}, optionsOrUseCachedToken) : {
            useCachedToken: optionsOrUseCachedToken,
            authenticationScheme: ITokenProvider_1.IAuthenticationScheme.BEARER
        };
        return this.getTokenData(resourceEndpoint, options).then(function (tokenData) { return tokenData.accessToken; });
    };
    MsalBrowserTokenProvider.prototype.getTokenData = function (resourceEndpoint, optionsOrUseCachedToken, skipLoggingAndDisableRedirects) {
        var _this = this;
        if (optionsOrUseCachedToken === void 0) { optionsOrUseCachedToken = true; }
        if (skipLoggingAndDisableRedirects === void 0) { skipLoggingAndDisableRedirects = false; }
        var getTokenDataMonitor = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.getTokenData');
        if ((!(0, AadKillSwitches_1.isFailAllAnonymousTokenRequestsKSActivated)() && this._defaultConfiguration.isAnonymousGuestUser) ||
            (!(0, AadKillSwitches_1.isFailAllEmailAuthGuestTokenRequestsKSActivated)() &&
                this._defaultConfiguration.isEmailAuthenticationGuestUser)) {
            throw new Error('Anonymous or Email authenticated Guest User may not request tokens');
        }
        else {
            var options_1 = optionsOrUseCachedToken && typeof optionsOrUseCachedToken === 'object'
                ? optionsOrUseCachedToken
                : {
                    skipLoggingAndDisableRedirects: skipLoggingAndDisableRedirects,
                    useCachedToken: optionsOrUseCachedToken,
                    claims: undefined,
                    authenticationScheme: ITokenProvider_1.IAuthenticationScheme.BEARER
                };
            var _a = options_1.skipLoggingAndDisableRedirects, shouldNotLogOrRedirect = _a === void 0 ? false : _a, _b = options_1.useCachedToken, useCachedToken = _b === void 0 ? true : _b, claims = options_1.claims, scopes = options_1.scopes, callersQosName = options_1.callersQosName;
            this._shouldPrintDebugLogs = (0, MsalUtilities_1.shouldPrintMsalLogsToConsole)();
            var requestContext_1 = {
                authenticationScheme: options_1.authenticationScheme,
                claims: claims,
                scopes: scopes,
                loginHintType: MsalBrowserLoginHint.SESSION_ID,
                resourceEndpoint: resourceEndpoint,
                resourceRequestMethod: options_1.resourceRequestMethod,
                shrClaims: options_1.shrClaims,
                shouldNotLogOrRedirect: shouldNotLogOrRedirect,
                telemetryData: this._generateTelemetryData(resourceEndpoint, options_1.authenticationScheme, callersQosName),
                useCachedToken: useCachedToken
            };
            this._updatePageEndVisibility(requestContext_1.telemetryData);
            if ((0, AadFlights_1.isPoPTokenFlightEnabled)() && options_1.authenticationScheme === ITokenProvider_1.IAuthenticationScheme.POP) {
                if (!popNotSupported.has(resourceEndpoint) || this._isResourceEndpointExpired(resourceEndpoint)) {
                    return this._getShrNonce(requestContext_1)
                        .then(function (shrNonce) {
                        getTokenDataMonitor.writeSuccess(requestContext_1.telemetryData);
                        requestContext_1.shrNonce = shrNonce;
                        return _this._getTokenDataInternal(requestContext_1, options_1);
                    })
                        .catch(function (error) {
                        _this._logger('_getShrNonce', 'Caught an error while fetching server Nonce.', error);
                        if (error.name === 'NonceNotSupported') {
                            popNotSupported.set(resourceEndpoint, new Date());
                            getTokenDataMonitor.writeUnexpectedFailure(error.errorCode, error, requestContext_1.telemetryData);
                            options_1.authenticationScheme = ITokenProvider_1.IAuthenticationScheme.BEARER;
                            return _this._getTokenDataInternal(requestContext_1, options_1);
                        }
                        else {
                            return Promise.reject(error);
                        }
                    });
                }
                else {
                    options_1.authenticationScheme = ITokenProvider_1.IAuthenticationScheme.BEARER;
                    return this._getTokenDataInternal(requestContext_1, options_1);
                }
            }
            return this._getTokenDataInternal(requestContext_1, options_1);
        }
    };
    MsalBrowserTokenProvider.prototype._ensureState = function () {
        var _this = this;
        if (!(0, AadKillSwitches_1.isEnableEncryptedAuthorizeResponseKSActivated)()) {
            var spa_rt_1 = this._getEncryptedAuthorizedResponseToken();
            if (spa_rt_1.spa_rt) {
                // We don't want to reinitialize with the EAR cookie incase a claims challenge was made and the EAR cookie does
                // not have that claim.  Therefore we only apply the cookie if the refresh token expiration date is not found
                if (!this._isRefreshTokenExpirationDateValid()) {
                    var earMonitor_1 = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.EncryptedAuthorizationResponse');
                    // We need an empty request context to ensure the msal instance is initialized.  It doesn't do anything and
                    // is only used for logging
                    var telemetryData = {
                        alias: 'false', // Alias column is used to mark cache hits
                        aadSessionId: this._getSessionId(),
                        CorrelationId: sp_core_library_1.Guid.newGuid().toString(),
                        isInternal: true,
                        isPageVisibleStart: document.visibilityState === 'visible',
                        isPageVisibleEnd: false,
                        redirectUri: this._getRedirectUri(),
                        msalVersion: '3.19.1'
                    };
                    var requestContext = {
                        claims: undefined,
                        loginHintType: MsalBrowserLoginHint.SESSION_ID,
                        resourceEndpoint: '',
                        shouldNotLogOrRedirect: true,
                        telemetryData: telemetryData,
                        useCachedToken: true
                    };
                    return this._ensureMsalClientIsInitialized(requestContext)
                        .then(function () {
                        var silentRequest = {
                            scopes: [],
                            authority: _this._getAuthority()
                        };
                        var serverResponse = {
                            refresh_token: spa_rt_1.spa_rt,
                            client_info: spa_rt_1.client_info
                        };
                        return _this._msalBrowserClient
                            .getTokenCache()
                            .loadExternalTokens(silentRequest, serverResponse, {});
                    })
                        .then(function () {
                        earMonitor_1.writeSuccess();
                        if (spa_rt_1.spa_refresh_token_exp) {
                            _this._setRefreshTokenExpirationDate(spa_rt_1.spa_refresh_token_exp);
                        }
                        return Promise.resolve();
                    })
                        .catch(function (error) {
                        earMonitor_1.writeUnexpectedFailure('FailedToCacheEarToken', error);
                    });
                }
                else {
                    var earMonitorProcessed = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.EncryptedAuthorizationResponseAlreadyProcessed');
                    earMonitorProcessed.writeSuccess();
                    return Promise.resolve();
                }
            }
            else {
                var cookieNotFound = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.EncryptedAuthorizationResponseCookieNotFound');
                cookieNotFound.writeUnexpectedFailure();
            }
        }
        return this.getTokenData('https://graph.microsoft.com', { isEnsureRequest: true }).then(function () {
            return Promise.resolve();
        });
    };
    MsalBrowserTokenProvider.prototype._ensureTelemetry = function () {
        if (!(0, AadKillSwitches_1.isUseSessionStorageForRedirectScenarioProxyMonitoringKSActivated)() &&
            !!window.sessionStorage.getItem(MsalRedirectManager_1.CURRENT_REDIRECT_START_TIME_SESSION_STORAGE_KEY)) {
            this._monitorFullPageRedirectReliability();
        }
        return Promise.resolve();
    };
    MsalBrowserTokenProvider.prototype._getEncryptedAuthorizedResponseToken = function () {
        var returnValue = {
            spa_rt: '',
            client_info: '',
            oid: '',
            // eslint-disable-next-line @typescript-eslint/naming-convention
            spa_refresh_token_exp: ''
        };
        var i = 0;
        var continueProcessing = true;
        var cookieContent = '';
        while (continueProcessing) {
            var key = "".concat(SPA_RT_COOKIE_BASE_KEY).concat(i > 0 ? i : '');
            var cookieChunk = this._getCookieData(key);
            if (cookieChunk.length < SPA_RT_COOKIE_CHUNK_SIZE) {
                continueProcessing = false;
            }
            cookieContent += cookieChunk;
            i++;
        }
        if (cookieContent.length > 0) {
            var decodedJson = window.atob(cookieContent);
            returnValue = JSON.parse(decodedJson);
        }
        return returnValue;
    };
    MsalBrowserTokenProvider.prototype._getCookieData = function (key) {
        var returnValue = '';
        if (document.cookie.length > 0) {
            var cookieStartIndex = document.cookie.indexOf(key + '=');
            if (cookieStartIndex >= 0) {
                cookieStartIndex += key.length + 1;
                var cookieEndIndex = document.cookie.indexOf(';', cookieStartIndex);
                if (cookieEndIndex < 0) {
                    cookieEndIndex = document.cookie.length;
                }
                returnValue = document.cookie.substring(cookieStartIndex, cookieEndIndex);
            }
        }
        return returnValue;
    };
    MsalBrowserTokenProvider.prototype._setRefreshTokenExpirationDate = function (expDate) {
        try {
            localStorage.setItem(SPA_REFRESH_TOKEN_EXP_STORAGE_KEY, expDate);
        }
        catch (_a) {
            // Local storage is not available so use session storage
            sessionStorage.setItem(SPA_REFRESH_TOKEN_EXP_STORAGE_KEY, expDate);
        }
    };
    MsalBrowserTokenProvider.prototype._isRefreshTokenExpirationDateValid = function () {
        var returnValue = false;
        var expirationTime;
        try {
            try {
                expirationTime = localStorage.getItem(SPA_REFRESH_TOKEN_EXP_STORAGE_KEY);
            }
            catch (_a) {
                expirationTime = sessionStorage.getItem(SPA_REFRESH_TOKEN_EXP_STORAGE_KEY);
            }
            if (expirationTime) {
                var expirationTimeAsDate = Date.parse(expirationTime);
                if (expirationTimeAsDate > Date.now()) {
                    returnValue = true;
                }
            }
        }
        catch (_b) {
            return false;
        }
        return returnValue;
    };
    MsalBrowserTokenProvider.prototype._getShrNonce = function (requestContext) {
        var _this = this;
        var nonceMonitor = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.GetShrNonce');
        return NonceManager_1.NonceManager.getNonceManager()
            .getNonceFromResource(requestContext.resourceEndpoint, requestContext.useCachedToken)
            .then(function (shrNonce) {
            _this._logger('getNonceFromResource', 'Successfully got a Server Nonce.');
            nonceMonitor.writeSuccess(requestContext.telemetryData);
            return shrNonce;
        })
            .catch(function (error) {
            _this._logger('getNonceFromResource', 'Caught an error while fetching server Nonce.', error);
            nonceMonitor.writeUnexpectedFailure(error.errorCode, error, requestContext.telemetryData);
            throw error;
        });
    };
    MsalBrowserTokenProvider.prototype._getTokenDataInternal = function (requestContext, options, isRetry) {
        var _this = this;
        if (isRetry === void 0) { isRetry = false; }
        return this._ensureMsalClientIsInitialized(requestContext).then(function () {
            var getTokenDataMonitorName;
            var shouldCreateNAAMonitor = !!_this._defaultConfiguration.isNaaSupported &&
                _this._defaultConfiguration.servicePrincipalId === AadConstants_1.default.PRE_AUTHORIZED_APP_PRINCIPAL_ID;
            var isNAAMobile = ((0, AadFlights_1.isNaaFlightEnabledForSharePointMobile)() && sp_core_library_1._BrowserUtilities.isMobileWebView()) ||
                ((0, AadFlights_1.isNaaFlightEnabledForVCM)() && sp_core_library_1._BrowserUtilities.isMEEBridgeApplicationHosted());
            if (isRetry) {
                getTokenDataMonitorName = 'MsalBrowserV3TokenProvider.GetTokenDataRetry';
            }
            else if (shouldCreateNAAMonitor) {
                getTokenDataMonitorName = isNAAMobile
                    ? 'MsalBrowserV3TokenProvider.GetTokenDataNAAMobile'
                    : 'MsalBrowserV3TokenProvider.GetTokenDataNAA';
            }
            else {
                getTokenDataMonitorName = 'MsalBrowserV3TokenProvider.GetTokenData';
            }
            var getTokenDataMonitor = new sp_diagnostics_1._QosMonitor(getTokenDataMonitorName);
            var tokenPromise;
            if (_this._isCurrentUserLoggedInToMsal()) {
                var acquireTokenSilentMonitor = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.AcquireTokenSilent');
                _this._logger('getTokenData', 'User is logged in, calling acquireTokenSilent().');
                tokenPromise = _this._acquireTokenSilent(requestContext, acquireTokenSilentMonitor);
            }
            else {
                var ssoSilentMonitor = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.SsoSilent');
                _this._logger('getTokenData', 'No user is logged in, calling ssoSilent().');
                tokenPromise = _this._ssoSilent(requestContext, ssoSilentMonitor);
            }
            return tokenPromise
                .then(function (tokenData) {
                _this._logger('getTokenData', 'Token retrieved. Exiting.');
                requestContext.telemetryData.alias = (!!tokenData.fromCache).toString();
                getTokenDataMonitor.writeSuccess(requestContext.telemetryData);
                return tokenData;
            })
                .catch(function (error) {
                var shouldReturnFailureType = !(0, AadKillSwitches_1.isExpectedResultOnErrorReturnedKSActivated)();
                if (!(0, AadKillSwitches_1.isLogCorrelationIdKSActivated)()) {
                    requestContext.telemetryData.aadCorrelationId = (error === null || error === void 0 ? void 0 : error.correlationId) ? error.correlationId : '';
                }
                _this._logger('getTokenData', 'Caught an error.', error);
                if (!(0, AadKillSwitches_1.isHandleNAAInteractionRequiredWithPopupKSActivated)() &&
                    _this._defaultConfiguration.isNaaSupported &&
                    _this._isInteractionRequiredError(error)) {
                    // Expected as we will handle it with popup
                    getTokenDataMonitor.writeExpectedFailure(error.errorCode, error, requestContext.telemetryData);
                    return _this._acquireTokenPopupNAA(requestContext);
                }
                if (_this._shouldUsePopup() && _this._isInteractionRequiredError(error)) {
                    var popupMonitor = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.Popup');
                    var pendingPopup = _this._acquireTokenPopup(requestContext, popupMonitor);
                    if (pendingPopup) {
                        return pendingPopup;
                    }
                }
                var canRedirect = _this._isErrorEligibleForRedirect(error) &&
                    _this._redirectManager.isAllowedToRedirect() &&
                    !requestContext.shouldNotLogOrRedirect;
                if (canRedirect &&
                    !(0, AadKillSwitches_1.isConditionalAccessIgnoredOnEnsureStateKSActivated)() &&
                    options.isEnsureRequest &&
                    AadErrorHandler_1.AadErrorHandler._doesAadErrorCodeExist(error.message, AadConstants_1.default.CONDITIONAL_ACCESS_POLICY_ERRORS)) {
                    canRedirect = false;
                    var conditionalAcccessPolicyHitDuringEnsureState = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.ConditionalAccessDuringEnsureState');
                    conditionalAcccessPolicyHitDuringEnsureState.writeUnexpectedFailure(error.errorCode, error, requestContext.telemetryData);
                }
                if (canRedirect) {
                    _this._logger('getTokenData', 'Calling _loginRedirect()');
                    requestContext.telemetryData.isTriggerFullPageRedirect = true;
                    getTokenDataMonitor.writeExpectedFailure(error.errorCode, error, requestContext.telemetryData);
                    if (shouldReturnFailureType) {
                        error.isExpectedFailure = true;
                    }
                    if ((0, AadKillSwitches_1.isLogAllFullPageRedirectsKSActivated)()) {
                        var fullPageRedirectQos = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.FullPageRedirect');
                        if (options.isEnsureRequest) {
                            fullPageRedirectQos.writeExpectedFailure('ensureRequest', error, requestContext.telemetryData);
                        }
                        else {
                            fullPageRedirectQos.writeUnexpectedFailure('redirectNotDuringEnsure', error, requestContext.telemetryData);
                        }
                    }
                    /* eslint-disable-next-line @typescript-eslint/no-floating-promises */
                    _this._loginRedirect(requestContext);
                }
                else if (_this._isExpectedFailure(error)) {
                    getTokenDataMonitor.writeExpectedFailure(error.errorCode, error, requestContext.telemetryData);
                    if (shouldReturnFailureType) {
                        error.isExpectedFailure = true;
                    }
                }
                else {
                    getTokenDataMonitor.writeUnexpectedFailure(error.errorCode, error, requestContext.telemetryData);
                    if (shouldReturnFailureType) {
                        error.isExpectedFailure = false;
                    }
                    if (_this._isMonitorTimeoutFailure(error)) {
                        if (!(0, AadKillSwitches_1.isRetryMonitorWindowTimeoutKSActivated)() && !isRetry) {
                            return _this._getTokenDataInternal(requestContext, options, true);
                        }
                        // We are adding a second qos monitor here because MSALjs is treating these errors as expected.
                        // All it means is that they didn't receive a response from eSTS.  That is not expected by us.
                        // Since MSALjs is not going to fix these we want to be able to give an adjusted metric, but
                        // we don't want to stop counting this error.
                        var monitorTimeoutFailure = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.MonitorWindowTimeout');
                        monitorTimeoutFailure.writeUnexpectedFailure(error.errorCode, error, requestContext.telemetryData);
                    }
                }
                _this._logger('getTokenData', 'Throwing the error back to caller. Exiting.');
                throw error;
            });
        });
    };
    /**
     * Returns a promise that only resolves once the Msal Browser client has been initialized and assigned.
     * If the client hasn't been initialized, MsalBrowserClientManager will provide an initialized one.
     *
     * @param requestContext - The request context for this request.
     * @returns The promise fulfils when this._msalBrowserClient has been initialized for use.
     */
    MsalBrowserTokenProvider.prototype._ensureMsalClientIsInitialized = function (requestContext) {
        var _this = this;
        return new Promise(function (resolve) {
            if (_this._msalBrowserClient) {
                resolve();
            }
            else {
                MsalBrowserClientManager_1.MsalBrowserClientManager.getMsalBrowserClient(_this._getAuthority(), _this._getClientId(), _this._getRedirectUri(), _this._defaultConfiguration.isNaaSupported ? true : false, _this._defaultConfiguration.isPairwiseBrokerEnabled ? true : false)
                    .then(function (msalBrowserClient) {
                    _this._msalBrowserClient = msalBrowserClient;
                    resolve();
                })
                    .catch(function (error) {
                    var msalClientInitQos = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider._ensureMsalClientIsInitialized');
                    msalClientInitQos.writeUnexpectedFailure('msalClientInit', error, requestContext.telemetryData);
                });
            }
        });
    };
    /**
     * Wrapper method for msalBrowser.acquireTokenSilent(). This method is used when the current user is arleady
     * logged into to the msal-browser framework. It will retry if there are any detectable network issues
     * during msalBrowser.acquireTokenSilent().
     *
     * The token will be acquired from the cache or from the network using a refresh token. If this fails, the
     * error will be thrown to the calling method.
     *
     * The retry monitor is only invoked on retries and is considered failed each time an error has raised. The
     * acquireTokenSilentMonitor will be re-used on each retry.
     *
     * @param requestContext - The request context for this request.
     * @param acquireTokenSilentMonitor - The monitor tracking the request.
     * @param attempt - The current attempt number. This method may invoke itself in an attempt to retry.
     * @returns A promise containing the access token and full authentication response object from msal-browser.
     */
    MsalBrowserTokenProvider.prototype._acquireTokenSilent = function (requestContext, acquireTokenSilentMonitor, attempt) {
        var _this = this;
        if (attempt === void 0) { attempt = 0; }
        var extraData = requestContext.telemetryData;
        var retryAcquireTokenSilentMonitor;
        var isFirstAttempt = attempt === 0;
        if (!isFirstAttempt) {
            retryAcquireTokenSilentMonitor = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.RetryAcquireTokenSilent');
        }
        var silentRequest = this._generateSilentRequest(requestContext);
        this._logger('_acquireTokenSilent', 'Calling acquireTokenSilent with parameters:', silentRequest);
        return this._msalBrowserClient
            .acquireTokenSilent(silentRequest)
            .then(function (authResult) {
            _this._logger('_acquireTokenSilent', 'Successfully got a token.');
            extraData.alias = (!!authResult.fromCache).toString();
            acquireTokenSilentMonitor.writeSuccess(extraData);
            retryAcquireTokenSilentMonitor === null || retryAcquireTokenSilentMonitor === void 0 ? void 0 : retryAcquireTokenSilentMonitor.writeSuccess(extraData);
            return authResult;
        })
            .catch(function (error) {
            _this._logger('_acquireTokenSilent', 'Caught an error:', error);
            if (!(0, AadKillSwitches_1.isLogCorrelationIdKSActivated)()) {
                extraData.aadCorrelationId = (error === null || error === void 0 ? void 0 : error.correlationId) ? error.correlationId : '';
            }
            retryAcquireTokenSilentMonitor === null || retryAcquireTokenSilentMonitor === void 0 ? void 0 : retryAcquireTokenSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            if (_this._isExpectedFailure(error)) {
                acquireTokenSilentMonitor.writeExpectedFailure(error.errorCode, error, extraData);
            }
            else {
                acquireTokenSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            }
            _this._logger('_acquireTokenSilent', 'Throwing error back to caller.');
            throw error;
        });
    };
    /**
     * Wrapper method for msalBrowser.ssoSilent(). This method is used when the current user is not logged
     * into to the msal-browser framework. It will retry if there are any detectable network issues during
     * msalBrowser.ssoSilent().
     *
     * The token will be acquired over the network and will use the current session ID if possible. If this
     * fails, the error will be thrown to the calling method.
     *
     * The retry monitor is only invoked on later attempts and is considered failed each time an error has
     * raised. The ssoSilentMonitor will be re-used on each retry.
     *
     * @param requestContext - The request context for this request.
     * @param ssoSilentMonitor - The monitor tracking the request.
     * @param attempt - The current attempt number. This method may invoke itself in an attempt to retry.
     * @returns A promise containing the access token and full authentication response object from msal-browser.
     */
    MsalBrowserTokenProvider.prototype._ssoSilent = function (requestContext, ssoSilentMonitor, attempt) {
        var _this = this;
        if (attempt === void 0) { attempt = 0; }
        var extraData = requestContext.telemetryData;
        var retrySsoSilentMonitor;
        var isFirstAttempt = attempt === 0;
        if (!isFirstAttempt) {
            retrySsoSilentMonitor = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.RetrySsoSilent');
        }
        var ssoSilentRequest = this._generateSsoSilentRequest(requestContext);
        this._logger('_ssoSilent', 'Calling ssoSilent with parameters:', ssoSilentRequest);
        return this._msalBrowserClient
            .ssoSilent(ssoSilentRequest)
            .then(function (authResult) {
            _this._logger('_ssoSilent', 'Successfully got a token.');
            extraData.alias = (!!authResult.fromCache).toString();
            ssoSilentMonitor.writeSuccess(extraData);
            retrySsoSilentMonitor === null || retrySsoSilentMonitor === void 0 ? void 0 : retrySsoSilentMonitor.writeSuccess(extraData);
            return authResult;
        })
            .catch(function (error) {
            _this._logger('_ssoSilent', 'Caught an error:', error);
            if (!(0, AadKillSwitches_1.isLogCorrelationIdKSActivated)()) {
                extraData.aadCorrelationId = (error === null || error === void 0 ? void 0 : error.correlationId) ? error.correlationId : '';
            }
            retrySsoSilentMonitor === null || retrySsoSilentMonitor === void 0 ? void 0 : retrySsoSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            if (ssoSilentRequest.sid &&
                requestContext.loginHintType === MsalBrowserLoginHint.SESSION_ID &&
                AadErrorHandler_1.AadErrorHandler._isSessionDoesNotExistError(error.errorMessage, error.errorCode)) {
                MsalSessionIdManager_1.MsalSessionIdManager.addInvalidSessionId(ssoSilentRequest.sid);
                _this._logger('_ssoSilent', 'Invalid session ID. Retrying with loginHint as UPN.');
                attempt++;
                return _this._ssoSilent(requestContext, ssoSilentMonitor, attempt);
            }
            var hasRetriesLeft = attempt < _this._ALLOWED_NETWORK_RETRY_ATTEMPTS;
            var isAllowedToRetry = _this._isRetriableNetworkError(error) && hasRetriesLeft;
            if (isAllowedToRetry) {
                attempt++;
                _this._logger('_ssoSilent', 'Retrying.');
                return _this._ssoSilent(requestContext, ssoSilentMonitor, attempt);
            }
            else if (_this._isExpectedFailure(error)) {
                ssoSilentMonitor.writeExpectedFailure(error.errorCode, error, extraData);
            }
            else {
                ssoSilentMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            }
            _this._logger('_ssoSilent', 'Throwing error back to caller.');
            throw error;
        });
    };
    /**
     * This method wraps msal-browser's loginRedirect method. This method must call
     * MalBrowserRedirectManager.prepareForRedirect(). This ensures that the redirect page,
     * spfxsinglesignon.aspx, will know how to properly instantiate and configure msal-browser.
     *
     * This method returns nothing and immediately redirects.
     *
     * @param requestContext - The request context for this request.
     * @returns Nothing. This method will immediately perform a redirect.
     */
    MsalBrowserTokenProvider.prototype._loginRedirect = function (requestContext) {
        var _this = this;
        var extraData = requestContext.telemetryData;
        var loginRedirectRequestData = this._generateLoginRedirectRequest(requestContext);
        this._logger('_loginRedirect', 'Calling prepareForRedirect().');
        if (!(0, AadKillSwitches_1.isUseSessionStorageForRedirectScenarioProxyMonitoringKSActivated)()) {
            this._redirectManager.prepareForRedirect(requestContext.telemetryData.CorrelationId);
        }
        else {
            this._redirectManager.prepareForRedirect();
        }
        MsalSessionIdManager_1.MsalSessionIdManager.saveInvalidSessionIdsToStorage();
        this._logger('_loginRedirect', 'Calling loginRedirect.');
        return this._msalBrowserClient.loginRedirect(loginRedirectRequestData).catch(function (error) {
            if (!(0, AadKillSwitches_1.isLogCorrelationIdKSActivated)()) {
                extraData.aadCorrelationId = (error === null || error === void 0 ? void 0 : error.correlationId) ? error.correlationId : '';
            }
            _this._logger('_loginRedirect', 'Failed to redirect with error:', error);
            if (!(0, AadKillSwitches_1.isManualRedirectCancellationActivated)()) {
                // If we failed make sure we cancel the redirect state. Cancellation is normally done in _getOnRedirectNavigate, however if
                // MSAL itself aborts the redirect (e.g. if it detects an attempt to redirect in an iframe) this code is not invoked. So
                // we need to explicitly do it here if the redirect failed. It's an idempotent call so we don't need to worry about calling it
                // twice.
                _this._redirectManager.cancelRedirect();
            }
            var loginRedirectMonitor = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider._loginRedirect');
            loginRedirectMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            throw error;
        });
    };
    MsalBrowserTokenProvider.prototype._acquireTokenPopupNAA = function (requestContext) {
        var _this = this;
        var popupMonitor = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.PopupMonitorNAA');
        var popupRequest = this._generatePopupRequest(requestContext);
        var resourceEndpoint = requestContext.resourceEndpoint;
        var extraData = this._generateTelemetryData(resourceEndpoint, requestContext.authenticationScheme);
        return this._msalBrowserClient
            .acquireTokenPopup(popupRequest)
            .then(function (authResult) {
            _this._logger('_acquireTokenPopupNAA', 'Successfully got a token.');
            extraData.alias = (!!authResult.fromCache).toString();
            popupMonitor.writeSuccess(extraData);
            return authResult;
        })
            .catch(function (error) {
            _this._logger('_acquireTokenPopup', 'Caught an error.', error);
            if (!(0, AadKillSwitches_1.isLogCorrelationIdKSActivated)()) {
                extraData.aadCorrelationId = (error === null || error === void 0 ? void 0 : error.correlationId) ? error.correlationId : '';
            }
            if (_this._isExpectedFailure(error)) {
                popupMonitor.writeExpectedFailure(error.errorCode, error, extraData);
            }
            else {
                popupMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
            }
            return Promise.reject(error);
        });
    };
    MsalBrowserTokenProvider.prototype._acquireTokenPopup = function (requestContext, popupMonitor) {
        var _this = this;
        var resourceEndpoint = requestContext.resourceEndpoint;
        var resolveAuthData;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var rejectAuthData;
        var promise = (0, AadKillSwitches_1.isModifyPopupLogicToCallRequestPopupKSActivated)()
            ? undefined
            : new Promise(function (resolve, 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            reject) {
                resolveAuthData = resolve;
                rejectAuthData = reject;
            });
        var requestPopup = function () {
            if (promise) {
                return;
            }
            if ((0, AadKillSwitches_1.isModifyPopupLogicToCallRequestPopupKSActivated)()) {
                promise = new Promise(function (resolve, 
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                reject) {
                    resolveAuthData = resolve;
                    rejectAuthData = reject;
                });
            }
        };
        var showPopup = function () {
            if (!promise && (0, AadKillSwitches_1.isModifyPopupLogicToCallRequestPopupKSActivated)()) {
                requestPopup();
            }
            var extraData = _this._generateTelemetryData(resourceEndpoint, requestContext.authenticationScheme);
            var popupRequest = _this._generatePopupRequest(requestContext);
            _this._logger('_acquireTokenPopup', 'Calling acquireTokenPopup with parameters:', popupRequest);
            if (resolveAuthData) {
                resolveAuthData(_this._msalBrowserClient
                    .acquireTokenPopup(popupRequest)
                    .then(function (authResult) {
                    _this._logger('_acquireTokenPopup', 'Successfully got a token.');
                    extraData.alias = (!!authResult.fromCache).toString();
                    popupMonitor.writeSuccess(extraData);
                    return authResult;
                })
                    .catch(function (error) {
                    _this._logger('_acquireTokenPopup', 'Caught an error.', error);
                    if (!(0, AadKillSwitches_1.isLogCorrelationIdKSActivated)()) {
                        extraData.aadCorrelationId = (error === null || error === void 0 ? void 0 : error.correlationId) ? error.correlationId : '';
                    }
                    if (_this._isExpectedFailure(error)) {
                        popupMonitor.writeExpectedFailure(error.errorCode, error, extraData);
                    }
                    else {
                        popupMonitor.writeUnexpectedFailure(error.errorCode, error, extraData);
                    }
                    return Promise.reject(error);
                }));
            }
        };
        var cancel = function (error) {
            if (!promise) {
                requestPopup();
            }
            if (rejectAuthData) {
                rejectAuthData(error);
            }
        };
        sp_core_library_1._SPEventManager.instance.raiseEvent(AadTokenProvider_1.default._popupEventId, new AadTokenProvider_1.PopupEventArgs(cancel, requestPopup, showPopup));
        if (promise) {
            return promise;
        }
    };
    /**
     * Generates an MSAL SilentRequest to be used with the loginSilent method.
     *
     * @param requestContext - The request context for this request.
     * @returns An MSAL SilentRequest object.
     */
    MsalBrowserTokenProvider.prototype._generateSilentRequest = function (requestContext) {
        var resourceEndpoint = requestContext.resourceEndpoint, claims = requestContext.claims, scopes = requestContext.scopes, useCachedToken = requestContext.useCachedToken, correlationId = requestContext.telemetryData.CorrelationId;
        var silentRequestData = tslib_1.__assign(tslib_1.__assign({ account: this._getCurrentAccount(), authority: this._getAuthority(), correlationId: correlationId, scopes: scopes || this._getScopes(resourceEndpoint) }, (useCachedToken || (0, AadKillSwitches_1.isSkipCacheForSilentAuthKSActivated)()
            ? {}
            : {
                cacheLookupPolicy: msal_browser_1p_1.CacheLookupPolicy.RefreshTokenAndNetwork
            })), (claims
            ? {
                claims: claims
            }
            : {}));
        if ((0, AadFlights_1.isPoPTokenFlightEnabled)() && requestContext.authenticationScheme === ITokenProvider_1.IAuthenticationScheme.POP) {
            silentRequestData.resourceRequestUri = resourceEndpoint;
            silentRequestData.authenticationScheme = this._getAuthenticationScheme(requestContext.authenticationScheme);
            if (requestContext.resourceRequestMethod) {
                silentRequestData.resourceRequestMethod = requestContext.resourceRequestMethod;
            }
            if (requestContext.shrClaims) {
                silentRequestData.shrClaims = requestContext.shrClaims;
            }
            silentRequestData.shrNonce = requestContext.shrNonce;
        }
        return silentRequestData;
    };
    MsalBrowserTokenProvider.prototype._setLoginHint = function (requestData, requestContext) {
        if (requestContext.loginHintType === MsalBrowserLoginHint.SESSION_ID) {
            var sessionId = this._getSessionId();
            if (sessionId && !MsalSessionIdManager_1.MsalSessionIdManager.isSessionIdInvalid(sessionId)) {
                requestData.loginHint = undefined;
                requestData.sid = sessionId;
            }
            else {
                requestContext.loginHintType = MsalBrowserLoginHint.UPN;
            }
        }
        if (requestContext.loginHintType === MsalBrowserLoginHint.UPN) {
            var upn = this._getUPN();
            if (upn) {
                requestData.loginHint = upn;
                requestData.sid = undefined;
            }
            else {
                requestContext.loginHintType = MsalBrowserLoginHint.NONE;
            }
        }
        if (requestContext.loginHintType === MsalBrowserLoginHint.NONE) {
            requestData.loginHint = undefined;
            requestData.sid = undefined;
        }
    };
    /**
     * Generates an MSAL SsoSilentRequest to be used with the ssoSilent method.
     * Note: SID and login hint may be undefined if they are non-existent or invalid. This
     *       may cause the request to fail and be handled by a redirect instead.
     *
     * @param requestContext - The request context for this request.
     * @returns An MSAL SsoSilentRequest object.
     */
    MsalBrowserTokenProvider.prototype._generateSsoSilentRequest = function (requestContext) {
        var resourceEndpoint = requestContext.resourceEndpoint, claims = requestContext.claims, correlationId = requestContext.telemetryData.CorrelationId, scopes = requestContext.scopes;
        var ssoSilentRequestData = tslib_1.__assign({ authority: this._getAuthority(), correlationId: correlationId, scopes: scopes || this._getScopes(resourceEndpoint) }, (claims
            ? {
                claims: claims
            }
            : {}));
        this._setLoginHint(ssoSilentRequestData, requestContext);
        if ((0, AadFlights_1.isPoPTokenFlightEnabled)() && requestContext.authenticationScheme === ITokenProvider_1.IAuthenticationScheme.POP) {
            ssoSilentRequestData.resourceRequestUri = resourceEndpoint;
            ssoSilentRequestData.authenticationScheme = this._getAuthenticationScheme(requestContext.authenticationScheme);
            if (requestContext.resourceRequestMethod) {
                ssoSilentRequestData.resourceRequestMethod = requestContext.resourceRequestMethod;
            }
            if (requestContext.shrClaims) {
                ssoSilentRequestData.shrClaims = requestContext.shrClaims;
            }
            ssoSilentRequestData.shrNonce = requestContext.shrNonce;
        }
        return ssoSilentRequestData;
    };
    /**
     * Generates an MSAL SilentRequest to be used with the loginSilent method.
     *
     * @param requestContext - The request context for this request.
     * @returns An MSAL SilentRequest object.
     */
    MsalBrowserTokenProvider.prototype._generatePopupRequest = function (requestContext) {
        var resourceEndpoint = requestContext.resourceEndpoint, claims = requestContext.claims, scopes = requestContext.scopes, correlationId = requestContext.telemetryData.CorrelationId;
        var popupRequestData = tslib_1.__assign({ account: this._getCurrentAccount(), authority: this._getAuthority(), correlationId: correlationId, scopes: scopes || this._getScopes(resourceEndpoint) }, (claims
            ? {
                claims: claims
            }
            : {}));
        this._setLoginHint(popupRequestData, requestContext);
        if ((0, AadFlights_1.isPoPTokenFlightEnabled)() && requestContext.authenticationScheme === ITokenProvider_1.IAuthenticationScheme.POP) {
            popupRequestData.resourceRequestUri = resourceEndpoint;
            popupRequestData.authenticationScheme = this._getAuthenticationScheme(requestContext.authenticationScheme);
            if (requestContext.resourceRequestMethod) {
                popupRequestData.resourceRequestMethod = requestContext.resourceRequestMethod;
            }
            if (requestContext.shrClaims) {
                popupRequestData.shrClaims = requestContext.shrClaims;
            }
            popupRequestData.shrNonce = requestContext.shrNonce;
        }
        return popupRequestData;
    };
    /**
     * Generates telemetry data to be added to QoS Monitors. We track:
     * - alias: Marks cache hits. This will be true if the request came from the cache.
     * - aadSessionId: AAD Session ID used in ssoSilent scenarios.
     * - CorrelationId: The correlation ID of the token request.
     * - isInternal: True if first party application ID.
     * - isPageVisibleStart: True if page is visible at scenario start.
     * - isPageVisibleEnd: True if page is visible at scenario end.
     * - redirectUri: redirect URI used in redirect and ssoSilent scenarios
     *
     * @param resourceEndpoint - The resource a token is being requested for.
     * @returns An IMsalBrowserTokenProviderExtraData object that can be added to QoS Monitor writes.
     */
    MsalBrowserTokenProvider.prototype._generateTelemetryData = function (resourceEndpoint, authenticationScheme, callersQosName) {
        var isInternal = this._defaultConfiguration.servicePrincipalId === AadConstants_1.default.PRE_AUTHORIZED_APP_PRINCIPAL_ID;
        var telemetryData = {
            alias: 'false', // Alias column is used to mark cache hits
            aadSessionId: this._getSessionId(),
            CorrelationId: sp_core_library_1.Guid.newGuid().toString(),
            isInternal: isInternal,
            isPageVisibleStart: document.visibilityState === 'visible',
            isPageVisibleEnd: false,
            redirectUri: this._getRedirectUri(),
            msalVersion: '4.2.0',
            callersQosName: callersQosName
        };
        if (telemetryData.isInternal) {
            telemetryData.name = resourceEndpoint;
        }
        if ((0, AadFlights_1.isPoPTokenFlightEnabled)()) {
            telemetryData.authenticationScheme = authenticationScheme;
        }
        return telemetryData;
    };
    /**
     * Given an error, this method will return true if the token provider is allowed to redirect
     * and the error can be solved with a redirect.
     *
     * Note: Redirects are not performed for IE.
     *
     * @param error - An msalBrowser AuthError.
     * @returns True if the error can be solved with a redirect and there are remaining redirects.
     */
    MsalBrowserTokenProvider.prototype._isErrorEligibleForRedirect = function (error) {
        var isInteractionRequiredError = this._isInteractionRequiredError(error);
        var isBrowserIE = sp_core_library_1._BrowserDetection.getBrowserInformation().browser === sp_core_library_1._Browser.IE;
        var isAbleToRedirect = isInteractionRequiredError && !isBrowserIE;
        return isAbleToRedirect;
    };
    MsalBrowserTokenProvider.prototype._shouldUsePopup = function () {
        return (!(0, AadKillSwitches_1.isEnablePopupFlowForMsalV3KSActivated)() && !!this._defaultConfiguration.isMsalTokenProviderPopupEnabled);
    };
    /**
     * Given an error, this method will return true if the provided error is any type of 'Interaction Required'
     * error. These errors can be solved by invoking a full-page redirect (interaction).
     *
     * @param error - An msal-browser AuthError.
     * @returns True if the error provided can be solved by a redirect and false otherwise.
     */
    MsalBrowserTokenProvider.prototype._isInteractionRequiredError = function (error) {
        return (error instanceof msal_browser_1p_1.InteractionRequiredAuthError ||
            AadErrorHandler_1.AadErrorHandler._isInteractionRequired(error.message, error.errorCode) ||
            error.errorCode === 'no_account_error');
    };
    /**
     * Given an msal-browser AuthError, returns true if the error is an expected failure for QoS Monitors.
     * These errors can either be ignored (i.e., TabStop test) or solved by a full-page redirect (as long as
     * there are redirect attempts remaining).
     *
     * @param error - An msal-browser AuthError.
     * @returns True if the error is expected and be recorded as successful for QoS Monitors.
     */
    MsalBrowserTokenProvider.prototype._isExpectedFailure = function (error) {
        var canAttemptRedirect = this._isErrorEligibleForRedirect(error) &&
            (this._redirectManager.hasRedirectAttemptsLeft() || this._redirectManager.isRedirectInProgress());
        var doesAadErrorCodeExist = AadErrorHandler_1.AadErrorHandler._doesAadErrorCodeExist(error.message, AadConstants_1.default.EXPECTED_AAD_ERRORS);
        var isTabStopTest = this._isTabStopTest();
        var isUserCancelledError = !(0, AadKillSwitches_1.isLogUserCancelledErrorAsExpectedFailureKSActivated)() &&
            USER_CANCELLED_ERROR_RESULT_CODES.indexOf(error.errorCode) > -1;
        return canAttemptRedirect || doesAadErrorCodeExist || isTabStopTest || isUserCancelledError;
    };
    MsalBrowserTokenProvider.prototype._isMonitorTimeoutFailure = function (error) {
        return error.errorCode === AadConstants_1.default.MONITOR_WINDOW_TIMEOUT;
    };
    /**
     * This method returns true if a TabStop test is currently being run. TabStop tests are
     * known to cause issues and so they are generally recorded as expected failures.
     *
     * @returns True if a TabStop test is running.
     */
    MsalBrowserTokenProvider.prototype._isTabStopTest = function () {
        var userAgentString = sp_core_library_1._BrowserDetection.getBrowserInformation().userAgent || '';
        var isTabStopTest = userAgentString.indexOf('TabStop/1.0') > -1;
        return isTabStopTest;
    };
    /**
     * Generates an MSAL RedirectRequest to be used with the loginRedirect method.
     *
     * @param requestContext - The request context.
     * @returns An MSAL RedirectRequest object.
     */
    MsalBrowserTokenProvider.prototype._generateLoginRedirectRequest = function (requestContext) {
        var resourceEndpoint = requestContext.resourceEndpoint, correlationId = requestContext.telemetryData.CorrelationId;
        var redirectRequestData = {
            authority: this._getAuthority(),
            correlationId: correlationId,
            onRedirectNavigate: this._getOnRedirectNavigate(requestContext),
            redirectUri: this._getRedirectUri(),
            scopes: this._getScopes(resourceEndpoint),
            state: window.location.href,
            claims: requestContext.claims
        };
        if ((0, AadFlights_1.isPoPTokenFlightEnabled)() && requestContext.authenticationScheme === ITokenProvider_1.IAuthenticationScheme.POP) {
            redirectRequestData.resourceRequestUri = resourceEndpoint;
            redirectRequestData.authenticationScheme = this._getAuthenticationScheme(requestContext.authenticationScheme);
            if (requestContext.resourceRequestMethod) {
                redirectRequestData.resourceRequestMethod = requestContext.resourceRequestMethod;
            }
            if (requestContext.shrClaims) {
                redirectRequestData.shrClaims = requestContext.shrClaims;
            }
            redirectRequestData.shrNonce = requestContext.shrNonce;
        }
        return redirectRequestData;
    };
    /**
     * This method is used to retrieve the callback for the onRedirectNavigate option on MSAL RedirectRequests.
     * If this method returns false, then MSAL will cancel the redirect. This method raises an event
     * that gives the method requesting a token the opportunity to cancel the redirect.
     *
     * Note: This method returns a method in order to correctly bind 'this'. If
     *       onRedirectNavigateCallback was a class-level method and included
     *       in a RedirectRequest as a parameter, 'this' fails to bind and
     *       throw a runtime error.
     *
     * @returns Returning callback for the onRedirectNavigate option.
     */
    MsalBrowserTokenProvider.prototype._getOnRedirectNavigate = function (requestContext) {
        var _this = this;
        var onRedirectNavigateCallback = function (url) {
            _this._redirectCancelled = false;
            sp_core_library_1._SPEventManager.instance.raiseEvent(AadTokenProvider_1.default._onBeforeRedirectEventId, new AadTokenProvider_1.BeforeRedirectEventArgs(url, _this._cancelRedirect.bind(_this), _this._defaultConfiguration));
            // If we are in tab cancel the redirect.
            if (window.sessionStorage.getItem('_isRunningTABTest') === 'true') {
                _this._redirectCancelled = true;
            }
            if (_this._redirectCancelled) {
                _this._redirectManager.cancelRedirect();
            }
            else if ((0, AadKillSwitches_1.isLogAllFullPageRedirectsKSActivated)()) {
                var fullPageRedirectQos = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.FullPageRedirectTriggering', true, true);
                fullPageRedirectQos.writeUnexpectedFailure('FullPageRedirect', undefined, requestContext.telemetryData);
            }
            return !_this._redirectCancelled;
        };
        return onRedirectNavigateCallback;
    };
    /**
     * Attempts to retrieve the current user account logged into the MSAL framework. The userPrincipalName
     * from the configuration object is used to determine if the account is logged in. This will return
     * undefined if no account is logged in.
     *
     * @returns An MSAL AccountInfo object of the currently logged in user or undefined if there is no
     *          logged in user.
     */
    MsalBrowserTokenProvider.prototype._getCurrentAccount = function () {
        var userName = this._defaultConfiguration.userPrincipalName || '';
        var localId = this._defaultConfiguration.aadUserId || '';
        var currentAccountByUsername = this._msalBrowserClient.getAccountByUsername(userName);
        var currentAccountByLocalId = this._msalBrowserClient.getAccountByLocalId(localId);
        var currentActiveAccount = this._msalBrowserClient.getActiveAccount();
        if (currentAccountByUsername || currentAccountByLocalId) {
            this._logger('_getCurrentAccount', 'Found an account', {
                currentAccountByLocalId: currentAccountByLocalId,
                currentAccountByUsername: currentAccountByUsername
            });
        }
        else {
            this._logger('_getCurrentAccount', 'No account found');
        }
        return currentAccountByUsername || currentAccountByLocalId || currentActiveAccount || undefined;
    };
    /**
     * This method is used to cancel redirects. It is binded to an event raised before full page redirects
     * so that the method requesting a token may choose to cancel the redirect if necessary by calling this.
     * By default redirects are turned on.
     */
    MsalBrowserTokenProvider.prototype._cancelRedirect = function () {
        this._redirectCancelled = true;
    };
    /**
     * This method returns whether or not a given error is a retriable network related error.
     *
     * @param error - An MSAL error code.
     * @returns Whether or not the error is network related.
     */
    MsalBrowserTokenProvider.prototype._isRetriableNetworkError = function (error) {
        return AadErrorHandler_1.AadErrorHandler._isTokenRenewalTimeout(error === null || error === void 0 ? void 0 : error.errorCode);
    };
    /**
     * Using the userPrincipalName from the configuration object, returns whether or not the user is logged
     * into the MSAL framework.
     *
     * @returns True if the current user is logged into the MSAL framework.
     */
    MsalBrowserTokenProvider.prototype._isCurrentUserLoggedInToMsal = function () {
        return this._getCurrentAccount() !== undefined;
    };
    /**
     * Using the configuration object passed to the token provider, assembles and returns the 'authority' string
     * to be used in MSAL requests.
     *
     * @returns The 'authority' string to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getAuthority = function () {
        return this._defaultConfiguration.aadInstanceUrl + '/' + this._defaultConfiguration.aadTenantId;
    };
    /**
     * Using the userPrincipalName from the configuration object passed to the token provider, returns the
     * 'upn' string to be used in MSAL requests.
     *
     * @returns The 'loginHint' string to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getUPN = function () {
        return this._defaultConfiguration.userPrincipalName;
    };
    /**
     * Given the resource a token is being requested for, returns the 'scopes' array to be used in MSAL
     * requests. Scopes are always returned as a single string in an array, where the scope requested is the
     * default scope.
     *
     * This scope will provide access to all preauthorized scopes and does not provide granular scope access.
     *
     * Example:
     *   resourceEndpoint: contoso.sharepoint.com
     *   returns: ['contoso.sharepoint.com/.default']
     *
     * @param resourceEndpoint - The resource a token is being requested for
     * @returns A scope array to be used with MSAL requests for the given resource.
     */
    MsalBrowserTokenProvider.prototype._getScopes = function (resourceEndpoint) {
        return [resourceEndpoint + '/.default'];
    };
    /**
     * Using the aadSessionId from the configuration object passed to the token provider, returns the 'sid'
     * string to be used in MSAL requests. If the session ID is not a valid GUID or does not exist, this
     * will return undefined.
     *
     * Note: A value of undefined may result in requiring a full page redirect.
     *
     * @returns The 'sid' field to be used in MSAL requests or undefined.
     */
    MsalBrowserTokenProvider.prototype._getSessionId = function () {
        var sessionId = this._defaultConfiguration.aadSessionId;
        var isValidSessionId = !!sp_core_library_1.Guid.tryParse(sessionId);
        if (!isValidSessionId) {
            sessionId = undefined;
        }
        if (sessionId) {
            this._logger('_getSessionId', 'Found session ID', sessionId);
        }
        else {
            this._logger('_getSessionId', 'No session ID was found');
        }
        return sessionId;
    };
    /**
     * Using the servicePrincipalId from the configuration object passed to the token provider, returns the
     * 'clientId' string to be used in MSAL requests.
     *
     * @returns The 'clientId' field to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getClientId = function () {
        return this._defaultConfiguration.servicePrincipalId;
    };
    /**
     * Using the redirectUri from the configuration object passed to the token provider, returns the
     * 'redirectUri' string to be used in MSAL requests.
     *
     * @returns The 'redirectUri' field to be used in MSAL requests.
     */
    MsalBrowserTokenProvider.prototype._getRedirectUri = function () {
        return this._defaultConfiguration.redirectUri;
    };
    /**
     * Logger for debugging. If the query string parameter 'msalLogging=true' is present,
     * logs will be printed to the console.
     */
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
    MsalBrowserTokenProvider.prototype._logger = function (fnName, message, extraData) {
        if (this._shouldPrintDebugLogs) {
            /* eslint-disable no-console */
            console.log('[sp-http][MsalBrowserTokenProvider][' + fnName + '][1]: ' + message);
            if (extraData) {
                console.log('[sp-http][MsalBrowserTokenProvider][' + fnName + '][2] Extra Data: ');
                console.log(extraData);
                /* eslint-enable no-console */
            }
        }
    };
    /**
     * to convert auth scheme of IAuthenticationScheme to AuthenticationScheme
     */
    MsalBrowserTokenProvider.prototype._getAuthenticationScheme = function (authenticationScheme) {
        var authScheme;
        if (authenticationScheme === ITokenProvider_1.IAuthenticationScheme.BEARER) {
            authScheme = msal_browser_1p_1.AuthenticationScheme.BEARER;
        }
        else {
            authScheme = msal_browser_1p_1.AuthenticationScheme.POP;
        }
        return authScheme;
    };
    MsalBrowserTokenProvider.prototype._updatePageEndVisibility = function (extraData) {
        if (extraData) {
            extraData.isPageVisibleEnd = document.visibilityState === 'visible';
        }
    };
    MsalBrowserTokenProvider.prototype._monitorFullPageRedirectReliability = function () {
        var redirectMonitor = new sp_diagnostics_1._QosMonitor('MsalBrowserV3TokenProvider.fullPageRedirect');
        var correlationId = window.sessionStorage.getItem(MsalRedirectManager_1.CORRELATION_ID_SESSION_STORAGE_KEY) || '';
        var redirectStartTimeDateString = window.sessionStorage.getItem(MsalRedirectManager_1.CURRENT_REDIRECT_START_TIME_SESSION_STORAGE_KEY);
        var redirectStartTime = redirectStartTimeDateString
            ? new Date(redirectStartTimeDateString)
            : undefined;
        var timeElapsed = redirectStartTime ? Date.now() - redirectStartTime.getTime() : 0;
        var isWithinSuccessfulTimeRange = !!redirectStartTime && timeElapsed <= SUCCESSFUL_REDIRECT_TIMEFRAME;
        var extraData = {
            isInternal: true,
            alias: 'false',
            timeElapsed: timeElapsed,
            CorrelationId: correlationId
        };
        if (isWithinSuccessfulTimeRange) {
            redirectMonitor.writeSuccess(extraData);
        }
        else {
            redirectMonitor.writeUnexpectedFailure('RedirectOccurredAfterTimeRange', new Error('Redirect occurred outside of time range'), extraData);
        }
        window.sessionStorage.removeItem(MsalRedirectManager_1.CORRELATION_ID_SESSION_STORAGE_KEY);
        window.sessionStorage.removeItem(MsalRedirectManager_1.CURRENT_REDIRECT_START_TIME_SESSION_STORAGE_KEY);
    };
    MsalBrowserTokenProvider.prototype._isResourceEndpointExpired = function (resourceEndpoint) {
        if (popNotSupported.has(resourceEndpoint)) {
            var resourceTimestamp = popNotSupported.get(resourceEndpoint);
            if (resourceTimestamp !== undefined) {
                var expireTimestamp = new Date(resourceTimestamp);
                expireTimestamp.setDate(expireTimestamp.getDate() + POP_SUPPORT_TIMEFRAME_LIMIT);
                if (new Date() > expireTimestamp) {
                    return true;
                }
            }
        }
        return false;
    };
    return MsalBrowserTokenProvider;
}());
exports.MsalBrowserTokenProvider = MsalBrowserTokenProvider;
//# sourceMappingURL=MsalBrowserTokenProvider.js.map