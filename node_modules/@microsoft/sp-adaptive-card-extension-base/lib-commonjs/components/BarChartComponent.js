"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._preProcessBarChartParameters = exports._barConfigurationToParameters = void 0;
var tslib_1 = require("tslib");
var DataVisualizationComponent_1 = require("./DataVisualizationComponent");
/**
 * Convert bar chart configuration to data visualization parameters.
 *
 * @internal
 */
function _barConfigurationToParameters(configuration) {
    return configuration;
}
exports._barConfigurationToParameters = _barConfigurationToParameters;
/**
 * Changes the value to a comparable value.
 * @remarks If the value is a Date, it will be converted to a number.
 *
 * @param value - value to be converted to comparable value
 * @returns comparable value
 * @internal
 */
function _getComparableValue(value) {
    if (value instanceof Date) {
        return value.getTime();
    }
    return value;
}
function _getBarChartXAxis(params, type, pointsCount) {
    var _a, _b;
    var labelValues = tslib_1.__spreadArray([], ((_b = (_a = params.xAxis) === null || _a === void 0 ? void 0 : _a.labelValues) !== null && _b !== void 0 ? _b : []), true);
    /**
     * If Developer dont provide x-axis labels, then generate them from series
     *
     * Number and Date types - sort in ascending order and pick last (5)pointsCount labels
     * String type
     * - Pick from last of series - 1 followed by series - 2 and series - 3
     * - Example: series - 1: ['A','Q','T'], series - 2: [A,B,C,Y,Z], series - 3: [A,B,X,S,H] and pointsCount = 5
     * - we need pur xAxis labels as ['Y','Z','A','Q','T']
     * - To achieve this we are traversing each series in reverse order and picking unique labels and then reversing the labels again
     */
    if (labelValues.length === 0) {
        var _loop_1 = function (series) {
            var _loop_2 = function (i) {
                if (!labelValues.find(function (value) { return _getComparableValue(value) === _getComparableValue(series.data[i].x); })) {
                    labelValues.push(series.data[i].x);
                }
            };
            for (var i = series.data.length - 1; i >= 0; i--) {
                _loop_2(i);
            }
        };
        for (var _i = 0, _c = params.series; _i < _c.length; _i++) {
            var series = _c[_i];
            _loop_1(series);
        }
        if (type === 'date') {
            labelValues.sort(function (a, b) { return a.getTime() - b.getTime(); });
        }
        else if (type === 'number') {
            labelValues.sort(function (a, b) { return a - b; });
        }
        else {
            labelValues.reverse();
        }
    }
    // If x-axis labels are more than allowed points, then slice them - take last pointsCount labels
    if (labelValues.length > pointsCount) {
        labelValues = labelValues.slice(labelValues.length - pointsCount);
    }
    return tslib_1.__assign(tslib_1.__assign({}, params.xAxis), { labelValues: labelValues });
}
function _getBarChartSeries(params) {
    var _a, _b;
    var labelsSet = new Set((_b = (_a = params.xAxis) === null || _a === void 0 ? void 0 : _a.labelValues) === null || _b === void 0 ? void 0 : _b.map(function (value) { return _getComparableValue(value); }));
    return params.series.map(function (series) {
        return tslib_1.__assign(tslib_1.__assign({}, series), { data: series.data.filter(function (data) { return labelsSet.has(_getComparableValue(data.x)); }) });
    });
}
function _getBarChartTypeByData(series) {
    for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
        var singleSeries = series_1[_i];
        for (var _a = 0, _b = singleSeries.data; _a < _b.length; _a++) {
            var data = _b[_a];
            if (data.x instanceof Date) {
                return 'date';
            }
            else if (typeof data.x === 'string') {
                return 'string';
            }
            else if (typeof data.x === 'number') {
                return 'number';
            }
        }
    }
    return 'number';
}
function _getBarChartShowDataLabels(params, isPartialHeightChart, isMediumSizedChart, cardSize) {
    return (params.showDataLabels === true &&
        !isPartialHeightChart &&
        !isMediumSizedChart &&
        params.series.length === 1 &&
        cardSize === 'Large');
}
function _preProcessBarChartParameters(parameters, hasHeader, hasDescription, hasFooter, cardSize) {
    var params = tslib_1.__assign({}, parameters);
    var _a = (0, DataVisualizationComponent_1._getCartesianChartLayoutProperties)(params, hasHeader, hasDescription, hasFooter, cardSize), isMediumSizedChart = _a.isMediumSizedChart, isPartialHeightChart = _a.isPartialHeightChart, showLegend = _a.showLegend, position = _a.position;
    // If at least one of series[].data[].x is of type Date, set type to 'date'
    var type = _getBarChartTypeByData(params.series);
    /**
     * Allowed points count as per chart size
     * Large - 5 points
     * Medium - single series - 3 points
     * Medium - multiple series - 2 points
     */
    var pointsCount = isMediumSizedChart ? (params.series.length > 1 ? 2 : 3) : 5;
    params.xAxis = _getBarChartXAxis(params, type, pointsCount);
    params.series = _getBarChartSeries(params);
    params._metadata = {
        type: type,
        xLabelsCount: pointsCount,
        yLabelsCount: isPartialHeightChart ? 3 : 4,
        showLegend: showLegend,
        position: position,
        showDataLabels: _getBarChartShowDataLabels(params, isPartialHeightChart, isMediumSizedChart, cardSize)
    };
    return params;
}
exports._preProcessBarChartParameters = _preProcessBarChartParameters;
//# sourceMappingURL=BarChartComponent.js.map