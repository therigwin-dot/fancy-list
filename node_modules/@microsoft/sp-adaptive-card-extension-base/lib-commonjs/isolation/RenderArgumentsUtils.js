"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRenderArgumentsForMessaging = exports.prepareRenderArgumentsForMessaging = void 0;
var tslib_1 = require("tslib");
var sp_lodash_subset_1 = require("@microsoft/sp-lodash-subset");
var BaseComponent_1 = require("../components/BaseComponent");
var sp_diagnostics_1 = require("@microsoft/sp-diagnostics");
var Killswitches_1 = require("../common/Killswitches");
/**
 * Prepares render arguments for messaging scenarios such as VCM and Bot ACE.
 *
 * @internal
 */
function prepareRenderArgumentsForMessaging(renderArguments) {
    var _a, _b, _c, _d;
    // the monitor is used to track the performance of this function
    var qosMonitor = new sp_diagnostics_1._QosMonitor('AdaptiveCardExtension.prepareRenderArgumentsForMessaging');
    if (!(0, Killswitches_1.isCorrectlyStripRenderParametersKSActivated)()) {
        //
        // corrected flow: we need to process quick view if there is quickLook property; card view if there is a card property - INDEPENDENTLY of lastUpdatedType
        //
        var quickView = renderArguments.quickLook;
        var card = renderArguments.card;
        var eventComponents = void 0;
        if (quickView) {
            if (quickView.quickViewType === 'AdaptiveCardQuickView') {
                // AC Quick View
                var acQVRenderParemeters = quickView;
                if (!(0, Killswitches_1.isKeyboardFocusViewNavChangesKSActivated)() &&
                    ((_a = acQVRenderParemeters.focusParameters) === null || _a === void 0 ? void 0 : _a._lastFocusedElement)) {
                    // we need to remove lastFocusedElement
                    quickView = tslib_1.__assign(tslib_1.__assign({}, acQVRenderParemeters), { focusParameters: tslib_1.__assign(tslib_1.__assign({}, acQVRenderParemeters.focusParameters), { _lastFocusedElement: undefined }) });
                }
            }
            else {
                // Web Quick View
                quickView = _prepareWebQuickViewForMessaging(quickView);
            }
        }
        if (card) {
            // processing card view
            var _e = _prepareCardViewForMessaging(card.cardViewParameters, renderArguments.instanceId), cardViewParameters = _e[0], cardViewEventComponents = _e[1];
            card.cardViewParameters = cardViewParameters;
            eventComponents = cardViewEventComponents;
        }
        qosMonitor.writeSuccess({
            viewType: renderArguments.lastUpdatedType === 'QuickView'
                ? quickView.quickViewType
                : card.cardViewParameters.cardViewType
        });
        return {
            renderArguments: tslib_1.__assign(tslib_1.__assign({}, renderArguments), { quickLook: quickView, card: card }),
            eventComponents: eventComponents
        };
    }
    else {
        if ((renderArguments.lastUpdatedType === 'QuickView' &&
            ((0, Killswitches_1.isPrepareHTMLQVForMessagingKSActivated)() ||
                ((_b = renderArguments.quickLook) === null || _b === void 0 ? void 0 : _b.quickViewType) === 'AdaptiveCardQuickView')) ||
            !((_c = renderArguments.card) === null || _c === void 0 ? void 0 : _c.cardViewParameters)) {
            var acQVRenderParemeters = renderArguments.quickLook;
            if (!(0, Killswitches_1.isKeyboardFocusViewNavChangesKSActivated)() &&
                ((_d = acQVRenderParemeters.focusParameters) === null || _d === void 0 ? void 0 : _d._lastFocusedElement)) {
                // we need to remove lastFocusedElement
                return {
                    renderArguments: tslib_1.__assign(tslib_1.__assign({}, renderArguments), { quickLook: tslib_1.__assign(tslib_1.__assign({}, acQVRenderParemeters), { focusParameters: tslib_1.__assign(tslib_1.__assign({}, acQVRenderParemeters.focusParameters), { _lastFocusedElement: undefined }) }) })
                };
            }
            return {
                renderArguments: renderArguments
            };
        }
        var viewType = void 0;
        var eventComponents = void 0;
        if (renderArguments.lastUpdatedType === 'QuickView') {
            // processing Web QV
            renderArguments.quickLook = _prepareWebQuickViewForMessaging(renderArguments.quickLook);
            viewType = renderArguments.quickLook.quickViewType;
        }
        else {
            // processing card view
            var _f = _prepareCardViewForMessaging(renderArguments.card.cardViewParameters, renderArguments.instanceId), cardViewParameters = _f[0], cardViewEventComponents = _f[1];
            renderArguments.card.cardViewParameters = cardViewParameters;
            eventComponents = cardViewEventComponents;
            viewType = cardViewParameters.cardViewType;
        }
        qosMonitor.writeSuccess({
            viewType: viewType
        });
        return {
            renderArguments: renderArguments,
            eventComponents: eventComponents
        };
    }
}
exports.prepareRenderArgumentsForMessaging = prepareRenderArgumentsForMessaging;
/**
 * Gets render arguments for messaging scenarios such as VCM and Bot ACE.
 *
 * @internal
 */
function getRenderArgumentsForMessaging(ace, renderType) {
    var _a;
    var renderArguments = ace._getRenderArguments(renderType);
    if (renderType !== 'Card' || !((_a = renderArguments.card) === null || _a === void 0 ? void 0 : _a.cardViewParameters)) {
        return {
            renderArguments: renderArguments
        };
    }
    return prepareRenderArgumentsForMessaging(renderArguments);
}
exports.getRenderArgumentsForMessaging = getRenderArgumentsForMessaging;
function _prepareWebQuickViewForMessaging(webQuickViewRenderArguments) {
    var clonedArguments = (0, sp_lodash_subset_1.cloneDeep)(webQuickViewRenderArguments);
    var clonedArgumentsObject = clonedArguments;
    Object.keys(clonedArgumentsObject).forEach(function (key) {
        if (typeof clonedArgumentsObject[key] === 'function') {
            delete clonedArgumentsObject[key];
        }
    });
    return clonedArguments;
}
function _prepareCardViewForMessaging(originalCardViewParameters, instanceId) {
    // collecting event handlers
    var handledEvents = _getEventHandlers(originalCardViewParameters);
    if (!handledEvents) {
        return [originalCardViewParameters, undefined];
    }
    // We need to clone the parameters because we don't want to modify the original object.
    var cardViewParameters = (0, sp_lodash_subset_1.cloneDeep)(originalCardViewParameters);
    var body = cardViewParameters.body, footer = cardViewParameters.footer;
    var eventComponents = new Map();
    _prepareCardPartForMessaging(instanceId, 'body', body, originalCardViewParameters.body, handledEvents.body, eventComponents);
    _prepareCardPartForMessaging(instanceId, 'footer', footer, originalCardViewParameters.footer, handledEvents.footer, eventComponents);
    return [cardViewParameters, eventComponents];
}
/**
 * Prepares the card view part (such as body, footer, etc.) for messaging.
 * If there are any event handlers, we will return them back (as they're stripped in serialzation) and propagate id and _events properties to communicate the events back.
 */
function _prepareCardPartForMessaging(instanceId, cardViewPart, components, originalComponents, handledEvents, eventComponents) {
    if (!components || !handledEvents) {
        return;
    }
    components.forEach(function (component, index) {
        var componentHandledEvents = handledEvents[index];
        if (!componentHandledEvents) {
            return;
        }
        //
        // After graduating d2cb3786-200c-408f-a646-6d091eadc1be id will be already there, so we don't need to generate it.
        //
        var componentId = (0, BaseComponent_1.generateComponentId)(instanceId, cardViewPart, component, index);
        component.id = componentId;
        component._events = componentHandledEvents;
        if (!(0, Killswitches_1.isRemoveFunctionsForMessagingKSActivated)()) {
            componentHandledEvents.forEach(function (eventName) {
                delete component[eventName];
            });
        }
        eventComponents.set(componentId, originalComponents[index]);
    });
}
/**
 * Collects all event handlers (names of handled events) from the card view parameters.
 */
function _getEventHandlers(cardViewParameters) {
    var bodyEventHandlers = _getCardPartEventHandlers(cardViewParameters.body);
    var footerEventHandlers = _getCardPartEventHandlers(cardViewParameters.footer);
    if (!bodyEventHandlers && !footerEventHandlers) {
        return undefined;
    }
    return {
        body: bodyEventHandlers,
        footer: footerEventHandlers
    };
}
/**
 * Collects all event handlers (functions) from the card part (such as body, footer, etc.).
 */
function _getCardPartEventHandlers(cardPart) {
    // array with undefined values is more performant that Map with integer keys
    // we also can't use compoents' ids here as they are optional
    if (!cardPart) {
        return undefined;
    }
    var hasHandlers = false;
    var handlers = cardPart.map(function (component) {
        var componentObject = component;
        var eventHandlers;
        Object.keys(component).forEach(function (key) {
            if (typeof componentObject[key] === 'function') {
                if (!eventHandlers) {
                    eventHandlers = [];
                }
                eventHandlers.push(key);
            }
        });
        hasHandlers = hasHandlers || !!eventHandlers;
        return eventHandlers;
    });
    if (!hasHandlers) {
        return undefined;
    }
    return handlers;
}
//# sourceMappingURL=RenderArgumentsUtils.js.map