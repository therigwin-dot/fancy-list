"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsAppsClient = void 0;
var sp_diagnostics_1 = require("@microsoft/sp-diagnostics");
var sp_http_1 = require("@microsoft/sp-http");
var sp_page_context_1 = require("@microsoft/sp-page-context");
var Flights_1 = require("../common/Flights");
var sp_lodash_subset_1 = require("@microsoft/sp-lodash-subset");
// base teams apps endpoint
var MS_GRAPH_TEAMS_APPS_ENDPOINT = '/appCatalogs/teamsApps';
// QSP to fetch all teams apps with dashboard cards
var MS_GRAPH_FETCH_TEAMS_APPS_QSP = "$expand=appDefinitions($expand=outlineIcon,colorIcon,dashboardCards)&$filter=appDefinitions/any(a:a/dashboardCards/$count ne 0)";
// QSP to check permissions for the list of app ids
var MS_GRAPH_CHECK_PERMISSIONS_QSP = "$expand=appDefinitions($expand=dashboardCards)&$filter=appDefinitions/any(a:a/dashboardCards/$count ne 0) and id in ('{appIds}')";
var MS_GRAPH_API_VERSION = 'beta';
// the number of app ids we can process without batching the request to avoid the URL length limit
var MAX_IDS_WITHOUT_BATCHING = 30;
var MAX_REQUESTS_PER_BATCH = 10;
var MANIFEST_VERSION = 2;
var ADVANCED_TOOLBOX_GROUP_ID = '5c03119e-3074-46fd-976b-c60198311f70';
/**
 * The client for the Teams Apps sync.
 *
 * @internal
 */
var TeamsAppsClient = /** @class */ (function () {
    function TeamsAppsClient(serviceScope) {
        /**
         * Map[teamsAppId, Promise[Set[teamsAppId]]]
         *
         * We store a map where the same promise can be used for multiple entries.
         * In that case we can avoid multiple requests to the API for the same teamsAppId as well as avoid race conditions and allow to make extra requests if needed.
         */
        this._appComponentsPermissionsPromises = new Map();
        this._serviceScope = serviceScope;
    }
    /**
     * Gets the list of Teams App components from Teams App Catalog.
     * @returns Promise that resolves to the list of Teams App components.
     */
    TeamsAppsClient.prototype.getTeamsAppComponentManifests = function () {
        var _this = this;
        if (!TeamsAppsClient._getTeamsAppComponentManifestsPromise) {
            if (!(0, Flights_1.isBotAcesFromTeamsEnabled)()) {
                TeamsAppsClient._getTeamsAppComponentManifestsPromise = Promise.resolve([]);
            }
            else {
                var monitor_1 = new sp_diagnostics_1._QosMonitor('TeamsAppsClient.FetchTeamsApp');
                TeamsAppsClient._getTeamsAppComponentManifestsPromise = this._msGraphClient
                    .then(function (client) {
                    return client
                        .api("".concat(MS_GRAPH_TEAMS_APPS_ENDPOINT, "?").concat(MS_GRAPH_FETCH_TEAMS_APPS_QSP))
                        .version(MS_GRAPH_API_VERSION)
                        .get();
                })
                    .then(function (response) {
                    var manifestsPromises = response.value.map(function (item) {
                        return _this._teamsAppCatalogItemToAceManifests(item);
                    });
                    return Promise.all(manifestsPromises).then(function (manifests) {
                        var flatManifests = [];
                        manifests.forEach(function (item) {
                            flatManifests.push.apply(flatManifests, item);
                        });
                        monitor_1.writeSuccess();
                        return flatManifests;
                    });
                })
                    .catch(function (error) {
                    monitor_1.writeUnexpectedFailure(undefined, error);
                    // removing reference to the promise to allow retry
                    TeamsAppsClient._getTeamsAppComponentManifestsPromise = undefined;
                    return [];
                });
            }
        }
        return TeamsAppsClient._getTeamsAppComponentManifestsPromise;
    };
    /**
     * Syncs the Teams App component into SharePoint App Catalog.
     */
    TeamsAppsClient.prototype.syncComponent = function (teamsAppComponentManifest) {
        var _this = this;
        var _a;
        var manifest = teamsAppComponentManifest;
        if (!(0, Flights_1.isBotAcesFromTeamsEnabled)() || !manifest.isPendingTeamsAppSync) {
            return Promise.resolve(teamsAppComponentManifest);
        }
        var monitor = new sp_diagnostics_1._QosMonitor('TeamsAppsClient.SyncComponent');
        if (!((_a = teamsAppComponentManifest.properties) === null || _a === void 0 ? void 0 : _a.teamsAppComponent)) {
            monitor.writeExpectedFailure('TeamsAppComponentMissing');
            return new Promise(function () {
                throw new Error('Teams App component manifest is missing teamsAppComponent property');
            });
        }
        var spHttpClient = this._serviceScope.consume(sp_http_1.SPHttpClient.serviceKey);
        var pageContext = this._serviceScope.consume(sp_page_context_1.PageContext.serviceKey);
        var baseRequestUrl = pageContext.web.absoluteUrl;
        var monitorFailureTagNameSuffix = undefined;
        var ensureAppCatalogPromise = TeamsAppsClient._ensureAppCatalogPromise;
        if (!TeamsAppsClient._ensureAppCatalogPromise) {
            // first step is to ensure app catalog
            var ensureAppCatalogRequestUrl = "".concat(baseRequestUrl, "/_api/web/EnsureTenantAppCatalog(callerId='TeamsAppsClient')");
            ensureAppCatalogPromise = TeamsAppsClient._ensureAppCatalogPromise = spHttpClient
                .post(ensureAppCatalogRequestUrl, sp_http_1.SPHttpClient.configurations.v1, {})
                .then(function (response) {
                return response.json();
            })
                .then(function (response) {
                if (response.error) {
                    throw new Error(response.error.message);
                }
            })
                .catch(function (error) {
                // app catalog error
                monitorFailureTagNameSuffix = 'EnsureAppCatalogFailed';
                // we want to retry if needed
                TeamsAppsClient._ensureAppCatalogPromise = undefined;
                throw error;
            });
        }
        return ensureAppCatalogPromise
            .then(function () {
            var syncRequestUrl = "".concat(baseRequestUrl, "/_api/web/SyncTeamsComponent");
            var teamsAppComponent = teamsAppComponentManifest.properties.teamsAppComponent;
            return spHttpClient
                .post(syncRequestUrl, sp_http_1.SPHttpClient.configurations.v1, {
                body: JSON.stringify({
                    teamsComponent: teamsAppComponent
                })
            })
                .catch(function (error) {
                // sync error
                monitorFailureTagNameSuffix = 'SyncComponentFailed';
                throw error;
            });
        })
            .then(function (response) {
            return response.json();
        })
            .then(function (syncedManifest) {
            if (syncedManifest.error) {
                monitorFailureTagNameSuffix = 'SyncComponentFailed';
                throw new Error(syncedManifest.error.message);
            }
            var manifestResponse = syncedManifest;
            var parsedManifest = JSON.parse(manifestResponse.Manifest);
            if (manifestResponse.ManifestActivatedTime) {
                parsedManifest.manifestActivatedTime = manifestResponse.ManifestActivatedTime;
            }
            monitor.writeSuccess();
            var appId = teamsAppComponentManifest.properties.teamsAppComponent.appId;
            // we know for sure the component is allowed
            _this._appComponentsPermissionsPromises.set(appId, Promise.resolve(new Set([appId])));
            return parsedManifest;
        })
            .catch(function (error) {
            monitor.writeUnexpectedFailure(monitorFailureTagNameSuffix, error);
            throw error;
        });
    };
    /**
     * Requests permissions for the Teams App components (apps) for the current user.
     */
    TeamsAppsClient.prototype.requestPermissions = function (teamsAppComponentIds) {
        if (!(0, Flights_1.isBotAcesFromTeamsEnabled)() || !teamsAppComponentIds.length) {
            return Promise.resolve();
        }
        return this._requestAppsPermissions(teamsAppComponentIds).then(function () { });
    };
    /**
     * Checks if the component is enabled for the current user based on requested Teams permissions.
     */
    TeamsAppsClient.prototype.isComponentEnabled = function (teamsAppId) {
        if (!(0, Flights_1.isBotAcesFromTeamsEnabled)()) {
            return Promise.resolve(true);
        }
        if (this._appComponentsPermissionsPromises.has(teamsAppId)) {
            return this._appComponentsPermissionsPromises.get(teamsAppId).then(function (allowedApps) {
                return allowedApps.has(teamsAppId) || false;
            });
        }
        else {
            return this._requestAppsPermissions([{ appId: teamsAppId, componentId: '' }]).then(function (allowedComponents) {
                return allowedComponents.has(teamsAppId) || false;
            });
        }
    };
    TeamsAppsClient.prototype._requestAppsPermissions = function (teamsAppComponentIds) {
        var _this = this;
        // getting app ids for which we don't have a promise yet
        var uniqueAppIds = (0, sp_lodash_subset_1.uniq)(teamsAppComponentIds.map(function (item) { return item.appId; })).filter(function (appId) { return !_this._appComponentsPermissionsPromises.has(appId); });
        var requestPermissionsPromise;
        if (uniqueAppIds.length > MAX_IDS_WITHOUT_BATCHING) {
            requestPermissionsPromise = this._requestAppsPermissionsBatched(uniqueAppIds);
        }
        if (!requestPermissionsPromise) {
            var monitor_2 = new sp_diagnostics_1._QosMonitor('TeamsAppsClient.RequestAppsPermissions');
            requestPermissionsPromise = this._msGraphClient
                .then(function (client) {
                return client.api(_this._getCheckPermissionsUrl(uniqueAppIds)).version(MS_GRAPH_API_VERSION).get();
            })
                .then(function (response) {
                if (response.error) {
                    monitor_2.writeUnexpectedFailure('RequestFailed', new Error(response.error.message));
                    return new Set();
                }
                var allowedApps = new Set();
                response.value.map(function (item) {
                    allowedApps.add(item.id);
                });
                monitor_2.writeSuccess();
                return allowedApps;
            })
                .catch(function (error) {
                monitor_2.writeUnexpectedFailure(undefined, error);
                return new Set();
            });
        }
        // store the promise to avoid multiple requests to the API for the same teamsAppId
        uniqueAppIds.forEach(function (teamsAppId) {
            _this._appComponentsPermissionsPromises.set(teamsAppId, requestPermissionsPromise);
        });
        return requestPermissionsPromise;
    };
    TeamsAppsClient.prototype._requestAppsPermissionsBatched = function (appIds) {
        var monitor = new sp_diagnostics_1._QosMonitor('TeamsAppsClient.RequestAppsPermissionsBatched');
        var allowedApps = new Set();
        //
        // MS Graph batch body is like that:
        // {
        //  "requests": [
        //    {
        //      "id": "1",
        //      "method": "GET",
        //      "url": "our-permissions-url"
        //    },
        //    {
        //      etc.
        //    }
        //  ]
        // }
        // We need to split the list of app ids to have no more than 10 requests per batch and no more than 30 ids per request
        //
        // we can have MAX_IDS_WITHOUT_BATCHING per one request in batch. And up to MAX_REQUESTS_PER_BATCH requests in batch.
        var maxIdsPerBatch = MAX_IDS_WITHOUT_BATCHING * MAX_REQUESTS_PER_BATCH;
        var batchesCount = Math.ceil(appIds.length / maxIdsPerBatch);
        var batchIndex = 0;
        var batchRequests = [];
        try {
            while (batchIndex < batchesCount) {
                var batchBody = {
                    requests: []
                };
                var batchStartIndex = batchIndex * maxIdsPerBatch;
                var batchEndIndex = Math.min(batchStartIndex + maxIdsPerBatch, appIds.length);
                var batchIdStartIndex = batchStartIndex;
                while (batchIdStartIndex < batchEndIndex) {
                    var batchIdEndIndex = batchIdStartIndex + MAX_IDS_WITHOUT_BATCHING;
                    var batchIds = appIds.slice(batchIdStartIndex, batchIdEndIndex);
                    batchBody.requests.push({
                        id: batchIdStartIndex.toString(),
                        method: 'GET',
                        url: this._getCheckPermissionsUrl(batchIds)
                    });
                    batchIdStartIndex = batchIdEndIndex;
                }
                batchRequests.push(batchBody);
                batchIndex++;
            }
        }
        catch (error) {
            monitor.writeUnexpectedFailure('BatchSplitLogicError', error);
            // Early return to avoid the request
            return Promise.resolve(allowedApps);
        }
        var errors = [];
        return this._msGraphClient
            .then(function (client) {
            var batchPromises = batchRequests.map(function (batchBody) {
                return client
                    .api('$batch')
                    .version(MS_GRAPH_API_VERSION)
                    .post(batchBody)
                    .then(function (response) {
                    response.responses.forEach(function (responseItem) {
                        if (responseItem.status !== 200) {
                            errors.push(new Error(responseItem.body.error.message));
                            return;
                        }
                        responseItem.body.value.map(function (app) {
                            allowedApps.add(app.id);
                        });
                    });
                })
                    .catch(function (error) {
                    errors.push(error);
                });
            });
            return Promise.all(batchPromises);
        })
            .then(function () {
            // some batches failed
            if (errors.length) {
                monitor.writeUnexpectedFailure('SomeBatchRequestsError', undefined, {
                    errors: errors
                });
            }
            return allowedApps;
        })
            .catch(function (error) {
            // all batches failed
            monitor.writeUnexpectedFailure('BatchRequestError', error);
            return new Set();
        });
    };
    TeamsAppsClient.prototype._getCheckPermissionsUrl = function (appIds) {
        return "".concat(MS_GRAPH_TEAMS_APPS_ENDPOINT, "?").concat(MS_GRAPH_CHECK_PERMISSIONS_QSP.replace('{appIds}', appIds.join("','")));
    };
    Object.defineProperty(TeamsAppsClient.prototype, "_msGraphClient", {
        get: function () {
            if (!this._msGraphClientFactory) {
                this._msGraphClientFactory = this._serviceScope.consume(sp_http_1.MSGraphClientFactory.serviceKey);
            }
            if (!this._msGraphClientDeferred) {
                this._msGraphClientDeferred = this._msGraphClientFactory.getClientInternal('3');
            }
            return this._msGraphClientDeferred;
        },
        enumerable: false,
        configurable: true
    });
    TeamsAppsClient.prototype._teamsAppCatalogItemToAceManifests = function (item) {
        var _this = this;
        var _a;
        //
        // collect components that use Teams App icon instead of having its own
        // if there are such components, we will need to fetch the app icon
        //
        var iconPromise;
        var colorIconWebUrl = (_a = item.appDefinitions[0].colorIcon) === null || _a === void 0 ? void 0 : _a.webUrl;
        var manifestsWithoutIcon = [];
        var dashboardCards = item.appDefinitions[0].dashboardCards || [];
        var manifests = [];
        dashboardCards.forEach(function (dashboardCard) {
            var _a, _b;
            var component = {
                appId: item.id,
                externalAppId: item.externalId || undefined,
                componentId: dashboardCard.id,
                groupId: ADVANCED_TOOLBOX_GROUP_ID, // Advanced group. If we decide to use the id from the app definition - we should use dashboardCard.pickerGroupId
                iconUrl: (_a = dashboardCard.icon) === null || _a === void 0 ? void 0 : _a.iconUrl,
                officeUIFabricIconName: (_b = dashboardCard.icon) === null || _b === void 0 ? void 0 : _b.officeUIFabricIconName,
                description: dashboardCard.description,
                name: dashboardCard.displayName,
                botId: dashboardCard.contentSource.botConfiguration.botId,
                appName: item.displayName,
                appDescription: item.appDefinitions[0].description,
                version: item.appDefinitions[0].version,
                // size is lower case in the manifest
                defaultSize: "".concat(dashboardCard.defaultSize.charAt(0).toUpperCase()).concat(dashboardCard.defaultSize.slice(1))
            };
            var manifest = _this._teamsAppComponentToAceManifest(component);
            manifests.push(manifest);
            if (!component.iconUrl && !component.officeUIFabricIconName) {
                manifestsWithoutIcon.push(manifest);
                if (!iconPromise && colorIconWebUrl)
                    iconPromise = _this._msGraphClient.then(function (client) {
                        return client
                            .api(colorIconWebUrl)
                            .responseType('blob')
                            .get();
                    });
            }
        });
        var resultPromise = Promise.resolve(manifests);
        if (manifestsWithoutIcon.length && iconPromise) {
            resultPromise = iconPromise
                .then(function (response) {
                return _this._convertBlobToBase64(response);
            })
                .then(function (iconUrl) {
                manifestsWithoutIcon.forEach(function (manifest) {
                    manifest.preconfiguredEntries[0].iconImageUrl = iconUrl;
                    manifest.properties.teamsAppComponent.iconUrl = iconUrl;
                });
                return manifests;
            });
        }
        return resultPromise;
    };
    TeamsAppsClient.prototype._convertBlobToBase64 = function (blob) {
        return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onload = function () {
                var base64String = reader.result;
                if (!base64String) {
                    reject('');
                }
                resolve(base64String.substr(base64String.indexOf(', ') + 1));
            };
            reader.readAsDataURL(blob);
        });
    };
    TeamsAppsClient.prototype._teamsAppComponentToAceManifest = function (component) {
        return {
            id: component.componentId,
            manifestVersion: MANIFEST_VERSION,
            version: component.version,
            componentType: 'AdaptiveCardExtension',
            alias: component.componentId,
            properties: {
                teamsAppComponent: component
            },
            loaderConfig: {
                entryModuleId: component.componentId,
                internalModuleBaseUrls: ['HTTPS://CLIENTSIDEASSETSLIBRARY/'],
                scriptResources: {}
            },
            preconfiguredEntries: [
                {
                    cardSize: component.defaultSize,
                    title: {
                        default: component.name
                    },
                    description: {
                        default: component.description
                    },
                    iconImageUrl: component.iconUrl,
                    officeFabricIconFontName: component.officeUIFabricIconName,
                    groupId: component.groupId,
                    properties: {}
                }
            ],
            connectedTeamsAppId: component.appId,
            isPendingTeamsAppSync: true
        };
    };
    return TeamsAppsClient;
}());
exports.TeamsAppsClient = TeamsAppsClient;
//# sourceMappingURL=TeamsAppsClient.js.map