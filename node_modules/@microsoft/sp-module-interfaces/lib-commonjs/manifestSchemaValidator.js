"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return ManifestValidator;
    },
    zSchemaOptions: function() {
        return zSchemaOptions;
    }
});
const _zschema = /*#__PURE__*/ _interop_require_default(require("z-schema"));
const _nodecorelibrary = require("@rushstack/node-core-library");
const _clientsidecomponentmanifestschemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/jsonSchemas/client-side-component-manifest.schema.json"));
const _clientsideapplicationmanifestschemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/jsonSchemas/client-side-application-manifest.schema.json"));
const _prefabappmanifestschemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/jsonSchemas/prefab-app-manifest.schema.json"));
const _clientsidewebpartmanifestschemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/jsonSchemas/client-side-web-part-manifest.schema.json"));
const _commandsetextensionmanifestschemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/jsonSchemas/command-set-extension-manifest.schema.json"));
const _clientsideextensionmanifestschemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/jsonSchemas/client-side-extension-manifest.schema.json"));
const _clientsidelibrarymanifestschemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/jsonSchemas/client-side-library-manifest.schema.json"));
const _clientsideassemblymanifestschemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/jsonSchemas/client-side-assembly-manifest.schema.json"));
const _clientsidemultiversionmanifestschemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/jsonSchemas/client-side-multi-version-manifest.schema.json"));
const _sitedesignscriptactionsschemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/remote/site-design-script-actions.schema.json"));
const _draft04schemajson = /*#__PURE__*/ _interop_require_default(require("./manifestSchemas/remote/draft-04.schema.json"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Discover the schema files
const schemasDirectory = `${__dirname}/manifestSchemas/jsonSchemas`;
const schemaFiles = _nodecorelibrary.FileSystem.readFolderItemNames(schemasDirectory);
const schemas = schemaFiles.map((schemaFile)=>require(`${schemasDirectory}/${schemaFile}`));
const SITE_SCRIPTS_SCHEMA_URL = 'https://developer.microsoft.com/json-schemas/sp/site-design-script-actions.schema.json';
const DRAFT_07_SCHEMA_URL = 'http://json-schema.org/draft-07/schema#';
const siteScriptsSchemaPromise = fetch(SITE_SCRIPTS_SCHEMA_URL).then((response)=>{
    return response.text();
}).catch((error)=>{
    // eslint-disable-next-line no-console
    console.error(`Failed to fetch remote schema: ${error}`);
    // fallback to local copy
    return JSON.stringify(_sitedesignscriptactionsschemajson.default);
});
const zSchemaOptions = {
    breakOnFirstError: true,
    forceAdditional: true,
    forceItems: true,
    forceMaxLength: false,
    forceProperties: false,
    noExtraKeywords: true,
    noTypeless: true,
    noEmptyStrings: true
};
const schemaValidator = new _zschema.default(zSchemaOptions);
const draft07ValidationOptions = {
    strictMode: false,
    ignoreUnresolvableReferences: true,
    ignoreUnknownFormats: true
};
//
// this one is needed for the site scripts reference.
// We're faking draft-07 schema with draft-04 schema as z-schema doesn't support draft-07
//
// eslint-disable-next-line @typescript-eslint/no-explicit-any
schemaValidator.setRemoteReference(DRAFT_07_SCHEMA_URL, _draft04schemajson.default, draft07ValidationOptions);
siteScriptsSchemaPromise.then((remoteSchema)=>{
    // ZSchema typedef doesn't contain setRemoteReference method. But it does exist in the implementation and referenced in the documentation.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    schemaValidator.setRemoteReference(SITE_SCRIPTS_SCHEMA_URL, JSON.parse(remoteSchema), {
        strictMode: false,
        ignoreUnresolvableReferences: true
    });
    schemaValidator.validateSchema(schemas);
}).catch((error)=>{
// swallowing the error here
});
class ManifestValidator {
    static registerRemoteSchemaReferences() {
        return siteScriptsSchemaPromise.then(()=>{
        // no-op;
        }).catch(()=>{
        // no-op;
        });
    }
    static validateApplicationManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, _clientsideapplicationmanifestschemajson.default);
    }
    static validatePrefabAppManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, _prefabappmanifestschemajson.default);
    }
    static validateCommandSetManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, _commandsetextensionmanifestschemajson.default);
    }
    static validateExtensionManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, _clientsideextensionmanifestschemajson.default);
    }
    static validateWebPartManifest(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    manifest) {
        return ManifestValidator._validateManifest(manifest, _clientsidewebpartmanifestschemajson.default);
    }
    static validateLibraryManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, _clientsidelibrarymanifestschemajson.default);
    }
    static validateAssemblyManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, _clientsideassemblymanifestschemajson.default);
    }
    static validateMultiVersionManifest(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    manifest) {
        return ManifestValidator._validateManifest(manifest, _clientsidemultiversionmanifestschemajson.default);
    }
    static validateManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, _clientsidecomponentmanifestschemajson.default);
    }
    static extractInnerErrorMessages(errors) {
        const printZSchemaError = (error)=>{
            let innerErrors = [];
            (error.inner || []).forEach((innerErr)=>{
                innerErrors = innerErrors.concat(printZSchemaError(innerErr));
            });
            return [
                `(${error.path}) ${error.message}`
            ].concat(innerErrors);
        };
        let errorList = [];
        errors.map((error)=>{
            errorList = errorList.concat(printZSchemaError(error));
        });
        return errorList;
    }
    static getFormattedErrorMessage(errors) {
        return this.extractInnerErrorMessages(errors).join('\n');
    }
    static _validateManifest(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    manifest, schema) {
        if (!schema) {
            throw new Error('Unable to find the manifest schema.');
        }
        if (typeof manifest === 'string') {
            manifest = JSON.parse(manifest);
        }
        const result = schemaValidator.validate(manifest, schema);
        return {
            result: result,
            errors: schemaValidator.getLastErrors() || []
        };
    }
}

//#sourceMappingUrl=./manifestSchemaValidator.js.map