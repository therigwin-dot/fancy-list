import ZSchema from 'z-schema';
import { FileSystem } from '@rushstack/node-core-library';
// Discover the schema files
const schemasDirectory = `${__dirname}/manifestSchemas/jsonSchemas`;
const schemaFiles = FileSystem.readFolderItemNames(schemasDirectory);
const schemas = schemaFiles.map((schemaFile)=>require(`${schemasDirectory}/${schemaFile}`));
import manifestSchema from './manifestSchemas/jsonSchemas/client-side-component-manifest.schema.json';
import applicationSchema from './manifestSchemas/jsonSchemas/client-side-application-manifest.schema.json';
import prefabAppSchema from './manifestSchemas/jsonSchemas/prefab-app-manifest.schema.json';
import webPartSchema from './manifestSchemas/jsonSchemas/client-side-web-part-manifest.schema.json';
import commandSetSchema from './manifestSchemas/jsonSchemas/command-set-extension-manifest.schema.json';
import extensionSchema from './manifestSchemas/jsonSchemas/client-side-extension-manifest.schema.json';
import librarySchema from './manifestSchemas/jsonSchemas/client-side-library-manifest.schema.json';
import assemblySchema from './manifestSchemas/jsonSchemas/client-side-assembly-manifest.schema.json';
import multiVersionSchema from './manifestSchemas/jsonSchemas/client-side-multi-version-manifest.schema.json';
// local copy of site scripts schema and draft-07 schema
import siteScriptsSchema from './manifestSchemas/remote/site-design-script-actions.schema.json';
import draft04Schema from './manifestSchemas/remote/draft-04.schema.json';
const SITE_SCRIPTS_SCHEMA_URL = 'https://developer.microsoft.com/json-schemas/sp/site-design-script-actions.schema.json';
const DRAFT_07_SCHEMA_URL = 'http://json-schema.org/draft-07/schema#';
const siteScriptsSchemaPromise = fetch(SITE_SCRIPTS_SCHEMA_URL).then((response)=>{
    return response.text();
}).catch((error)=>{
    // eslint-disable-next-line no-console
    console.error(`Failed to fetch remote schema: ${error}`);
    // fallback to local copy
    return JSON.stringify(siteScriptsSchema);
});
export const zSchemaOptions = {
    breakOnFirstError: true,
    forceAdditional: true,
    forceItems: true,
    forceMaxLength: false,
    forceProperties: false,
    noExtraKeywords: true,
    noTypeless: true,
    noEmptyStrings: true
};
const schemaValidator = new ZSchema(zSchemaOptions);
const draft07ValidationOptions = {
    strictMode: false,
    ignoreUnresolvableReferences: true,
    ignoreUnknownFormats: true
};
//
// this one is needed for the site scripts reference.
// We're faking draft-07 schema with draft-04 schema as z-schema doesn't support draft-07
//
// eslint-disable-next-line @typescript-eslint/no-explicit-any
schemaValidator.setRemoteReference(DRAFT_07_SCHEMA_URL, draft04Schema, draft07ValidationOptions);
siteScriptsSchemaPromise.then((remoteSchema)=>{
    // ZSchema typedef doesn't contain setRemoteReference method. But it does exist in the implementation and referenced in the documentation.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    schemaValidator.setRemoteReference(SITE_SCRIPTS_SCHEMA_URL, JSON.parse(remoteSchema), {
        strictMode: false,
        ignoreUnresolvableReferences: true
    });
    schemaValidator.validateSchema(schemas);
}).catch((error)=>{
// swallowing the error here
});
class ManifestValidator {
    static registerRemoteSchemaReferences() {
        return siteScriptsSchemaPromise.then(()=>{
        // no-op;
        }).catch(()=>{
        // no-op;
        });
    }
    static validateApplicationManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, applicationSchema);
    }
    static validatePrefabAppManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, prefabAppSchema);
    }
    static validateCommandSetManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, commandSetSchema);
    }
    static validateExtensionManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, extensionSchema);
    }
    static validateWebPartManifest(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    manifest) {
        return ManifestValidator._validateManifest(manifest, webPartSchema);
    }
    static validateLibraryManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, librarySchema);
    }
    static validateAssemblyManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, assemblySchema);
    }
    static validateMultiVersionManifest(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    manifest) {
        return ManifestValidator._validateManifest(manifest, multiVersionSchema);
    }
    static validateManifest(manifest) {
        return ManifestValidator._validateManifest(manifest, manifestSchema);
    }
    static extractInnerErrorMessages(errors) {
        const printZSchemaError = (error)=>{
            let innerErrors = [];
            (error.inner || []).forEach((innerErr)=>{
                innerErrors = innerErrors.concat(printZSchemaError(innerErr));
            });
            return [
                `(${error.path}) ${error.message}`
            ].concat(innerErrors);
        };
        let errorList = [];
        errors.map((error)=>{
            errorList = errorList.concat(printZSchemaError(error));
        });
        return errorList;
    }
    static getFormattedErrorMessage(errors) {
        return this.extractInnerErrorMessages(errors).join('\n');
    }
    static _validateManifest(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    manifest, schema) {
        if (!schema) {
            throw new Error('Unable to find the manifest schema.');
        }
        if (typeof manifest === 'string') {
            manifest = JSON.parse(manifest);
        }
        const result = schemaValidator.validate(manifest, schema);
        return {
            result: result,
            errors: schemaValidator.getLastErrors() || []
        };
    }
}
export { ManifestValidator as default };

//#sourceMappingUrl=./manifestSchemaValidator.js.map