"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringValuesTypingsGenerator = void 0;
const os_1 = require("os");
const node_core_library_1 = require("@rushstack/node-core-library");
const TypingsGenerator_1 = require("./TypingsGenerator");
const EXPORT_AS_DEFAULT_INTERFACE_NAME = 'IExport';
function convertToTypingsGeneratorOptions(options) {
    var _a;
    const { exportAsDefault: exportAsDefaultOptions, exportAsDefaultInterfaceName: exportAsDefaultInterfaceName_deprecated, parseAndGenerateTypings } = options;
    let defaultSplitExportAsDefaultInterfaceDocumentationComment;
    let defaultSplitExportAsDefaultValueDocumentationComment;
    let defaultExportAsDefaultInterfaceName;
    if (typeof exportAsDefaultOptions === 'object') {
        const { interfaceDocumentationComment, documentationComment: interfaceDocumentationComment_deprecated, valueDocumentationComment, interfaceName } = exportAsDefaultOptions;
        defaultSplitExportAsDefaultInterfaceDocumentationComment = node_core_library_1.Text.splitByNewLines(interfaceDocumentationComment !== null && interfaceDocumentationComment !== void 0 ? interfaceDocumentationComment : interfaceDocumentationComment_deprecated);
        defaultSplitExportAsDefaultValueDocumentationComment = node_core_library_1.Text.splitByNewLines(valueDocumentationComment);
        defaultExportAsDefaultInterfaceName =
            (_a = interfaceName !== null && interfaceName !== void 0 ? interfaceName : exportAsDefaultInterfaceName_deprecated) !== null && _a !== void 0 ? _a : EXPORT_AS_DEFAULT_INTERFACE_NAME;
    }
    else if (exportAsDefaultOptions) {
        defaultExportAsDefaultInterfaceName =
            exportAsDefaultInterfaceName_deprecated !== null && exportAsDefaultInterfaceName_deprecated !== void 0 ? exportAsDefaultInterfaceName_deprecated : EXPORT_AS_DEFAULT_INTERFACE_NAME;
    }
    async function parseAndGenerateTypingsOuter(fileContents, filePath, relativePath) {
        var _a, _b, _c, _d;
        const stringValueTypings = await parseAndGenerateTypings(fileContents, filePath, relativePath);
        if (stringValueTypings === undefined) {
            return;
        }
        const { exportAsDefault: exportAsDefaultOptionsOverride, typings } = stringValueTypings;
        let exportAsDefaultInterfaceName;
        let interfaceDocumentationCommentLines;
        let valueDocumentationCommentLines;
        if (typeof exportAsDefaultOptionsOverride === 'boolean') {
            if (exportAsDefaultOptionsOverride) {
                exportAsDefaultInterfaceName =
                    defaultExportAsDefaultInterfaceName !== null && defaultExportAsDefaultInterfaceName !== void 0 ? defaultExportAsDefaultInterfaceName : EXPORT_AS_DEFAULT_INTERFACE_NAME;
                interfaceDocumentationCommentLines = defaultSplitExportAsDefaultInterfaceDocumentationComment;
                valueDocumentationCommentLines = defaultSplitExportAsDefaultValueDocumentationComment;
            }
        }
        else if (exportAsDefaultOptionsOverride) {
            const { interfaceName, documentationComment, interfaceDocumentationComment, valueDocumentationComment } = exportAsDefaultOptionsOverride;
            exportAsDefaultInterfaceName =
                (_a = interfaceName !== null && interfaceName !== void 0 ? interfaceName : defaultExportAsDefaultInterfaceName) !== null && _a !== void 0 ? _a : EXPORT_AS_DEFAULT_INTERFACE_NAME;
            interfaceDocumentationCommentLines =
                (_c = (_b = node_core_library_1.Text.splitByNewLines(interfaceDocumentationComment)) !== null && _b !== void 0 ? _b : node_core_library_1.Text.splitByNewLines(documentationComment)) !== null && _c !== void 0 ? _c : defaultSplitExportAsDefaultInterfaceDocumentationComment;
            valueDocumentationCommentLines =
                (_d = node_core_library_1.Text.splitByNewLines(valueDocumentationComment)) !== null && _d !== void 0 ? _d : defaultSplitExportAsDefaultValueDocumentationComment;
        }
        else {
            exportAsDefaultInterfaceName = defaultExportAsDefaultInterfaceName;
            interfaceDocumentationCommentLines = defaultSplitExportAsDefaultInterfaceDocumentationComment;
            valueDocumentationCommentLines = defaultSplitExportAsDefaultValueDocumentationComment;
        }
        const outputLines = [];
        let indent = '';
        if (exportAsDefaultInterfaceName) {
            if (interfaceDocumentationCommentLines) {
                outputLines.push(`/**`);
                for (const line of interfaceDocumentationCommentLines) {
                    outputLines.push(` * ${line}`);
                }
                outputLines.push(` */`);
            }
            outputLines.push(`export interface ${exportAsDefaultInterfaceName} {`);
            indent = '  ';
        }
        for (const stringValueTyping of typings) {
            const { exportName, comment } = stringValueTyping;
            if (comment && comment.trim() !== '') {
                outputLines.push(`${indent}/**`, `${indent} * ${comment.replace(/\*\//g, '*\\/')}`, `${indent} */`);
            }
            if (exportAsDefaultInterfaceName) {
                outputLines.push(`${indent}'${exportName}': string;`, '');
            }
            else {
                outputLines.push(`export declare const ${exportName}: string;`, '');
            }
        }
        if (exportAsDefaultInterfaceName) {
            outputLines.push('}', '');
            if (valueDocumentationCommentLines) {
                outputLines.push(`/**`);
                for (const line of valueDocumentationCommentLines) {
                    outputLines.push(` * ${line}`);
                }
                outputLines.push(` */`);
            }
            outputLines.push(`declare const strings: ${exportAsDefaultInterfaceName};`, '', 'export default strings;');
        }
        return outputLines.join(os_1.EOL);
    }
    const convertedOptions = {
        ...options,
        parseAndGenerateTypings: parseAndGenerateTypingsOuter
    };
    return convertedOptions;
}
/**
 * This is a simple tool that generates .d.ts files for non-TS files that can be represented as
 * a simple set of named string exports.
 *
 * @public
 */
class StringValuesTypingsGenerator extends TypingsGenerator_1.TypingsGenerator {
    constructor(options) {
        super(convertToTypingsGeneratorOptions(options));
    }
}
exports.StringValuesTypingsGenerator = StringValuesTypingsGenerator;
//# sourceMappingURL=StringValuesTypingsGenerator.js.map