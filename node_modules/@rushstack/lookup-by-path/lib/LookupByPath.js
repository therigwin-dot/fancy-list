"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.LookupByPath = void 0;
/**
 * This class is used to associate path-like-strings, such as those returned by `git` commands,
 * with entities that correspond with ancestor folders, such as Rush Projects or npm packages.
 *
 * It is optimized for efficiently locating the nearest ancestor path with an associated value.
 *
 * It is implemented as a Trie (https://en.wikipedia.org/wiki/Trie) data structure, with each edge
 * being a path segment.
 *
 * @example
 * ```ts
 * const trie = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);
 * trie.findChildPath('foo'); // returns 1
 * trie.findChildPath('foo/baz'); // returns 1
 * trie.findChildPath('baz'); // returns undefined
 * trie.findChildPath('foo/bar/baz'); returns 3
 * trie.findChildPath('bar/foo/bar'); returns 2
 * ```
 * @beta
 */
class LookupByPath {
    /**
     * Constructs a new `LookupByPath`
     *
     * @param entries - Initial path-value pairs to populate the trie.
     */
    constructor(entries, delimiter) {
        this._root = {
            value: undefined,
            children: undefined
        };
        this.delimiter = delimiter !== null && delimiter !== void 0 ? delimiter : '/';
        this._size = 0;
        if (entries) {
            for (const [path, item] of entries) {
                this.setItem(path, item);
            }
        }
    }
    /**
     * Iterates over the segments of a serialized path.
     *
     * @example
     *
     * `LookupByPath.iteratePathSegments('foo/bar/baz')` yields 'foo', 'bar', 'baz'
     *
     * `LookupByPath.iteratePathSegments('foo\\bar\\baz', '\\')` yields 'foo', 'bar', 'baz'
     */
    static *iteratePathSegments(serializedPath, delimiter = '/') {
        for (const prefixMatch of this._iteratePrefixes(serializedPath, delimiter)) {
            yield prefixMatch.prefix;
        }
    }
    static *_iteratePrefixes(input, delimiter = '/') {
        if (!input) {
            return;
        }
        let previousIndex = 0;
        let nextIndex = input.indexOf(delimiter);
        // Leading segments
        while (nextIndex >= 0) {
            yield {
                prefix: input.slice(previousIndex, nextIndex),
                index: nextIndex
            };
            previousIndex = nextIndex + 1;
            nextIndex = input.indexOf(delimiter, previousIndex);
        }
        // Last segment
        if (previousIndex < input.length) {
            yield {
                prefix: input.slice(previousIndex, input.length),
                index: input.length
            };
        }
    }
    /**
     * {@inheritdoc IReadonlyLookupByPath}
     */
    get size() {
        return this._size;
    }
    /**
     * Deletes all entries from this `LookupByPath` instance.
     *
     * @returns this, for chained calls
     */
    clear() {
        this._root.value = undefined;
        this._root.children = undefined;
        this._size = 0;
        return this;
    }
    /**
     * Associates the value with the specified serialized path.
     * If a value is already associated, will overwrite.
     *
     * @returns this, for chained calls
     */
    setItem(serializedPath, value, delimiter = this.delimiter) {
        return this.setItemFromSegments(LookupByPath.iteratePathSegments(serializedPath, delimiter), value);
    }
    /**
     * Deletes an item if it exists.
     * @param query - The path to the item to delete
     * @param delimeter - Optional override delimeter for parsing the query
     * @returns `true` if the item was found and deleted, `false` otherwise
     * @remarks
     * If the node has children with values, they will be retained.
     */
    deleteItem(query, delimeter = this.delimiter) {
        const node = this._findNodeAtPrefix(query, delimeter);
        if ((node === null || node === void 0 ? void 0 : node.value) !== undefined) {
            node.value = undefined;
            this._size--;
            return true;
        }
        return false;
    }
    /**
     * Associates the value with the specified path.
     * If a value is already associated, will overwrite.
     *
     * @returns this, for chained calls
     */
    setItemFromSegments(pathSegments, value) {
        let node = this._root;
        for (const segment of pathSegments) {
            if (!node.children) {
                node.children = new Map();
            }
            let child = node.children.get(segment);
            if (!child) {
                node.children.set(segment, (child = {
                    value: undefined,
                    children: undefined
                }));
            }
            node = child;
        }
        if (node.value === undefined) {
            this._size++;
        }
        node.value = value;
        return this;
    }
    /**
     * {@inheritdoc IReadonlyLookupByPath}
     */
    findChildPath(childPath, delimiter = this.delimiter) {
        return this.findChildPathFromSegments(LookupByPath.iteratePathSegments(childPath, delimiter));
    }
    /**
     * {@inheritdoc IReadonlyLookupByPath}
     */
    findLongestPrefixMatch(query, delimiter = this.delimiter) {
        return this._findLongestPrefixMatch(LookupByPath._iteratePrefixes(query, delimiter));
    }
    /**
     * {@inheritdoc IReadonlyLookupByPath}
     */
    findChildPathFromSegments(childPathSegments) {
        var _a;
        let node = this._root;
        let best = node.value;
        // Trivial cases
        if (node.children) {
            for (const segment of childPathSegments) {
                const child = node.children.get(segment);
                if (!child) {
                    break;
                }
                node = child;
                best = (_a = node.value) !== null && _a !== void 0 ? _a : best;
                if (!node.children) {
                    break;
                }
            }
        }
        return best;
    }
    /**
     * {@inheritdoc IReadonlyLookupByPath}
     */
    has(key, delimiter = this.delimiter) {
        const match = this.findLongestPrefixMatch(key, delimiter);
        return (match === null || match === void 0 ? void 0 : match.index) === key.length;
    }
    /**
     * {@inheritdoc IReadonlyLookupByPath}
     */
    get(key, delimiter = this.delimiter) {
        const match = this.findLongestPrefixMatch(key, delimiter);
        return (match === null || match === void 0 ? void 0 : match.index) === key.length ? match.value : undefined;
    }
    /**
     * {@inheritdoc IReadonlyLookupByPath}
     */
    groupByChild(infoByPath, delimiter = this.delimiter) {
        const groupedInfoByChild = new Map();
        for (const [path, info] of infoByPath) {
            const child = this.findChildPath(path, delimiter);
            if (child === undefined) {
                continue;
            }
            let groupedInfo = groupedInfoByChild.get(child);
            if (!groupedInfo) {
                groupedInfo = new Map();
                groupedInfoByChild.set(child, groupedInfo);
            }
            groupedInfo.set(path, info);
        }
        return groupedInfoByChild;
    }
    /**
     * {@inheritdoc IReadonlyLookupByPath}
     */
    *entries(query, delimiter = this.delimiter) {
        let root;
        if (query) {
            root = this._findNodeAtPrefix(query, delimiter);
            if (!root) {
                return;
            }
        }
        else {
            root = this._root;
        }
        const stack = [[query !== null && query !== void 0 ? query : '', root]];
        while (stack.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const [prefix, node] = stack.pop();
            if (node.value !== undefined) {
                yield [prefix, node.value];
            }
            if (node.children) {
                for (const [segment, child] of node.children) {
                    stack.push([prefix ? `${prefix}${delimiter}${segment}` : segment, child]);
                }
            }
        }
    }
    /**
     * {@inheritdoc IReadonlyLookupByPath}
     */
    [Symbol.iterator](query, delimiter = this.delimiter) {
        return this.entries(query, delimiter);
    }
    /**
     * Iterates through progressively longer prefixes of a given string and returns as soon
     * as the number of candidate items that match the prefix are 1 or 0.
     *
     * If a match is present, returns the matched itme and the length of the matched prefix.
     *
     * @returns the found item, or `undefined` if no item was found
     */
    _findLongestPrefixMatch(prefixes) {
        let node = this._root;
        let best = node.value
            ? {
                value: node.value,
                index: 0,
                lastMatch: undefined
            }
            : undefined;
        // Trivial cases
        if (node.children) {
            for (const { prefix: hash, index } of prefixes) {
                const child = node.children.get(hash);
                if (!child) {
                    break;
                }
                node = child;
                if (node.value !== undefined) {
                    best = {
                        value: node.value,
                        index,
                        lastMatch: best
                    };
                }
                if (!node.children) {
                    break;
                }
            }
        }
        return best;
    }
    /**
     * Finds the node at the specified path, or `undefined` if no node was found.
     *
     * @param query - The path to the node to search for
     * @returns The trie node at the specified path, or `undefined` if no node was found
     */
    _findNodeAtPrefix(query, delimiter = this.delimiter) {
        let node = this._root;
        for (const { prefix } of LookupByPath._iteratePrefixes(query, delimiter)) {
            if (!node.children) {
                return undefined;
            }
            const child = node.children.get(prefix);
            if (!child) {
                return undefined;
            }
            node = child;
        }
        return node;
    }
}
exports.LookupByPath = LookupByPath;
//# sourceMappingURL=LookupByPath.js.map