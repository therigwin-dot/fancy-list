{"version":3,"file":"LookupByPath.js","sourceRoot":"","sources":["../src/LookupByPath.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAoK3D;;;;;;;;;;;;;;;;;;;GAmBG;AACH,MAAa,YAAY;IAgBvB;;;;OAIG;IACH,YAAmB,OAAmC,EAAE,SAAkB;QACxE,IAAI,CAAC,KAAK,GAAG;YACX,KAAK,EAAE,SAAS;YAChB,QAAQ,EAAE,SAAS;SACpB,CAAC;QAEF,IAAI,CAAC,SAAS,GAAG,SAAS,aAAT,SAAS,cAAT,SAAS,GAAI,GAAG,CAAC;QAClC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;QAEf,IAAI,OAAO,EAAE,CAAC;YACZ,KAAK,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,OAAO,EAAE,CAAC;gBACnC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YAC3B,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;;;;;;OAQG;IACI,MAAM,CAAC,CAAC,mBAAmB,CAAC,cAAsB,EAAE,YAAoB,GAAG;QAChF,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,SAAS,CAAC,EAAE,CAAC;YAC3E,MAAM,WAAW,CAAC,MAAM,CAAC;QAC3B,CAAC;IACH,CAAC;IAEO,MAAM,CAAC,CAAC,gBAAgB,CAAC,KAAa,EAAE,YAAoB,GAAG;QACrE,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,OAAO;QACT,CAAC;QAED,IAAI,aAAa,GAAW,CAAC,CAAC;QAC9B,IAAI,SAAS,GAAW,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAEjD,mBAAmB;QACnB,OAAO,SAAS,IAAI,CAAC,EAAE,CAAC;YACtB,MAAM;gBACJ,MAAM,EAAE,KAAK,CAAC,KAAK,CAAC,aAAa,EAAE,SAAS,CAAC;gBAC7C,KAAK,EAAE,SAAS;aACjB,CAAC;YACF,aAAa,GAAG,SAAS,GAAG,CAAC,CAAC;YAC9B,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;QACtD,CAAC;QAED,eAAe;QACf,IAAI,aAAa,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC;YACjC,MAAM;gBACJ,MAAM,EAAE,KAAK,CAAC,KAAK,CAAC,aAAa,EAAE,KAAK,CAAC,MAAM,CAAC;gBAChD,KAAK,EAAE,KAAK,CAAC,MAAM;aACpB,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;OAEG;IACH,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED;;;;OAIG;IACI,KAAK;QACV,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC;QAC7B,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,SAAS,CAAC;QAChC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;QACf,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACI,OAAO,CAAC,cAAsB,EAAE,KAAY,EAAE,YAAoB,IAAI,CAAC,SAAS;QACrF,OAAO,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,mBAAmB,CAAC,cAAc,EAAE,SAAS,CAAC,EAAE,KAAK,CAAC,CAAC;IACtG,CAAC;IAED;;;;;;;OAOG;IACI,UAAU,CAAC,KAAa,EAAE,YAAoB,IAAI,CAAC,SAAS;QACjE,MAAM,IAAI,GAAqC,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;QACxF,IAAI,CAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,KAAK,MAAK,SAAS,EAAE,CAAC;YAC9B,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;YACvB,IAAI,CAAC,KAAK,EAAE,CAAC;YACb,OAAO,IAAI,CAAC;QACd,CAAC;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;;OAKG;IACI,mBAAmB,CAAC,YAA8B,EAAE,KAAY;QACrE,IAAI,IAAI,GAAyB,IAAI,CAAC,KAAK,CAAC;QAC5C,KAAK,MAAM,OAAO,IAAI,YAAY,EAAE,CAAC;YACnC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;YAC5B,CAAC;YACD,IAAI,KAAK,GAAqC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACzE,IAAI,CAAC,KAAK,EAAE,CAAC;gBACX,IAAI,CAAC,QAAQ,CAAC,GAAG,CACf,OAAO,EACP,CAAC,KAAK,GAAG;oBACP,KAAK,EAAE,SAAS;oBAChB,QAAQ,EAAE,SAAS;iBACpB,CAAC,CACH,CAAC;YACJ,CAAC;YACD,IAAI,GAAG,KAAK,CAAC;QACf,CAAC;QACD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;YAC7B,IAAI,CAAC,KAAK,EAAE,CAAC;QACf,CAAC;QACD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QAEnB,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACI,aAAa,CAAC,SAAiB,EAAE,YAAoB,IAAI,CAAC,SAAS;QACxE,OAAO,IAAI,CAAC,yBAAyB,CAAC,YAAY,CAAC,mBAAmB,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;IAChG,CAAC;IAED;;OAEG;IACI,sBAAsB,CAC3B,KAAa,EACb,YAAoB,IAAI,CAAC,SAAS;QAElC,OAAO,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC,gBAAgB,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC;IACvF,CAAC;IAED;;OAEG;IACI,yBAAyB,CAAC,iBAAmC;;QAClE,IAAI,IAAI,GAAyB,IAAI,CAAC,KAAK,CAAC;QAC5C,IAAI,IAAI,GAAsB,IAAI,CAAC,KAAK,CAAC;QACzC,gBAAgB;QAChB,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAClB,KAAK,MAAM,OAAO,IAAI,iBAAiB,EAAE,CAAC;gBACxC,MAAM,KAAK,GAAqC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;gBAC3E,IAAI,CAAC,KAAK,EAAE,CAAC;oBACX,MAAM;gBACR,CAAC;gBACD,IAAI,GAAG,KAAK,CAAC;gBACb,IAAI,GAAG,MAAA,IAAI,CAAC,KAAK,mCAAI,IAAI,CAAC;gBAC1B,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;oBACnB,MAAM;gBACR,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACI,GAAG,CAAC,GAAW,EAAE,YAAoB,IAAI,CAAC,SAAS;QACxD,MAAM,KAAK,GAAoC,IAAI,CAAC,sBAAsB,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;QAC3F,OAAO,CAAA,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,KAAK,MAAK,GAAG,CAAC,MAAM,CAAC;IACrC,CAAC;IAED;;OAEG;IACI,GAAG,CAAC,GAAW,EAAE,YAAoB,IAAI,CAAC,SAAS;QACxD,MAAM,KAAK,GAAoC,IAAI,CAAC,sBAAsB,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;QAC3F,OAAO,CAAA,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,KAAK,MAAK,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC;IAC/D,CAAC;IAED;;OAEG;IACI,YAAY,CACjB,UAA8B,EAC9B,YAAoB,IAAI,CAAC,SAAS;QAElC,MAAM,kBAAkB,GAAmC,IAAI,GAAG,EAAE,CAAC;QAErE,KAAK,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,UAAU,EAAE,CAAC;YACtC,MAAM,KAAK,GAAsB,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;YACrE,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;gBACxB,SAAS;YACX,CAAC;YACD,IAAI,WAAW,GAAmC,kBAAkB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAChF,IAAI,CAAC,WAAW,EAAE,CAAC;gBACjB,WAAW,GAAG,IAAI,GAAG,EAAE,CAAC;gBACxB,kBAAkB,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;YAC7C,CAAC;YACD,WAAW,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC9B,CAAC;QAED,OAAO,kBAAkB,CAAC;IAC5B,CAAC;IAED;;OAEG;IACI,CAAC,OAAO,CAAC,KAAc,EAAE,YAAoB,IAAI,CAAC,SAAS;QAChE,IAAI,IAAsC,CAAC;QAC3C,IAAI,KAAK,EAAE,CAAC;YACV,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;YAChD,IAAI,CAAC,IAAI,EAAE,CAAC;gBACV,OAAO;YACT,CAAC;QACH,CAAC;aAAM,CAAC;YACN,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;QACpB,CAAC;QAED,MAAM,KAAK,GAAqC,CAAC,CAAC,KAAK,aAAL,KAAK,cAAL,KAAK,GAAI,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC;QACtE,OAAO,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACxB,oEAAoE;YACpE,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,KAAK,CAAC,GAAG,EAAG,CAAC;YACpC,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;gBAC7B,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;YAC7B,CAAC;YACD,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAClB,KAAK,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;oBAC7C,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,GAAG,SAAS,GAAG,OAAO,EAAE,CAAC,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;gBAC5E,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED;;OAEG;IACI,CAAC,MAAM,CAAC,QAAQ,CAAC,CACtB,KAAc,EACd,YAAoB,IAAI,CAAC,SAAS;QAElC,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;IACxC,CAAC;IAED;;;;;;;OAOG;IACK,uBAAuB,CAAC,QAAgC;QAC9D,IAAI,IAAI,GAAyB,IAAI,CAAC,KAAK,CAAC;QAC5C,IAAI,IAAI,GAAoC,IAAI,CAAC,KAAK;YACpD,CAAC,CAAC;gBACE,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,KAAK,EAAE,CAAC;gBACR,SAAS,EAAE,SAAS;aACrB;YACH,CAAC,CAAC,SAAS,CAAC;QACd,gBAAgB;QAChB,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAClB,KAAK,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,QAAQ,EAAE,CAAC;gBAC/C,MAAM,KAAK,GAAqC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;gBACxE,IAAI,CAAC,KAAK,EAAE,CAAC;oBACX,MAAM;gBACR,CAAC;gBACD,IAAI,GAAG,KAAK,CAAC;gBACb,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;oBAC7B,IAAI,GAAG;wBACL,KAAK,EAAE,IAAI,CAAC,KAAK;wBACjB,KAAK;wBACL,SAAS,EAAE,IAAI;qBAChB,CAAC;gBACJ,CAAC;gBACD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;oBACnB,MAAM;gBACR,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACK,iBAAiB,CACvB,KAAa,EACb,YAAoB,IAAI,CAAC,SAAS;QAElC,IAAI,IAAI,GAAyB,IAAI,CAAC,KAAK,CAAC;QAC5C,KAAK,MAAM,EAAE,MAAM,EAAE,IAAI,YAAY,CAAC,gBAAgB,CAAC,KAAK,EAAE,SAAS,CAAC,EAAE,CAAC;YACzE,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACnB,OAAO,SAAS,CAAC;YACnB,CAAC;YACD,MAAM,KAAK,GAAqC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;YAC1E,IAAI,CAAC,KAAK,EAAE,CAAC;gBACX,OAAO,SAAS,CAAC;YACnB,CAAC;YACD,IAAI,GAAG,KAAK,CAAC;QACf,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAxVD,oCAwVC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * A node in the path trie used in LookupByPath\n */\ninterface IPathTrieNode<TItem extends {}> {\n  /**\n   * The value that exactly matches the current relative path\n   */\n  value: TItem | undefined;\n\n  /**\n   * Child nodes by subfolder\n   */\n  children: Map<string, IPathTrieNode<TItem>> | undefined;\n}\n\ninterface IPrefixEntry {\n  /**\n   * The prefix that was matched\n   */\n  prefix: string;\n\n  /**\n   * The index of the first character after the matched prefix\n   */\n  index: number;\n}\n\n/**\n * Object containing both the matched item and the start index of the remainder of the query.\n *\n * @beta\n */\nexport interface IPrefixMatch<TItem extends {}> {\n  /**\n   * The item that matched the prefix\n   */\n  value: TItem;\n\n  /**\n   * The index of the first character after the matched prefix\n   */\n  index: number;\n\n  /**\n   * The last match found (with a shorter prefix), if any\n   */\n  lastMatch?: IPrefixMatch<TItem>;\n}\n\n/**\n * The readonly component of `LookupByPath`, to simplify unit testing.\n *\n * @beta\n */\nexport interface IReadonlyLookupByPath<TItem extends {}> extends Iterable<[string, TItem]> {\n  /**\n   * Searches for the item associated with `childPath`, or the nearest ancestor of that path that\n   * has an associated item.\n   *\n   * @returns the found item, or `undefined` if no item was found\n   *\n   * @example\n   * ```ts\n   * const trie = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n   * trie.findChildPath('foo/baz'); // returns 1\n   * trie.findChildPath('foo/bar/baz'); // returns 2\n   * ```\n   */\n  findChildPath(childPath: string, delimiter?: string): TItem | undefined;\n\n  /**\n   * Searches for the item for which the recorded prefix is the longest matching prefix of `query`.\n   * Obtains both the item and the length of the matched prefix, so that the remainder of the path can be\n   * extracted.\n   *\n   * @returns the found item and the length of the matched prefix, or `undefined` if no item was found\n   *\n   * @example\n   * ```ts\n   * const trie = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n   * trie.findLongestPrefixMatch('foo/baz'); // returns { item: 1, index: 3 }\n   * trie.findLongestPrefixMatch('foo/bar/baz'); // returns { item: 2, index: 7 }\n   * ```\n   */\n  findLongestPrefixMatch(query: string, delimiter?: string): IPrefixMatch<TItem> | undefined;\n\n  /**\n   * Searches for the item associated with `childPathSegments`, or the nearest ancestor of that path that\n   * has an associated item.\n   *\n   * @returns the found item, or `undefined` if no item was found\n   *\n   * @example\n   * ```ts\n   * const trie = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n   * trie.findChildPathFromSegments(['foo', 'baz']); // returns 1\n   * trie.findChildPathFromSegments(['foo','bar', 'baz']); // returns 2\n   * ```\n   */\n  findChildPathFromSegments(childPathSegments: Iterable<string>): TItem | undefined;\n\n  /**\n   * Determines if an entry exists exactly at the specified path.\n   *\n   * @returns `true` if an entry exists at the specified path, `false` otherwise\n   */\n  has(query: string, delimiter?: string): boolean;\n\n  /**\n   * Retrieves the entry that exists exactly at the specified path, if any.\n   *\n   * @returns The entry that exists exactly at the specified path, or `undefined` if no entry exists.\n   */\n  get(query: string, delimiter?: string): TItem | undefined;\n\n  /**\n   * Gets the number of entries in this trie.\n   *\n   * @returns The number of entries in this trie.\n   */\n  get size(): number;\n\n  /**\n   * Iterates over the entries in this trie.\n   *\n   * @param query - An optional query. If specified only entries that start with the query will be returned.\n   *\n   * @returns An iterator over the entries under the specified query (or the root if no query is specified).\n   * @remarks\n   * Keys in the returned iterator use the provided delimiter to join segments.\n   * Iteration order is not specified.\n   * @example\n   * ```ts\n   * const trie = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n   * [...trie.entries(undefined, ',')); // returns [['foo', 1], ['foo,bar', 2]]\n   * ```\n   */\n  entries(query?: string, delimiter?: string): IterableIterator<[string, TItem]>;\n\n  /**\n   * Iterates over the entries in this trie.\n   *\n   * @param query - An optional query. If specified only entries that start with the query will be returned.\n   *\n   * @returns An iterator over the entries under the specified query (or the root if no query is specified).\n   * @remarks\n   * Keys in the returned iterator use the provided delimiter to join segments.\n   * Iteration order is not specified.\n   */\n  [Symbol.iterator](query?: string, delimiter?: string): IterableIterator<[string, TItem]>;\n\n  /**\n   * Groups the provided map of info by the nearest entry in the trie that contains the path. If the path\n   * is not found in the trie, the info is ignored.\n   *\n   * @returns The grouped info, grouped by the nearest entry in the trie that contains the path\n   *\n   * @param infoByPath - The info to be grouped, keyed by path\n   */\n  groupByChild<TInfo>(infoByPath: Map<string, TInfo>, delimiter?: string): Map<TItem, Map<string, TInfo>>;\n}\n\n/**\n * This class is used to associate path-like-strings, such as those returned by `git` commands,\n * with entities that correspond with ancestor folders, such as Rush Projects or npm packages.\n *\n * It is optimized for efficiently locating the nearest ancestor path with an associated value.\n *\n * It is implemented as a Trie (https://en.wikipedia.org/wiki/Trie) data structure, with each edge\n * being a path segment.\n *\n * @example\n * ```ts\n * const trie = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);\n * trie.findChildPath('foo'); // returns 1\n * trie.findChildPath('foo/baz'); // returns 1\n * trie.findChildPath('baz'); // returns undefined\n * trie.findChildPath('foo/bar/baz'); returns 3\n * trie.findChildPath('bar/foo/bar'); returns 2\n * ```\n * @beta\n */\nexport class LookupByPath<TItem extends {}> implements IReadonlyLookupByPath<TItem> {\n  /**\n   * The delimiter used to split paths\n   */\n  public readonly delimiter: string;\n\n  /**\n   * The root node of the trie, corresponding to the path ''\n   */\n  private readonly _root: IPathTrieNode<TItem>;\n\n  /**\n   * The number of entries in this trie.\n   */\n  private _size: number;\n\n  /**\n   * Constructs a new `LookupByPath`\n   *\n   * @param entries - Initial path-value pairs to populate the trie.\n   */\n  public constructor(entries?: Iterable<[string, TItem]>, delimiter?: string) {\n    this._root = {\n      value: undefined,\n      children: undefined\n    };\n\n    this.delimiter = delimiter ?? '/';\n    this._size = 0;\n\n    if (entries) {\n      for (const [path, item] of entries) {\n        this.setItem(path, item);\n      }\n    }\n  }\n\n  /**\n   * Iterates over the segments of a serialized path.\n   *\n   * @example\n   *\n   * `LookupByPath.iteratePathSegments('foo/bar/baz')` yields 'foo', 'bar', 'baz'\n   *\n   * `LookupByPath.iteratePathSegments('foo\\\\bar\\\\baz', '\\\\')` yields 'foo', 'bar', 'baz'\n   */\n  public static *iteratePathSegments(serializedPath: string, delimiter: string = '/'): Iterable<string> {\n    for (const prefixMatch of this._iteratePrefixes(serializedPath, delimiter)) {\n      yield prefixMatch.prefix;\n    }\n  }\n\n  private static *_iteratePrefixes(input: string, delimiter: string = '/'): Iterable<IPrefixEntry> {\n    if (!input) {\n      return;\n    }\n\n    let previousIndex: number = 0;\n    let nextIndex: number = input.indexOf(delimiter);\n\n    // Leading segments\n    while (nextIndex >= 0) {\n      yield {\n        prefix: input.slice(previousIndex, nextIndex),\n        index: nextIndex\n      };\n      previousIndex = nextIndex + 1;\n      nextIndex = input.indexOf(delimiter, previousIndex);\n    }\n\n    // Last segment\n    if (previousIndex < input.length) {\n      yield {\n        prefix: input.slice(previousIndex, input.length),\n        index: input.length\n      };\n    }\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Deletes all entries from this `LookupByPath` instance.\n   *\n   * @returns this, for chained calls\n   */\n  public clear(): this {\n    this._root.value = undefined;\n    this._root.children = undefined;\n    this._size = 0;\n    return this;\n  }\n\n  /**\n   * Associates the value with the specified serialized path.\n   * If a value is already associated, will overwrite.\n   *\n   * @returns this, for chained calls\n   */\n  public setItem(serializedPath: string, value: TItem, delimiter: string = this.delimiter): this {\n    return this.setItemFromSegments(LookupByPath.iteratePathSegments(serializedPath, delimiter), value);\n  }\n\n  /**\n   * Deletes an item if it exists.\n   * @param query - The path to the item to delete\n   * @param delimeter - Optional override delimeter for parsing the query\n   * @returns `true` if the item was found and deleted, `false` otherwise\n   * @remarks\n   * If the node has children with values, they will be retained.\n   */\n  public deleteItem(query: string, delimeter: string = this.delimiter): boolean {\n    const node: IPathTrieNode<TItem> | undefined = this._findNodeAtPrefix(query, delimeter);\n    if (node?.value !== undefined) {\n      node.value = undefined;\n      this._size--;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Associates the value with the specified path.\n   * If a value is already associated, will overwrite.\n   *\n   * @returns this, for chained calls\n   */\n  public setItemFromSegments(pathSegments: Iterable<string>, value: TItem): this {\n    let node: IPathTrieNode<TItem> = this._root;\n    for (const segment of pathSegments) {\n      if (!node.children) {\n        node.children = new Map();\n      }\n      let child: IPathTrieNode<TItem> | undefined = node.children.get(segment);\n      if (!child) {\n        node.children.set(\n          segment,\n          (child = {\n            value: undefined,\n            children: undefined\n          })\n        );\n      }\n      node = child;\n    }\n    if (node.value === undefined) {\n      this._size++;\n    }\n    node.value = value;\n\n    return this;\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public findChildPath(childPath: string, delimiter: string = this.delimiter): TItem | undefined {\n    return this.findChildPathFromSegments(LookupByPath.iteratePathSegments(childPath, delimiter));\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public findLongestPrefixMatch(\n    query: string,\n    delimiter: string = this.delimiter\n  ): IPrefixMatch<TItem> | undefined {\n    return this._findLongestPrefixMatch(LookupByPath._iteratePrefixes(query, delimiter));\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public findChildPathFromSegments(childPathSegments: Iterable<string>): TItem | undefined {\n    let node: IPathTrieNode<TItem> = this._root;\n    let best: TItem | undefined = node.value;\n    // Trivial cases\n    if (node.children) {\n      for (const segment of childPathSegments) {\n        const child: IPathTrieNode<TItem> | undefined = node.children.get(segment);\n        if (!child) {\n          break;\n        }\n        node = child;\n        best = node.value ?? best;\n        if (!node.children) {\n          break;\n        }\n      }\n    }\n\n    return best;\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public has(key: string, delimiter: string = this.delimiter): boolean {\n    const match: IPrefixMatch<TItem> | undefined = this.findLongestPrefixMatch(key, delimiter);\n    return match?.index === key.length;\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public get(key: string, delimiter: string = this.delimiter): TItem | undefined {\n    const match: IPrefixMatch<TItem> | undefined = this.findLongestPrefixMatch(key, delimiter);\n    return match?.index === key.length ? match.value : undefined;\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public groupByChild<TInfo>(\n    infoByPath: Map<string, TInfo>,\n    delimiter: string = this.delimiter\n  ): Map<TItem, Map<string, TInfo>> {\n    const groupedInfoByChild: Map<TItem, Map<string, TInfo>> = new Map();\n\n    for (const [path, info] of infoByPath) {\n      const child: TItem | undefined = this.findChildPath(path, delimiter);\n      if (child === undefined) {\n        continue;\n      }\n      let groupedInfo: Map<string, TInfo> | undefined = groupedInfoByChild.get(child);\n      if (!groupedInfo) {\n        groupedInfo = new Map();\n        groupedInfoByChild.set(child, groupedInfo);\n      }\n      groupedInfo.set(path, info);\n    }\n\n    return groupedInfoByChild;\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public *entries(query?: string, delimiter: string = this.delimiter): IterableIterator<[string, TItem]> {\n    let root: IPathTrieNode<TItem> | undefined;\n    if (query) {\n      root = this._findNodeAtPrefix(query, delimiter);\n      if (!root) {\n        return;\n      }\n    } else {\n      root = this._root;\n    }\n\n    const stack: [string, IPathTrieNode<TItem>][] = [[query ?? '', root]];\n    while (stack.length > 0) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const [prefix, node] = stack.pop()!;\n      if (node.value !== undefined) {\n        yield [prefix, node.value];\n      }\n      if (node.children) {\n        for (const [segment, child] of node.children) {\n          stack.push([prefix ? `${prefix}${delimiter}${segment}` : segment, child]);\n        }\n      }\n    }\n  }\n\n  /**\n   * {@inheritdoc IReadonlyLookupByPath}\n   */\n  public [Symbol.iterator](\n    query?: string,\n    delimiter: string = this.delimiter\n  ): IterableIterator<[string, TItem]> {\n    return this.entries(query, delimiter);\n  }\n\n  /**\n   * Iterates through progressively longer prefixes of a given string and returns as soon\n   * as the number of candidate items that match the prefix are 1 or 0.\n   *\n   * If a match is present, returns the matched itme and the length of the matched prefix.\n   *\n   * @returns the found item, or `undefined` if no item was found\n   */\n  private _findLongestPrefixMatch(prefixes: Iterable<IPrefixEntry>): IPrefixMatch<TItem> | undefined {\n    let node: IPathTrieNode<TItem> = this._root;\n    let best: IPrefixMatch<TItem> | undefined = node.value\n      ? {\n          value: node.value,\n          index: 0,\n          lastMatch: undefined\n        }\n      : undefined;\n    // Trivial cases\n    if (node.children) {\n      for (const { prefix: hash, index } of prefixes) {\n        const child: IPathTrieNode<TItem> | undefined = node.children.get(hash);\n        if (!child) {\n          break;\n        }\n        node = child;\n        if (node.value !== undefined) {\n          best = {\n            value: node.value,\n            index,\n            lastMatch: best\n          };\n        }\n        if (!node.children) {\n          break;\n        }\n      }\n    }\n\n    return best;\n  }\n\n  /**\n   * Finds the node at the specified path, or `undefined` if no node was found.\n   *\n   * @param query - The path to the node to search for\n   * @returns The trie node at the specified path, or `undefined` if no node was found\n   */\n  private _findNodeAtPrefix(\n    query: string,\n    delimiter: string = this.delimiter\n  ): IPathTrieNode<TItem> | undefined {\n    let node: IPathTrieNode<TItem> = this._root;\n    for (const { prefix } of LookupByPath._iteratePrefixes(query, delimiter)) {\n      if (!node.children) {\n        return undefined;\n      }\n      const child: IPathTrieNode<TItem> | undefined = node.children.get(prefix);\n      if (!child) {\n        return undefined;\n      }\n      node = child;\n    }\n    return node;\n  }\n}\n"]}