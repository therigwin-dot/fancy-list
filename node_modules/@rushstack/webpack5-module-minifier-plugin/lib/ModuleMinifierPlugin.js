"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleMinifierPlugin = void 0;
const crypto_1 = require("crypto");
const tapable_1 = require("tapable");
const Constants_1 = require("./Constants");
const module_minifier_1 = require("@rushstack/module-minifier");
const GenerateLicenseFileForAsset_1 = require("./GenerateLicenseFileForAsset");
const RehydrateAsset_1 = require("./RehydrateAsset");
// The name of the plugin, for use in taps
const PLUGIN_NAME = 'ModuleMinifierPlugin';
// Monotonically increasing identifier to be incremented any time the code generation logic changes
// Will be applied to the webpack hash.
const CODE_GENERATION_REVISION = 1;
// Match behavior of terser's "some" option
// https://github.com/terser/terser/blob/d3d924fa9e4c57bbe286b811c6068bcc7026e902/lib/output.js#L175
const LICENSE_COMMENT_REGEX = /@preserve|@lic|@cc_on|^\**!/i;
const TAP_BEFORE = {
    name: PLUGIN_NAME,
    stage: Constants_1.STAGE_BEFORE
};
const TAP_AFTER = {
    name: PLUGIN_NAME,
    stage: Constants_1.STAGE_AFTER
};
const compilationMetadataMap = new WeakMap();
function hashCodeFragment(code) {
    return (0, crypto_1.createHash)('sha256').update(code).digest('hex');
}
/**
 * Base implementation of asset rehydration
 *
 * @param dehydratedAssets The dehydrated assets
 * @param compilation The webpack compilation
 */
function defaultRehydrateAssets(dehydratedAssets, compilation) {
    const { assets, modules } = dehydratedAssets;
    const compilationMetadata = compilationMetadataMap.get(compilation);
    if (!compilationMetadata) {
        throw new Error(`Could not get compilation metadata`);
    }
    const { metadataByAssetFileName } = compilationMetadata;
    // Now assets/modules contain fully minified code. Rehydrate.
    for (const [assetName, info] of assets) {
        const banner = info.type === 'javascript' ? (0, GenerateLicenseFileForAsset_1.generateLicenseFileForAsset)(compilation, info) : '';
        const replacementSource = (0, RehydrateAsset_1.rehydrateAsset)(compilation, info, modules, banner, true);
        metadataByAssetFileName.set(assetName, {
            positionByModuleId: info.renderInfo
        });
        compilation.updateAsset(assetName, replacementSource);
    }
    return dehydratedAssets;
}
function isMinificationResultError(result) {
    return !!result.error;
}
function isLicenseComment(comment) {
    return LICENSE_COMMENT_REGEX.test(comment.value);
}
/**
 * Webpack plugin that minifies code on a per-module basis rather than per-asset. The actual minification is handled by the input `minifier` object.
 * @public
 */
class ModuleMinifierPlugin {
    constructor(options) {
        this.hooks = {
            rehydrateAssets: new tapable_1.AsyncSeriesWaterfallHook(['dehydratedContent', 'compilation']),
            postProcessCodeFragment: new tapable_1.SyncWaterfallHook(['code', 'context'])
        };
        const { minifier, sourceMap } = options;
        this._optionsForHash = {
            ...options,
            minifier: undefined,
            revision: CODE_GENERATION_REVISION
        };
        this._enhancers = [];
        this.hooks.rehydrateAssets.tap(PLUGIN_NAME, defaultRehydrateAssets);
        this.minifier = minifier;
        this._sourceMap = sourceMap;
    }
    static getCompilationStatistics(compilation) {
        return compilationMetadataMap.get(compilation);
    }
    apply(compiler) {
        for (const enhancer of this._enhancers) {
            enhancer.apply(compiler);
        }
        const { options: { devtool, mode }, webpack } = compiler;
        webpack.Template.numberToIdentifier = module_minifier_1.getIdentifier;
        const { CachedSource, ConcatSource, RawSource, ReplaceSource, SourceMapSource } = webpack.sources;
        // The explicit setting is preferred due to accuracy, but try to guess based on devtool
        const useSourceMaps = typeof this._sourceMap === 'boolean'
            ? this._sourceMap
            : typeof devtool === 'string'
                ? devtool.endsWith('source-map')
                : mode === 'production' && devtool !== false;
        this._optionsForHash.sourceMap = useSourceMaps;
        const binaryConfig = Buffer.from(JSON.stringify(this._optionsForHash), 'utf-8');
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation, compilationData) => {
            const { normalModuleFactory } = compilationData;
            function addCommentExtraction(parser) {
                parser.hooks.program.tap(PLUGIN_NAME, (program, comments) => {
                    const relevantComments = comments.filter(isLicenseComment);
                    if (comments.length > 0) {
                        // Webpack's typings now restrict the properties on factoryMeta for unknown reasons
                        const module = parser.state.module;
                        if (!module.factoryMeta) {
                            module.factoryMeta = {
                                comments: relevantComments
                            };
                        }
                        else {
                            module.factoryMeta.comments = relevantComments;
                        }
                    }
                });
            }
            normalModuleFactory.hooks.parser.for('javascript/auto').tap(PLUGIN_NAME, addCommentExtraction);
            normalModuleFactory.hooks.parser.for('javascript/dynamic').tap(PLUGIN_NAME, addCommentExtraction);
            normalModuleFactory.hooks.parser.for('javascript/esm').tap(PLUGIN_NAME, addCommentExtraction);
            /**
             * Set of local module ids that have been processed.
             */
            const submittedModules = new Set();
            /**
             * The text and comments of all minified modules.
             */
            const minifiedModules = new Map();
            /**
             * The text and comments of all minified chunks. Most of these are trivial, but the runtime chunk is a bit larger.
             */
            const minifiedAssets = new Map();
            const metadataByModule = new WeakMap();
            const metadataByAssetFileName = new Map();
            const compilationStatistics = {
                metadataByModule,
                metadataByAssetFileName
            };
            compilationMetadataMap.set(compilation, compilationStatistics);
            function getOrCreateMetadata(mod) {
                let moduleStats = metadataByModule.get(mod);
                if (!moduleStats) {
                    moduleStats = {
                        hashByChunk: new Map(),
                        sizeByHash: new Map()
                    };
                    metadataByModule.set(mod, moduleStats);
                }
                return moduleStats;
            }
            let pendingMinificationRequests = 0;
            /**
             * Indicates that all files have been sent to the minifier and therefore that when pending hits 0, assets can be rehydrated.
             */
            let allRequestsIssued = false;
            let resolveMinifyPromise;
            const postProcessCode = (code, context) => this.hooks.postProcessCodeFragment.call(code, context);
            /**
             * Callback to invoke when a file has finished minifying.
             */
            function onFileMinified() {
                if (--pendingMinificationRequests === 0 && allRequestsIssued) {
                    resolveMinifyPromise();
                }
            }
            const { minifier } = this;
            let minifierConnection;
            // Typings for this object are not exposed
            // eslint-disable-next-line @typescript-eslint/typedef
            const javascriptHooks = webpack.javascript.JavascriptModulesPlugin.getCompilationHooks(compilation);
            /**
             * The minifier needs to know if the module was wrapped in a factory function, because
             * function (module, exports, require) { // <implementation> }
             * minifies to nothing. Unfortunately we can't tell by inspection if the output was wrapped or not.
             * However, the JavaScriptModulesPlugin invokes three hooks in order when rendering a module:
             * 1) renderModuleContent - Invoked for every module.
             * 2) renderModuleContainer - Invoked when wrapping a module in a factory.
             * 3) renderModulePackage - Invoked for every module as the last hook.
             */
            let nextModule;
            const sourceCache = new WeakMap();
            javascriptHooks.renderModuleContent.tap(TAP_AFTER, (source) => {
                // Clear the identification state of the current module.
                nextModule = undefined;
                return source;
            });
            javascriptHooks.renderModuleContainer.tap(TAP_AFTER, (source, mod) => {
                // Module is being wrapped in a factory, so it is safe for per-module minification
                // Leave external modules in-place to avoid needing special handling for externals
                if (mod.context !== null || !mod.externalType) {
                    nextModule = mod;
                }
                return source;
            });
            javascriptHooks.renderModulePackage.tap(TAP_AFTER, 
            /**
             * Extracts the code for the module and sends it to be minified.
             */
            function minifyModule(source, mod, chunkRenderContext) {
                if (nextModule !== mod) {
                    // This module is being inlined. Abandon per-module minification.
                    return source;
                }
                const id = compilation.chunkGraph.getModuleId(mod);
                if (id === null) {
                    // This module has no id. Abandon per-module minification.
                    return source;
                }
                const metadata = getOrCreateMetadata(mod);
                const cachedResult = sourceCache.get(source);
                if (cachedResult) {
                    metadata.hashByChunk.set(chunkRenderContext.chunk, cachedResult.hash);
                    return cachedResult.source;
                }
                // If this module is wrapped in a factory, need to add boilerplate so that the minifier keeps the function
                const wrapped = new ConcatSource(Constants_1.MODULE_WRAPPER_PREFIX + '\n', source, '\n' + Constants_1.MODULE_WRAPPER_SUFFIX);
                const nameForMap = `(modules)/${id}`;
                const { source: wrappedCodeRaw, map } = useSourceMaps
                    ? wrapped.sourceAndMap()
                    : {
                        source: wrapped.source(),
                        map: undefined
                    };
                const wrappedCode = wrappedCodeRaw.toString();
                const hash = hashCodeFragment(wrappedCode);
                metadata.hashByChunk.set(chunkRenderContext.chunk, hash);
                if (!submittedModules.has(hash)) {
                    submittedModules.add(hash);
                    ++pendingMinificationRequests;
                    minifier.minify({
                        hash,
                        code: wrappedCode,
                        nameForMap: useSourceMaps ? nameForMap : undefined,
                        externals: undefined
                    }, (result) => {
                        if (isMinificationResultError(result)) {
                            compilation.errors.push(result.error);
                        }
                        else {
                            try {
                                const { code: minified, map: minifierMap } = result;
                                const rawOutput = useSourceMaps
                                    ? new SourceMapSource(minified, // Code
                                    nameForMap, // File
                                    minifierMap, // Base source map
                                    wrappedCode, // Source from before transform
                                    map, // Source Map from before transform
                                    true // Remove original source
                                    )
                                    : new RawSource(minified);
                                const unwrapped = new ReplaceSource(rawOutput);
                                const len = minified.length;
                                // Trim off the boilerplate used to preserve the factory
                                unwrapped.replace(0, Constants_1.MODULE_WRAPPER_PREFIX.length - 1, '');
                                unwrapped.replace(len - Constants_1.MODULE_WRAPPER_SUFFIX.length, len - 1, '');
                                const withIds = postProcessCode(unwrapped, {
                                    compilation,
                                    module: mod,
                                    loggingName: mod.identifier()
                                });
                                const cached = new CachedSource(withIds);
                                const minifiedSize = Buffer.byteLength(cached.source(), 'utf-8');
                                metadata.sizeByHash.set(hash, minifiedSize);
                                minifiedModules.set(hash, {
                                    source: cached,
                                    module: mod,
                                    id
                                });
                            }
                            catch (err) {
                                compilation.errors.push(err);
                            }
                        }
                        onFileMinified();
                    });
                }
                const result = new RawSource(`${Constants_1.CHUNK_MODULE_TOKEN}${hash}`);
                sourceCache.set(source, {
                    hash,
                    source: result
                });
                // Return an expression to replace later
                return result;
            });
            // The optimizeChunkModules hook is the last async hook that occurs before chunk rendering
            compilation.hooks.optimizeChunkModules.tapPromise(PLUGIN_NAME, async () => {
                minifierConnection = await minifier.connectAsync();
                submittedModules.clear();
            });
            const isJSAsset = /\.[cm]?js(\?.+)?$/;
            // This should happen before any other tasks that operate during processAssets
            compilation.hooks.processAssets.tapPromise(TAP_BEFORE, async () => {
                const { chunkGraph, chunks } = compilation;
                // Still need to minify the rendered assets
                for (const chunk of chunks) {
                    const allChunkModules = chunkGraph.getChunkModulesIterableBySourceType(chunk, 'javascript');
                    if (!allChunkModules) {
                        // This chunk does not contain javascript modules
                        continue;
                    }
                    for (const assetName of chunk.files) {
                        const asset = compilation.assets[assetName];
                        // Verify that this is a JS asset
                        if (isJSAsset.test(assetName)) {
                            ++pendingMinificationRequests;
                            const { source: wrappedCodeRaw, map } = useSourceMaps
                                ? asset.sourceAndMap()
                                : {
                                    source: asset.source(),
                                    map: undefined
                                };
                            const rawCode = wrappedCodeRaw.toString();
                            const nameForMap = `(chunks)/${assetName}`;
                            const hash = hashCodeFragment(rawCode);
                            minifier.minify({
                                hash,
                                code: rawCode,
                                nameForMap: useSourceMaps ? nameForMap : undefined,
                                externals: undefined
                            }, (result) => {
                                if (isMinificationResultError(result)) {
                                    compilation.errors.push(result.error);
                                    // eslint-disable-next-line no-console
                                    console.error(result.error);
                                }
                                else {
                                    try {
                                        const { code: minified, map: minifierMap } = result;
                                        const rawOutput = useSourceMaps
                                            ? new SourceMapSource(minified, // Code
                                            nameForMap, // File
                                            minifierMap, // Base source map
                                            rawCode, // Source from before transform
                                            map, // Source Map from before transform
                                            true // Remove original source
                                            )
                                            : new RawSource(minified);
                                        const withIds = postProcessCode(new ReplaceSource(rawOutput), {
                                            compilation,
                                            module: undefined,
                                            loggingName: assetName
                                        });
                                        minifiedAssets.set(assetName, {
                                            source: new CachedSource(withIds),
                                            chunk,
                                            fileName: assetName,
                                            renderInfo: new Map(),
                                            type: 'javascript'
                                        });
                                    }
                                    catch (err) {
                                        compilation.errors.push(err);
                                    }
                                }
                                onFileMinified();
                            });
                        }
                        else {
                            // This isn't a JS asset. Don't try to minify the asset wrapper, though if it contains modules, those might still get replaced with minified versions.
                            minifiedAssets.set(assetName, {
                                // Still need to restore ids
                                source: postProcessCode(new ReplaceSource(asset), {
                                    compilation,
                                    module: undefined,
                                    loggingName: assetName
                                }),
                                chunk,
                                fileName: assetName,
                                renderInfo: new Map(),
                                type: 'unknown'
                            });
                        }
                    }
                }
                allRequestsIssued = true;
                if (pendingMinificationRequests) {
                    await new Promise((resolve) => {
                        resolveMinifyPromise = resolve;
                    });
                }
                // Handle any error from the minifier.
                await (minifierConnection === null || minifierConnection === void 0 ? void 0 : minifierConnection.disconnectAsync());
                // All assets and modules have been minified, hand them off to be rehydrated
                await this.hooks.rehydrateAssets.promise({
                    assets: minifiedAssets,
                    modules: minifiedModules
                }, compilation);
            });
            // Need to update chunk hashes with information from this plugin
            javascriptHooks.chunkHash.tap(PLUGIN_NAME, (chunk, hash) => {
                // Apply the options hash
                hash.update(binaryConfig);
                // Apply the hash from the minifier
                if (minifierConnection) {
                    hash.update(minifierConnection.configHash, 'utf8');
                }
            });
        });
    }
}
exports.ModuleMinifierPlugin = ModuleMinifierPlugin;
//# sourceMappingURL=ModuleMinifierPlugin.js.map