"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.rehydrateAsset = rehydrateAsset;
const Constants_1 = require("./Constants");
/**
 * Rehydrates an asset with minified modules.
 * @param asset - The asset
 * @param moduleMap - The minified modules
 * @param banner - A banner to inject for license information
 * @public
 */
function rehydrateAsset(compilation, asset, moduleMap, banner, emitRenderInfo) {
    const { source: assetSource } = asset;
    const { webpack: { sources, WebpackError } } = compilation.compiler;
    const assetCode = assetSource.source().toString();
    const tokenIndex = assetCode.indexOf(Constants_1.CHUNK_MODULE_TOKEN);
    if (tokenIndex < 0) {
        // This is not a JS asset.
        return assetSource;
    }
    const { CachedSource, ConcatSource, ReplaceSource } = sources;
    Constants_1.CHUNK_MODULE_REGEX.lastIndex = -1;
    let lastStart = 0;
    const cachedAssetSource = new CachedSource(assetSource);
    const source = new ConcatSource(banner);
    let charOffset = banner.length;
    // RegExp.exec uses null or an array as the return type, explicitly
    let match = null;
    while ((match = Constants_1.CHUNK_MODULE_REGEX.exec(assetCode))) {
        const hash = match[1];
        const moduleSource = moduleMap.get(hash);
        if (moduleSource === undefined) {
            compilation.errors.push(new WebpackError(`Missing module source for ${hash} in ${asset.fileName}!`));
        }
        const separator = extractSegmentFromSource(ReplaceSource, cachedAssetSource, lastStart, match.index);
        source.add(separator);
        charOffset += separator.size();
        lastStart = Constants_1.CHUNK_MODULE_REGEX.lastIndex;
        if (moduleSource) {
            const charLength = moduleSource.source.source().length;
            if (emitRenderInfo) {
                asset.renderInfo.set(moduleSource.id, {
                    charOffset,
                    charLength
                });
            }
            source.add(moduleSource.source);
            charOffset += charLength;
        }
        else {
            const errorModule = `()=>{throw new Error(\`Missing module with hash "${hash}"\`)}`;
            source.add(errorModule);
            charOffset += errorModule.length;
        }
        source.add('\n');
        charOffset += 1;
    }
    source.add(extractSegmentFromSource(ReplaceSource, cachedAssetSource, lastStart, Infinity));
    return new CachedSource(source);
}
// In order to preserve source maps during substitution, have to use a ConcatSource instead of a ReplaceSource, so need to extract the segements from the original
function extractSegmentFromSource(replaceSourceConstructor, source, start, end) {
    const result = new replaceSourceConstructor(source);
    result.replace(end, Infinity, '');
    result.replace(0, start - 1, '');
    return result;
}
//# sourceMappingURL=RehydrateAsset.js.map