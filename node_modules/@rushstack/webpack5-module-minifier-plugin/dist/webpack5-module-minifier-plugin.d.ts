import type { AsyncSeriesWaterfallHook } from 'tapable';
import type { Chunk } from 'webpack';
import type { Comment } from 'estree';
import type { Compilation } from 'webpack';
import type { Compiler } from 'webpack';
import type { IModuleMinifier } from '@rushstack/module-minifier';
import type { Module } from 'webpack';
import type { sources } from 'webpack';
import type { SyncWaterfallHook } from 'tapable';
import type { WebpackPluginInstance } from 'webpack';

/**
 * RegExp for replacing chunk module placeholders
 * @public
 */
export declare const CHUNK_MODULE_REGEX: RegExp;

/**
 * Token preceding a module id in the emitted asset so the minifier can operate on the Webpack runtime or chunk boilerplate in isolation
 * @public
 */
export declare const CHUNK_MODULE_TOKEN: '__WEBPACK_CHUNK_MODULE__';

/**
 * Generates a companion asset containing all extracted comments. If it is non-empty, returns a banner comment directing users to said companion asset.
 *
 * @param compilation - The webpack compilation
 * @param asset - The asset to process
 * @public
 */
export declare function generateLicenseFileForAsset(compilation: Compilation, asset: IAssetInfo): string;

/**
 * Information about a dehydrated webpack ECMAScript asset
 * @public
 */
export declare interface IAssetInfo {
    /**
     * The (minified) boilerplate code for the asset. Will contain a token to be replaced by the minified modules.
     */
    source: sources.Source;
    /**
     * The name of the asset, used to index into compilation.assets
     */
    fileName: string;
    /**
     * The raw chunk object from Webpack, in case information from it is necessary for reconstruction
     */
    chunk: Chunk;
    /**
     * Information about the offsets and character lengths for each rendered module in the final asset.
     */
    renderInfo: Map<string | number, IRenderedModulePosition>;
    /**
     * The type of the asset
     * @example 'javascript'
     * @example 'css'
     */
    type: string;
}

/**
 * A map from file names to dehydrated assets
 * @public
 */
export declare type IAssetMap = Map<string, IAssetInfo>;

/**
 * Rendered positional data
 * @public
 */
export declare interface IAssetStats {
    positionByModuleId: Map<string | number, IRenderedModulePosition>;
}

/**
 * The set of data remaining to rehydrate in the current compilation
 * @public
 */
export declare interface IDehydratedAssets {
    /**
     * The set of remaining assets to rehydrate. Each tap may remove some or all assets from this collection
     */
    assets: IAssetMap;
    /**
     * The set of modules to use for rehydrating assets.
     */
    modules: IModuleMap;
}

/**
 * Properties surfaced via the `factoryMeta` property on webpack modules
 * @public
 */
export declare interface IFactoryMeta {
    comments?: Comment[];
    skipMinification?: boolean;
}

/**
 * Information about a minified module
 * @public
 */
export declare interface IModuleInfo {
    /**
     * The (minified) code of this module. Will be a function expression.
     */
    source: sources.Source;
    /**
     * The raw module object from Webpack, in case information from it is necessary for reconstruction
     */
    module: Module;
    /**
     * The id of the module, from the chunk graph.
     */
    id: string | number;
}

/**
 * A map from module ids to minified modules
 * @public
 */
export declare type IModuleMap = Map<string | number, IModuleInfo>;

/**
 * Hooks provided by the ModuleMinifierPlugin
 * @public
 */
export declare interface IModuleMinifierPluginHooks {
    /**
     * Hook invoked at the start of optimizeChunkAssets to rehydrate the minified boilerplate and runtime into chunk assets.
     */
    rehydrateAssets: AsyncSeriesWaterfallHook<[IDehydratedAssets, Compilation]>;
    /**
     * Hook invoked on code after it has been returned from the minifier.
     */
    postProcessCodeFragment: SyncWaterfallHook<[sources.ReplaceSource, IPostProcessFragmentContext]>;
}

/**
 * Options to the ModuleMinifierPlugin constructor
 * @public
 */
export declare interface IModuleMinifierPluginOptions {
    /**
     * Minifier implementation to use. Required.
     */
    minifier: IModuleMinifier;
    /**
     * Whether to enable source map processing. If not provided, will attempt to guess based on `mode` and `devtool` in the webpack config.
     * Set to `false` for faster builds at the expense of debuggability.
     */
    sourceMap?: boolean;
}

/**
 * Statistics from the plugin. Namely module sizes.
 * @public
 */
export declare interface IModuleMinifierPluginStats {
    metadataByModule: WeakMap<Module, IModuleStats>;
    metadataByAssetFileName: Map<string, IAssetStats>;
}

/**
 * Module size data as a function of the target chunk.
 * @public
 */
export declare interface IModuleStats {
    hashByChunk: Map<Chunk, string>;
    sizeByHash: Map<string, number>;
}

/**
 * Argument to the postProcessCodeFragment hook for the current execution context
 * @public
 */
export declare interface IPostProcessFragmentContext {
    /**
     * The current webpack compilation, for error reporting
     */
    compilation: Compilation;
    /**
     * A name to use for logging
     */
    loggingName: string;
    /**
     * The current module being processed, or `undefined` if not in a module (e.g. the bootstrapper)
     */
    module: Module | undefined;
}

/**
 * Information about where the module was rendered in the emitted asset.
 * @public
 */
export declare interface IRenderedModulePosition {
    /**
     * The offset from the start of tha asset to the start of the module, in characters.
     */
    charOffset: number;
    /**
     * The length of the rendered module, in characters.
     */
    charLength: number;
}

/**
 * Prefix to wrap `function (module, __webpack_exports__, __webpack_require__) { ... }` so that the minifier doesn't delete it.
 * Public because alternate Minifier implementations may wish to know about it.
 * @public
 */
export declare const MODULE_WRAPPER_PREFIX: '__MINIFY_MODULE__(';

/**
 * Suffix to wrap `function (module, __webpack_exports__, __webpack_require__) { ... }` so that the minifier doesn't delete it.
 * Public because alternate Minifier implementations may wish to know about it.
 * @public
 */
export declare const MODULE_WRAPPER_SUFFIX: ');';

/**
 * Webpack plugin that minifies code on a per-module basis rather than per-asset. The actual minification is handled by the input `minifier` object.
 * @public
 */
export declare class ModuleMinifierPlugin implements WebpackPluginInstance {
    readonly hooks: IModuleMinifierPluginHooks;
    minifier: IModuleMinifier;
    private readonly _enhancers;
    private readonly _sourceMap;
    private readonly _optionsForHash;
    constructor(options: IModuleMinifierPluginOptions);
    static getCompilationStatistics(compilation: Compilation): IModuleMinifierPluginStats | undefined;
    apply(compiler: Compiler): void;
}

/**
 * Stage # to use when this should be the last tap in the hook
 * @public
 */
export declare const STAGE_AFTER: 100;

/**
 * Stage # to use when this should be the first tap in the hook
 * @public
 */
export declare const STAGE_BEFORE: -10000;

export { }
