{"version":3,"file":"AssetHandler.js","sourceRoot":"","sources":["../src/AssetHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport path from 'node:path';\nimport fs from 'node:fs';\nimport { Async, FileSystem, Path, type FileSystemStats } from '@rushstack/node-core-library';\nimport type { ITerminal } from '@rushstack/terminal';\nimport { ArchiveManager } from './ArchiveManager';\nimport type { IExtractorOptions, LinkCreationMode } from './PackageExtractor';\nimport type { ILinkInfo, SymlinkAnalyzer } from './SymlinkAnalyzer';\nimport { remapSourcePathForTargetFolder } from './Utils';\n\nexport interface IIncludeAssetOptions {\n  sourceFilePath?: string;\n  sourceFileStats?: FileSystemStats;\n  sourceFileContent?: string | Buffer;\n  targetFilePath: string;\n  ignoreIfExisting?: boolean;\n}\n\nexport interface IIncludeAssetPathOptions extends IIncludeAssetOptions {\n  sourceFilePath: string;\n  sourceFileContent?: never;\n}\n\nexport interface IIncludeExistingAssetPathOptions extends IIncludeAssetOptions {\n  sourceFilePath?: never;\n  sourceFileContent?: never;\n}\n\nexport interface IIncludeAssetContentOptions extends IIncludeAssetOptions {\n  sourceFileContent: string | Buffer;\n  sourceFilePath?: never;\n  sourceFileStats?: never;\n}\n\nexport interface IAssetHandlerOptions extends IExtractorOptions {\n  symlinkAnalyzer: SymlinkAnalyzer;\n}\n\nexport interface IFinalizeOptions {\n  onAfterExtractSymlinksAsync: () => Promise<void>;\n}\n\nexport class AssetHandler {\n  private readonly _terminal: ITerminal;\n  private readonly _sourceRootFolder: string;\n  private readonly _targetRootFolder: string;\n  private readonly _createArchiveOnly: boolean;\n  private readonly _symlinkAnalyzer: SymlinkAnalyzer;\n  private readonly _archiveManager: ArchiveManager | undefined;\n  private readonly _archiveFilePath: string | undefined;\n  private readonly _linkCreationMode: LinkCreationMode;\n  private readonly _includedAssetPaths: Set<string> = new Set<string>();\n  private _isFinalized: boolean = false;\n\n  public constructor(options: IAssetHandlerOptions) {\n    const {\n      terminal,\n      sourceRootFolder,\n      targetRootFolder,\n      linkCreation,\n      symlinkAnalyzer,\n      createArchiveFilePath,\n      createArchiveOnly = false\n    } = options;\n    this._terminal = terminal;\n    this._sourceRootFolder = sourceRootFolder;\n    this._targetRootFolder = targetRootFolder;\n    this._symlinkAnalyzer = symlinkAnalyzer;\n    if (createArchiveFilePath) {\n      if (path.extname(createArchiveFilePath) !== '.zip') {\n        throw new Error('Only archives with the .zip file extension are currently supported.');\n      }\n      this._archiveFilePath = path.resolve(targetRootFolder, createArchiveFilePath);\n      this._archiveManager = new ArchiveManager();\n    }\n    if (createArchiveOnly && !this._archiveManager) {\n      throw new Error('createArchiveOnly cannot be true if createArchiveFilePath is not provided');\n    }\n    this._createArchiveOnly = createArchiveOnly;\n    this._linkCreationMode = linkCreation || 'default';\n  }\n\n  public async includeAssetAsync(options: IIncludeAssetPathOptions): Promise<void>;\n  public async includeAssetAsync(options: IIncludeExistingAssetPathOptions): Promise<void>;\n  public async includeAssetAsync(options: IIncludeAssetContentOptions): Promise<void>;\n  public async includeAssetAsync(options: IIncludeAssetOptions): Promise<void> {\n    const { sourceFileContent, targetFilePath, ignoreIfExisting = false } = options;\n    let { sourceFilePath } = options;\n\n    if (this._isFinalized) {\n      throw new Error('includeAssetAsync() cannot be called after finalizeAsync()');\n    }\n    if (!sourceFilePath && !sourceFileContent) {\n      if (!Path.isUnder(targetFilePath, this._targetRootFolder)) {\n        throw new Error('The existing asset path must be under the target root folder');\n      }\n      sourceFilePath = targetFilePath;\n    }\n    if (sourceFilePath && sourceFileContent) {\n      throw new Error('Either sourceFilePath or sourceFileContent must be provided, but not both');\n    }\n    if (this._includedAssetPaths.has(targetFilePath)) {\n      if (ignoreIfExisting) {\n        return;\n      }\n      throw new Error(`The asset at path \"${targetFilePath}\" has already been included`);\n    }\n\n    if (!this._createArchiveOnly) {\n      // Ignore when the source file is the same as the target file, as it's a no-op\n      if (sourceFilePath && sourceFilePath !== targetFilePath) {\n        // Use the fs.copyFile API instead of FileSystem.copyFileAsync() since copyFileAsync performs\n        // a needless stat() call to determine if it's a file or folder, and we already know it's a file.\n        try {\n          await fs.promises.copyFile(sourceFilePath, targetFilePath, fs.constants.COPYFILE_EXCL);\n        } catch (e: unknown) {\n          if (!FileSystem.isNotExistError(e as Error)) {\n            throw e;\n          }\n          // The parent folder may not exist, so ensure it exists before trying to copy again\n          await FileSystem.ensureFolderAsync(path.dirname(targetFilePath));\n          await fs.promises.copyFile(sourceFilePath, targetFilePath, fs.constants.COPYFILE_EXCL);\n        }\n      } else if (sourceFileContent) {\n        await FileSystem.writeFileAsync(targetFilePath, sourceFileContent, {\n          ensureFolderExists: true\n        });\n      }\n    }\n\n    if (this._archiveManager) {\n      const targetRelativeFilePath: string = path.relative(this._targetRootFolder, targetFilePath);\n      if (sourceFilePath) {\n        await this._archiveManager.addToArchiveAsync({\n          filePath: sourceFilePath,\n          archivePath: targetRelativeFilePath\n        });\n      } else if (sourceFileContent) {\n        await this._archiveManager.addToArchiveAsync({\n          fileData: sourceFileContent,\n          archivePath: targetRelativeFilePath\n        });\n      }\n    }\n\n    this._includedAssetPaths.add(targetFilePath);\n  }\n\n  public get assetPaths(): string[] {\n    return [...this._includedAssetPaths];\n  }\n\n  public async finalizeAsync(options?: IFinalizeOptions): Promise<void> {\n    const { onAfterExtractSymlinksAsync } = options ?? {};\n\n    if (this._isFinalized) {\n      throw new Error('finalizeAsync() has already been called');\n    }\n\n    if (this._linkCreationMode === 'default') {\n      this._terminal.writeLine('Creating symlinks');\n      const linksToCopy: ILinkInfo[] = this._symlinkAnalyzer.reportSymlinks();\n      await Async.forEachAsync(linksToCopy, async (linkToCopy: ILinkInfo) => {\n        await this._extractSymlinkAsync(linkToCopy);\n      });\n    }\n\n    await onAfterExtractSymlinksAsync?.();\n\n    if (this._archiveManager && this._archiveFilePath) {\n      this._terminal.writeLine(`Creating archive at \"${this._archiveFilePath}\"`);\n      await this._archiveManager.createArchiveAsync(this._archiveFilePath);\n    }\n\n    this._isFinalized = true;\n  }\n\n  /**\n   * Create a symlink as described by the ILinkInfo object.\n   */\n  private async _extractSymlinkAsync(linkInfo: ILinkInfo): Promise<void> {\n    const { kind, linkPath, targetPath } = {\n      ...linkInfo,\n      linkPath: remapSourcePathForTargetFolder({\n        sourceRootFolder: this._sourceRootFolder,\n        targetRootFolder: this._targetRootFolder,\n        sourcePath: linkInfo.linkPath\n      }),\n      targetPath: remapSourcePathForTargetFolder({\n        sourceRootFolder: this._sourceRootFolder,\n        targetRootFolder: this._targetRootFolder,\n        sourcePath: linkInfo.targetPath\n      })\n    };\n\n    const newLinkFolder: string = path.dirname(linkPath);\n    await FileSystem.ensureFolderAsync(newLinkFolder);\n\n    // Link to the relative path for symlinks\n    const relativeTargetPath: string = path.relative(newLinkFolder, targetPath);\n\n    // NOTE: This logic is based on NpmLinkManager._createSymlink()\n    if (kind === 'fileLink') {\n      // For files, we use a Windows \"hard link\", because creating a symbolic link requires\n      // administrator permission. However hard links seem to cause build failures on Mac,\n      // so for all other operating systems we use symbolic links for this case.\n      if (process.platform === 'win32') {\n        await FileSystem.createHardLinkAsync({\n          linkTargetPath: relativeTargetPath,\n          newLinkPath: linkPath\n        });\n      } else {\n        await FileSystem.createSymbolicLinkFileAsync({\n          linkTargetPath: relativeTargetPath,\n          newLinkPath: linkPath\n        });\n      }\n    } else {\n      // Junctions are only supported on Windows. This will create a symbolic link on other platforms.\n      await FileSystem.createSymbolicLinkJunctionAsync({\n        linkTargetPath: relativeTargetPath,\n        newLinkPath: linkPath\n      });\n    }\n\n    // Since the created symlinks have the required relative paths, they can be added directly to\n    // the archive.\n    await this.includeAssetAsync({ targetFilePath: linkPath });\n  }\n}\n"]}