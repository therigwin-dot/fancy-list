{"version":3,"file":"PackageExtractor.js","sourceRoot":"","sources":["../src/PackageExtractor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport { type IMinimatch, Minimatch } from 'minimatch';\nimport semver from 'semver';\nimport npmPacklist from 'npm-packlist';\nimport ignore, { type Ignore } from 'ignore';\nimport {\n  Async,\n  AsyncQueue,\n  Path,\n  FileSystem,\n  Import,\n  JsonFile,\n  type IPackageJson\n} from '@rushstack/node-core-library';\nimport { Colorize, type ITerminal } from '@rushstack/terminal';\n\nimport { SymlinkAnalyzer, type ILinkInfo, type PathNode } from './SymlinkAnalyzer';\nimport { AssetHandler } from './AssetHandler';\nimport {\n  matchesWithStar,\n  remapSourcePathForTargetFolder,\n  remapPathForExtractorMetadata,\n  makeBinLinksAsync\n} from './Utils';\nimport {\n  CREATE_LINKS_SCRIPT_FILENAME,\n  EXTRACTOR_METADATA_FILENAME,\n  SCRIPTS_FOLDER_PATH\n} from './PathConstants';\nimport { MAX_CONCURRENCY } from './scripts/createLinks/utilities/constants';\n\n// (@types/npm-packlist is missing this API)\ndeclare module 'npm-packlist' {\n  export class Walker {\n    public readonly result: string[];\n    public constructor(opts: { path: string });\n    public on(event: 'done', callback: (result: string[]) => void): Walker;\n    public on(event: 'error', callback: (error: Error) => void): Walker;\n    public start(): void;\n  }\n}\n\nexport const TARGET_ROOT_SCRIPT_RELATIVE_PATH_TEMPLATE_STRING: '{TARGET_ROOT_SCRIPT_RELATIVE_PATH}' =\n  '{TARGET_ROOT_SCRIPT_RELATIVE_PATH}';\n\n/**\n * Part of the extractor-matadata.json file format. Represents an extracted project.\n *\n * @public\n */\nexport interface IProjectInfoJson {\n  /**\n   * The name of the project as specified in its package.json file.\n   */\n  projectName: string;\n  /**\n   * This path is relative to the root of the extractor output folder\n   */\n  path: string;\n}\n\n/**\n * The extractor-metadata.json file format.\n *\n * @public\n */\nexport interface IExtractorMetadataJson {\n  /**\n   * The name of the main project the extraction was performed for.\n   */\n  mainProjectName: string;\n  /**\n   * A list of all projects that were extracted.\n   */\n  projects: IProjectInfoJson[];\n  /**\n   * A list of all links that are part of the extracted project.\n   */\n  links: ILinkInfo[];\n  /**\n   * A list of all files that are part of the extracted project.\n   */\n  files: string[];\n}\n\n/**\n * The extractor subspace configurations\n *\n * @public\n */\nexport interface IExtractorSubspace {\n  /**\n   * The subspace name\n   */\n  subspaceName: string;\n  /**\n   * The folder where the PNPM \"node_modules\" folder is located. This is used to resolve packages linked\n   * to the PNPM virtual store.\n   */\n  pnpmInstallFolder?: string;\n  /**\n   * The pnpmfile configuration if using PNPM, otherwise undefined. The configuration will be used to\n   * transform the package.json prior to extraction.\n   */\n  transformPackageJson?: (packageJson: IPackageJson) => IPackageJson;\n}\n\ninterface IExtractorState {\n  foldersToCopy: Set<string>;\n  packageJsonByPath: Map<string, IPackageJson>;\n  projectConfigurationsByPath: Map<string, IExtractorProjectConfiguration>;\n  projectConfigurationsByName: Map<string, IExtractorProjectConfiguration>;\n  dependencyConfigurationsByName: Map<string, IExtractorDependencyConfiguration[]>;\n  symlinkAnalyzer: SymlinkAnalyzer;\n  assetHandler: AssetHandler;\n}\n\n/**\n * The extractor configuration for individual projects.\n *\n * @public\n */\nexport interface IExtractorProjectConfiguration {\n  /**\n   * The name of the project.\n   */\n  projectName: string;\n  /**\n   * The absolute path to the project.\n   */\n  projectFolder: string;\n  /**\n   * A list of glob patterns to include when extracting this project. If a path is\n   * matched by both \"patternsToInclude\" and \"patternsToExclude\", the path will be\n   * excluded. If undefined, all paths will be included.\n   */\n  patternsToInclude?: string[];\n  /**\n   * A list of glob patterns to exclude when extracting this project. If a path is\n   * matched by both \"patternsToInclude\" and \"patternsToExclude\", the path will be\n   * excluded. If undefined, no paths will be excluded.\n   */\n  patternsToExclude?: string[];\n  /**\n   * The names of additional projects to include when extracting this project.\n   */\n  additionalProjectsToInclude?: string[];\n  /**\n   * The names of additional dependencies to include when extracting this project.\n   */\n  additionalDependenciesToInclude?: string[];\n  /**\n   * The names of additional dependencies to exclude when extracting this project.\n   */\n  dependenciesToExclude?: string[];\n}\n\n/**\n * The extractor configuration for individual dependencies.\n *\n * @public\n */\nexport interface IExtractorDependencyConfiguration {\n  /**\n   * The name of dependency\n   */\n  dependencyName: string;\n  /**\n   * The semver version range of dependency\n   */\n  dependencyVersionRange: string;\n  /**\n   * A list of glob patterns to exclude when extracting this dependency. If a path is\n   * matched by both \"patternsToInclude\" and \"patternsToExclude\", the path will be\n   * excluded. If undefined, no paths will be excluded.\n   */\n  patternsToExclude?: string[];\n  /**\n   * A list of glob patterns to include when extracting this dependency. If a path is\n   * matched by both \"patternsToInclude\" and \"patternsToExclude\", the path will be\n   * excluded. If undefined, all paths will be included.\n   */\n  patternsToInclude?: string[];\n}\n\n/**\n * The mode to use for link creation.\n *\n * @public\n */\nexport type LinkCreationMode = 'default' | 'script' | 'none';\n\n/**\n * Options that can be provided to the extractor.\n *\n * @public\n */\nexport interface IExtractorOptions {\n  /**\n   * A terminal to log extraction progress.\n   */\n  terminal: ITerminal;\n\n  /**\n   * The main project to include in the extraction operation.\n   */\n  mainProjectName: string;\n\n  /**\n   * The source folder that copying originates from.  Generally it is the repo root folder.\n   */\n  sourceRootFolder: string;\n\n  /**\n   * The target folder for the extraction.\n   */\n  targetRootFolder: string;\n\n  /**\n   * Whether to overwrite the target folder if it already exists.\n   */\n  overwriteExisting: boolean;\n\n  /**\n   * The desired path to be used when archiving the target folder. Supported file extensions: .zip.\n   */\n  createArchiveFilePath?: string;\n\n  /**\n   * Whether to skip copying files to the extraction target directory, and only create an extraction\n   * archive. This is only supported when {@link IExtractorOptions.linkCreation} is 'script' or 'none'.\n   */\n  createArchiveOnly?: boolean;\n\n  /**\n   * The pnpmfile configuration if using PNPM, otherwise `undefined`. The configuration will be used to\n   * transform the package.json prior to extraction.\n   *\n   * @remarks\n   * When Rush subspaces are enabled, this setting applies to `default` subspace only.  To configure\n   * each subspace, use the {@link IExtractorOptions.subspaces} array instead.  The two approaches\n   * cannot be combined.\n   */\n  transformPackageJson?: (packageJson: IPackageJson) => IPackageJson;\n\n  /**\n   * If dependencies from the \"devDependencies\" package.json field should be included in the extraction.\n   */\n  includeDevDependencies?: boolean;\n\n  /**\n   * If files ignored by the .npmignore file should be included in the extraction.\n   */\n  includeNpmIgnoreFiles?: boolean;\n\n  /**\n   * The folder where the PNPM \"node_modules\" folder is located. This is used to resolve packages linked\n   * to the PNPM virtual store.\n   *\n   * @remarks\n   * When Rush subspaces are enabled, this setting applies to `default` subspace only.  To configure\n   * each subspace, use the {@link IExtractorOptions.subspaces} array instead.  The two approaches\n   * cannot be combined.\n   */\n  pnpmInstallFolder?: string;\n\n  /**\n   * The link creation mode to use.\n   * \"default\": Create the links while copying the files; this is the default behavior. Use this setting\n   * if your file copy tool can handle links correctly.\n   * \"script\": A Node.js script called create-links.js will be written to the target folder. Use this setting\n   * to create links on the server machine, after the files have been uploaded.\n   * \"none\": Do nothing; some other tool may create the links later, based on the extractor-metadata.json file.\n   */\n  linkCreation?: LinkCreationMode;\n\n  /**\n   * The path to the generated link creation script. This is only used when {@link IExtractorOptions.linkCreation}\n   * is 'script'.\n   */\n  linkCreationScriptPath?: string;\n\n  /**\n   * An additional folder containing files which will be copied into the root of the extraction.\n   */\n  folderToCopy?: string;\n\n  /**\n   * Configurations for individual projects, keyed by the project path relative to the sourceRootFolder.\n   */\n  projectConfigurations: IExtractorProjectConfiguration[];\n\n  /**\n   * Configurations for individual dependencies.\n   */\n  dependencyConfigurations?: IExtractorDependencyConfiguration[];\n\n  /**\n   * When using Rush subspaces, this setting can be used to provide configuration information for each\n   * individual subspace.\n   *\n   * @remarks\n   * To avoid confusion, if this setting is used, then the {@link IExtractorOptions.transformPackageJson} and\n   * {@link IExtractorOptions.pnpmInstallFolder} settings must not be used.\n   */\n  subspaces?: IExtractorSubspace[];\n}\n\n/**\n * Manages the business logic for the \"rush deploy\" command.\n *\n * @public\n */\nexport class PackageExtractor {\n  /**\n   * Get a list of files that would be included in a package created from the provided package root path.\n   *\n   * @beta\n   */\n  public static async getPackageIncludedFilesAsync(packageRootPath: string): Promise<string[]> {\n    // Use npm-packlist to filter the files.  Using the Walker class (instead of the default API) ensures\n    // that \"bundledDependencies\" are not included.\n    const walkerPromise: Promise<string[]> = new Promise<string[]>(\n      (resolve: (result: string[]) => void, reject: (error: Error) => void) => {\n        const walker: npmPacklist.Walker = new npmPacklist.Walker({\n          path: packageRootPath\n        });\n        walker.on('done', resolve).on('error', reject).start();\n      }\n    );\n    const npmPackFiles: string[] = await walkerPromise;\n    return npmPackFiles;\n  }\n\n  /**\n   * Extract a package using the provided options\n   */\n  public async extractAsync(options: IExtractorOptions): Promise<void> {\n    options = PackageExtractor._normalizeOptions(options);\n    const {\n      terminal,\n      projectConfigurations,\n      sourceRootFolder,\n      targetRootFolder,\n      mainProjectName,\n      overwriteExisting,\n      dependencyConfigurations,\n      linkCreation\n    } = options;\n\n    terminal.writeLine(Colorize.cyan(`Extracting to target folder:  ${targetRootFolder}`));\n    terminal.writeLine(Colorize.cyan(`Main project for extraction: ${mainProjectName}`));\n\n    await FileSystem.ensureFolderAsync(targetRootFolder);\n    const existingExtraction: boolean =\n      (await FileSystem.readFolderItemNamesAsync(targetRootFolder)).length > 0;\n    if (existingExtraction) {\n      if (!overwriteExisting) {\n        throw new Error('The extraction target folder is not empty. Overwrite must be explicitly requested');\n      }\n      terminal.writeLine('Deleting target folder contents...');\n      terminal.writeLine('');\n      await FileSystem.ensureEmptyFolderAsync(targetRootFolder);\n    }\n\n    // Create a new state for each run\n    const symlinkAnalyzer: SymlinkAnalyzer = new SymlinkAnalyzer({\n      requiredSourceParentPath: sourceRootFolder\n    });\n    const state: IExtractorState = {\n      symlinkAnalyzer,\n      assetHandler: new AssetHandler({ ...options, symlinkAnalyzer }),\n      foldersToCopy: new Set(),\n      packageJsonByPath: new Map(),\n      projectConfigurationsByName: new Map(projectConfigurations.map((p) => [p.projectName, p])),\n      projectConfigurationsByPath: new Map(projectConfigurations.map((p) => [p.projectFolder, p])),\n      dependencyConfigurationsByName: new Map()\n    };\n\n    // set state dependencyConfigurationsByName\n    for (const dependencyConfiguration of dependencyConfigurations || []) {\n      const { dependencyName } = dependencyConfiguration;\n      let existingDependencyConfigurations: IExtractorDependencyConfiguration[] | undefined =\n        state.dependencyConfigurationsByName.get(dependencyName);\n      if (!existingDependencyConfigurations) {\n        existingDependencyConfigurations = [];\n        state.dependencyConfigurationsByName.set(dependencyName, existingDependencyConfigurations);\n      }\n      existingDependencyConfigurations.push(dependencyConfiguration);\n    }\n\n    await this._performExtractionAsync(options, state);\n    await state.assetHandler.finalizeAsync({\n      onAfterExtractSymlinksAsync: async () => {\n        // We need the symlinks to be created before attempting to create the bin links, since it requires\n        // the node_modules folder to be realized. While we're here, we may as well perform some specific\n        // link creation tasks and write the extractor-metadata.json file before the asset handler finalizes.\n        if (linkCreation === 'default') {\n          await this._makeBinLinksAsync(options, state);\n        } else if (linkCreation === 'script') {\n          await this._writeCreateLinksScriptAsync(options, state);\n        }\n\n        terminal.writeLine('Creating extractor-metadata.json');\n        await this._writeExtractorMetadataAsync(options, state);\n      }\n    });\n  }\n\n  private static _normalizeOptions(options: IExtractorOptions): IExtractorOptions {\n    if (options.subspaces) {\n      if (options.pnpmInstallFolder !== undefined) {\n        throw new Error(\n          'IExtractorOptions.pnpmInstallFolder cannot be combined with IExtractorOptions.subspaces'\n        );\n      }\n      if (options.transformPackageJson !== undefined) {\n        throw new Error(\n          'IExtractorOptions.transformPackageJson cannot be combined with IExtractorOptions.subspaces'\n        );\n      }\n      return options;\n    }\n\n    const normalizedOptions: IExtractorOptions = { ...options };\n    delete normalizedOptions.pnpmInstallFolder;\n    delete normalizedOptions.transformPackageJson;\n\n    normalizedOptions.subspaces = [\n      {\n        subspaceName: 'default',\n        pnpmInstallFolder: options.pnpmInstallFolder,\n        transformPackageJson: options.transformPackageJson\n      }\n    ];\n\n    return normalizedOptions;\n  }\n\n  private async _performExtractionAsync(options: IExtractorOptions, state: IExtractorState): Promise<void> {\n    const {\n      terminal,\n      mainProjectName,\n      sourceRootFolder,\n      targetRootFolder,\n      folderToCopy: additionalFolderToCopy,\n      createArchiveOnly\n    } = options;\n    const { projectConfigurationsByName, foldersToCopy } = state;\n\n    const mainProjectConfiguration: IExtractorProjectConfiguration | undefined =\n      projectConfigurationsByName.get(mainProjectName);\n    if (!mainProjectConfiguration) {\n      throw new Error(`Main project \"${mainProjectName}\" was not found in the list of projects`);\n    }\n\n    // Calculate the set with additionalProjectsToInclude\n    const includedProjectsSet: Set<IExtractorProjectConfiguration> = new Set([mainProjectConfiguration]);\n    for (const { additionalProjectsToInclude } of includedProjectsSet) {\n      if (additionalProjectsToInclude) {\n        for (const additionalProjectNameToInclude of additionalProjectsToInclude) {\n          const additionalProjectToInclude: IExtractorProjectConfiguration | undefined =\n            projectConfigurationsByName.get(additionalProjectNameToInclude);\n          if (!additionalProjectToInclude) {\n            throw new Error(\n              `Project \"${additionalProjectNameToInclude}\" was not found in the list of projects.`\n            );\n          }\n          includedProjectsSet.add(additionalProjectToInclude);\n        }\n      }\n    }\n\n    for (const { projectName, projectFolder } of includedProjectsSet) {\n      terminal.writeLine(Colorize.cyan(`Analyzing project: ${projectName}`));\n      await this._collectFoldersAsync(projectFolder, options, state);\n    }\n\n    if (!createArchiveOnly) {\n      terminal.writeLine(`Copying folders to target folder \"${targetRootFolder}\"`);\n    }\n    await Async.forEachAsync(\n      foldersToCopy,\n      async (folderToCopy: string) => {\n        await this._extractFolderAsync(folderToCopy, options, state);\n      },\n      {\n        concurrency: MAX_CONCURRENCY\n      }\n    );\n\n    if (additionalFolderToCopy) {\n      // Copy the additional folder directly into the root of the target folder by setting the sourceRootFolder\n      // to the root of the folderToCopy\n      const additionalFolderPath: string = path.resolve(sourceRootFolder, additionalFolderToCopy);\n      const additionalFolderExtractorOptions: IExtractorOptions = {\n        ...options,\n        sourceRootFolder: additionalFolderPath,\n        targetRootFolder\n      };\n      await this._extractFolderAsync(additionalFolderPath, additionalFolderExtractorOptions, state);\n    }\n  }\n\n  /**\n   * Recursively crawl the node_modules dependencies and collect the result in IExtractorState.foldersToCopy.\n   */\n  private async _collectFoldersAsync(\n    packageJsonFolder: string,\n    options: IExtractorOptions,\n    state: IExtractorState\n  ): Promise<void> {\n    const { terminal, subspaces } = options;\n    const { projectConfigurationsByPath } = state;\n\n    const packageJsonFolderPathQueue: AsyncQueue<string> = new AsyncQueue([packageJsonFolder]);\n\n    await Async.forEachAsync(\n      packageJsonFolderPathQueue,\n      async ([packageJsonFolderPath, callback]: [string, () => void]) => {\n        const packageJsonRealFolderPath: string = await FileSystem.getRealPathAsync(packageJsonFolderPath);\n        if (state.foldersToCopy.has(packageJsonRealFolderPath)) {\n          // we've already seen this folder\n          callback();\n          return;\n        }\n        state.foldersToCopy.add(packageJsonRealFolderPath);\n\n        const originalPackageJson: IPackageJson = await JsonFile.loadAsync(\n          path.join(packageJsonRealFolderPath, 'package.json')\n        );\n\n        const targetSubspace: IExtractorSubspace | undefined = subspaces?.find(\n          (subspace) =>\n            subspace.pnpmInstallFolder && Path.isUnder(packageJsonFolderPath, subspace.pnpmInstallFolder)\n        );\n\n        // Transform packageJson using the provided transformer, if requested\n        const packageJson: IPackageJson =\n          targetSubspace?.transformPackageJson?.(originalPackageJson) ?? originalPackageJson;\n\n        state.packageJsonByPath.set(packageJsonRealFolderPath, packageJson);\n        // Union of keys from regular dependencies, peerDependencies, optionalDependencies\n        // (and possibly devDependencies if includeDevDependencies=true)\n        const dependencyNamesToProcess: Set<string> = new Set<string>();\n\n        // Just the keys from optionalDependencies and peerDependencies\n        const optionalDependencyNames: Set<string> = new Set<string>();\n\n        for (const name of Object.keys(packageJson.dependencies || {})) {\n          dependencyNamesToProcess.add(name);\n        }\n        for (const name of Object.keys(packageJson.peerDependencies || {})) {\n          dependencyNamesToProcess.add(name);\n          optionalDependencyNames.add(name); // consider peers optional, since they are so frequently broken\n        }\n        for (const name of Object.keys(packageJson.optionalDependencies || {})) {\n          dependencyNamesToProcess.add(name);\n          optionalDependencyNames.add(name);\n        }\n\n        // Check to see if this is a local project\n        const projectConfiguration: IExtractorProjectConfiguration | undefined =\n          projectConfigurationsByPath.get(packageJsonRealFolderPath);\n\n        if (projectConfiguration) {\n          if (options.includeDevDependencies) {\n            for (const name of Object.keys(packageJson.devDependencies || {})) {\n              dependencyNamesToProcess.add(name);\n            }\n          }\n\n          this._applyDependencyFilters(\n            terminal,\n            dependencyNamesToProcess,\n            projectConfiguration.additionalDependenciesToInclude,\n            projectConfiguration.dependenciesToExclude\n          );\n        }\n\n        for (const dependencyPackageName of dependencyNamesToProcess) {\n          try {\n            const dependencyPackageFolderPath: string = await Import.resolvePackageAsync({\n              packageName: dependencyPackageName,\n              baseFolderPath: packageJsonRealFolderPath,\n              getRealPathAsync: async (filePath: string) => {\n                try {\n                  return (await state.symlinkAnalyzer.analyzePathAsync({ inputPath: filePath })).nodePath;\n                } catch (error: unknown) {\n                  if (FileSystem.isFileDoesNotExistError(error as Error)) {\n                    return filePath;\n                  }\n                  throw error;\n                }\n              }\n            });\n            packageJsonFolderPathQueue.push(dependencyPackageFolderPath);\n          } catch (resolveErr) {\n            if (optionalDependencyNames.has(dependencyPackageName)) {\n              // Ignore missing optional dependency\n              continue;\n            }\n            throw resolveErr;\n          }\n        }\n\n        // Replicate the links to the virtual store. Note that if the package has not been hoisted by\n        // PNPM, the package will not be resolvable from here.\n        // Only apply this logic for packages that were actually installed under the common/temp folder.\n        const realPnpmInstallFolder: string | undefined = targetSubspace?.pnpmInstallFolder;\n        if (realPnpmInstallFolder && Path.isUnder(packageJsonFolderPath, realPnpmInstallFolder)) {\n          try {\n            // The PNPM virtual store links are created in this folder.  We will resolve the current package\n            // from that location and collect any additional links encountered along the way.\n            // TODO: This can be configured via NPMRC. We should support that.\n            const pnpmDotFolderPath: string = path.join(realPnpmInstallFolder, 'node_modules', '.pnpm');\n\n            // TODO: Investigate how package aliases are handled by PNPM in this case.  For example:\n            //\n            // \"dependencies\": {\n            //   \"alias-name\": \"npm:real-name@^1.2.3\"\n            // }\n            const dependencyPackageFolderPath: string = await Import.resolvePackageAsync({\n              packageName: packageJson.name,\n              baseFolderPath: pnpmDotFolderPath,\n              getRealPathAsync: async (filePath: string) => {\n                try {\n                  return (await state.symlinkAnalyzer.analyzePathAsync({ inputPath: filePath })).nodePath;\n                } catch (error: unknown) {\n                  if (FileSystem.isFileDoesNotExistError(error as Error)) {\n                    return filePath;\n                  }\n                  throw error;\n                }\n              }\n            });\n            packageJsonFolderPathQueue.push(dependencyPackageFolderPath);\n          } catch (resolveErr) {\n            // The virtual store link isn't guaranteed to exist, so ignore if it's missing\n            // NOTE: If you encounter this warning a lot, please report it to the Rush maintainers.\n            // eslint-disable-next-line no-console\n            console.log('Ignoring missing PNPM virtual store link for ' + packageJsonFolderPath);\n          }\n        }\n\n        callback();\n      },\n      {\n        concurrency: MAX_CONCURRENCY\n      }\n    );\n  }\n\n  private _applyDependencyFilters(\n    terminal: ITerminal,\n    allDependencyNames: Set<string>,\n    additionalDependenciesToInclude: string[] = [],\n    dependenciesToExclude: string[] = []\n  ): Set<string> {\n    // Track packages that got added/removed for reporting purposes\n    const extraIncludedPackageNames: string[] = [];\n    const extraExcludedPackageNames: string[] = [];\n\n    for (const patternWithStar of dependenciesToExclude) {\n      for (const dependency of allDependencyNames) {\n        if (matchesWithStar(patternWithStar, dependency)) {\n          if (allDependencyNames.delete(dependency)) {\n            extraExcludedPackageNames.push(dependency);\n          }\n        }\n      }\n    }\n\n    for (const dependencyToInclude of additionalDependenciesToInclude) {\n      if (!allDependencyNames.has(dependencyToInclude)) {\n        allDependencyNames.add(dependencyToInclude);\n        extraIncludedPackageNames.push(dependencyToInclude);\n      }\n    }\n\n    if (extraIncludedPackageNames.length > 0) {\n      extraIncludedPackageNames.sort();\n      terminal.writeLine(`Extra dependencies included by settings: ${extraIncludedPackageNames.join(', ')}`);\n    }\n\n    if (extraExcludedPackageNames.length > 0) {\n      extraExcludedPackageNames.sort();\n      terminal.writeLine(`Extra dependencies excluded by settings: ${extraExcludedPackageNames.join(', ')}`);\n    }\n\n    return allDependencyNames;\n  }\n\n  /**\n   * Copy one package folder to the extractor target folder.\n   */\n  private async _extractFolderAsync(\n    sourceFolderPath: string,\n    options: IExtractorOptions,\n    state: IExtractorState\n  ): Promise<void> {\n    const { includeNpmIgnoreFiles } = options;\n    const { projectConfigurationsByPath, packageJsonByPath, dependencyConfigurationsByName, assetHandler } =\n      state;\n    let useNpmIgnoreFilter: boolean = false;\n\n    const sourceFolderRealPath: string = await FileSystem.getRealPathAsync(sourceFolderPath);\n    const sourceProjectConfiguration: IExtractorProjectConfiguration | undefined =\n      projectConfigurationsByPath.get(sourceFolderRealPath);\n\n    const packagesJson: IPackageJson | undefined = packageJsonByPath.get(sourceFolderRealPath);\n    // As this function will be used to copy folder for both project inside monorepo and third party\n    // dependencies insides node_modules. Third party dependencies won't have project configurations\n    const isLocalProject: boolean = !!sourceProjectConfiguration;\n\n    // Function to filter files inside local project or third party dependencies.\n    const isFileExcluded = (filePath: string): boolean => {\n      // Encapsulate exclude logic into a function, so it can be reused.\n      const excludeFileByPatterns = (\n        patternsToInclude: string[] | undefined,\n        patternsToExclude: string[] | undefined\n      ): boolean => {\n        let includeFilters: IMinimatch[] | undefined;\n        let excludeFilters: IMinimatch[] | undefined;\n        if (patternsToInclude?.length) {\n          includeFilters = patternsToInclude?.map((p) => new Minimatch(p, { dot: true }));\n        }\n        if (patternsToExclude?.length) {\n          excludeFilters = patternsToExclude?.map((p) => new Minimatch(p, { dot: true }));\n        }\n        // If there are no filters, then we can't exclude anything.\n        if (!includeFilters && !excludeFilters) {\n          return false;\n        }\n\n        const isIncluded: boolean = !includeFilters || includeFilters.some((m) => m.match(filePath));\n\n        // If the file is not included, then we don't need to check the excludeFilter. If it is included\n        // and there is no exclude filter, then we know that the file is not excluded. If it is included\n        // and there is an exclude filter, then we need to check for a match.\n        return !isIncluded || !!excludeFilters?.some((m) => m.match(filePath));\n      };\n\n      if (isLocalProject) {\n        return excludeFileByPatterns(\n          sourceProjectConfiguration?.patternsToInclude,\n          sourceProjectConfiguration?.patternsToExclude\n        );\n      } else {\n        if (!packagesJson) {\n          return false;\n        }\n        const dependenciesConfigurations: IExtractorDependencyConfiguration[] | undefined =\n          dependencyConfigurationsByName.get(packagesJson.name);\n        if (!dependenciesConfigurations) {\n          return false;\n        }\n        const matchedDependenciesConfigurations: IExtractorDependencyConfiguration[] =\n          dependenciesConfigurations.filter((d) =>\n            semver.satisfies(packagesJson.version, d.dependencyVersionRange)\n          );\n        return matchedDependenciesConfigurations.some((d) =>\n          excludeFileByPatterns(d.patternsToInclude, d.patternsToExclude)\n        );\n      }\n    };\n\n    if (sourceProjectConfiguration && !includeNpmIgnoreFiles) {\n      // Only use the npmignore filter if the project configuration explicitly asks for it\n      useNpmIgnoreFilter = true;\n    }\n\n    const targetFolderPath: string = remapSourcePathForTargetFolder({\n      ...options,\n      sourcePath: sourceFolderPath\n    });\n    if (useNpmIgnoreFilter) {\n      const npmPackFiles: string[] = await PackageExtractor.getPackageIncludedFilesAsync(sourceFolderPath);\n      await Async.forEachAsync(\n        npmPackFiles,\n        async (npmPackFile: string) => {\n          // In issue https://github.com/microsoft/rushstack/issues/2121 we found that npm-packlist sometimes returns\n          // duplicate file paths, for example:\n          //\n          //   'dist//index.js'\n          //   'dist/index.js'\n          //\n\n          // Filter out files that are excluded by the project configuration or dependency configuration.\n          if (isFileExcluded(npmPackFile)) {\n            return;\n          }\n\n          const sourceFilePath: string = path.resolve(sourceFolderPath, npmPackFile);\n          const { kind, linkStats: sourceFileStats } = await state.symlinkAnalyzer.analyzePathAsync({\n            inputPath: sourceFilePath\n          });\n          if (kind === 'file') {\n            const targetFilePath: string = path.resolve(targetFolderPath, npmPackFile);\n            await assetHandler.includeAssetAsync({\n              sourceFilePath,\n              sourceFileStats,\n              targetFilePath\n            });\n          }\n        },\n        {\n          concurrency: MAX_CONCURRENCY\n        }\n      );\n    } else {\n      // use a simplistic \"ignore\" ruleset to filter the files\n      const ignoreFilter: Ignore = ignore();\n      ignoreFilter.add([\n        // The top-level node_modules folder is always excluded\n        '/node_modules',\n        // Also exclude well-known folders that can contribute a lot of unnecessary files\n        '**/.git',\n        '**/.svn',\n        '**/.hg',\n        '**/.DS_Store'\n      ]);\n\n      // Do a breadth-first search of the source folder, copying each file to the target folder\n      const queue: AsyncQueue<string> = new AsyncQueue([sourceFolderPath]);\n      await Async.forEachAsync(\n        queue,\n        async ([sourcePath, callback]: [string, () => void]) => {\n          const relativeSourcePath: string = path.relative(sourceFolderPath, sourcePath);\n          if (relativeSourcePath !== '' && ignoreFilter.ignores(relativeSourcePath)) {\n            callback();\n            return;\n          }\n\n          const sourcePathNode: PathNode | undefined = await state.symlinkAnalyzer.analyzePathAsync({\n            inputPath: sourcePath,\n            // Treat all links to external paths as if they are files for this scenario. In the future, we may\n            // want to explore the target of the external link to see if all files within the target are\n            // excluded, and throw if they are not.\n            shouldIgnoreExternalLink: (linkSourcePath: string) => {\n              // Ignore the provided linkSourcePath since it may not be the first link in the chain. Instead,\n              // we will consider only the relativeSourcePath, since that would be our entrypoint into the\n              // link chain.\n              return isFileExcluded(relativeSourcePath);\n            }\n          });\n\n          if (sourcePathNode === undefined) {\n            // The target was a symlink that is excluded. We don't need to do anything.\n            callback();\n            return;\n          } else if (sourcePathNode.kind === 'file') {\n            // Only ignore files and not folders to ensure that we traverse the contents of all folders. This is\n            // done so that we can match against subfolder patterns, ex. \"src/subfolder/**/*\"\n            if (relativeSourcePath !== '' && isFileExcluded(relativeSourcePath)) {\n              callback();\n              return;\n            }\n\n            const targetFilePath: string = path.resolve(targetFolderPath, relativeSourcePath);\n            await assetHandler.includeAssetAsync({\n              sourceFilePath: sourcePath,\n              sourceFileStats: sourcePathNode.linkStats,\n              targetFilePath\n            });\n          } else if (sourcePathNode.kind === 'folder') {\n            const children: string[] = await FileSystem.readFolderItemNamesAsync(sourcePath);\n            for (const child of children) {\n              queue.push(path.join(sourcePath, child));\n            }\n          }\n\n          callback();\n        },\n        {\n          concurrency: MAX_CONCURRENCY\n        }\n      );\n    }\n  }\n\n  /**\n   * Write the common/deploy/deploy-metadata.json file.\n   */\n  private async _writeExtractorMetadataAsync(\n    options: IExtractorOptions,\n    state: IExtractorState\n  ): Promise<void> {\n    const { mainProjectName, sourceRootFolder, targetRootFolder, linkCreation, linkCreationScriptPath } =\n      options;\n    const { projectConfigurationsByPath } = state;\n\n    const extractorMetadataFolderPath: string =\n      linkCreation === 'script' && linkCreationScriptPath\n        ? path.dirname(path.resolve(targetRootFolder, linkCreationScriptPath))\n        : targetRootFolder;\n    const extractorMetadataFilePath: string = path.join(\n      extractorMetadataFolderPath,\n      EXTRACTOR_METADATA_FILENAME\n    );\n    const extractorMetadataJson: IExtractorMetadataJson = {\n      mainProjectName,\n      projects: [],\n      links: [],\n      files: []\n    };\n\n    for (const { projectFolder, projectName } of projectConfigurationsByPath.values()) {\n      if (state.foldersToCopy.has(projectFolder)) {\n        extractorMetadataJson.projects.push({\n          projectName,\n          path: remapPathForExtractorMetadata(sourceRootFolder, projectFolder)\n        });\n      }\n    }\n\n    // Remap the links to be relative to target folder\n    for (const { kind, linkPath, targetPath } of state.symlinkAnalyzer.reportSymlinks()) {\n      extractorMetadataJson.links.push({\n        kind,\n        linkPath: remapPathForExtractorMetadata(sourceRootFolder, linkPath),\n        targetPath: remapPathForExtractorMetadata(sourceRootFolder, targetPath)\n      });\n    }\n\n    for (const assetPath of state.assetHandler.assetPaths) {\n      extractorMetadataJson.files.push(remapPathForExtractorMetadata(targetRootFolder, assetPath));\n    }\n\n    const extractorMetadataFileContent: string = JSON.stringify(extractorMetadataJson, undefined, 0);\n    await state.assetHandler.includeAssetAsync({\n      sourceFileContent: extractorMetadataFileContent,\n      targetFilePath: extractorMetadataFilePath\n    });\n  }\n\n  private async _makeBinLinksAsync(options: IExtractorOptions, state: IExtractorState): Promise<void> {\n    const { terminal } = options;\n\n    const extractedProjectFolderPaths: string[] = [];\n    for (const folderPath of state.projectConfigurationsByPath.keys()) {\n      if (state.foldersToCopy.has(folderPath)) {\n        extractedProjectFolderPaths.push(\n          remapSourcePathForTargetFolder({ ...options, sourcePath: folderPath })\n        );\n      }\n    }\n\n    const binFilePaths: string[] = await makeBinLinksAsync(terminal, extractedProjectFolderPaths);\n    await Async.forEachAsync(\n      binFilePaths,\n      (targetFilePath: string) => state.assetHandler.includeAssetAsync({ targetFilePath }),\n      {\n        concurrency: MAX_CONCURRENCY\n      }\n    );\n  }\n\n  private async _writeCreateLinksScriptAsync(\n    options: IExtractorOptions,\n    state: IExtractorState\n  ): Promise<void> {\n    const { terminal, targetRootFolder, linkCreationScriptPath } = options;\n    const { assetHandler } = state;\n\n    terminal.writeLine(`Creating ${CREATE_LINKS_SCRIPT_FILENAME}`);\n    const createLinksSourceFilePath: string = `${SCRIPTS_FOLDER_PATH}/${CREATE_LINKS_SCRIPT_FILENAME}`;\n    const createLinksTargetFilePath: string = path.resolve(\n      targetRootFolder,\n      linkCreationScriptPath || CREATE_LINKS_SCRIPT_FILENAME\n    );\n    let createLinksScriptContent: string = await FileSystem.readFileAsync(createLinksSourceFilePath);\n    createLinksScriptContent = createLinksScriptContent.replace(\n      TARGET_ROOT_SCRIPT_RELATIVE_PATH_TEMPLATE_STRING,\n      Path.convertToSlashes(path.relative(path.dirname(createLinksTargetFilePath), targetRootFolder))\n    );\n    await assetHandler.includeAssetAsync({\n      sourceFileContent: createLinksScriptContent,\n      targetFilePath: createLinksTargetFilePath\n    });\n  }\n}\n"]}