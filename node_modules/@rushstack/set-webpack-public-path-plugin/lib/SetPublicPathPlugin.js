"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SetPublicPathPlugin = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const codeGenerator_1 = require("./codeGenerator");
const SetPublicPathPluginBase_1 = require("./SetPublicPathPluginBase");
const SHOULD_REPLACE_ASSET_NAME_TOKEN = Symbol('set-public-path-plugin-should-replace-asset-name');
const PLUGIN_NAME = 'set-webpack-public-path';
const ASSET_NAME_TOKEN = '-ASSET-NAME-c0ef4f86-b570-44d3-b210-4428c5b7825c';
/**
 * This simple plugin sets the __webpack_public_path__ variable to a value specified in the arguments.
 *
 * @public
 */
class SetPublicPathPlugin extends SetPublicPathPluginBase_1.SetPublicPathPluginBase {
    constructor(options) {
        super(PLUGIN_NAME);
        this.options = options;
        const scriptNameOptions = options.scriptName;
        if (scriptNameOptions.useAssetName && scriptNameOptions.name) {
            throw new Error('scriptName.userAssetName and scriptName.name must not be used together');
        }
        else if (scriptNameOptions.isTokenized && !scriptNameOptions.name) {
            throw new Error('scriptName.isTokenized is only valid if scriptName.name is set');
        }
    }
    _applyCompilation(thisWebpack, compilation) {
        class SetPublicPathRuntimeModule extends thisWebpack.RuntimeModule {
            constructor(pluginOptions) {
                super('publicPath', thisWebpack.RuntimeModule.STAGE_BASIC);
                this._pluginOptions = pluginOptions;
            }
            generate() {
                const { name: regexpName, isTokenized: regexpIsTokenized, useAssetName } = this._pluginOptions.scriptName;
                const { chunk } = this;
                if (!chunk) {
                    throw new Error(`Chunk is not defined`);
                }
                let regexName;
                if (regexpName) {
                    regexName = regexpName;
                    if (regexpIsTokenized) {
                        regexName = regexName
                            .replace(/\[name\]/g, node_core_library_1.Text.escapeRegExp(`${chunk.name}`))
                            .replace(/\[hash\]/g, chunk.renderedHash || '');
                    }
                }
                else if (useAssetName) {
                    chunk[SHOULD_REPLACE_ASSET_NAME_TOKEN] = true;
                    regexName = ASSET_NAME_TOKEN;
                }
                else {
                    throw new Error('scriptName.name or scriptName.useAssetName must be set');
                }
                const moduleOptions = {
                    webpackPublicPathVariable: thisWebpack.RuntimeGlobals.publicPath,
                    regexName,
                    ...this._pluginOptions
                };
                return (0, codeGenerator_1.getSetPublicPathCode)(moduleOptions);
            }
        }
        compilation.hooks.runtimeRequirementInTree
            .for(thisWebpack.RuntimeGlobals.publicPath)
            .tap(PLUGIN_NAME, (chunk, set) => {
            compilation.addRuntimeModule(chunk, new SetPublicPathRuntimeModule(this.options));
        });
        compilation.hooks.processAssets.tap(PLUGIN_NAME, (assets) => {
            for (const chunkGroup of compilation.chunkGroups) {
                for (const chunk of chunkGroup.chunks) {
                    if (chunk[SHOULD_REPLACE_ASSET_NAME_TOKEN]) {
                        for (const assetFilename of chunk.files) {
                            let escapedAssetFilename;
                            if (assetFilename.match(/\.map$/)) {
                                // Trim the ".map" extension
                                escapedAssetFilename = assetFilename.slice(0, -4 /* '.map'.length */);
                                escapedAssetFilename = node_core_library_1.Text.escapeRegExp(escapedAssetFilename);
                                // source in sourcemaps is JSON-encoded
                                escapedAssetFilename = JSON.stringify(escapedAssetFilename);
                                // Trim the quotes from the JSON encoding
                                escapedAssetFilename = escapedAssetFilename.slice(1, -1);
                            }
                            else {
                                escapedAssetFilename = node_core_library_1.Text.escapeRegExp(assetFilename);
                            }
                            const asset = assets[assetFilename];
                            const newAsset = new thisWebpack.sources.ReplaceSource(asset);
                            const sourceString = asset.source().toString();
                            for (let index = sourceString.lastIndexOf(ASSET_NAME_TOKEN); index >= 0; index = sourceString.lastIndexOf(ASSET_NAME_TOKEN, index - 1)) {
                                newAsset.replace(index, index + ASSET_NAME_TOKEN.length - 1, escapedAssetFilename);
                            }
                            assets[assetFilename] = newAsset;
                        }
                    }
                }
            }
        });
    }
}
exports.SetPublicPathPlugin = SetPublicPathPlugin;
//# sourceMappingURL=SetPublicPathPlugin.js.map