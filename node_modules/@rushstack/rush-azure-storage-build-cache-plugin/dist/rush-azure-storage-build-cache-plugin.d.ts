import { AzureAuthorityHosts } from '@azure/identity';
import { CredentialCache } from '@rushstack/rush-sdk';
import { DeviceCodeCredentialOptions } from '@azure/identity';
import type { ICredentialCacheEntry } from '@rushstack/rush-sdk';
import { InteractiveBrowserCredentialNodeOptions } from '@azure/identity';
import type { IRushPlugin } from '@rushstack/rush-sdk';
import type { ITerminal } from '@rushstack/terminal';
import type { RushConfiguration } from '@rushstack/rush-sdk';
import type { RushSession } from '@rushstack/rush-sdk';
import { TokenCredential } from '@azure/identity';

/**
 * @public
 */
export declare abstract class AzureAuthenticationBase {
    protected abstract readonly _credentialNameForCache: string;
    protected abstract readonly _credentialKindForLogging: string;
    protected readonly _credentialUpdateCommandForLogging: string | undefined;
    protected readonly _additionalDeviceCodeCredentialOptions: DeviceCodeCredentialOptions | undefined;
    protected readonly _additionalInteractiveCredentialOptions: InteractiveBrowserCredentialNodeOptions | undefined;
    protected readonly _azureEnvironment: AzureEnvironmentName;
    protected readonly _loginFlow: LoginFlowType;
    protected readonly _failoverOrder: Record<LoginFlowType, LoginFlowType | undefined>;
    private __credentialCacheId;
    protected get _credentialCacheId(): string;
    constructor(options: IAzureAuthenticationBaseOptions);
    updateCachedCredentialAsync(terminal: ITerminal, credential: string): Promise<void>;
    /**
     * Launches an interactive flow to renew a cached credential.
     *
     * @param terminal - The terminal to log output to
     * @param onlyIfExistingCredentialExpiresBefore - If specified, and a cached credential exists, action will only
     * be taken if the cached credential expires before the specified date.
     */
    updateCachedCredentialInteractiveAsync(terminal: ITerminal, onlyIfExistingCredentialExpiresBefore?: Date): Promise<void>;
    deleteCachedCredentialsAsync(terminal: ITerminal): Promise<void>;
    tryGetCachedCredentialAsync(options?: ITryGetCachedCredentialOptionsThrow | ITryGetCachedCredentialOptionsIgnore): Promise<ICredentialCacheEntry | undefined>;
    tryGetCachedCredentialAsync(options: ITryGetCachedCredentialOptionsLogWarning): Promise<ICredentialCacheEntry | undefined>;
    /**
     * Get parts of the cache ID that are specific to the credential type. Note that this should
     * not contain the Azure environment or the {@link AzureAuthenticationBase._credentialNameForCache}
     * value, as those are added automatically.
     */
    protected abstract _getCacheIdParts(): string[];
    protected abstract _getCredentialFromTokenAsync(terminal: ITerminal, tokenCredential: TokenCredential, credentialsCache: CredentialCache): Promise<ICredentialResult>;
    private _getCredentialAsync;
}

/**
 * @public
 */
export declare type AzureEnvironmentName = keyof typeof AzureAuthorityHosts;

/**
 * @public
 */
export declare class AzureStorageAuthentication extends AzureAuthenticationBase {
    protected readonly _credentialNameForCache: string;
    protected readonly _credentialKindForLogging: string;
    protected readonly _storageAccountName: string;
    protected readonly _storageContainerName: string;
    protected readonly _isCacheWriteAllowedByConfiguration: boolean;
    protected readonly _storageAccountUrl: string;
    constructor(options: IAzureStorageAuthenticationOptions);
    protected _getCacheIdParts(): string[];
    protected _getCredentialFromTokenAsync(terminal: ITerminal, tokenCredential: TokenCredential): Promise<ICredentialResult>;
}

/**
 * @public
 */
export declare type ExpiredCredentialBehavior = 'logWarning' | 'throwError' | 'ignore';

/**
 * @public
 */
export declare interface IAzureAuthenticationBaseOptions {
    azureEnvironment?: AzureEnvironmentName;
    credentialUpdateCommandForLogging?: string | undefined;
    loginFlow?: LoginFlowType;
    /**
     * A map to define the failover order for login flows. When a login flow fails to get a credential,
     * the next login flow in the map will be attempted. If the login flow fails and there is no next
     * login flow, the error will be thrown.
     *
     * @defaultValue
     * ```json
     * {
     *   "AdoCodespacesAuth": "InteractiveBrowser",
     *   "InteractiveBrowser": "DeviceCode",
     *   "DeviceCode": null
     * }
     * ```
     */
    loginFlowFailover?: Record<LoginFlowType, LoginFlowType | undefined>;
}

/**
 * @public
 */
export declare interface IAzureStorageAuthenticationOptions extends IAzureAuthenticationBaseOptions {
    storageContainerName: string;
    storageAccountName: string;
    isCacheWriteAllowed: boolean;
}

/**
 * @public
 */ export declare interface ICredentialResult {
    credentialString: string;
    expiresOn?: Date;
    credentialMetadata?: object;
}

/**
 * @public
 */
export declare interface ITryGetCachedCredentialOptionsBase {
    /**
     * The behavior to take when the cached credential has expired.
     * Defaults to 'throwError'
     */
    expiredCredentialBehavior?: ExpiredCredentialBehavior;
    terminal?: ITerminal;
}

/**
 * @public
 */
export declare interface ITryGetCachedCredentialOptionsIgnore extends ITryGetCachedCredentialOptionsBase {
    /**
     * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}
     */
    expiredCredentialBehavior: 'ignore';
}

/**
 * @public
 */
export declare interface ITryGetCachedCredentialOptionsLogWarning extends ITryGetCachedCredentialOptionsBase {
    /**
     * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}
     */
    expiredCredentialBehavior: 'logWarning';
    terminal: ITerminal;
}

/**
 * @public
 */
export declare interface ITryGetCachedCredentialOptionsThrow extends ITryGetCachedCredentialOptionsBase {
    /**
     * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}
     */
    expiredCredentialBehavior: 'throwError';
}

/**
 * @public
 */
export declare type LoginFlowType = 'DeviceCode' | 'InteractiveBrowser' | 'AdoCodespacesAuth';

/**
 * @public
 */
declare class RushAzureStorageBuildCachePlugin implements IRushPlugin {
    pluginName: string;
    apply(rushSession: RushSession, rushConfig: RushConfiguration): void;
}
export default RushAzureStorageBuildCachePlugin;

export { }
