{"version":3,"file":"AzureAuthenticationBase.js","sourceRoot":"","sources":["../src/AzureAuthenticationBase.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport {\n  DeviceCodeCredential,\n  type DeviceCodeInfo,\n  AzureAuthorityHosts,\n  type DeviceCodeCredentialOptions,\n  type InteractiveBrowserCredentialInBrowserOptions,\n  InteractiveBrowserCredential,\n  type InteractiveBrowserCredentialNodeOptions,\n  type TokenCredential\n} from '@azure/identity';\nimport type { ITerminal } from '@rushstack/terminal';\nimport { CredentialCache } from '@rushstack/rush-sdk';\n// Use a separate import line so the .d.ts file ends up with an `import type { ... }`\n// See https://github.com/microsoft/rushstack/issues/3432\nimport type { ICredentialCacheEntry } from '@rushstack/rush-sdk';\nimport { PrintUtilities } from '@rushstack/terminal';\nimport { AdoCodespacesAuthCredential } from './AdoCodespacesAuthCredential';\n\n/**\n * @public\n */\nexport type ExpiredCredentialBehavior = 'logWarning' | 'throwError' | 'ignore';\n\n/**\n * @public\n */\nexport interface ITryGetCachedCredentialOptionsBase {\n  /**\n   * The behavior to take when the cached credential has expired.\n   * Defaults to 'throwError'\n   */\n  expiredCredentialBehavior?: ExpiredCredentialBehavior;\n  terminal?: ITerminal;\n}\n\n/**\n * @public\n */\nexport interface ITryGetCachedCredentialOptionsLogWarning extends ITryGetCachedCredentialOptionsBase {\n  /**\n   * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}\n   */\n  expiredCredentialBehavior: 'logWarning';\n  terminal: ITerminal;\n}\n\n/**\n * @public\n */\nexport interface ITryGetCachedCredentialOptionsThrow extends ITryGetCachedCredentialOptionsBase {\n  /**\n   * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}\n   */\n  expiredCredentialBehavior: 'throwError';\n}\n\n/**\n * @public\n */\nexport interface ITryGetCachedCredentialOptionsIgnore extends ITryGetCachedCredentialOptionsBase {\n  /**\n   * {@inheritdoc ITryGetCachedCredentialOptionsBase.expiredCredentialBehavior}\n   */\n  expiredCredentialBehavior: 'ignore';\n}\n\nexport type ITryGetCachedCredentialOptions =\n  | ITryGetCachedCredentialOptionsLogWarning\n  | ITryGetCachedCredentialOptionsThrow\n  | ITryGetCachedCredentialOptionsIgnore;\n\n/**\n * @public\n */\nexport type AzureEnvironmentName = keyof typeof AzureAuthorityHosts;\n\n/**\n * @public\n */\nexport type LoginFlowType = 'DeviceCode' | 'InteractiveBrowser' | 'AdoCodespacesAuth';\n\n/**\n * @public\n */\nexport interface IAzureAuthenticationBaseOptions {\n  azureEnvironment?: AzureEnvironmentName;\n  credentialUpdateCommandForLogging?: string | undefined;\n  loginFlow?: LoginFlowType;\n  /**\n   * A map to define the failover order for login flows. When a login flow fails to get a credential,\n   * the next login flow in the map will be attempted. If the login flow fails and there is no next\n   * login flow, the error will be thrown.\n   *\n   * @defaultValue\n   * ```json\n   * {\n   *   \"AdoCodespacesAuth\": \"InteractiveBrowser\",\n   *   \"InteractiveBrowser\": \"DeviceCode\",\n   *   \"DeviceCode\": null\n   * }\n   * ```\n   */\n  loginFlowFailover?: Record<LoginFlowType, LoginFlowType | undefined>;\n}\n\n/**\n * @public\n */ export interface ICredentialResult {\n  credentialString: string;\n  expiresOn?: Date;\n  credentialMetadata?: object;\n}\n\n/**\n * @public\n */\nexport abstract class AzureAuthenticationBase {\n  protected abstract readonly _credentialNameForCache: string;\n  protected abstract readonly _credentialKindForLogging: string;\n  protected readonly _credentialUpdateCommandForLogging: string | undefined;\n  protected readonly _additionalDeviceCodeCredentialOptions: DeviceCodeCredentialOptions | undefined;\n  protected readonly _additionalInteractiveCredentialOptions:\n    | InteractiveBrowserCredentialNodeOptions\n    | undefined;\n\n  protected readonly _azureEnvironment: AzureEnvironmentName;\n  protected readonly _loginFlow: LoginFlowType;\n  protected readonly _failoverOrder: Record<LoginFlowType, LoginFlowType | undefined>;\n\n  private __credentialCacheId: string | undefined;\n  protected get _credentialCacheId(): string {\n    if (!this.__credentialCacheId) {\n      const cacheIdParts: string[] = [\n        this._credentialNameForCache,\n        this._azureEnvironment,\n        ...this._getCacheIdParts()\n      ];\n\n      this.__credentialCacheId = cacheIdParts.join('|');\n    }\n\n    return this.__credentialCacheId;\n  }\n\n  public constructor(options: IAzureAuthenticationBaseOptions) {\n    const {\n      azureEnvironment = 'AzurePublicCloud',\n      loginFlow = process.env.CODESPACES === 'true' ? 'AdoCodespacesAuth' : 'InteractiveBrowser'\n    } = options;\n    this._azureEnvironment = azureEnvironment;\n    this._credentialUpdateCommandForLogging = options.credentialUpdateCommandForLogging;\n    this._loginFlow = loginFlow;\n    this._failoverOrder = options.loginFlowFailover || {\n      AdoCodespacesAuth: 'InteractiveBrowser',\n      InteractiveBrowser: 'DeviceCode',\n      DeviceCode: undefined\n    };\n  }\n\n  public async updateCachedCredentialAsync(terminal: ITerminal, credential: string): Promise<void> {\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: true\n      },\n      async (credentialsCache: CredentialCache) => {\n        credentialsCache.setCacheEntry(this._credentialCacheId, {\n          credential\n        });\n        await credentialsCache.saveIfModifiedAsync();\n      }\n    );\n  }\n\n  /**\n   * Launches an interactive flow to renew a cached credential.\n   *\n   * @param terminal - The terminal to log output to\n   * @param onlyIfExistingCredentialExpiresBefore - If specified, and a cached credential exists, action will only\n   * be taken if the cached credential expires before the specified date.\n   */\n  public async updateCachedCredentialInteractiveAsync(\n    terminal: ITerminal,\n    onlyIfExistingCredentialExpiresBefore?: Date\n  ): Promise<void> {\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: true\n      },\n      async (credentialsCache: CredentialCache) => {\n        if (onlyIfExistingCredentialExpiresBefore) {\n          const existingCredentialExpiration: Date | undefined = credentialsCache.tryGetCacheEntry(\n            this._credentialCacheId\n          )?.expires;\n          if (\n            existingCredentialExpiration &&\n            existingCredentialExpiration > onlyIfExistingCredentialExpiresBefore\n          ) {\n            return;\n          }\n        }\n\n        const credential: ICredentialResult = await this._getCredentialAsync(\n          terminal,\n          this._loginFlow,\n          credentialsCache\n        );\n        credentialsCache.setCacheEntry(this._credentialCacheId, {\n          credential: credential.credentialString,\n          expires: credential.expiresOn,\n          credentialMetadata: credential.credentialMetadata\n        });\n        await credentialsCache.saveIfModifiedAsync();\n      }\n    );\n  }\n\n  public async deleteCachedCredentialsAsync(terminal: ITerminal): Promise<void> {\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: true\n      },\n      async (credentialsCache: CredentialCache) => {\n        credentialsCache.deleteCacheEntry(this._credentialCacheId);\n        await credentialsCache.saveIfModifiedAsync();\n      }\n    );\n  }\n\n  public async tryGetCachedCredentialAsync(\n    options?: ITryGetCachedCredentialOptionsThrow | ITryGetCachedCredentialOptionsIgnore\n  ): Promise<ICredentialCacheEntry | undefined>;\n  public async tryGetCachedCredentialAsync(\n    options: ITryGetCachedCredentialOptionsLogWarning\n  ): Promise<ICredentialCacheEntry | undefined>;\n  public async tryGetCachedCredentialAsync(\n    { expiredCredentialBehavior, terminal }: ITryGetCachedCredentialOptions = {\n      expiredCredentialBehavior: 'throwError'\n    }\n  ): Promise<ICredentialCacheEntry | undefined> {\n    let cacheEntry: ICredentialCacheEntry | undefined;\n    await CredentialCache.usingAsync(\n      {\n        supportEditing: false\n      },\n      (credentialsCache: CredentialCache) => {\n        cacheEntry = credentialsCache.tryGetCacheEntry(this._credentialCacheId);\n      }\n    );\n\n    const expirationTime: number | undefined = cacheEntry?.expires?.getTime();\n    if (expirationTime && expirationTime < Date.now()) {\n      if (expiredCredentialBehavior === 'logWarning' || expiredCredentialBehavior === 'throwError') {\n        let errorMessage: string = `Cached Azure ${this._credentialKindForLogging} credentials have expired.`;\n        if (this._credentialUpdateCommandForLogging) {\n          errorMessage += ` Update the credentials by running \"${this._credentialUpdateCommandForLogging}\".`;\n        }\n\n        if (expiredCredentialBehavior === 'logWarning') {\n          terminal.writeWarningLine(errorMessage);\n        } else if (expiredCredentialBehavior === 'throwError') {\n          throw new Error(errorMessage);\n        }\n      }\n\n      return undefined;\n    } else {\n      return cacheEntry;\n    }\n  }\n\n  /**\n   * Get parts of the cache ID that are specific to the credential type. Note that this should\n   * not contain the Azure environment or the {@link AzureAuthenticationBase._credentialNameForCache}\n   * value, as those are added automatically.\n   */\n  protected abstract _getCacheIdParts(): string[];\n\n  protected abstract _getCredentialFromTokenAsync(\n    terminal: ITerminal,\n    tokenCredential: TokenCredential,\n    credentialsCache: CredentialCache\n  ): Promise<ICredentialResult>;\n\n  private async _getCredentialAsync(\n    terminal: ITerminal,\n    loginFlow: LoginFlowType,\n    credentialsCache: CredentialCache\n  ): Promise<ICredentialResult> {\n    const authorityHost: string | undefined = AzureAuthorityHosts[this._azureEnvironment];\n    if (!authorityHost) {\n      throw new Error(`Unexpected Azure environment: ${this._azureEnvironment}`);\n    }\n\n    let tokenCredential: TokenCredential;\n\n    const interactiveCredentialOptions: (\n      | InteractiveBrowserCredentialNodeOptions\n      | InteractiveBrowserCredentialInBrowserOptions\n    ) &\n      DeviceCodeCredentialOptions = {\n      ...this._additionalInteractiveCredentialOptions,\n      authorityHost\n    };\n\n    switch (loginFlow) {\n      case 'AdoCodespacesAuth': {\n        tokenCredential = new AdoCodespacesAuthCredential();\n        break;\n      }\n      case 'InteractiveBrowser': {\n        tokenCredential = new InteractiveBrowserCredential(interactiveCredentialOptions);\n        break;\n      }\n      case 'DeviceCode': {\n        tokenCredential = new DeviceCodeCredential({\n          ...interactiveCredentialOptions,\n          userPromptCallback: (deviceCodeInfo: DeviceCodeInfo) => {\n            PrintUtilities.printMessageInBox(deviceCodeInfo.message, terminal);\n          }\n        });\n        break;\n      }\n      default: {\n        throw new Error(`Unsupported login flow: ${loginFlow}`);\n      }\n    }\n\n    try {\n      return await this._getCredentialFromTokenAsync(terminal, tokenCredential, credentialsCache);\n    } catch (error) {\n      terminal.writeVerbose(`Failed to get credentials with ${loginFlow}: ${error}`);\n      const fallbackFlow: LoginFlowType | undefined = this._failoverOrder[loginFlow];\n      if (fallbackFlow) {\n        terminal.writeVerbose(`Falling back to ${fallbackFlow} login flow`);\n        return this._getCredentialAsync(terminal, fallbackFlow, credentialsCache);\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n"]}