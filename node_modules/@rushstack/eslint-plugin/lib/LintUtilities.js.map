{"version":3,"file":"LintUtilities.js","sourceRoot":"","sources":["../src/LintUtilities.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport { ESLintUtils, TSESTree, type TSESLint } from '@typescript-eslint/utils';\nimport type { Program } from 'typescript';\n\nexport interface IParsedImportSpecifier {\n  loader?: string;\n  importTarget: string;\n  loaderOptions?: string;\n}\n\n// Regex to parse out the import target from the specifier. Expected formats are:\n//  - '<target>'\n//  - '<loader>!<target>'\n//  - '<target>?<loader-options>'\n//  - '<loader>!<target>?<loader-options>'\nconst LOADER_CAPTURE_GROUP: 'loader' = 'loader';\nconst IMPORT_TARGET_CAPTURE_GROUP: 'importTarget' = 'importTarget';\nconst LOADER_OPTIONS_CAPTURE_GROUP: 'loaderOptions' = 'loaderOptions';\n// eslint-disable-next-line @rushstack/security/no-unsafe-regexp\nconst SPECIFIER_REGEX: RegExp = new RegExp(\n  `^((?<${LOADER_CAPTURE_GROUP}>(!|-!|!!).+)!)?` +\n    `(?<${IMPORT_TARGET_CAPTURE_GROUP}>[^!?]+)` +\n    `(\\\\?(?<${LOADER_OPTIONS_CAPTURE_GROUP}>.*))?$`\n);\n\nexport function getFilePathFromContext(context: TSESLint.RuleContext<string, unknown[]>): string {\n  return context.physicalFilename || context.filename;\n}\n\nexport function getRootDirectoryFromContext(\n  context: TSESLint.RuleContext<string, unknown[]>\n): string | undefined {\n  let rootDirectory: string | undefined;\n  try {\n    // First attempt to get the root directory from the tsconfig baseUrl, then the program current directory\n    const program: Program | null | undefined = (\n      context.sourceCode?.parserServices ?? ESLintUtils.getParserServices(context)\n    ).program;\n    rootDirectory = program?.getCompilerOptions().baseUrl ?? program?.getCurrentDirectory();\n  } catch {\n    // Ignore the error if we cannot retrieve a TS program\n  }\n\n  // Fall back to the parserOptions.tsconfigRootDir if available, otherwise the eslint working directory\n  if (!rootDirectory) {\n    rootDirectory = context.parserOptions?.tsconfigRootDir ?? context.getCwd?.();\n  }\n\n  return rootDirectory;\n}\n\nexport function parseImportSpecifierFromExpression(\n  importExpression: TSESTree.Expression\n): IParsedImportSpecifier | undefined {\n  if (\n    !importExpression ||\n    importExpression.type !== TSESTree.AST_NODE_TYPES.Literal ||\n    typeof importExpression.value !== 'string'\n  ) {\n    // Can't determine the path of the import target, return\n    return undefined;\n  }\n\n  // Extract the target of the import, stripping out webpack loaders and query strings. The regex will\n  // also ensure that the import target is a relative path.\n  const specifierMatch: RegExpMatchArray | null = importExpression.value.match(SPECIFIER_REGEX);\n  if (!specifierMatch?.groups) {\n    // Can't determine the path of the import target, return\n    return undefined;\n  }\n\n  const loader: string | undefined = specifierMatch.groups[LOADER_CAPTURE_GROUP];\n  const importTarget: string = specifierMatch.groups[IMPORT_TARGET_CAPTURE_GROUP];\n  const loaderOptions: string | undefined = specifierMatch.groups[LOADER_OPTIONS_CAPTURE_GROUP];\n  return { loader, importTarget, loaderOptions };\n}\n\nexport function serializeImportSpecifier(parsedImportPath: IParsedImportSpecifier): string {\n  const { loader, importTarget, loaderOptions } = parsedImportPath;\n  return `${loader ? `${loader}!` : ''}${importTarget}${loaderOptions ? `?${loaderOptions}` : ''}`;\n}\n\nexport function getImportPathFromExpression(\n  importExpression: TSESTree.Expression,\n  relativeImportsOnly: boolean = true\n): string | undefined {\n  const parsedImportSpecifier: IParsedImportSpecifier | undefined =\n    parseImportSpecifierFromExpression(importExpression);\n  if (\n    !parsedImportSpecifier ||\n    (relativeImportsOnly && !parsedImportSpecifier.importTarget.startsWith('.'))\n  ) {\n    // The import target isn't a path, return\n    return undefined;\n  }\n  return parsedImportSpecifier?.importTarget;\n}\n\nexport function getImportAbsolutePathFromExpression(\n  context: TSESLint.RuleContext<string, unknown[]>,\n  importExpression: TSESTree.Expression,\n  relativeImportsOnly: boolean = true\n): string | undefined {\n  const importPath: string | undefined = getImportPathFromExpression(importExpression, relativeImportsOnly);\n  if (importPath === undefined) {\n    // Can't determine the absolute path of the import target, return\n    return undefined;\n  }\n\n  const filePath: string = getFilePathFromContext(context);\n  const fileDirectory: string = path.dirname(filePath);\n\n  // Combine the import path with the absolute path of the file parent directory to get the\n  // absolute path of the import target\n  return path.resolve(fileDirectory, importPath);\n}\n"]}