"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('@rushstack/rush-sdk/lib/utilities/WebClient', () => {
    return jest.requireActual('@microsoft/rush-lib/lib/utilities/WebClient');
});
const rush_sdk_1 = require("@rushstack/rush-sdk");
const terminal_1 = require("@rushstack/terminal");
const WebClient_1 = require("@rushstack/rush-sdk/lib/utilities/WebClient");
const HttpBuildCacheProvider_1 = require("../HttpBuildCacheProvider");
const EXAMPLE_OPTIONS = {
    url: 'https://buildcache.example.acme.com',
    tokenHandler: {
        exec: 'node',
        args: ['tokenHandler.js']
    },
    uploadMethod: 'POST',
    isCacheWriteAllowed: false,
    pluginName: 'example-plugin',
    rushJsonFolder: '/repo',
    minHttpRetryDelayMs: 1
};
describe('HttpBuildCacheProvider', () => {
    let terminalBuffer;
    let terminal;
    let fetchFn;
    beforeEach(() => {
        terminalBuffer = new terminal_1.StringBufferTerminalProvider();
        terminal = new terminal_1.Terminal(terminalBuffer);
        fetchFn = jest.fn();
        WebClient_1.WebClient.mockRequestFn(fetchFn);
    });
    afterEach(() => {
        WebClient_1.WebClient.resetMockRequestFn();
    });
    describe('tryGetCacheEntryBufferByIdAsync', () => {
        it('prints warning if read credentials are not available', async () => {
            jest.spyOn(rush_sdk_1.EnvironmentConfiguration, 'buildCacheCredential', 'get').mockReturnValue(undefined);
            const session = {};
            const provider = new HttpBuildCacheProvider_1.HttpBuildCacheProvider(EXAMPLE_OPTIONS, session);
            mocked(fetchFn).mockResolvedValue({
                status: 401,
                statusText: 'Unauthorized',
                ok: false
            });
            const result = await provider.tryGetCacheEntryBufferByIdAsync(terminal, 'some-key');
            expect(result).toBe(undefined);
            expect(fetchFn).toHaveBeenCalledTimes(1);
            expect(fetchFn).toHaveBeenNthCalledWith(1, 'https://buildcache.example.acme.com/some-key', expect.objectContaining({
                method: 'GET',
                redirect: 'follow'
            }));
            expect(terminalBuffer.getWarningOutput()).toMatchInlineSnapshot(`"Error getting cache entry: Error: Credentials for https://buildcache.example.acme.com/ have not been provided.[n]In CI, verify that RUSH_BUILD_CACHE_CREDENTIAL contains a valid Authorization header value.[n][n]For local developers, run:[n][n]    rush update-cloud-credentials --interactive[n][n]"`);
        });
        it('attempts up to 3 times to download a cache entry', async () => {
            jest.spyOn(rush_sdk_1.EnvironmentConfiguration, 'buildCacheCredential', 'get').mockReturnValue(undefined);
            const session = {};
            const provider = new HttpBuildCacheProvider_1.HttpBuildCacheProvider(EXAMPLE_OPTIONS, session);
            mocked(fetchFn).mockResolvedValueOnce({
                status: 500,
                statusText: 'InternalServiceError',
                ok: false
            });
            mocked(fetchFn).mockResolvedValueOnce({
                status: 503,
                statusText: 'ServiceUnavailable',
                ok: false
            });
            mocked(fetchFn).mockResolvedValueOnce({
                status: 504,
                statusText: 'BadGateway',
                ok: false
            });
            const result = await provider.tryGetCacheEntryBufferByIdAsync(terminal, 'some-key');
            expect(result).toBe(undefined);
            expect(fetchFn).toHaveBeenCalledTimes(3);
            expect(fetchFn).toHaveBeenNthCalledWith(1, 'https://buildcache.example.acme.com/some-key', expect.objectContaining({
                method: 'GET',
                redirect: 'follow'
            }));
            expect(fetchFn).toHaveBeenNthCalledWith(2, 'https://buildcache.example.acme.com/some-key', expect.objectContaining({
                method: 'GET',
                redirect: 'follow'
            }));
            expect(fetchFn).toHaveBeenNthCalledWith(3, 'https://buildcache.example.acme.com/some-key', expect.objectContaining({
                method: 'GET',
                redirect: 'follow'
            }));
            expect(terminalBuffer.getWarningOutput()).toMatchInlineSnapshot(`"Could not get cache entry: HTTP 504: BadGateway[n]"`);
        });
    });
});
//# sourceMappingURL=HttpBuildCacheProvider.test.js.map