"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypingsGenerator = void 0;
const typings_generator_1 = require("@rushstack/typings-generator");
const node_core_library_1 = require("@rushstack/node-core-library");
const LocFileParser_1 = require("./LocFileParser");
/**
 * This is a simple tool that generates .d.ts files for .loc.json, .resx.json, .resjson, and .resx files.
 *
 * @public
 */
class TypingsGenerator extends typings_generator_1.StringValuesTypingsGenerator {
    constructor(options) {
        const { ignoreString, processComment, resxNewlineNormalization, ignoreMissingResxComments, trimmedJsonOutputFolders, exportAsDefault } = options;
        const inferDefaultExportInterfaceNameFromFilename = typeof exportAsDefault === 'object'
            ? exportAsDefault.inferInterfaceNameFromFilename
            : undefined;
        const getJsonPaths = trimmedJsonOutputFolders && trimmedJsonOutputFolders.length > 0
            ? (relativePath) => {
                const jsonRelativePath = relativePath.endsWith('.json') || relativePath.endsWith('.resjson')
                    ? relativePath
                    : `${relativePath}.json`;
                const jsonPaths = [];
                for (const outputFolder of trimmedJsonOutputFolders) {
                    jsonPaths.push(`${outputFolder}/${jsonRelativePath}`);
                }
                return jsonPaths;
            }
            : undefined;
        super({
            ...options,
            fileExtensions: ['.resx', '.resx.json', '.loc.json', '.resjson'],
            getAdditionalOutputFiles: getJsonPaths,
            // eslint-disable-next-line @typescript-eslint/naming-convention
            parseAndGenerateTypings: async (content, filePath, relativeFilePath) => {
                const locFileData = (0, LocFileParser_1.parseLocFile)({
                    filePath,
                    content,
                    terminal: this.terminal,
                    resxNewlineNormalization,
                    ignoreMissingResxComments,
                    ignoreString
                });
                const typings = [];
                const json = trimmedJsonOutputFolders ? {} : undefined;
                for (const [stringName, value] of Object.entries(locFileData)) {
                    let comment = value.comment;
                    if (processComment) {
                        comment = processComment(comment, relativeFilePath, stringName);
                    }
                    if (json) {
                        json[stringName] = value.value;
                    }
                    typings.push({
                        exportName: stringName,
                        comment
                    });
                }
                if (getJsonPaths) {
                    const jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');
                    for (const jsonFile of getJsonPaths(relativeFilePath)) {
                        await node_core_library_1.FileSystem.writeFileAsync(jsonFile, jsonBuffer, {
                            ensureFolderExists: true
                        });
                    }
                }
                if (inferDefaultExportInterfaceNameFromFilename) {
                    const lastSlashIndex = Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\'));
                    let extensionIndex = filePath.lastIndexOf('.');
                    if (filePath.slice(extensionIndex).toLowerCase() === '.json') {
                        extensionIndex = filePath.lastIndexOf('.', extensionIndex - 1);
                    }
                    const fileNameWithoutExtension = filePath.substring(lastSlashIndex + 1, extensionIndex);
                    const normalizedFileName = fileNameWithoutExtension.replace(/[^a-zA-Z0-9$_]/g, '');
                    const firstCharUpperCased = normalizedFileName.charAt(0).toUpperCase();
                    let interfaceName = `I${firstCharUpperCased}${normalizedFileName.slice(1)}`;
                    if (!interfaceName.endsWith('strings') && !interfaceName.endsWith('Strings')) {
                        interfaceName += 'Strings';
                    }
                    return {
                        typings,
                        exportAsDefault: {
                            interfaceName
                        }
                    };
                }
                else {
                    return {
                        typings
                    };
                }
            }
        });
    }
}
exports.TypingsGenerator = TypingsGenerator;
//# sourceMappingURL=TypingsGenerator.js.map