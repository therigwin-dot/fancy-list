{"version":3,"file":"TypingsGenerator.js","sourceRoot":"","sources":["../src/TypingsGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport {\n  StringValuesTypingsGenerator,\n  type IStringValueTypings,\n  type IExportAsDefaultOptions,\n  type IStringValueTyping,\n  type ITypingsGeneratorBaseOptions\n} from '@rushstack/typings-generator';\nimport { FileSystem, type NewlineKind } from '@rushstack/node-core-library';\n\nimport type { IgnoreStringFunction, ILocalizationFile } from './interfaces';\nimport { parseLocFile } from './LocFileParser';\n\n/**\n * @public\n */\nexport interface IInferInterfaceNameExportAsDefaultOptions\n  extends Omit<IExportAsDefaultOptions, 'interfaceName'> {\n  /**\n   * When `exportAsDefault` is true and this option is true, the default export interface name will be inferred\n   * from the filename.\n   */\n  inferInterfaceNameFromFilename?: boolean;\n}\n\n/**\n * @public\n */\nexport interface ITypingsGeneratorOptions extends ITypingsGeneratorBaseOptions {\n  /**\n   * Options for configuring the default export.\n   */\n  exportAsDefault?: boolean | IExportAsDefaultOptions | IInferInterfaceNameExportAsDefaultOptions;\n\n  /**\n   * Normalizes the line endings in .resx files to the specified kind.\n   */\n  resxNewlineNormalization?: NewlineKind | undefined;\n\n  /**\n   * If specified, the generator will write trimmed .json files to the specified folders.\n   * The .json files will be written to the same relative path as the source file.\n   * For example, if the source file is \"&lt;root&gt;/foo/bar.resx\", and the output folder is \"dist\",\n   * the trimmed .json file will be written to \"dist/foo/bar.resx.json\".\n   */\n  trimmedJsonOutputFolders?: string[] | undefined;\n\n  /**\n   * If true, .resx files will not throw errors if comments are missing.\n   */\n  ignoreMissingResxComments?: boolean | undefined;\n\n  /**\n   * Optionally, provide a function that will be called for each string. If the function returns `true`\n   * the string will not be included.\n   */\n  ignoreString?: IgnoreStringFunction;\n\n  /**\n   * Processes the raw text of a comment.\n   * @param comment - The original text of the comment to process\n   * @param relativeFilePath - The relative file path\n   * @param stringName - The name of the string that the comment is for\n   * @returns The processed comment\n   */\n  processComment?: (\n    comment: string | undefined,\n    relativeFilePath: string,\n    stringName: string\n  ) => string | undefined;\n}\n\n/**\n * This is a simple tool that generates .d.ts files for .loc.json, .resx.json, .resjson, and .resx files.\n *\n * @public\n */\nexport class TypingsGenerator extends StringValuesTypingsGenerator {\n  public constructor(options: ITypingsGeneratorOptions) {\n    const {\n      ignoreString,\n      processComment,\n      resxNewlineNormalization,\n      ignoreMissingResxComments,\n      trimmedJsonOutputFolders,\n      exportAsDefault\n    } = options;\n    const inferDefaultExportInterfaceNameFromFilename: boolean | undefined =\n      typeof exportAsDefault === 'object'\n        ? (exportAsDefault as IInferInterfaceNameExportAsDefaultOptions).inferInterfaceNameFromFilename\n        : undefined;\n\n    const getJsonPaths: ((relativePath: string) => string[]) | undefined =\n      trimmedJsonOutputFolders && trimmedJsonOutputFolders.length > 0\n        ? (relativePath: string): string[] => {\n            const jsonRelativePath: string =\n              relativePath.endsWith('.json') || relativePath.endsWith('.resjson')\n                ? relativePath\n                : `${relativePath}.json`;\n\n            const jsonPaths: string[] = [];\n            for (const outputFolder of trimmedJsonOutputFolders) {\n              jsonPaths.push(`${outputFolder}/${jsonRelativePath}`);\n            }\n            return jsonPaths;\n          }\n        : undefined;\n\n    super({\n      ...options,\n      fileExtensions: ['.resx', '.resx.json', '.loc.json', '.resjson'],\n      getAdditionalOutputFiles: getJsonPaths,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      parseAndGenerateTypings: async (\n        content: string,\n        filePath: string,\n        relativeFilePath: string\n      ): Promise<IStringValueTypings> => {\n        const locFileData: ILocalizationFile = parseLocFile({\n          filePath,\n          content,\n          terminal: this.terminal,\n          resxNewlineNormalization,\n          ignoreMissingResxComments,\n          ignoreString\n        });\n\n        const typings: IStringValueTyping[] = [];\n\n        const json: Record<string, string> | undefined = trimmedJsonOutputFolders ? {} : undefined;\n\n        for (const [stringName, value] of Object.entries(locFileData)) {\n          let comment: string | undefined = value.comment;\n          if (processComment) {\n            comment = processComment(comment, relativeFilePath, stringName);\n          }\n\n          if (json) {\n            json[stringName] = value.value;\n          }\n\n          typings.push({\n            exportName: stringName,\n            comment\n          });\n        }\n\n        if (getJsonPaths) {\n          const jsonBuffer: Buffer = Buffer.from(JSON.stringify(json), 'utf8');\n          for (const jsonFile of getJsonPaths(relativeFilePath)) {\n            await FileSystem.writeFileAsync(jsonFile, jsonBuffer, {\n              ensureFolderExists: true\n            });\n          }\n        }\n\n        if (inferDefaultExportInterfaceNameFromFilename) {\n          const lastSlashIndex: number = Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\\\'));\n          let extensionIndex: number = filePath.lastIndexOf('.');\n          if (filePath.slice(extensionIndex).toLowerCase() === '.json') {\n            extensionIndex = filePath.lastIndexOf('.', extensionIndex - 1);\n          }\n\n          const fileNameWithoutExtension: string = filePath.substring(lastSlashIndex + 1, extensionIndex);\n          const normalizedFileName: string = fileNameWithoutExtension.replace(/[^a-zA-Z0-9$_]/g, '');\n          const firstCharUpperCased: string = normalizedFileName.charAt(0).toUpperCase();\n          let interfaceName: string | undefined = `I${firstCharUpperCased}${normalizedFileName.slice(1)}`;\n\n          if (!interfaceName.endsWith('strings') && !interfaceName.endsWith('Strings')) {\n            interfaceName += 'Strings';\n          }\n\n          return {\n            typings,\n            exportAsDefault: {\n              interfaceName\n            }\n          };\n        } else {\n          return {\n            typings\n          };\n        }\n      }\n    });\n  }\n}\n"]}