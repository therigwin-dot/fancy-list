"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalizationPlugin = void 0;
exports.getPluginInstance = getPluginInstance;
const path = __importStar(require("path"));
const localization_utilities_1 = require("@rushstack/localization-utilities");
const Async_1 = require("@rushstack/node-core-library/lib/Async");
const Constants = __importStar(require("./utilities/Constants"));
const EntityMarker_1 = require("./utilities/EntityMarker");
const AssetProcessor_1 = require("./AssetProcessor");
const trueHashes_1 = require("./trueHashes");
const chunkUtilities_1 = require("./utilities/chunkUtilities");
const PLUGIN_NAME = 'localization';
const pluginForCompiler = new WeakMap();
/**
 * Gets the instance of the LocalizationPlugin bound to the specified webpack compiler.
 * Used by loaders.
 */
function getPluginInstance(compiler) {
    const instance = compiler && pluginForCompiler.get(compiler);
    if (!instance) {
        throw new Error(`Could not find a LocalizationPlugin instance for the current webpack compiler!`);
    }
    return instance;
}
/**
 * This plugin facilitates localization in webpack.
 *
 * @public
 */
class LocalizationPlugin {
    constructor(options) {
        this._locFiles = new Map();
        this._resolvedTranslatedStringsFromOptions = new Map();
        this._stringPlaceholderMap = new Map();
        this._pseudolocalizers = new Map();
        /**
         * The set of locales that have translations provided.
         */
        this._translatedLocales = new Set();
        this._options = options;
    }
    /**
     * Apply this plugin to the specified webpack compiler.
     */
    apply(compiler) {
        pluginForCompiler.set(compiler, this);
        // https://github.com/webpack/webpack-dev-server/pull/1929/files#diff-15fb51940da53816af13330d8ce69b4eR66
        const isWebpackDevServer = process.env.WEBPACK_DEV_SERVER === 'true';
        const { errors, warnings } = this._initializeAndValidateOptions(compiler, isWebpackDevServer);
        if (errors.length > 0 || warnings.length > 0) {
            compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {
                compilation.errors.push(...errors);
                compilation.warnings.push(...warnings);
            });
            if (errors.length > 0) {
                // If there are any errors, just pass through the resources in source and don't do any
                // additional configuration
                return;
            }
        }
        const { webpack: thisWebpack } = compiler;
        const { WebpackError, runtime: { GetChunkFilenameRuntimeModule } } = thisWebpack;
        // Side-channel for async chunk URL generator chunk, since the actual chunk is completely inaccessible
        // from the assetPath hook below when invoked to build the async URL generator
        let chunkWithAsyncURLGenerator;
        const originalGenerate = GetChunkFilenameRuntimeModule.prototype.generate;
        GetChunkFilenameRuntimeModule.prototype.generate = function () {
            // `originalGenerate` will invoke `getAssetPath` to produce the async URL generator
            // Need to know the identity of the containing chunk to correctly produce the asset path expression
            chunkWithAsyncURLGenerator = this.chunk;
            const result = originalGenerate.call(this);
            // Unset after the call finishes because we are no longer generating async URL generators
            chunkWithAsyncURLGenerator = undefined;
            return result;
        };
        const asyncGeneratorTest = /^\" \+/;
        const { runtimeLocaleExpression } = this._options;
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {
            var _a;
            let hashFn;
            if (this._options.realContentHash) {
                if (runtimeLocaleExpression) {
                    compilation.errors.push(new WebpackError(`The "realContentHash" option cannot be used in conjunction with "runtimeLocaleExpression".`));
                }
                else {
                    hashFn = (0, trueHashes_1.getHashFunction)({ thisWebpack, compilation });
                }
            }
            else if ((_a = compiler.options.optimization) === null || _a === void 0 ? void 0 : _a.realContentHash) {
                compilation.errors.push(new thisWebpack.WebpackError(`The \`optimization.realContentHash\` option is set and the ${LocalizationPlugin.name}'s ` +
                    '`realContentHash` option is not set. This will likely produce invalid results. Consider setting the ' +
                    `\`realContentHash\` option in the ${LocalizationPlugin.name} plugin.`));
            }
            const chunksWithUrlGenerators = new WeakSet();
            compilation.hooks.assetPath.tap(PLUGIN_NAME, (assetPath, options) => {
                var _a;
                const { chunkGraph } = compilation;
                if (options.contentHashType === 'javascript' &&
                    assetPath.match(Constants.LOCALE_FILENAME_TOKEN_REGEX)) {
                    // Does this look like an async chunk URL generator?
                    if (typeof ((_a = options.chunk) === null || _a === void 0 ? void 0 : _a.id) === 'string' && options.chunk.id.match(asyncGeneratorTest)) {
                        const chunkIdsWithStrings = new Set();
                        const chunkIdsWithoutStrings = new Set();
                        const activeChunkWithAsyncUrlGenerator = chunkWithAsyncURLGenerator;
                        if (!activeChunkWithAsyncUrlGenerator) {
                            compilation.errors.push(new WebpackError(`No active chunk while constructing async chunk URL generator!`));
                            return assetPath;
                        }
                        const asyncChunks = activeChunkWithAsyncUrlGenerator.getAllAsyncChunks();
                        for (const asyncChunk of asyncChunks) {
                            const chunkId = asyncChunk.id;
                            if (chunkId === null || chunkId === undefined) {
                                throw new Error(`Chunk "${asyncChunk.name}"'s ID is null or undefined.`);
                            }
                            if (_chunkHasLocalizedModules(chunkGraph, asyncChunk, runtimeLocaleExpression)) {
                                chunkIdsWithStrings.add(chunkId);
                            }
                            else {
                                chunkIdsWithoutStrings.add(chunkId);
                            }
                        }
                        return assetPath.replace(Constants.LOCALE_FILENAME_TOKEN_REGEX, () => {
                            // Use a replacer function so that we don't need to escape anything in the return value
                            // If the runtime chunk is itself localized, forcibly match the locale of the runtime chunk
                            // Otherwise prefer the runtime expression if specified
                            const localeExpression = (!_chunkHasLocalizedModules(chunkGraph, activeChunkWithAsyncUrlGenerator, runtimeLocaleExpression) &&
                                runtimeLocaleExpression) ||
                                Constants.JSONP_PLACEHOLDER;
                            if (localeExpression === Constants.JSONP_PLACEHOLDER) {
                                chunksWithUrlGenerators.add(activeChunkWithAsyncUrlGenerator);
                            }
                            if (chunkIdsWithStrings.size === 0) {
                                return this._formatLocaleForFilename(this._noStringsLocaleName);
                            }
                            else if (chunkIdsWithoutStrings.size === 0) {
                                return `" + ${localeExpression} + "`;
                            }
                            else {
                                // Generate an object that is used to select between <locale> and <nostrings locale> for each chunk ID
                                // Method: pick the smaller set of (localized, non-localized) and map that to 1 (a truthy value)
                                // All other IDs map to `undefined` (a falsy value), so we then use the ternary operator to select
                                // the appropriate token
                                //
                                // This can be improved in the future. We can maybe sort the chunks such that the chunks below a certain ID
                                // number are localized and the those above are not.
                                const chunkMapping = {};
                                // Use the map with the fewest values to shorten the expression
                                const isLocalizedSmaller = chunkIdsWithStrings.size <= chunkIdsWithoutStrings.size;
                                // These are the ids for which the expression should evaluate to a truthy value
                                const smallerSet = isLocalizedSmaller
                                    ? chunkIdsWithStrings
                                    : chunkIdsWithoutStrings;
                                for (const id of smallerSet) {
                                    chunkMapping[id] = 1;
                                }
                                const noLocaleExpression = JSON.stringify(this._formatLocaleForFilename(this._noStringsLocaleName));
                                return `" + (${JSON.stringify(chunkMapping)}[chunkId]?${isLocalizedSmaller ? localeExpression : noLocaleExpression}:${isLocalizedSmaller ? noLocaleExpression : localeExpression}) + "`;
                            }
                        });
                    }
                    else {
                        let locale = options.locale;
                        if (!locale) {
                            const isLocalized = _chunkHasLocalizedModules(chunkGraph, options.chunk, runtimeLocaleExpression);
                            // Ensure that the initial name maps to a file that should exist in the final output
                            locale = isLocalized ? this._defaultLocale : this._noStringsLocaleName;
                        }
                        return assetPath.replace(Constants.LOCALE_FILENAME_TOKEN_REGEX, this._formatLocaleForFilename(locale));
                    }
                }
                else {
                    return assetPath;
                }
            });
            const { outputOptions } = compilation;
            // For compatibility with minifiers, need to generate the additional assets after the optimize process runs
            compilation.hooks.processAssets.tapPromise({
                name: PLUGIN_NAME,
                // Generating derived assets, but explicitly want to create them *after* asset optimization
                stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING - 1
            }, async () => {
                const locales = this._translatedLocales;
                const { chunkGraph, chunks } = compilation;
                const { localizationStats: statsOptions } = this._options;
                const filesByChunkName = statsOptions
                    ? new Map()
                    : undefined;
                const localizedEntryPointNames = [];
                const localizedChunkNames = [];
                const cache = compilation.getCache(PLUGIN_NAME);
                await Async_1.Async.forEachAsync(chunks, async (chunk) => {
                    if (!(0, chunkUtilities_1.chunkIsJs)(chunk, chunkGraph)) {
                        return;
                    }
                    const isLocalized = _chunkHasLocalizedModules(chunkGraph, chunk, runtimeLocaleExpression);
                    const template = chunk.filenameTemplate ||
                        (chunk.hasRuntime() ? outputOptions.filename : outputOptions.chunkFilename);
                    const defaultAssetName = compilation.getPath(template, {
                        chunk,
                        contentHashType: 'javascript'
                        // Without locale this should return the name of the default asset
                    });
                    const asset = compilation.getAsset(defaultAssetName);
                    if (!asset) {
                        compilation.errors.push(new WebpackError(`Missing expected chunk asset ${defaultAssetName}`));
                        return;
                    }
                    if (isLocalized) {
                        const localizedAssets = await (0, AssetProcessor_1.processLocalizedAssetCachedAsync)({
                            // Global values
                            plugin: this,
                            compilation,
                            cache,
                            locales,
                            defaultLocale: this._defaultLocale,
                            passthroughLocaleName: this._passthroughLocaleName,
                            fillMissingTranslationStrings: this._fillMissingTranslationStrings,
                            formatLocaleForFilenameFn: this._formatLocaleForFilename,
                            // Chunk-specific values
                            chunk,
                            asset,
                            filenameTemplate: template
                        });
                        if (filesByChunkName && chunk.name) {
                            filesByChunkName.set(chunk.name, localizedAssets);
                            (chunk.hasRuntime() ? localizedEntryPointNames : localizedChunkNames).push(chunk.name);
                        }
                    }
                    else {
                        await (0, AssetProcessor_1.processNonLocalizedAssetCachedAsync)({
                            // Global values
                            plugin: this,
                            compilation,
                            cache,
                            hasUrlGenerator: chunksWithUrlGenerators.has(chunk),
                            noStringsLocaleName: this._noStringsLocaleName,
                            formatLocaleForFilenameFn: this._formatLocaleForFilename,
                            // Chunk-specific values
                            chunk,
                            asset,
                            fileName: defaultAssetName
                        });
                    }
                }, {
                    // Only async component is the cache layer
                    concurrency: 20
                });
                if (hashFn) {
                    (0, trueHashes_1.updateAssetHashes)({
                        thisWebpack,
                        compilation,
                        hashFn,
                        filesByChunkName
                    });
                }
                // Since the stats generation doesn't depend on content, do it immediately
                if (statsOptions && filesByChunkName) {
                    const localizationStats = {
                        entrypoints: {},
                        namedChunkGroups: {}
                    };
                    // Sort in lexicographic order to ensure stable output
                    localizedChunkNames.sort();
                    for (const chunkName of localizedChunkNames) {
                        localizationStats.namedChunkGroups[chunkName] = {
                            localizedAssets: filesByChunkName.get(chunkName)
                        };
                    }
                    // Sort in lexicographic order to ensure stable output
                    localizedEntryPointNames.sort();
                    for (const chunkName of localizedEntryPointNames) {
                        localizationStats.entrypoints[chunkName] = {
                            localizedAssets: filesByChunkName.get(chunkName)
                        };
                    }
                    const { dropPath, callback } = statsOptions;
                    if (dropPath) {
                        compilation.emitAsset(dropPath, new compiler.webpack.sources.RawSource(JSON.stringify(localizationStats)));
                    }
                    if (callback) {
                        try {
                            callback(localizationStats, compilation);
                        }
                        catch (e) {
                            /* swallow errors from the callback */
                        }
                    }
                }
            });
        });
    }
    /**
     * @public
     *
     * @returns An object mapping the string keys to placeholders
     */
    async addDefaultLocFileAsync(context, localizedFileKey, localizedResourceData) {
        const locFileData = convertLocalizationFileToLocData(localizedResourceData);
        const fileInfo = this._addLocFileAndGetPlaceholders(this._defaultLocale, localizedFileKey, locFileData);
        const missingLocales = [];
        for (const [translatedLocaleName, translatedStrings] of this._resolvedTranslatedStringsFromOptions) {
            const translatedLocFileFromOptions = translatedStrings.get(localizedFileKey);
            if (!translatedLocFileFromOptions) {
                missingLocales.push(translatedLocaleName);
            }
            else {
                const translatedLocFileData = await normalizeLocalizedDataAsync(context, translatedLocFileFromOptions);
                fileInfo.translations.set(translatedLocaleName, translatedLocFileData);
            }
        }
        const { resolveMissingTranslatedStrings } = this._options.localizedData;
        if (missingLocales.length > 0 && resolveMissingTranslatedStrings) {
            let resolvedTranslatedData = undefined;
            try {
                resolvedTranslatedData = await resolveMissingTranslatedStrings(missingLocales, localizedFileKey, context);
            }
            catch (e) {
                context.emitError(e);
            }
            if (resolvedTranslatedData) {
                const iterable = resolvedTranslatedData instanceof Map
                    ? resolvedTranslatedData.entries()
                    : Object.entries(resolvedTranslatedData);
                for (const [resolvedLocaleName, resolvedLocaleData] of iterable) {
                    if (resolvedLocaleData) {
                        const translatedLocFileData = await normalizeLocalizedDataAsync(context, resolvedLocaleData);
                        fileInfo.translations.set(resolvedLocaleName, translatedLocFileData);
                    }
                }
            }
        }
        for (const [pseudolocaleName, pseudolocalizer] of this._pseudolocalizers) {
            const pseudolocFileData = new Map();
            for (const [stringName, stringValue] of locFileData) {
                pseudolocFileData.set(stringName, pseudolocalizer(stringValue));
            }
            fileInfo.translations.set(pseudolocaleName, pseudolocFileData);
        }
        (0, EntityMarker_1.markEntity)(context._module, true);
        return fileInfo.renderedPlacholders;
    }
    /**
     * @public
     */
    getPlaceholder(localizedFileKey, stringName) {
        const file = this._locFiles.get(localizedFileKey);
        if (!file) {
            return undefined;
        }
        return file.placeholders.get(stringName);
    }
    /**
     * @internal
     */
    getDataForSerialNumber(serialNumber) {
        return this._stringPlaceholderMap.get(serialNumber);
    }
    _addLocFileAndGetPlaceholders(localeName, localizedFileKey, localizedFileData) {
        let fileInfo = this._locFiles.get(localizedFileKey);
        if (!fileInfo) {
            fileInfo = {
                placeholders: new Map(),
                translations: new Map(),
                renderedPlacholders: {}
            };
            this._locFiles.set(localizedFileKey, fileInfo);
        }
        const { placeholders, translations } = fileInfo;
        const locFilePrefix = Buffer.from(localizedFileKey, 'utf-8').toString('hex') + '$';
        const resultObject = {};
        for (const stringName of localizedFileData.keys()) {
            let placeholder = placeholders.get(stringName);
            if (!placeholder) {
                const suffix = `${locFilePrefix}${Buffer.from(stringName, 'utf-8').toString('hex')}`;
                placeholder = {
                    value: `${Constants.STRING_PLACEHOLDER_PREFIX}_${Constants.STRING_PLACEHOLDER_LABEL}_\\_${suffix}_`,
                    suffix,
                    translations,
                    locFilePath: localizedFileKey,
                    stringName
                };
                placeholders.set(stringName, placeholder);
                this._stringPlaceholderMap.set(suffix, placeholder);
            }
            resultObject[stringName] = placeholder.value;
        }
        translations.set(localeName, localizedFileData);
        fileInfo.renderedPlacholders = resultObject;
        return fileInfo;
    }
    _addTranslations(localeName, fileInfo, localizedFileData) {
        fileInfo.translations.set(localeName, localizedFileData);
    }
    _initializeAndValidateOptions(compiler, isWebpackDevServer) {
        var _a;
        const errors = [];
        const warnings = [];
        const { WebpackError } = compiler.webpack;
        const { options: configuration } = compiler;
        const LOCALE_NAME_REGEX = /[a-z-]/i;
        function ensureValidLocaleName(localeName) {
            if (!localeName.match(LOCALE_NAME_REGEX)) {
                errors.push(new WebpackError(`Invalid locale name: ${localeName}. Locale names may only contain letters and hyphens.`));
                return false;
            }
            else {
                return true;
            }
        }
        // START configuration
        if (!configuration.output ||
            !configuration.output.filename ||
            typeof configuration.output.filename !== 'string' ||
            configuration.output.filename.indexOf(Constants.LOCALE_FILENAME_TOKEN) === -1) {
            errors.push(new WebpackError('The configuration.output.filename property must be provided, must be a string, and must include ' +
                `the ${Constants.LOCALE_FILENAME_TOKEN} placeholder`));
        }
        // END configuration
        // START misc options
        // START options.localizedData
        const { localizedData } = this._options;
        if (localizedData) {
            // START options.localizedData.passthroughLocale
            const { passthroughLocale } = localizedData;
            if (passthroughLocale) {
                const { usePassthroughLocale, passthroughLocaleName = 'passthrough' } = passthroughLocale;
                if (usePassthroughLocale) {
                    this._passthroughLocaleName = passthroughLocaleName;
                    this._translatedLocales.add(passthroughLocaleName);
                }
            }
            // END options.localizedData.passthroughLocale
            // START options.localizedData.translatedStrings
            const resolveRelativeToContext = (((_a = configuration.context) === null || _a === void 0 ? void 0 : _a.startsWith('/')) ? path.posix.resolve : path.resolve).bind(0, configuration.context);
            const { translatedStrings } = localizedData;
            this._resolvedTranslatedStringsFromOptions.clear();
            if (translatedStrings) {
                for (const [localeName, locale] of Object.entries(translatedStrings)) {
                    if (this._translatedLocales.has(localeName)) {
                        errors.push(new WebpackError(`The locale "${localeName}" appears multiple times. ` +
                            'There may be multiple instances with different casing.'));
                        return { errors, warnings };
                    }
                    if (!ensureValidLocaleName(localeName)) {
                        return { errors, warnings };
                    }
                    this._translatedLocales.add(localeName);
                    const resolvedFromOptionsForLocale = new Map();
                    this._resolvedTranslatedStringsFromOptions.set(localeName, resolvedFromOptionsForLocale);
                    for (const [locFilePath, locFileDataFromOptions] of Object.entries(locale)) {
                        const normalizedLocFilePath = resolveRelativeToContext(locFilePath);
                        if (resolvedFromOptionsForLocale.has(normalizedLocFilePath)) {
                            errors.push(new WebpackError(`The localization file path "${locFilePath}" appears multiple times in locale ${localeName}. ` +
                                'There may be multiple instances with different casing.'));
                            return { errors, warnings };
                        }
                        const normalizedLocFileDataFromOptions = typeof locFileDataFromOptions === 'string'
                            ? resolveRelativeToContext(locFileDataFromOptions)
                            : locFileDataFromOptions;
                        resolvedFromOptionsForLocale.set(normalizedLocFilePath, normalizedLocFileDataFromOptions);
                    }
                }
            }
            // END options.localizedData.translatedStrings
            // START options.localizedData.defaultLocale
            const { defaultLocale } = localizedData;
            if (defaultLocale) {
                const { localeName, fillMissingTranslationStrings } = defaultLocale;
                if (localeName) {
                    if (this._translatedLocales.has(localeName)) {
                        errors.push(new WebpackError('The default locale is also specified in the translated strings.'));
                        return { errors, warnings };
                    }
                    else if (!ensureValidLocaleName(localeName)) {
                        return { errors, warnings };
                    }
                    this._translatedLocales.add(localeName);
                    this._defaultLocale = localeName;
                    this._fillMissingTranslationStrings = !!fillMissingTranslationStrings;
                }
                else {
                    errors.push(new WebpackError('Missing default locale name'));
                    return { errors, warnings };
                }
            }
            else {
                errors.push(new WebpackError('Missing default locale options.'));
                return { errors, warnings };
            }
            // END options.localizedData.defaultLocale
            // START options.localizedData.pseudoLocales
            const { pseudolocales } = localizedData;
            if (pseudolocales) {
                for (const [pseudolocaleName, pseudoLocaleOpts] of Object.entries(pseudolocales)) {
                    if (this._defaultLocale === pseudolocaleName) {
                        errors.push(new WebpackError(`A pseudolocale (${pseudolocaleName}) name is also the default locale name.`));
                        return { errors, warnings };
                    }
                    if (this._translatedLocales.has(pseudolocaleName)) {
                        errors.push(new WebpackError(`A pseudolocale (${pseudolocaleName}) name is also specified in the translated strings.`));
                        return { errors, warnings };
                    }
                    this._pseudolocalizers.set(pseudolocaleName, (0, localization_utilities_1.getPseudolocalizer)(pseudoLocaleOpts));
                    this._translatedLocales.add(pseudolocaleName);
                }
            }
            // END options.localizedData.pseudoLocales
        }
        else if (!isWebpackDevServer) {
            throw new Error('Localized data must be provided unless webpack dev server is running.');
        }
        // END options.localizedData
        // START options.noStringsLocaleName
        const { noStringsLocaleName } = this._options;
        if (noStringsLocaleName === undefined ||
            noStringsLocaleName === null ||
            !ensureValidLocaleName(noStringsLocaleName)) {
            this._noStringsLocaleName = 'none';
        }
        else {
            this._noStringsLocaleName = noStringsLocaleName;
        }
        // END options.noStringsLocaleName
        // START options.formatLocaleForFilename
        const { formatLocaleForFilename = (localeName) => localeName } = this._options;
        this._formatLocaleForFilename = formatLocaleForFilename;
        // END options.formatLocaleForFilename
        return { errors, warnings };
    }
}
exports.LocalizationPlugin = LocalizationPlugin;
function _chunkHasLocalizedModules(chunkGraph, chunk, runtimeLocaleExpression) {
    let chunkHasAnyLocModules = (0, EntityMarker_1.getMark)(chunk);
    if (chunkHasAnyLocModules === undefined) {
        chunkHasAnyLocModules = false;
        const candidateModules = chunkGraph.getChunkModulesIterableBySourceType(chunk, 'javascript');
        if (candidateModules) {
            outer: for (const module of candidateModules) {
                const moduleMark = (0, EntityMarker_1.getMark)(module);
                if (moduleMark) {
                    chunkHasAnyLocModules = true;
                    break;
                }
                else if (moduleMark === false) {
                    continue;
                }
                // Is this a concatenated module?
                const { _modules: modules } = module;
                if (modules) {
                    for (const nestedModule of modules) {
                        if ((0, EntityMarker_1.getMark)(nestedModule)) {
                            (0, EntityMarker_1.markEntity)(module, true);
                            chunkHasAnyLocModules = true;
                            break outer;
                        }
                    }
                    (0, EntityMarker_1.markEntity)(module, false);
                }
            }
        }
        // If this chunk doesn't directly contain any localized resources, it still
        // needs to be localized if it's an entrypoint chunk (i.e. - it has a runtime)
        // and it loads localized async chunks.
        // In that case, the generated chunk URL generation code needs to contain
        // the locale name.
        if (!chunkHasAnyLocModules && !runtimeLocaleExpression && chunk.hasRuntime()) {
            for (const asyncChunk of chunk.getAllAsyncChunks()) {
                if (_chunkHasLocalizedModules(chunkGraph, asyncChunk, runtimeLocaleExpression)) {
                    chunkHasAnyLocModules = true;
                    break;
                }
            }
        }
        (0, EntityMarker_1.markEntity)(chunk, chunkHasAnyLocModules);
    }
    return chunkHasAnyLocModules;
}
function convertLocalizationFileToLocData(locFile) {
    const locFileData = new Map();
    for (const [stringName, locFileEntry] of Object.entries(locFile)) {
        locFileData.set(stringName, locFileEntry.value);
    }
    return locFileData;
}
async function normalizeLocalizedDataAsync(context, localizedData) {
    if (typeof localizedData === 'string') {
        // The value is the path to a file. Add it as a file dependency
        context.addDependency(localizedData);
        const content = await new Promise((resolve, reject) => {
            // Use context.fs so that the plugin is compatible with overriding compiler.inputFileSystem
            context.fs.readFile(localizedData, (err, data) => {
                if (err) {
                    return reject(err);
                }
                else if (!data) {
                    return reject(new Error(`No data in ${localizedData}`));
                }
                resolve(data.toString());
            });
        });
        const localizationFile = (0, localization_utilities_1.parseResJson)({
            filePath: localizedData,
            content
        });
        return convertLocalizationFileToLocData(localizationFile);
    }
    else {
        return localizedData instanceof Map ? localizedData : new Map(Object.entries(localizedData));
    }
}
//# sourceMappingURL=LocalizationPlugin.js.map