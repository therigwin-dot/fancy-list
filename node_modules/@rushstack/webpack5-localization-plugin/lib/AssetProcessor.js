"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PLACEHOLDER_REGEX = void 0;
exports.processLocalizedAssetCachedAsync = processLocalizedAssetCachedAsync;
exports.processLocalizedAsset = processLocalizedAsset;
exports.processNonLocalizedAssetCachedAsync = processNonLocalizedAssetCachedAsync;
exports.processNonLocalizedAsset = processNonLocalizedAsset;
const Constants = __importStar(require("./utilities/Constants"));
exports.PLACEHOLDER_REGEX = new RegExp(`${Constants.STRING_PLACEHOLDER_PREFIX}_([A-C])_(\\\\*)_([0-9a-f$]+)_`, 'g');
async function processLocalizedAssetCachedAsync(options) {
    const { compilation, asset, cache, chunk } = options;
    const { source: originalSource } = asset;
    const eTag = cache.getLazyHashedEtag(originalSource);
    const { name: originName } = asset;
    const cacheItem = cache.getItemCache(originName, eTag);
    let output = await cacheItem.getPromise();
    if (!output) {
        output = processLocalizedAsset(options);
        await cacheItem.storePromise(output);
    }
    const { localizedFiles, processedAssets } = output;
    chunk.localizedFiles = localizedFiles;
    for (const { filename, source, info } of processedAssets) {
        if (originName === filename) {
            // This helper throws if the asset doesn't already exist
            // Use the function form so that the object identity of `related` is preserved.
            // Since we already read the original info, we don't need fancy merge logic.
            compilation.updateAsset(filename, source, () => info);
        }
        else {
            // This helper throws if the asset already exists
            compilation.emitAsset(filename, source, info);
        }
    }
    return localizedFiles;
}
function processLocalizedAsset(options) {
    const { compilation, asset, chunk, filenameTemplate, locales, formatLocaleForFilenameFn } = options;
    const { sources, WebpackError } = compilation.compiler.webpack;
    const { source: originalSource } = asset;
    const rawSource = originalSource instanceof sources.CachedSource
        ? originalSource
        : new sources.CachedSource(originalSource);
    const assetSource = rawSource.source().toString();
    const parsedAsset = _parseStringToReconstructionSequence(options.plugin, assetSource, formatLocaleForFilenameFn);
    const { issues } = parsedAsset;
    const localizedFiles = {};
    const processedAssets = [];
    const { info: originInfo, name: originName } = asset;
    if (!originInfo.related) {
        originInfo.related = {};
    }
    for (const locale of locales) {
        const { issues: localeIssues, result: localeResult } = _reconstructLocalized(new sources.ReplaceSource(rawSource, locale), parsedAsset.reconstructionSeries, locale, options.fillMissingTranslationStrings ? options.defaultLocale : undefined, options.passthroughLocaleName);
        for (const issue of localeIssues) {
            issues.push(issue);
        }
        const data = {
            chunk,
            contentHashType: 'javascript',
            // The locale property will get processed by the extension to the getAssetPath hook
            locale
        };
        const fileName = compilation.getAssetPath(filenameTemplate, data);
        const info = {
            ...originInfo,
            locale
        };
        const wrapped = new sources.CachedSource(localeResult);
        localizedFiles[locale] = fileName;
        processedAssets.push({
            filename: fileName,
            source: wrapped,
            info
        });
        // If file already exists
        if (originName !== fileName) {
            // If A.related points to B, B.related can't point to A or the stats emitter explodes
            // So just strip the related object for the localized assets
            info.related = undefined;
            // We omit the `related` property that does a self-reference.
            originInfo.related[locale] = fileName;
        }
    }
    if (issues.length > 0) {
        compilation.errors.push(new WebpackError(`localization:\n${issues.map((issue) => `  ${issue}`).join('\n')}`));
    }
    return {
        localizedFiles,
        processedAssets
    };
}
async function processNonLocalizedAssetCachedAsync(options) {
    const { compilation, asset, cache } = options;
    const { source: originalSource } = asset;
    const eTag = cache.getLazyHashedEtag(originalSource);
    const { name: originName } = asset;
    const cacheItem = cache.getItemCache(originName, eTag);
    let output = await cacheItem.getPromise();
    if (!output) {
        output = processNonLocalizedAsset(options);
        await cacheItem.storePromise(output);
    }
    const { filename, source, info } = output;
    compilation.updateAsset(originName, source, info);
    if (originName !== filename) {
        compilation.renameAsset(originName, filename);
    }
}
function processNonLocalizedAsset(options) {
    const { asset, fileName, compilation, formatLocaleForFilenameFn, hasUrlGenerator } = options;
    const { sources, WebpackError } = compilation.compiler.webpack;
    const rawSource = asset.source;
    let cachedSource = rawSource instanceof sources.CachedSource ? rawSource : new sources.CachedSource(rawSource);
    const { info: originInfo } = asset;
    const locale = options.noStringsLocaleName;
    if (hasUrlGenerator) {
        const assetSource = cachedSource.source().toString();
        const parsedAsset = _parseStringToReconstructionSequence(options.plugin, assetSource, formatLocaleForFilenameFn);
        const { issues } = parsedAsset;
        const { issues: localeIssues, result } = _reconstructNonLocalized(new sources.ReplaceSource(cachedSource, locale), parsedAsset.reconstructionSeries, locale);
        for (const issue of localeIssues) {
            issues.push(issue);
        }
        if (issues.length > 0) {
            options.compilation.errors.push(new WebpackError(`localization:\n${issues.map((issue) => `  ${issue}`).join('\n')}`));
        }
        cachedSource = new sources.CachedSource(result);
    }
    else {
        // Force the CachedSource to cache the concatenated *string*, so that the subsequent ask for the buffer is fast
        cachedSource.source();
    }
    const info = {
        ...originInfo,
        locale
    };
    return {
        filename: fileName,
        source: cachedSource,
        info
    };
}
const ESCAPE_MAP = new Map([
    ['\r', 'r'],
    ['\n', 'n'],
    ['\t', 't'],
    ['"', 'u0022'],
    ["'", 'u0027']
]);
const BACKSLASH_REGEX = /\\/g;
const ESCAPE_REGEX = /[\r\n\t"']/g;
function _reconstructLocalized(result, reconstructionSeries, locale, fallbackLocale, passthroughLocale) {
    var _a, _b;
    const issues = [];
    for (const element of reconstructionSeries) {
        switch (element.kind) {
            case 'localized': {
                const { data } = element;
                const { stringName, translations } = data;
                let newValue = locale === passthroughLocale ? stringName : (_a = translations.get(locale)) === null || _a === void 0 ? void 0 : _a.get(stringName);
                if (fallbackLocale && newValue === undefined) {
                    newValue = (_b = translations.get(fallbackLocale)) === null || _b === void 0 ? void 0 : _b.get(stringName);
                }
                if (newValue === undefined) {
                    issues.push(`The string "${stringName}" in "${data.locFilePath}" is missing in the locale ${locale}`);
                    newValue = '-- MISSING STRING --';
                }
                const escapedBackslash = element.escapedBackslash || '\\';
                if (newValue.includes('\\')) {
                    // The vast majority of localized strings do not contain `\\`, so this check avoids an allocation.
                    // Replace backslashes with the properly escaped backslash
                    BACKSLASH_REGEX.lastIndex = -1;
                    newValue = newValue.replace(BACKSLASH_REGEX, escapedBackslash);
                }
                // Ensure the the quotemark, apostrophe, tab, and newline characters are properly escaped
                ESCAPE_REGEX.lastIndex = -1;
                if (ESCAPE_REGEX.test(newValue)) {
                    // The majority of localized strings do not contain the characters that need to be escaped,
                    // so this check avoids an allocation.
                    // @todo: look into using JSON.parse(...) to get the escaping characters
                    const escapingCharacterSequence = escapedBackslash.slice(escapedBackslash.length / 2);
                    newValue = newValue.replace(ESCAPE_REGEX, (match) => `${escapingCharacterSequence}${ESCAPE_MAP.get(match)}`);
                }
                result.replace(element.start, element.end - 1, newValue);
                break;
            }
            case 'dynamic': {
                const newValue = element.valueFn(locale);
                result.replace(element.start, element.end - 1, newValue);
                break;
            }
        }
    }
    return {
        issues,
        result
    };
}
function _reconstructNonLocalized(result, reconstructionSeries, noStringsLocaleName) {
    const issues = [];
    for (const element of reconstructionSeries) {
        switch (element.kind) {
            case 'localized': {
                issues.push(`The string "${element.data.stringName}" in "${element.data.locFilePath}" appeared in an asset ` +
                    'that is not expected to contain localized resources.');
                const newValue = '-- NOT EXPECTED TO BE LOCALIZED --';
                result.replace(element.start, element.end - 1, newValue);
                break;
            }
            case 'dynamic': {
                const newValue = element.valueFn(noStringsLocaleName);
                result.replace(element.start, element.end - 1, newValue);
                break;
            }
        }
    }
    return {
        issues,
        result
    };
}
function _parseStringToReconstructionSequence(plugin, source, formatLocaleForFilenameFn) {
    const issues = [];
    const reconstructionSeries = [];
    let jsonStringifyFormatLocaleForFilenameFn;
    let index = source.indexOf(Constants.STRING_PLACEHOLDER_PREFIX);
    const increment = Constants.STRING_PLACEHOLDER_PREFIX.length + 1;
    while (index >= 0) {
        const start = index;
        const elementStart = index + increment;
        const elementLabel = source.charAt(elementStart);
        let end = elementStart + 2;
        switch (elementLabel) {
            case Constants.STRING_PLACEHOLDER_LABEL: {
                const backslashEnd = source.indexOf('_', end);
                const escapedBackslash = source.slice(end, backslashEnd);
                end = backslashEnd + 1;
                const serialEnd = source.indexOf('_', end);
                const serial = source.slice(end, serialEnd);
                end = serialEnd + 1;
                const stringData = plugin.getDataForSerialNumber(serial);
                if (!stringData) {
                    issues.push(`Missing placeholder ${serial}`);
                }
                else {
                    const localizedElement = {
                        kind: 'localized',
                        start,
                        end,
                        escapedBackslash,
                        data: stringData
                    };
                    reconstructionSeries.push(localizedElement);
                }
                break;
            }
            case Constants.LOCALE_NAME_PLACEHOLDER_LABEL: {
                const dynamicElement = {
                    kind: 'dynamic',
                    start,
                    end,
                    valueFn: formatLocaleForFilenameFn
                };
                reconstructionSeries.push(dynamicElement);
                break;
            }
            case Constants.JSONP_PLACEHOLDER_LABEL: {
                jsonStringifyFormatLocaleForFilenameFn || (jsonStringifyFormatLocaleForFilenameFn = (locale) => JSON.stringify(formatLocaleForFilenameFn(locale)));
                const dynamicElement = {
                    kind: 'dynamic',
                    start,
                    end,
                    valueFn: jsonStringifyFormatLocaleForFilenameFn
                };
                reconstructionSeries.push(dynamicElement);
                break;
            }
            default: {
                throw new Error(`Unexpected label ${elementLabel} in pattern ${source.slice(start, end)}`);
            }
        }
        index = source.indexOf(Constants.STRING_PLACEHOLDER_PREFIX, end);
    }
    return {
        issues,
        reconstructionSeries
    };
}
//# sourceMappingURL=AssetProcessor.js.map