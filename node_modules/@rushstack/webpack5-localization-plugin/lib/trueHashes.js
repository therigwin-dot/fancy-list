"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHashFunction = getHashFunction;
exports.updateAssetHashes = updateAssetHashes;
const node_core_library_1 = require("@rushstack/node-core-library");
const chunkUtilities_1 = require("./utilities/chunkUtilities");
function getHashFunction({ thisWebpack, compilation }) {
    const { hashFunction = 'md5', hashDigest = 'hex', hashDigestLength, hashSalt } = compilation.outputOptions;
    return (contents) => {
        const hash = thisWebpack.util.createHash(hashFunction);
        if (hashSalt) {
            hash.update(hashSalt, 'utf-8');
        }
        return hash.update(contents).digest(hashDigest).toString().slice(0, hashDigestLength);
    };
}
function updateAssetHashes({ thisWebpack, compilation, hashFn, filesByChunkName }) {
    var _a, _b, _c;
    const unprocessedDependenciesByChunk = new Map();
    const dependenciesByChunk = new Map();
    const dependentsByChunk = new Map();
    const unprocessedChunks = new Set();
    const nonJsChunks = new Set();
    for (const chunk of compilation.chunks) {
        if (!(0, chunkUtilities_1.chunkIsJs)(chunk, compilation.chunkGraph)) {
            nonJsChunks.add(chunk);
        }
        else {
            unprocessedChunks.add(chunk);
        }
    }
    for (const chunk of compilation.chunks) {
        let unprocessedDependencies = unprocessedDependenciesByChunk.get(chunk);
        if (!unprocessedDependencies) {
            unprocessedDependencies = new Set();
            unprocessedDependenciesByChunk.set(chunk, unprocessedDependencies);
        }
        let dependencies = dependenciesByChunk.get(chunk);
        if (!dependencies) {
            dependencies = new Set();
            dependenciesByChunk.set(chunk, dependencies);
        }
        if (chunk.hasRuntime()) {
            for (const asyncChunk of chunk.getAllAsyncChunks()) {
                if (!nonJsChunks.has(asyncChunk)) {
                    unprocessedDependencies.add(asyncChunk);
                    dependencies.add(asyncChunk);
                    let dependents = dependentsByChunk.get(asyncChunk);
                    if (!dependents) {
                        dependents = new Set();
                        dependentsByChunk.set(asyncChunk, dependents);
                    }
                    dependents.add(chunk);
                    if (!unprocessedChunks.has(asyncChunk)) {
                        compilation.errors.push(new thisWebpack.WebpackError(`Found an async chunk that was not included in the compilation: ${asyncChunk.id} ` +
                            `(reason: ${asyncChunk.chunkReason}).`));
                    }
                }
            }
        }
    }
    const hashReplacementsByChunk = new Map();
    let previousSize = -1;
    while (unprocessedChunks.size > 0) {
        const currentSize = unprocessedChunks.size;
        if (currentSize === previousSize) {
            compilation.errors.push(new thisWebpack.WebpackError(`Detected a cycle in the chunk dependencies. This should not be possible.`));
            break;
        }
        previousSize = currentSize;
        for (const chunk of unprocessedChunks) {
            if (((_a = unprocessedDependenciesByChunk.get(chunk)) === null || _a === void 0 ? void 0 : _a.size) === 0) {
                // TODO: do we need to check if the chunk is rendered?
                if (!chunk.renderedHash) {
                    compilation.errors.push(new thisWebpack.WebpackError(`Could not find the hash for chunk ${chunk.id}.`));
                }
                else {
                    const existingHash = chunk.contentHash.javascript;
                    const chunkDependencies = dependenciesByChunk.get(chunk);
                    if (!chunkDependencies) {
                        compilation.errors.push(new thisWebpack.WebpackError(`Could not find dependencies for chunk ${chunk.id}.`));
                    }
                    else {
                        function processChunkAsset(jsAssetName, locale) {
                            const asset = compilation.getAsset(jsAssetName);
                            if (!asset) {
                                compilation.errors.push(new thisWebpack.WebpackError(`Could not find asset "${jsAssetName}" for chunk ${chunk.id}.`));
                            }
                            else {
                                let assetSource = asset.source;
                                const assetName = asset.name;
                                if (chunkDependencies.size > 0) {
                                    const relevantHashReplacements = new Map();
                                    let hasAnyReplacements = false;
                                    for (const dependency of chunkDependencies) {
                                        const asyncChunkHashReplacements = hashReplacementsByChunk.get(dependency);
                                        if (!asyncChunkHashReplacements) {
                                            compilation.errors.push(new thisWebpack.WebpackError(`Could not find hash replacements for chunk ${dependency.id}.`));
                                        }
                                        else {
                                            const { existingHash: otherChunkExistingHash, trueHashByLocale } = asyncChunkHashReplacements;
                                            let replacementHash;
                                            if (typeof trueHashByLocale === 'object') {
                                                if (locale) {
                                                    replacementHash = trueHashByLocale[locale];
                                                }
                                            }
                                            else {
                                                replacementHash = trueHashByLocale;
                                            }
                                            if (replacementHash) {
                                                if (relevantHashReplacements.has(otherChunkExistingHash)) {
                                                    compilation.errors.push(new thisWebpack.WebpackError(`Found multiple replacements for hash ${otherChunkExistingHash} ` +
                                                        `in chunk ${chunk.id}.`));
                                                }
                                                else {
                                                    relevantHashReplacements.set(otherChunkExistingHash, replacementHash);
                                                    hasAnyReplacements = true;
                                                }
                                            }
                                        }
                                    }
                                    if (hasAnyReplacements) {
                                        const sourceString = assetSource.source().toString();
                                        const replaceSource = new thisWebpack.sources.ReplaceSource(assetSource, assetName);
                                        const regexp = new RegExp(Array.from(relevantHashReplacements.keys(), (hashToReplace) => node_core_library_1.Text.escapeRegExp(hashToReplace)).join('|'), 'g');
                                        let match;
                                        while ((match = regexp.exec(sourceString)) !== null) {
                                            const { 0: originalHash, index } = match;
                                            const matchStart = index;
                                            const matchEnd = matchStart + originalHash.length - 1;
                                            const replacement = relevantHashReplacements.get(originalHash);
                                            replaceSource.replace(matchStart, matchEnd, replacement);
                                        }
                                        assetSource = new thisWebpack.sources.CachedSource(replaceSource);
                                        compilation.updateAsset(jsAssetName, assetSource);
                                    }
                                }
                                if (jsAssetName.includes(existingHash)) {
                                    const trueHash = hashFn(assetSource.buffer());
                                    if (trueHash !== existingHash) {
                                        const newJsFilename = jsAssetName.replace(existingHash, trueHash);
                                        compilation.renameAsset(jsAssetName, newJsFilename);
                                        if (locale) {
                                            const filesForChunkName = chunk.name
                                                ? filesByChunkName === null || filesByChunkName === void 0 ? void 0 : filesByChunkName.get(chunk.name)
                                                : undefined;
                                            if (filesForChunkName) {
                                                filesForChunkName[locale] = newJsFilename;
                                            }
                                        }
                                        return {
                                            trueHash,
                                            newJsFilename
                                        };
                                    }
                                }
                            }
                        }
                        const localizedFiles = chunk
                            .localizedFiles;
                        if (localizedFiles) {
                            const trueHashByLocale = {};
                            hashReplacementsByChunk.set(chunk, {
                                existingHash,
                                trueHashByLocale
                            });
                            for (const [locale, jsAssetName] of Object.entries(localizedFiles)) {
                                const processAssetResult = processChunkAsset(jsAssetName, locale);
                                if (processAssetResult) {
                                    const { trueHash, newJsFilename } = processAssetResult;
                                    trueHashByLocale[locale] = trueHash;
                                    localizedFiles[locale] = newJsFilename;
                                }
                            }
                        }
                        else {
                            const assetNames = Array.from(chunk.files);
                            let jsAssetName;
                            for (const assetName of assetNames) {
                                if (assetName.endsWith('.js')) {
                                    if (jsAssetName) {
                                        compilation.errors.push(new thisWebpack.WebpackError(`Found multiple .js assets for chunk ${chunk.id}.`));
                                    }
                                    else {
                                        jsAssetName = assetName;
                                    }
                                }
                            }
                            if (!jsAssetName) {
                                compilation.errors.push(new thisWebpack.WebpackError(`Could not find a .js asset for chunk ${chunk.id}.`));
                            }
                            else {
                                const { trueHash, newJsFilename } = (_b = processChunkAsset(jsAssetName, undefined)) !== null && _b !== void 0 ? _b : {};
                                hashReplacementsByChunk.set(chunk, { existingHash, trueHashByLocale: trueHash });
                                if (newJsFilename) {
                                    chunk.files.delete(jsAssetName);
                                    chunk.files.add(newJsFilename);
                                }
                            }
                        }
                    }
                    unprocessedChunks.delete(chunk);
                    const dependents = dependentsByChunk.get(chunk);
                    if (dependents) {
                        for (const dependent of dependents) {
                            (_c = unprocessedDependenciesByChunk.get(dependent)) === null || _c === void 0 ? void 0 : _c.delete(chunk);
                        }
                    }
                }
            }
        }
    }
}
//# sourceMappingURL=trueHashes.js.map