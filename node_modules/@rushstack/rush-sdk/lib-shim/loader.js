/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lib-commonjs/helpers.js":
/*!*********************************!*\
  !*** ./lib-commonjs/helpers.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requireRushLibUnderFolderPath = exports._require = exports.tryFindRushJsonLocation = exports.sdkContext = exports.RUSH_LIB_PATH_ENV_VAR_NAME = exports.RUSH_LIB_NAME = void 0;
const path = __importStar(__webpack_require__(/*! path */ "path"));
const node_core_library_1 = __webpack_require__(/*! @rushstack/node-core-library */ "@rushstack/node-core-library");
exports.RUSH_LIB_NAME = '@microsoft/rush-lib';
exports.RUSH_LIB_PATH_ENV_VAR_NAME = '_RUSH_LIB_PATH';
exports.sdkContext = {
    rushLibModule: undefined
};
/**
 * Find the rush.json location and return the path, or undefined if a rush.json can't be found.
 *
 * @privateRemarks
 * Keep this in sync with `RushConfiguration.tryFindRushJsonLocation`.
 */
function tryFindRushJsonLocation(startingFolder) {
    let currentFolder = startingFolder;
    // Look upwards at parent folders until we find a folder containing rush.json
    for (let i = 0; i < 10; ++i) {
        const rushJsonFilename = path.join(currentFolder, 'rush.json');
        if (node_core_library_1.FileSystem.exists(rushJsonFilename)) {
            return rushJsonFilename;
        }
        const parentFolder = path.dirname(currentFolder);
        if (parentFolder === currentFolder) {
            break;
        }
        currentFolder = parentFolder;
    }
    return undefined;
}
exports.tryFindRushJsonLocation = tryFindRushJsonLocation;
function _require(moduleName) {
    if (typeof require === 'function') {
        // If this library has been bundled with Webpack, we need to call the real `require` function
        // that doesn't get turned into a `__webpack_require__` statement.
        // `__non_webpack_require__` is a Webpack macro that gets turned into a `require` statement
        // during bundling.
        return require(moduleName);
    }
    else {
        return require(moduleName);
    }
}
exports._require = _require;
/**
 * Require `@microsoft/rush-lib` under the specified folder path.
 */
function requireRushLibUnderFolderPath(folderPath) {
    const rushLibModulePath = node_core_library_1.Import.resolveModule({
        modulePath: exports.RUSH_LIB_NAME,
        baseFolderPath: folderPath
    });
    return _require(rushLibModulePath);
}
exports.requireRushLibUnderFolderPath = requireRushLibUnderFolderPath;
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ "./lib-commonjs/loader.js":
/*!********************************!*\
  !*** ./lib-commonjs/loader.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RushSdkLoader = void 0;
const path = __importStar(__webpack_require__(/*! path */ "path"));
const node_core_library_1 = __webpack_require__(/*! @rushstack/node-core-library */ "@rushstack/node-core-library");
const helpers_1 = __webpack_require__(/*! ./helpers */ "./lib-commonjs/helpers.js");
/**
 * Exposes operations that control how the `@microsoft/rush-lib` engine is
 * located and loaded.
 * @public
 */
class RushSdkLoader {
    /**
     * Throws an "AbortError" exception if abortSignal.aborted is true.
     */
    static _checkForCancel(abortSignal, onNotifyEvent, progressPercent) {
        if (!(abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted)) {
            return;
        }
        if (onNotifyEvent) {
            onNotifyEvent({
                logMessage: {
                    kind: 'info',
                    text: `The operation was canceled`
                },
                progressPercent
            });
        }
        const error = new Error('The operation was canceled');
        error.name = 'AbortError';
        throw error;
    }
    /**
     * Returns true if the Rush engine has already been loaded.
     */
    static get isLoaded() {
        return helpers_1.sdkContext.rushLibModule !== undefined;
    }
    /**
     * Manually load the Rush engine based on rush.json found for `rushJsonSearchFolder`.
     * Throws an exception if {@link RushSdkLoader.isLoaded} is already `true`.
     *
     * @remarks
     * This API supports an callback that can be used display a progress bar,
     * log of operations, and allow the operation to be canceled prematurely.
     */
    static async loadAsync(options) {
        // SCENARIO 5: The rush-lib engine is loaded manually using rushSdkLoader.loadAsync().
        var _a, _b;
        if (!options) {
            options = {};
        }
        if (RushSdkLoader.isLoaded) {
            throw new Error('RushSdkLoader.loadAsync() failed because the Rush engine has already been loaded');
        }
        const onNotifyEvent = options.onNotifyEvent;
        let progressPercent = undefined;
        const abortSignal = options.abortSignal;
        try {
            const rushJsonSearchFolder = (_a = options.rushJsonSearchFolder) !== null && _a !== void 0 ? _a : process.cwd();
            if (onNotifyEvent) {
                onNotifyEvent({
                    logMessage: {
                        kind: 'debug',
                        text: `Searching for rush.json starting from: ` + rushJsonSearchFolder
                    },
                    progressPercent
                });
            }
            const rushJsonPath = (0, helpers_1.tryFindRushJsonLocation)(rushJsonSearchFolder);
            if (!rushJsonPath) {
                throw new Error('Unable to find rush.json in the specified folder or its parent folders:\n' +
                    `${rushJsonSearchFolder}\n`);
            }
            const monorepoRoot = path.dirname(rushJsonPath);
            const rushJson = await node_core_library_1.JsonFile.loadAsync(rushJsonPath);
            const { rushVersion } = rushJson;
            const installRunNodeModuleFolder = path.join(monorepoRoot, `common/temp/install-run/@microsoft+rush@${rushVersion}`);
            try {
                // First, try to load the version of "rush-lib" that was installed by install-run-rush.js
                if (onNotifyEvent) {
                    onNotifyEvent({
                        logMessage: {
                            kind: 'info',
                            text: `Trying to load  ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush`
                        },
                        progressPercent
                    });
                }
                helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(installRunNodeModuleFolder);
            }
            catch (e1) {
                let installAndRunRushStderrContent = '';
                try {
                    const installAndRunRushJSPath = path.join(monorepoRoot, 'common/scripts/install-run-rush.js');
                    if (onNotifyEvent) {
                        onNotifyEvent({
                            logMessage: {
                                kind: 'info',
                                text: 'The Rush engine has not been installed yet. Invoking install-run-rush.js...'
                            },
                            progressPercent
                        });
                    }
                    // Start the installation
                    progressPercent = 0;
                    const installAndRunRushProcess = node_core_library_1.Executable.spawnSync('node', [installAndRunRushJSPath, '--help'], {
                        stdio: 'pipe'
                    });
                    installAndRunRushStderrContent = installAndRunRushProcess.stderr;
                    if (installAndRunRushProcess.status !== 0) {
                        throw new Error(`The ${helpers_1.RUSH_LIB_NAME} package failed to install`);
                    }
                    if (abortSignal) {
                        RushSdkLoader._checkForCancel(abortSignal, onNotifyEvent, progressPercent);
                    }
                    // TODO: Implement incremental progress updates
                    progressPercent = 90;
                    // Retry to load "rush-lib" after install-run-rush run
                    if (onNotifyEvent) {
                        onNotifyEvent({
                            logMessage: {
                                kind: 'debug',
                                text: `Trying to load  ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush a second time`
                            },
                            progressPercent
                        });
                    }
                    helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(installRunNodeModuleFolder);
                    progressPercent = 100;
                }
                catch (e2) {
                    // eslint-disable-next-line no-console
                    console.error(`${installAndRunRushStderrContent}`);
                    throw new Error(`The ${helpers_1.RUSH_LIB_NAME} package failed to load`);
                }
            }
            if (helpers_1.sdkContext.rushLibModule !== undefined) {
                // to track which scenario is active and how it got initialized.
                global.___rush___rushLibModuleFromInstallAndRunRush = helpers_1.sdkContext.rushLibModule;
                if (onNotifyEvent) {
                    onNotifyEvent({
                        logMessage: {
                            kind: 'debug',
                            text: `Loaded ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush`
                        },
                        progressPercent
                    });
                }
            }
        }
        catch (e) {
            if (onNotifyEvent) {
                onNotifyEvent({
                    logMessage: {
                        kind: 'info',
                        text: 'The operation failed: ' + ((_b = e.message) !== null && _b !== void 0 ? _b : 'An unknown error occurred')
                    },
                    progressPercent
                });
            }
            throw e;
        }
    }
}
exports.RushSdkLoader = RushSdkLoader;
//# sourceMappingURL=loader.js.map

/***/ }),

/***/ "@rushstack/node-core-library":
/*!***********************************************!*\
  !*** external "@rushstack/node-core-library" ***!
  \***********************************************/
/***/ ((module) => {

module.exports = require("@rushstack/node-core-library");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lib-commonjs/loader.js");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=loader.js.map