{"version":3,"file":"index.js","mappings":";;;;;;;;;;AAAY;;AAEZ,QAAQ,iCAAiC,EAAE,mBAAO,CAAC,cAAI;AACvD,QAAQ,WAAW,EAAE,mBAAO,CAAC,cAAI;AACjC,QAAQ,wBAAwB,EAAE,mBAAO,CAAC,kBAAM;AAChD,QAAQ,kBAAkB,EAAE,mBAAO,CAAC,kBAAM;;AAE1C;AACA;AACA;;AAEA;AACA,gCAAgC,aAAa;AAC7C,oCAAoC,YAAY;AAChD;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA,QAAQ,8BAA8B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;;AAEA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA,6EAA6E,SAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7FA,MAAM,sCAA4B;;;;ACAlC,MAAM,mCAA4B;;ACAlC,MAAM,+BAA4B;;;;;;ACAlC;AACA;AACA;AACyB;AACI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8EAA8E;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uBAAa;AACrB,+BAA+B,yBAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,mBAAmB;AAC9G;AACA;AACO;AACP;AACA;AACA,gEAAgE,SAAS;AACzE,iCAAiC,KAAK,KAAK;AAC3C,yCAAyC;AACzC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA,yBAAyB,6BAA6B;AACtD,yBAAyB,6BAA6B;AACtD,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAkE,cAAc;AAClG,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2CAA2C;AACvD,gCAAgC,gBAAgB,IAAI;AACpD,0BAA0B,gBAAgB;AAC1C;AACA,IAAI,0BAAgB;AACpB;AACA;AACO;AACP,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK,4BAA4B;AACjC,4BAA4B,mBAAS;AACrC,4BAA4B,mBAAS;AACrC;AACA,YAAY,uBAAa;AACzB;AACA,iBAAiB,uBAAa;AAC9B,gBAAgB,sBAAY,sBAAsB,iBAAiB;AACnE;AACA,yDAAyD;AACzD;AACA,wBAAwB;AACxB;AACA,iBAAiB,uBAAa;AAC9B;AACA,oCAAoC,gBAAgB,IAAI;AACxD,YAAY,uBAAa;AACzB;AACA;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACO;AACP,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA,8CAA8C,8CAA8C;AAC5F,6CAA6C,YAAY;AACzD;AACA;AACA;;;;AC9JA;AACA;AACyB;AACI;AACqB;AAClD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAA6D;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+BAA+B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM,iCAAiC,KAAK;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAc;AACnC,2EAA2E,kBAAQ;AACnF,2BAA2B,oBAAU;AACrC;AACA;AACA,oDAAoD,kBAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C,oCAAoC,mBAAS;AAC7C;AACA,kDAAkD,mCAAgB;AAClE,+BAA+B,mBAAS;AACxC;AACA,8BAA8B,OAAO,EAAE,kBAAQ,CAAC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA;AACA;AAC+C;AACtB;AACI;AACY;AACN;AACyF;AAC/E;AAC8B;AACpB;AACvD;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAY;AACvC,aAAa,6BAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO,iBAAiB,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6BAAU,qEAAqE,EAAE;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6BAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAAU;AACtB;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAK;AACnB;AACA;AACA;AACA,uCAAuC,6BAAU;AACjD;AACA;AACA,wBAAwB,6BAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8HAA8H;AACrK,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA,gCAAgC,SAAS;AACzC;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,gDAAuB;AAClG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,4CAAmB;AAC7F;AACA,YAAY,uCAAoB,8BAA8B,uCAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+GAA+G;AACjK,oBAAoB,sBAAY;AAChC,sCAAsC,6BAAU;AAChD;AACA;AACA;AACA;AACA,cAAc,6BAAU;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc,2BAAQ,2BAA2B,mBAAS,YAAY,gCAAa;AACnF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAAU;AACtB;AACA,oCAAoC,WAAW;AAC/C;AACA,kCAAkC,gBAAgB;AAClD,YAAY,6BAAU,YAAY,6BAA6B;AAC/D;AACA;AACA,gBAAgB,6BAAU;AAC1B;AACA;AACA,wCAAwC,gBAAgB;AACxD,gBAAgB,6BAAU;AAC1B;AACA;AACA;AACA;AACA,2CAA2C,aAAa,mBAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qCAAqC,sPAAsP;AAClV,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uCAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,wBAAc;AACvH;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAY;AACpC;AACA,sBAAsB,QAAQ,EAAE,wBAAc,CAAC,EAAE,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oIAAoI;AACpL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iCAAiC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAmB;AAChD;AACA,sCAAsC,yCAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qBAAqB,6BAAU;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA,4BAA4B,uBAAuB;AACnD;AACA,kCAAkC,OAAO;AACzC;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA,iEAAiE,OAAO,IAAI,OAAO;AACnF;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;;AC3hBA;AACA;AAC6B;AACsB;AACmB;AACtE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,yCAAyC,wBAAwB;AACjE;AACA;AACA;AACA;AACA,wBAAwB,mBAAS,CAAC,SAAS;AAC3C;AACA;AACA;AACA;AACA,gCAAgC,mBAAS,oBAAoB,sBAAsB;AACnF;AACA;AACA;;;;;;;;;;AC3Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qCAAqC,GAAG,gBAAgB,GAAG,+BAA+B,GAAG,kBAAkB,GAAG,kCAAkC,GAAG,qBAAqB;AAC5K,0BAA0B,mBAAO,CAAC,kBAAM;AACxC,4BAA4B,mBAAO,CAAC,kEAA8B;AAClE,qBAAqB;AACrB,kCAAkC;AAClC,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,eAAe,OAAuB;AACtC;AACA;AACA;AACA;AACA,eAAe,OAAuB;AACtC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qCAAqC;AACrC;;;;;;;;;;;AClFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mCAAmC;AACnC,0BAA0B,mBAAO,CAAC,kBAAM;AACxC,4BAA4B,mBAAO,CAAC,kEAA8B;AAClE,mBAAmB,mBAAO,CAAC,gDAAqB;AAChD,2BAA2B,mBAAO,CAAC,2GAAqD;AACxF,kBAAkB,mBAAO,CAAC,4CAAW;AACrC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA,gEAAgE,yBAAyB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,yBAAyB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yBAAyB,mBAAmB,sCAAsC;AACnI;AACA;AACA;AACA;AACA;AACA,wDAAwD,yBAAyB,kBAAkB,qCAAqC;AACxI;AACA;AACA;AACA;AACA,gDAAgD,yBAAyB,mBAAmB,qCAAqC;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA,qDAAqD,yBAAyB;AAC9E;AACA;AACA,yDAAyD,kCAAkC,QAAQ,YAAY;AAC/G,uFAAuF,kCAAkC;AACzH;AACA;AACA;AACA,wDAAwD,yBAAyB,2BAA2B,UAAU;AACtH;AACA;AACA;AACA;AACA,gDAAgD,yBAAyB;AACzE;AACA;AACA,kDAAkD,aAAa,2CAA2C,YAAY;AACtH;AACA;AACA,6DAA6D,yBAAyB;AACtF;AACA;AACA;AACA;AACA;AACA,uDAAuD,aAAa;AACpE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C,yBAAyB;AACxE;AACA;AACA,iEAAiE,yBAAyB;AAC1F;AACA;AACA;AACA;AACA,qCAAqC,+BAA+B;AACpE,2CAA2C,yBAAyB;AACpE;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA,mCAAmC;AACnC;;;;;;;;;;AC9MA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;;;;;UEJA;UACA;UACA;UACA","sources":["webpack://@rushstack/rush-sdk/../../common/temp/default/node_modules/.pnpm/true-case-path@2.2.1/node_modules/true-case-path/index.js","webpack://@rushstack/rush-sdk/external node-commonjs \"child_process\"","webpack://@rushstack/rush-sdk/external node-commonjs \"perf_hooks\"","webpack://@rushstack/rush-sdk/external node-commonjs \"stream\"","webpack://@rushstack/rush-sdk/../rush-lib/lib-esnext/utilities/npmrcUtilities.js","webpack://@rushstack/rush-sdk/../rush-lib/lib-esnext/api/EnvironmentConfiguration.js","webpack://@rushstack/rush-sdk/../rush-lib/lib-esnext/logic/RushConstants.js","webpack://@rushstack/rush-sdk/../rush-lib/lib-esnext/utilities/Utilities.js","webpack://@rushstack/rush-sdk/../rush-lib/lib-esnext/api/RushGlobalFolder.js","webpack://@rushstack/rush-sdk/./lib-commonjs/helpers.js","webpack://@rushstack/rush-sdk/./lib-commonjs/index.js","webpack://@rushstack/rush-sdk/external commonjs \"@rushstack/node-core-library\"","webpack://@rushstack/rush-sdk/external commonjs \"@rushstack/terminal\"","webpack://@rushstack/rush-sdk/external node-commonjs \"fs\"","webpack://@rushstack/rush-sdk/external node-commonjs \"os\"","webpack://@rushstack/rush-sdk/external node-commonjs \"path\"","webpack://@rushstack/rush-sdk/external node-commonjs \"util\"","webpack://@rushstack/rush-sdk/webpack/bootstrap","webpack://@rushstack/rush-sdk/webpack/runtime/define property getters","webpack://@rushstack/rush-sdk/webpack/runtime/hasOwnProperty shorthand","webpack://@rushstack/rush-sdk/webpack/runtime/make namespace object","webpack://@rushstack/rush-sdk/webpack/runtime/node module decorator","webpack://@rushstack/rush-sdk/webpack/before-startup","webpack://@rushstack/rush-sdk/webpack/startup","webpack://@rushstack/rush-sdk/webpack/after-startup"],"sourcesContent":["'use strict'\n\nconst { readdir: _readdir, readdirSync } = require('fs')\nconst { platform } = require('os')\nconst { isAbsolute, normalize } = require('path')\nconst { promisify: pify } = require('util')\n\nconst readdir = pify(_readdir)\nconst isWindows = platform() === 'win32'\nconst delimiter = isWindows ? '\\\\' : '/'\n\nmodule.exports = {\n  trueCasePath: _trueCasePath({ sync: false }),\n  trueCasePathSync: _trueCasePath({ sync: true })\n}\n\nfunction getRelevantFilePathSegments(filePath) {\n  return filePath.split(delimiter).filter((s) => s !== '')\n}\n\nfunction escapeString(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction matchCaseInsensitive(fileOrDirectory, directoryContents, filePath) {\n  const caseInsensitiveRegex = new RegExp(\n    `^${escapeString(fileOrDirectory)}$`,\n    'i'\n  )\n  for (const file of directoryContents) {\n    if (caseInsensitiveRegex.test(file)) return file\n  }\n  throw new Error(\n    `[true-case-path]: Called with ${filePath}, but no matching file exists`\n  )\n}\n\nfunction _trueCasePath({ sync }) {\n  return (filePath, basePath) => {\n    if (basePath) {\n      if (!isAbsolute(basePath)) {\n        throw new Error(\n          `[true-case-path]: basePath argument must be absolute. Received \"${basePath}\"`\n        )\n      }\n      basePath = normalize(basePath)\n    }\n    filePath = normalize(filePath)\n    const segments = getRelevantFilePathSegments(filePath)\n    if (isAbsolute(filePath)) {\n      if (basePath) {\n        throw new Error(\n          '[true-case-path]: filePath must be relative when used with basePath'\n        )\n      }\n      basePath = isWindows\n        ? segments.shift().toUpperCase() // drive letter\n        : ''\n    } else if (!basePath) {\n      basePath = process.cwd()\n    }\n    return sync\n      ? iterateSync(basePath, filePath, segments)\n      : iterateAsync(basePath, filePath, segments)\n  }\n}\n\nfunction iterateSync(basePath, filePath, segments) {\n  return segments.reduce(\n    (realPath, fileOrDirectory) =>\n      realPath +\n      delimiter +\n      matchCaseInsensitive(\n        fileOrDirectory,\n        readdirSync(realPath + delimiter),\n        filePath\n      ),\n    basePath\n  )\n}\n\nasync function iterateAsync(basePath, filePath, segments) {\n  return await segments.reduce(\n    async (realPathPromise, fileOrDirectory) =>\n      (await realPathPromise) +\n      delimiter +\n      matchCaseInsensitive(\n        fileOrDirectory,\n        await readdir((await realPathPromise) + delimiter),\n        filePath\n      ),\n    basePath\n  )\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"child_process\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"perf_hooks\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"stream\");","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n// IMPORTANT - do not use any non-built-in libraries in this file\nimport * as fs from 'fs';\nimport * as path from 'path';\n/**\n * This function reads the content for given .npmrc file path, and also trims\n * unusable lines from the .npmrc file.\n *\n * @returns\n * The text of the the .npmrc.\n */\n// create a global _combinedNpmrc for cache purpose\nconst _combinedNpmrcMap = new Map();\nfunction _trimNpmrcFile(options) {\n    const { sourceNpmrcPath, linesToPrepend, linesToAppend, supportEnvVarFallbackSyntax } = options;\n    const combinedNpmrcFromCache = _combinedNpmrcMap.get(sourceNpmrcPath);\n    if (combinedNpmrcFromCache !== undefined) {\n        return combinedNpmrcFromCache;\n    }\n    let npmrcFileLines = [];\n    if (linesToPrepend) {\n        npmrcFileLines.push(...linesToPrepend);\n    }\n    if (fs.existsSync(sourceNpmrcPath)) {\n        npmrcFileLines.push(...fs.readFileSync(sourceNpmrcPath).toString().split('\\n'));\n    }\n    if (linesToAppend) {\n        npmrcFileLines.push(...linesToAppend);\n    }\n    npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());\n    const resultLines = trimNpmrcFileLines(npmrcFileLines, process.env, supportEnvVarFallbackSyntax);\n    const combinedNpmrc = resultLines.join('\\n');\n    //save the cache\n    _combinedNpmrcMap.set(sourceNpmrcPath, combinedNpmrc);\n    return combinedNpmrc;\n}\n/**\n *\n * @param npmrcFileLines The npmrc file's lines\n * @param env The environment variables object\n * @param supportEnvVarFallbackSyntax Whether to support fallback values in the form of `${VAR_NAME:-fallback}`\n * @returns\n */\nexport function trimNpmrcFileLines(npmrcFileLines, env, supportEnvVarFallbackSyntax) {\n    var _a;\n    const resultLines = [];\n    // This finds environment variable tokens that look like \"${VAR_NAME}\"\n    const expansionRegExp = /\\$\\{([^\\}]+)\\}/g;\n    // Comment lines start with \"#\" or \";\"\n    const commentRegExp = /^\\s*[#;]/;\n    // Trim out lines that reference environment variables that aren't defined\n    for (let line of npmrcFileLines) {\n        let lineShouldBeTrimmed = false;\n        //remove spaces before or after key and value\n        line = line\n            .split('=')\n            .map((lineToTrim) => lineToTrim.trim())\n            .join('=');\n        // Ignore comment lines\n        if (!commentRegExp.test(line)) {\n            const environmentVariables = line.match(expansionRegExp);\n            if (environmentVariables) {\n                for (const token of environmentVariables) {\n                    /**\n                     * Remove the leading \"${\" and the trailing \"}\" from the token\n                     *\n                     * ${nameString}                  -> nameString\n                     * ${nameString-fallbackString}   -> name-fallbackString\n                     * ${nameString:-fallbackString}  -> name:-fallbackString\n                     */\n                    const nameWithFallback = token.substring(2, token.length - 1);\n                    let environmentVariableName;\n                    let fallback;\n                    if (supportEnvVarFallbackSyntax) {\n                        /**\n                         * Get the environment variable name and fallback value.\n                         *\n                         *                                name          fallback\n                         * nameString                 ->  nameString    undefined\n                         * nameString-fallbackString  ->  nameString    fallbackString\n                         * nameString:-fallbackString ->  nameString    fallbackString\n                         */\n                        const matched = nameWithFallback.match(/^([^:-]+)(?:\\:?-(.+))?$/);\n                        // matched: [originStr, variableName, fallback]\n                        environmentVariableName = (_a = matched === null || matched === void 0 ? void 0 : matched[1]) !== null && _a !== void 0 ? _a : nameWithFallback;\n                        fallback = matched === null || matched === void 0 ? void 0 : matched[2];\n                    }\n                    else {\n                        environmentVariableName = nameWithFallback;\n                    }\n                    // Is the environment variable and fallback value defined.\n                    if (!env[environmentVariableName] && !fallback) {\n                        // No, so trim this line\n                        lineShouldBeTrimmed = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (lineShouldBeTrimmed) {\n            // Example output:\n            // \"; MISSING ENVIRONMENT VARIABLE: //my-registry.com/npm/:_authToken=${MY_AUTH_TOKEN}\"\n            resultLines.push('; MISSING ENVIRONMENT VARIABLE: ' + line);\n        }\n        else {\n            resultLines.push(line);\n        }\n    }\n    return resultLines;\n}\nfunction _copyAndTrimNpmrcFile(options) {\n    const { logger, sourceNpmrcPath, targetNpmrcPath } = options;\n    logger.info(`Transforming ${sourceNpmrcPath}`); // Verbose\n    logger.info(`  --> \"${targetNpmrcPath}\"`);\n    const combinedNpmrc = _trimNpmrcFile(options);\n    fs.writeFileSync(targetNpmrcPath, combinedNpmrc);\n    return combinedNpmrc;\n}\nexport function syncNpmrc(options) {\n    const { sourceNpmrcFolder, targetNpmrcFolder, useNpmrcPublish, logger = {\n        // eslint-disable-next-line no-console\n        info: console.log,\n        // eslint-disable-next-line no-console\n        error: console.error\n    }, createIfMissing = false } = options;\n    const sourceNpmrcPath = path.join(sourceNpmrcFolder, !useNpmrcPublish ? '.npmrc' : '.npmrc-publish');\n    const targetNpmrcPath = path.join(targetNpmrcFolder, '.npmrc');\n    try {\n        if (fs.existsSync(sourceNpmrcPath) || createIfMissing) {\n            // Ensure the target folder exists\n            if (!fs.existsSync(targetNpmrcFolder)) {\n                fs.mkdirSync(targetNpmrcFolder, { recursive: true });\n            }\n            return _copyAndTrimNpmrcFile(Object.assign({ sourceNpmrcPath,\n                targetNpmrcPath,\n                logger }, options));\n        }\n        else if (fs.existsSync(targetNpmrcPath)) {\n            // If the source .npmrc doesn't exist and there is one in the target, delete the one in the target\n            logger.info(`Deleting ${targetNpmrcPath}`); // Verbose\n            fs.unlinkSync(targetNpmrcPath);\n        }\n    }\n    catch (e) {\n        throw new Error(`Error syncing .npmrc file: ${e}`);\n    }\n}\nexport function isVariableSetInNpmrcFile(sourceNpmrcFolder, variableKey, supportEnvVarFallbackSyntax) {\n    const sourceNpmrcPath = `${sourceNpmrcFolder}/.npmrc`;\n    //if .npmrc file does not exist, return false directly\n    if (!fs.existsSync(sourceNpmrcPath)) {\n        return false;\n    }\n    const trimmedNpmrcFile = _trimNpmrcFile({ sourceNpmrcPath, supportEnvVarFallbackSyntax });\n    const variableKeyRegExp = new RegExp(`^${variableKey}=`, 'm');\n    return trimmedNpmrcFile.match(variableKeyRegExp) !== null;\n}\n//# sourceMappingURL=npmrcUtilities.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as os from 'os';\nimport * as path from 'path';\nimport { trueCasePathSync } from 'true-case-path';\n/**\n * Names of environment variables used by Rush.\n * @beta\n */\n// eslint-disable-next-line @typescript-eslint/typedef\nexport const EnvironmentVariableNames = {\n    /**\n     * This variable overrides the temporary folder used by Rush.\n     * The default value is \"common/temp\" under the repository root.\n     *\n     * @remarks This environment variable is not compatible with workspace installs. If attempting\n     * to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.\n     */\n    RUSH_TEMP_FOLDER: 'RUSH_TEMP_FOLDER',\n    /**\n     * This variable overrides the version of Rush that will be installed by\n     * the version selector.  The default value is determined by the \"rushVersion\"\n     * field from rush.json.\n     */\n    RUSH_PREVIEW_VERSION: 'RUSH_PREVIEW_VERSION',\n    /**\n     * If this variable is set to \"1\", Rush will not fail the build when running a version\n     * of Node that does not match the criteria specified in the \"nodeSupportedVersionRange\"\n     * field from rush.json.\n     */\n    RUSH_ALLOW_UNSUPPORTED_NODEJS: 'RUSH_ALLOW_UNSUPPORTED_NODEJS',\n    /**\n     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`\n     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,\n     * or `0` to disallow them. (See the comments in the command-line.json file for more information).\n     */\n    RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: 'RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD',\n    /**\n     * This variable selects a specific installation variant for Rush to use when installing\n     * and linking package dependencies.\n     * For more information, see the command-line help for the `--variant` parameter\n     * and this article:  https://rushjs.io/pages/advanced/installation_variants/\n     */\n    RUSH_VARIANT: 'RUSH_VARIANT',\n    /**\n     * Specifies the maximum number of concurrent processes to launch during a build.\n     * For more information, see the command-line help for the `--parallelism` parameter for \"rush build\".\n     */\n    RUSH_PARALLELISM: 'RUSH_PARALLELISM',\n    /**\n     * If this variable is set to \"1\", Rush will create symlinks with absolute paths instead\n     * of relative paths. This can be necessary when a repository is moved during a build or\n     * if parts of a repository are moved into a sandbox.\n     */\n    RUSH_ABSOLUTE_SYMLINKS: 'RUSH_ABSOLUTE_SYMLINKS',\n    /**\n     * When using PNPM as the package manager, this variable can be used to configure the path that\n     * PNPM will use as the store directory.\n     *\n     * If a relative path is used, then the store path will be resolved relative to the process's\n     * current working directory.  An absolute path is recommended.\n     */\n    RUSH_PNPM_STORE_PATH: 'RUSH_PNPM_STORE_PATH',\n    /**\n     * When using PNPM as the package manager, this variable can be used to control whether or not PNPM\n     * validates the integrity of the PNPM store during installation. The value of this environment variable must be\n     * `1` (for true) or `0` (for false). If not specified, defaults to the value in .npmrc.\n     */\n    RUSH_PNPM_VERIFY_STORE_INTEGRITY: 'RUSH_PNPM_VERIFY_STORE_INTEGRITY',\n    /**\n     * This environment variable can be used to specify the `--target-folder` parameter\n     * for the \"rush deploy\" command.\n     */\n    RUSH_DEPLOY_TARGET_FOLDER: 'RUSH_DEPLOY_TARGET_FOLDER',\n    /**\n     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.\n     *\n     * @remarks\n     *\n     * Most of the temporary files created by Rush are stored separately for each monorepo working folder,\n     * to avoid issues of concurrency and compatibility between tool versions.  However, a small set\n     * of files (e.g. installations of the `@microsoft/rush-lib` engine and the package manager) are stored\n     * in a global folder to speed up installations.  The default location is `~/.rush` on POSIX-like\n     * operating systems or `C:\\Users\\YourName` on Windows.\n     *\n     * Use `RUSH_GLOBAL_FOLDER` to specify a different folder path.  This is useful for example if a Windows\n     * group policy forbids executing scripts installed in a user's home directory.\n     *\n     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\n     */\n    RUSH_GLOBAL_FOLDER: 'RUSH_GLOBAL_FOLDER',\n    /**\n     * Provides a credential for a remote build cache, if configured.  This credential overrides any cached credentials.\n     *\n     * @remarks\n     * Setting this environment variable overrides whatever credential has been saved in the\n     * local cloud cache credentials using `rush update-cloud-credentials`.\n     *\n     *\n     * If Azure Blob Storage is used to store cache entries, this must be a SAS token serialized as query\n     * parameters.\n     *\n     * For information on SAS tokens, see here: https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview\n     */\n    RUSH_BUILD_CACHE_CREDENTIAL: 'RUSH_BUILD_CACHE_CREDENTIAL',\n    /**\n     * Setting this environment variable overrides the value of `buildCacheEnabled` in the `build-cache.json`\n     * configuration file.\n     *\n     * @remarks\n     * Specify `1` to enable the build cache or `0` to disable it.\n     *\n     * If there is no build cache configured, then this environment variable is ignored.\n     */\n    RUSH_BUILD_CACHE_ENABLED: 'RUSH_BUILD_CACHE_ENABLED',\n    /**\n     * Overrides the value of `isCacheWriteAllowed` in the `build-cache.json` configuration file. The value of this\n     * environment variable must be `1` (for true) or `0` (for false). If there is no build cache configured, then\n     * this environment variable is ignored.\n     */\n    RUSH_BUILD_CACHE_WRITE_ALLOWED: 'RUSH_BUILD_CACHE_WRITE_ALLOWED',\n    /**\n     * Setting this environment variable opts into running with cobuilds. The context id should be the same across\n     * multiple VMs, but changed when it is a new round of cobuilds.\n     *\n     * e.g. `Build.BuildNumber` in Azure DevOps Pipeline.\n     *\n     * @remarks\n     * If there is no cobuild configured, then this environment variable is ignored.\n     */\n    RUSH_COBUILD_CONTEXT_ID: 'RUSH_COBUILD_CONTEXT_ID',\n    /**\n     * Explicitly specifies a name for each participating cobuild runner.\n     *\n     * Setting this environment variable opts into running with cobuilds.\n     *\n     * @remarks\n     * This environment variable is optional, if it is not provided, a random id is used.\n     *\n     * If there is no cobuild configured, then this environment variable is ignored.\n     */\n    RUSH_COBUILD_RUNNER_ID: 'RUSH_COBUILD_RUNNER_ID',\n    /**\n     * If this variable is set to \"1\", When getting distributed builds, Rush will automatically handle the leaf project\n     * with build cache \"disabled\" by writing to the cache in a special \"log files only mode\". This is useful when you\n     * want to use Cobuilds to improve the performance in CI validations and the leaf projects have not enabled cache.\n     */\n    RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: 'RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED',\n    /**\n     * Explicitly specifies the path for the Git binary that is invoked by certain Rush operations.\n     */\n    RUSH_GIT_BINARY_PATH: 'RUSH_GIT_BINARY_PATH',\n    /**\n     * Explicitly specifies the path for the `tar` binary that is invoked by certain Rush operations.\n     */\n    RUSH_TAR_BINARY_PATH: 'RUSH_TAR_BINARY_PATH',\n    /**\n     * Internal variable used by `rushx` when recursively invoking another `rushx` process, to avoid\n     * nesting event hooks.\n     */\n    _RUSH_RECURSIVE_RUSHX_CALL: '_RUSH_RECURSIVE_RUSHX_CALL',\n    /**\n     * Internal variable that explicitly specifies the path for the version of `@microsoft/rush-lib` being executed.\n     * Will be set upon loading Rush.\n     */\n    _RUSH_LIB_PATH: '_RUSH_LIB_PATH',\n    /**\n     * When Rush executes shell scripts, it sometimes changes the working directory to be a project folder or\n     * the repository root folder.  The original working directory (where the Rush command was invoked) is assigned\n     * to the the child process's `RUSH_INVOKED_FOLDER` environment variable, in case it is needed by the script.\n     *\n     * @remarks\n     * The `RUSH_INVOKED_FOLDER` variable is the same idea as the `INIT_CWD` variable that package managers\n     * assign when they execute lifecycle scripts.\n     */\n    RUSH_INVOKED_FOLDER: 'RUSH_INVOKED_FOLDER',\n    /**\n     * When running a hook script, this environment variable communicates the original arguments\n     * passed to the `rush` or `rushx` command.\n     *\n     * @remarks\n     * Unlike `RUSH_INVOKED_FOLDER`, the `RUSH_INVOKED_ARGS` variable is only available for hook scripts.\n     * Other lifecycle scripts should not make assumptions about Rush's command line syntax\n     * if Rush did not explicitly pass along command-line parameters to their process.\n     */\n    RUSH_INVOKED_ARGS: 'RUSH_INVOKED_ARGS'\n};\n/**\n * Provides Rush-specific environment variable data. All Rush environment variables must start with \"RUSH_\". This class\n * is designed to be used by RushConfiguration.\n * @beta\n *\n * @remarks\n * Initialize will throw if any unknown parameters are present.\n */\nexport class EnvironmentConfiguration {\n    /**\n     * An override for the common/temp folder path.\n     */\n    static get rushTempFolderOverride() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._rushTempFolderOverride;\n    }\n    /**\n     * If \"1\", create symlinks with absolute paths instead of relative paths.\n     * See {@link EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS}\n     */\n    static get absoluteSymlinks() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._absoluteSymlinks;\n    }\n    /**\n     * If this environment variable is set to \"1\", the Node.js version check will print a warning\n     * instead of causing a hard error if the environment's Node.js version doesn't match the\n     * version specifier in `rush.json`'s \"nodeSupportedVersionRange\" property.\n     *\n     * See {@link EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS}.\n     */\n    static get allowUnsupportedNodeVersion() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._allowUnsupportedNodeVersion;\n    }\n    /**\n     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`\n     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,\n     * or `0` to disallow them. (See the comments in the command-line.json file for more information).\n     */\n    static get allowWarningsInSuccessfulBuild() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._allowWarningsInSuccessfulBuild;\n    }\n    /**\n     * An override for the PNPM store path, if `pnpmStore` configuration is set to 'path'\n     * See {@link EnvironmentVariableNames.RUSH_PNPM_STORE_PATH}\n     */\n    static get pnpmStorePathOverride() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._pnpmStorePathOverride;\n    }\n    /**\n     * If specified, enables or disables integrity verification of the pnpm store during install.\n     * See {@link EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY}\n     */\n    static get pnpmVerifyStoreIntegrity() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._pnpmVerifyStoreIntegrity;\n    }\n    /**\n     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.\n     * See {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER}\n     */\n    static get rushGlobalFolderOverride() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._rushGlobalFolderOverride;\n    }\n    /**\n     * Provides a credential for reading from and writing to a remote build cache, if configured.\n     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL}\n     */\n    static get buildCacheCredential() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._buildCacheCredential;\n    }\n    /**\n     * If set, enables or disables the cloud build cache feature.\n     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED}\n     */\n    static get buildCacheEnabled() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._buildCacheEnabled;\n    }\n    /**\n     * If set, enables or disables writing to the cloud build cache.\n     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED}\n     */\n    static get buildCacheWriteAllowed() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._buildCacheWriteAllowed;\n    }\n    /**\n     * Provides a determined cobuild context id if configured\n     * See {@link EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID}\n     */\n    static get cobuildContextId() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._cobuildContextId;\n    }\n    /**\n     * Provides a determined cobuild runner id if configured\n     * See {@link EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID}\n     */\n    static get cobuildRunnerId() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._cobuildRunnerId;\n    }\n    /**\n     * If set, enables or disables the cobuild leaf project log only feature.\n     * See {@link EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED}\n     */\n    static get cobuildLeafProjectLogOnlyAllowed() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._cobuildLeafProjectLogOnlyAllowed;\n    }\n    /**\n     * Allows the git binary path to be explicitly provided.\n     * See {@link EnvironmentVariableNames.RUSH_GIT_BINARY_PATH}\n     */\n    static get gitBinaryPath() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._gitBinaryPath;\n    }\n    /**\n     * Allows the tar binary path to be explicitly provided.\n     * See {@link EnvironmentVariableNames.RUSH_TAR_BINARY_PATH}\n     */\n    static get tarBinaryPath() {\n        EnvironmentConfiguration._ensureValidated();\n        return EnvironmentConfiguration._tarBinaryPath;\n    }\n    /**\n     * The front-end RushVersionSelector relies on `RUSH_GLOBAL_FOLDER`, so its value must be read before\n     * `EnvironmentConfiguration` is initialized (and actually before the correct version of `EnvironmentConfiguration`\n     * is even installed). Thus we need to read this environment variable differently from all the others.\n     * @internal\n     */\n    static _getRushGlobalFolderOverride(processEnv) {\n        const value = processEnv[EnvironmentVariableNames.RUSH_GLOBAL_FOLDER];\n        if (value) {\n            const normalizedValue = EnvironmentConfiguration._normalizeDeepestParentFolderPath(value);\n            return normalizedValue;\n        }\n    }\n    /**\n     * Reads and validates environment variables. If any are invalid, this function will throw.\n     */\n    static validate(options = {}) {\n        var _a, _b, _c;\n        EnvironmentConfiguration.reset();\n        const unknownEnvVariables = [];\n        for (const envVarName in process.env) {\n            if (process.env.hasOwnProperty(envVarName) && envVarName.match(/^RUSH_/i)) {\n                const value = process.env[envVarName];\n                // Environment variables are only case-insensitive on Windows\n                const normalizedEnvVarName = os.platform() === 'win32' ? envVarName.toUpperCase() : envVarName;\n                switch (normalizedEnvVarName) {\n                    case EnvironmentVariableNames.RUSH_TEMP_FOLDER: {\n                        EnvironmentConfiguration._rushTempFolderOverride =\n                            value && !options.doNotNormalizePaths\n                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value\n                                : value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS: {\n                        EnvironmentConfiguration._absoluteSymlinks =\n                            (_a = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS, value)) !== null && _a !== void 0 ? _a : false;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS: {\n                        if (value === 'true' || value === 'false') {\n                            // Small, undocumented acceptance of old \"true\" and \"false\" values for\n                            // users of RUSH_ALLOW_UNSUPPORTED_NODEJS in rush pre-v5.46.\n                            EnvironmentConfiguration._allowUnsupportedNodeVersion = value === 'true';\n                        }\n                        else {\n                            EnvironmentConfiguration._allowUnsupportedNodeVersion =\n                                (_b = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS, value)) !== null && _b !== void 0 ? _b : false;\n                        }\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: {\n                        EnvironmentConfiguration._allowWarningsInSuccessfulBuild =\n                            (_c = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD, value)) !== null && _c !== void 0 ? _c : false;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_PNPM_STORE_PATH: {\n                        EnvironmentConfiguration._pnpmStorePathOverride =\n                            value && !options.doNotNormalizePaths\n                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value\n                                : value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY: {\n                        EnvironmentConfiguration._pnpmVerifyStoreIntegrity =\n                            value === '1' ? true : value === '0' ? false : undefined;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_GLOBAL_FOLDER: {\n                        // Handled specially below\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL: {\n                        EnvironmentConfiguration._buildCacheCredential = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED: {\n                        EnvironmentConfiguration._buildCacheEnabled =\n                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED, value);\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED: {\n                        EnvironmentConfiguration._buildCacheWriteAllowed =\n                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED, value);\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID: {\n                        EnvironmentConfiguration._cobuildContextId = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID: {\n                        EnvironmentConfiguration._cobuildRunnerId = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: {\n                        EnvironmentConfiguration._cobuildLeafProjectLogOnlyAllowed =\n                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED, value);\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_GIT_BINARY_PATH: {\n                        EnvironmentConfiguration._gitBinaryPath = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_TAR_BINARY_PATH: {\n                        EnvironmentConfiguration._tarBinaryPath = value;\n                        break;\n                    }\n                    case EnvironmentVariableNames.RUSH_PARALLELISM:\n                    case EnvironmentVariableNames.RUSH_PREVIEW_VERSION:\n                    case EnvironmentVariableNames.RUSH_VARIANT:\n                    case EnvironmentVariableNames.RUSH_DEPLOY_TARGET_FOLDER:\n                        // Handled by @microsoft/rush front end\n                        break;\n                    case EnvironmentVariableNames.RUSH_INVOKED_FOLDER:\n                    case EnvironmentVariableNames.RUSH_INVOKED_ARGS:\n                    case EnvironmentVariableNames._RUSH_LIB_PATH:\n                        // Assigned by Rush itself\n                        break;\n                    case EnvironmentVariableNames._RUSH_RECURSIVE_RUSHX_CALL:\n                        // Assigned/read internally by RushXCommandLine\n                        break;\n                    default:\n                        unknownEnvVariables.push(envVarName);\n                        break;\n                }\n            }\n        }\n        // This strictness intends to catch mistakes where variables are misspelled or not used correctly.\n        if (unknownEnvVariables.length > 0) {\n            throw new Error('The following environment variables were found with the \"RUSH_\" prefix, but they are not ' +\n                `recognized by this version of Rush: ${unknownEnvVariables.join(', ')}`);\n        }\n        // See doc comment for EnvironmentConfiguration._getRushGlobalFolderOverride().\n        EnvironmentConfiguration._rushGlobalFolderOverride =\n            EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);\n        EnvironmentConfiguration._hasBeenValidated = true;\n    }\n    /**\n     * Resets EnvironmentConfiguration into an un-initialized state.\n     */\n    static reset() {\n        EnvironmentConfiguration._rushTempFolderOverride = undefined;\n        EnvironmentConfiguration._hasBeenValidated = false;\n    }\n    static _ensureValidated() {\n        if (!EnvironmentConfiguration._hasBeenValidated) {\n            EnvironmentConfiguration.validate();\n        }\n    }\n    static parseBooleanEnvironmentVariable(name, value) {\n        if (value === '' || value === undefined) {\n            return undefined;\n        }\n        else if (value === '0') {\n            return false;\n        }\n        else if (value === '1') {\n            return true;\n        }\n        else {\n            throw new Error(`Invalid value \"${value}\" for the environment variable ${name}. Valid choices are 0 or 1.`);\n        }\n    }\n    /**\n     * Given a path to a folder (that may or may not exist), normalize the path, including casing,\n     * to the first existing parent folder in the path.\n     *\n     * If no existing path can be found (for example, if the root is a volume that doesn't exist),\n     * this function returns undefined.\n     *\n     * @example\n     * If the following path exists on disk: `C:\\Folder1\\folder2\\`\n     * _normalizeFirstExistingFolderPath('c:\\\\folder1\\\\folder2\\\\temp\\\\subfolder')\n     * returns 'C:\\\\Folder1\\\\folder2\\\\temp\\\\subfolder'\n     */\n    static _normalizeDeepestParentFolderPath(folderPath) {\n        folderPath = path.normalize(folderPath);\n        const endsWithSlash = folderPath.charAt(folderPath.length - 1) === path.sep;\n        const parsedPath = path.parse(folderPath);\n        const pathRoot = parsedPath.root;\n        const pathWithoutRoot = parsedPath.dir.substr(pathRoot.length);\n        const pathParts = [...pathWithoutRoot.split(path.sep), parsedPath.name].filter((part) => !!part);\n        // Starting with all path sections, and eliminating one from the end during each loop iteration,\n        // run trueCasePathSync. If trueCasePathSync returns without exception, we've found a subset\n        // of the path that exists and we've now gotten the correct casing.\n        //\n        // Once we've found a parent folder that exists, append the path sections that didn't exist.\n        for (let i = pathParts.length; i >= 0; i--) {\n            const constructedPath = path.join(pathRoot, ...pathParts.slice(0, i));\n            try {\n                const normalizedConstructedPath = trueCasePathSync(constructedPath);\n                const result = path.join(normalizedConstructedPath, ...pathParts.slice(i));\n                if (endsWithSlash) {\n                    return `${result}${path.sep}`;\n                }\n                else {\n                    return result;\n                }\n            }\n            catch (e) {\n                // This path doesn't exist, continue to the next subpath\n            }\n        }\n        return undefined;\n    }\n}\nEnvironmentConfiguration._hasBeenValidated = false;\nEnvironmentConfiguration._absoluteSymlinks = false;\nEnvironmentConfiguration._allowUnsupportedNodeVersion = false;\nEnvironmentConfiguration._allowWarningsInSuccessfulBuild = false;\n//# sourceMappingURL=EnvironmentConfiguration.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n/**\n * Constants used by the Rush tool.\n * @beta\n *\n * @remarks\n *\n * These are NOT part of the public API surface for rush-lib.\n * The rationale is that we don't want people implementing custom parsers for\n * the Rush config files; instead, they should rely on the official APIs from rush-lib.\n */\nexport class RushConstants {\n}\n/**\n * The filename (\"rush.json\") for the root-level configuration file.\n */\nRushConstants.rushJsonFilename = 'rush.json';\n/**\n * The filename (\"browser-approved-packages.json\") for an optional policy configuration file\n * that stores a list of NPM packages that have been approved for usage by Rush projects.\n * This is part of a pair of config files, one for projects that run in a web browser\n * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else\n * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).\n */\nRushConstants.browserApprovedPackagesFilename = 'browser-approved-packages.json';\n/**\n * The folder name (\"changes\") where change files will be stored.\n */\nRushConstants.changeFilesFolderName = 'changes';\n/**\n * The filename (\"nonbrowser-approved-packages.json\") for an optional policy configuration file\n * that stores a list of NPM packages that have been approved for usage by Rush projects.\n * This is part of a pair of config files, one for projects that run in a web browser\n * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else\n * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).\n */\nRushConstants.nonbrowserApprovedPackagesFilename = 'nonbrowser-approved-packages.json';\n/**\n * The folder name (\"common\") where Rush's common data will be stored.\n */\nRushConstants.commonFolderName = 'common';\n/**\n * The NPM scope (\"\\@rush-temp\") that is used for Rush's temporary projects.\n */\nRushConstants.rushTempNpmScope = '@rush-temp';\n/**\n * The folder name (\"variants\") under which named variant configurations for\n * alternate dependency sets may be found.\n * Example: `C:\\MyRepo\\common\\config\\rush\\variants`\n */\nRushConstants.rushVariantsFolderName = 'variants';\n/**\n * The folder name (\"temp\") under the common folder, or under the .rush folder in each project's directory where\n * temporary files will be stored.\n * Example: `C:\\MyRepo\\common\\temp`\n */\nRushConstants.rushTempFolderName = 'temp';\n/**\n * The folder name (\"projects\") where temporary projects will be stored.\n * Example: `C:\\MyRepo\\common\\temp\\projects`\n */\nRushConstants.rushTempProjectsFolderName = 'projects';\n/**\n * The filename (\"npm-shrinkwrap.json\") used to store an installation plan for the NPM package manger.\n */\nRushConstants.npmShrinkwrapFilename = 'npm-shrinkwrap.json';\n/**\n * Number of installation attempts\n */\nRushConstants.defaultMaxInstallAttempts = 1;\n/**\n * The filename (\"pnpm-lock.yaml\") used to store an installation plan for the PNPM package manger\n * (PNPM version 3.x and later).\n */\nRushConstants.pnpmV3ShrinkwrapFilename = 'pnpm-lock.yaml';\n/**\n * The filename (\"pnpmfile.js\") used to add custom configuration to PNPM (PNPM version 1.x and later).\n */\nRushConstants.pnpmfileV1Filename = 'pnpmfile.js';\n/**\n * The filename (\".pnpmfile.cjs\") used to add custom configuration to PNPM (PNPM version 6.x and later).\n */\nRushConstants.pnpmfileV6Filename = '.pnpmfile.cjs';\n/**\n * The filename (\".modules.yaml\") used by pnpm to specify configurations in the node_modules directory\n */\nRushConstants.pnpmModulesFilename = '.modules.yaml';\n/**\n * The filename (\"global-pnpmfile.cjs\") used to add custom configuration to subspaces\n */\nRushConstants.pnpmfileGlobalFilename = 'global-pnpmfile.cjs';\n/**\n * The folder name used to store patch files for pnpm\n * Example: `C:\\MyRepo\\common\\config\\pnpm-patches`\n * Example: `C:\\MyRepo\\common\\temp\\patches`\n */\nRushConstants.pnpmPatchesFolderName = 'patches';\n/**\n * The folder name under `/common/temp` used to store checked-in patches.\n * Example: `C:\\MyRepo\\common\\pnpm-patches`\n */\nRushConstants.pnpmPatchesCommonFolderName = `pnpm-${RushConstants.pnpmPatchesFolderName}`;\n/**\n * The filename (\"shrinkwrap.yaml\") used to store state for pnpm\n */\nRushConstants.yarnShrinkwrapFilename = 'yarn.lock';\n/**\n * The folder name (\"node_modules\") where NPM installs its packages.\n */\nRushConstants.nodeModulesFolderName = 'node_modules';\n/**\n * The filename (\"pinned-versions.json\") for an old configuration file that\n * that is no longer supported.\n *\n * @deprecated This feature has been superseded by the \"preferredVersions\" setting\n * in common-versions.json\n */\n// NOTE: Although this is marked as \"deprecated\", we will probably never retire it,\n// since we always want to report the warning when someone upgrades an old repo.\nRushConstants.pinnedVersionsFilename = 'pinned-versions.json';\n/**\n * The filename (\"common-versions.json\") for an optional configuration file\n * that stores dependency version information that affects all projects in the repo.\n * This configuration file should go in the \"common/config/rush\" folder.\n */\nRushConstants.commonVersionsFilename = 'common-versions.json';\n/**\n * The filename (\"repo-state.json\") for a file used by Rush to\n * store the state of various features as they stand in the repo.\n */\nRushConstants.repoStateFilename = 'repo-state.json';\n/**\n * The filename (\"custom-tips.json\") for the file used by Rush to\n * print user-customized messages.\n * This configuration file should go in the \"common/config/rush\" folder.\n */\nRushConstants.customTipsFilename = 'custom-tips.json';\n/**\n * The name of the per-project folder where project-specific Rush files are stored. For example,\n * the package-deps files, which are used by commands to determine if a particular project needs to be rebuilt.\n */\nRushConstants.projectRushFolderName = '.rush';\n/**\n * Custom command line configuration file, which is used by rush for implementing\n * custom command and options.\n */\nRushConstants.commandLineFilename = 'command-line.json';\nRushConstants.versionPoliciesFilename = 'version-policies.json';\n/**\n * Experiments configuration file.\n */\nRushConstants.experimentsFilename = 'experiments.json';\n/**\n * Pnpm configuration file\n */\nRushConstants.pnpmConfigFilename = 'pnpm-config.json';\n/**\n * Rush plugins configuration file name.\n */\nRushConstants.rushPluginsConfigFilename = 'rush-plugins.json';\n/**\n * Rush plugin manifest file name.\n */\nRushConstants.rushPluginManifestFilename = 'rush-plugin-manifest.json';\n/**\n * The artifactory.json configuration file name.\n */\nRushConstants.artifactoryFilename = 'artifactory.json';\n/**\n * The subspaces.json configuration file name\n */\nRushConstants.subspacesConfigFilename = 'subspaces.json';\n/**\n * The name of the default subspace if one isn't specified but subspaces is enabled.\n */\nRushConstants.defaultSubspaceName = 'default';\n/**\n * Build cache configuration file.\n */\nRushConstants.buildCacheFilename = 'build-cache.json';\n/**\n * Build cache version number, incremented when the logic to create cache entries changes.\n * Changing this ensures that cache entries generated by an old version will no longer register as a cache hit.\n */\nRushConstants.buildCacheVersion = 1;\n/**\n * Cobuild configuration file.\n */\nRushConstants.cobuildFilename = 'cobuild.json';\n/**\n * Per-project configuration filename.\n */\nRushConstants.rushProjectConfigFilename = 'rush-project.json';\n/**\n * The URL (\"http://rushjs.io\") for the Rush web site.\n */\nRushConstants.rushWebSiteUrl = 'https://rushjs.io';\n/**\n * The name of the NPM package for the Rush tool (\"\\@microsoft/rush\").\n */\nRushConstants.rushPackageName = '@microsoft/rush';\n/**\n * The folder name (\"rush-recycler\") where Rush moves large folder trees\n * before asynchronously deleting them.\n */\nRushConstants.rushRecyclerFolderName = 'rush-recycler';\n/**\n * The name of the file to drop in project-folder/.rush/temp/ containing a listing of the project's direct\n * and indirect dependencies. This is used to detect if a project's dependencies have changed since the last build.\n */\nRushConstants.projectShrinkwrapFilename = 'shrinkwrap-deps.json';\n/**\n * The value of the \"commandKind\" property for a bulk command in command-line.json\n */\nRushConstants.bulkCommandKind = 'bulk';\n/**\n * The value of the \"commandKind\" property for a global command in command-line.json\n */\nRushConstants.globalCommandKind = 'global';\n/**\n * The value of the \"commandKind\" property for a phased command in command-line.json\n */\nRushConstants.phasedCommandKind = 'phased';\n/**\n * The name of the incremental build command.\n */\nRushConstants.buildCommandName = 'build';\n/**\n * The name of the non-incremental build command.\n */\nRushConstants.rebuildCommandName = 'rebuild';\nRushConstants.updateCloudCredentialsCommandName = 'update-cloud-credentials';\n/**\n * When a hash generated that contains multiple input segments, this character may be used\n * to separate them to avoid issues like\n * crypto.createHash('sha1').update('a').update('bc').digest('hex') === crypto.createHash('sha1').update('ab').update('c').digest('hex')\n */\nRushConstants.hashDelimiter = '|';\n/**\n * The name of the per-user Rush configuration data folder.\n */\nRushConstants.rushUserConfigurationFolderName = '.rush-user';\n/**\n * The name of the project `rush-logs` folder.\n */\nRushConstants.rushLogsFolderName = 'rush-logs';\n/**\n * The expected prefix for phase names in \"common/config/rush/command-line.json\"\n */\nRushConstants.phaseNamePrefix = '_phase:';\n/**\n * The default debounce value for Rush multi-project watch mode. When watching, controls\n * how long to wait after the last encountered file system event before execution. If another\n * file system event occurs in this interval, the timeout will reset.\n */\nRushConstants.defaultWatchDebounceMs = 1000;\n/**\n * The name of the parameter that can be used to bypass policies.\n */\nRushConstants.bypassPolicyFlagLongName = '--bypass-policy';\n/**\n * Merge Queue ignore configuration file.\n */\nRushConstants.mergeQueueIgnoreFileName = '.mergequeueignore';\n/**\n * The filename (\"project-impact-graph.yaml\") for the project impact graph file.\n */\nRushConstants.projectImpactGraphFilename = 'project-impact-graph.yaml';\n/**\n * The filename for the last link flag\n */\nRushConstants.lastLinkFlagFilename = 'last-link';\n/**\n * The filename for the Rush alerts config file.\n */\nRushConstants.rushAlertsConfigFilename = 'rush-alerts.json';\n/**\n * The filename for the file that tracks which variant is currently installed.\n */\nRushConstants.currentVariantsFilename = 'current-variants.json';\n//# sourceMappingURL=RushConstants.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as child_process from 'child_process';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { performance } from 'perf_hooks';\nimport { Transform } from 'stream';\nimport { JsonFile, FileSystem, FileConstants, SubprocessTerminator, Executable, Async } from '@rushstack/node-core-library';\nimport { syncNpmrc } from './npmrcUtilities';\nimport { EnvironmentVariableNames } from '../api/EnvironmentConfiguration';\nimport { RushConstants } from '../logic/RushConstants';\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const UNINITIALIZED = 'UNINITIALIZED';\nexport class Utilities {\n    /**\n     * Get the user's home directory. On windows this looks something like \"C:\\users\\username\\\" and on UNIX\n     * this looks something like \"/home/username/\"\n     */\n    static getHomeFolder() {\n        const unresolvedUserFolder = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];\n        const dirError = \"Unable to determine the current user's home directory\";\n        if (unresolvedUserFolder === undefined) {\n            throw new Error(dirError);\n        }\n        const homeFolder = path.resolve(unresolvedUserFolder);\n        if (!FileSystem.exists(homeFolder)) {\n            throw new Error(dirError);\n        }\n        return homeFolder;\n    }\n    /**\n     * Node.js equivalent of performance.now().\n     */\n    static getTimeInMs() {\n        return performance.now();\n    }\n    /**\n     * Retries a function until a timeout is reached. The function is expected to throw if it failed and\n     *  should be retried.\n     */\n    static retryUntilTimeout(fn, maxWaitTimeMs, getTimeoutError, fnName) {\n        const startTime = Utilities.getTimeInMs();\n        let looped = false;\n        let result;\n        for (;;) {\n            try {\n                result = fn();\n                break;\n            }\n            catch (e) {\n                looped = true;\n                const currentTime = Utilities.getTimeInMs();\n                if (currentTime - startTime > maxWaitTimeMs) {\n                    throw getTimeoutError(e);\n                }\n            }\n        }\n        if (looped) {\n            const currentTime = Utilities.getTimeInMs();\n            const totalSeconds = ((currentTime - startTime) / 1000.0).toFixed(2);\n            // This logging statement isn't meaningful to the end-user. `fnName` should be updated\n            // to something like `operationDescription`\n            // eslint-disable-next-line no-console\n            console.log(`${fnName}() stalled for ${totalSeconds} seconds`);\n        }\n        return result;\n    }\n    /**\n     * Creates the specified folder by calling FileSystem.ensureFolder(), but using a\n     * retry loop to recover from temporary locks that may be held by other processes.\n     * If the folder already exists, no error occurs.\n     */\n    static createFolderWithRetry(folderName) {\n        // Note: If a file exists with the same name, then we fall through and report\n        // an error.\n        if (Utilities.directoryExists(folderName)) {\n            return;\n        }\n        // We need to do a simple \"FileSystem.ensureFolder(localModulesFolder)\" here,\n        // however if the folder we deleted above happened to contain any files,\n        // then there seems to be some OS process (virus scanner?) that holds\n        // a lock on the folder for a split second, which causes mkdirSync to\n        // fail.  To workaround that, retry for up to 7 seconds before giving up.\n        const maxWaitTimeMs = 7 * 1000;\n        return Utilities.retryUntilTimeout(() => FileSystem.ensureFolder(folderName), maxWaitTimeMs, (e) => new Error(`Error: ${e}\\nOften this is caused by a file lock ` +\n            'from a process such as your text editor, command prompt, ' +\n            'or a filesystem watcher.'), 'createFolderWithRetry');\n    }\n    /**\n     * Determines if a path points to a directory and that it exists.\n     */\n    static directoryExists(directoryPath) {\n        let exists = false;\n        try {\n            const lstat = FileSystem.getLinkStatistics(directoryPath);\n            exists = lstat.isDirectory();\n        }\n        catch (e) {\n            /* no-op */\n        }\n        return exists;\n    }\n    /**\n     * BE VERY CAREFUL CALLING THIS FUNCTION!\n     * If you specify the wrong folderPath (e.g. \"/\"), it could potentially delete your entire\n     * hard disk.\n     */\n    static dangerouslyDeletePath(folderPath) {\n        try {\n            FileSystem.deleteFolder(folderPath);\n        }\n        catch (e) {\n            throw new Error(`${e.message}\\nOften this is caused by a file lock from a process ` +\n                'such as your text editor, command prompt, or a filesystem watcher');\n        }\n    }\n    /*\n     * Returns true if dateToCompare is more recent than all of the inputFilenames, which\n     * would imply that we don't need to rebuild it. Returns false if any of the files\n     * does not exist.\n     * NOTE: The filenames can also be paths for directories, in which case the directory\n     * timestamp is compared.\n     */\n    static async isFileTimestampCurrentAsync(dateToCompare, inputFilePaths) {\n        let anyAreOutOfDate = false;\n        await Async.forEachAsync(inputFilePaths, async (filePath) => {\n            if (!anyAreOutOfDate) {\n                let inputStats;\n                try {\n                    inputStats = await FileSystem.getStatisticsAsync(filePath);\n                }\n                catch (e) {\n                    if (FileSystem.isNotExistError(e)) {\n                        // eslint-disable-next-line require-atomic-updates\n                        anyAreOutOfDate = true;\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n                if (inputStats && dateToCompare < inputStats.mtime) {\n                    // eslint-disable-next-line require-atomic-updates\n                    anyAreOutOfDate = true;\n                }\n            }\n        }, { concurrency: 10 });\n        return !anyAreOutOfDate;\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     */\n    static async executeCommandAsync({ command, args, workingDirectory, suppressOutput, onStdoutStreamChunk, environment, keepEnvironment, captureExitCodeAndSignal }) {\n        const { exitCode, signal } = await Utilities._executeCommandInternalAsync({\n            command,\n            args,\n            workingDirectory,\n            stdio: onStdoutStreamChunk\n                ? // Inherit the stdin and stderr streams, but pipe the stdout stream, which will then be piped\n                    // to the process's stdout after being intercepted by the onStdoutStreamChunk callback.\n                    ['inherit', 'pipe', 'inherit']\n                : suppressOutput\n                    ? // If the output is being suppressed, create pipes for all streams to prevent the child process\n                        // from printing to the parent process's (this process's) stdout/stderr, but allow the stdout and\n                        // stderr to be inspected if an error occurs.\n                        // TODO: Consider ignoring stdout and stdin and only piping stderr for inspection on error.\n                        ['pipe', 'pipe', 'pipe']\n                    : // If the output is not being suppressed or intercepted, inherit all streams from the parent process.\n                        ['inherit', 'inherit', 'inherit'],\n            environment,\n            keepEnvironment,\n            onStdoutStreamChunk,\n            captureOutput: false,\n            captureExitCodeAndSignal\n        });\n        if (captureExitCodeAndSignal) {\n            return { exitCode, signal };\n        }\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     */\n    static async executeCommandAndCaptureOutputAsync(command, args, workingDirectory, environment, keepEnvironment = false) {\n        const { stdout } = await Utilities._executeCommandInternalAsync({\n            command,\n            args,\n            workingDirectory,\n            stdio: ['pipe', 'pipe', 'pipe'],\n            environment,\n            keepEnvironment,\n            captureOutput: true\n        });\n        return stdout;\n    }\n    /**\n     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.\n     */\n    static async executeCommandWithRetryAsync(options, maxAttempts, retryCallback) {\n        if (maxAttempts < 1) {\n            throw new Error('The maxAttempts parameter cannot be less than 1');\n        }\n        let attemptNumber = 1;\n        for (;;) {\n            try {\n                await Utilities.executeCommandAsync(options);\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.log('\\nThe command failed:');\n                const { command, args } = options;\n                // eslint-disable-next-line no-console\n                console.log(` ${command} ` + args.join(' '));\n                // eslint-disable-next-line no-console\n                console.log(`ERROR: ${error.toString()}`);\n                if (attemptNumber < maxAttempts) {\n                    ++attemptNumber;\n                    // eslint-disable-next-line no-console\n                    console.log(`Trying again (attempt #${attemptNumber})...\\n`);\n                    if (retryCallback) {\n                        retryCallback();\n                    }\n                    continue;\n                }\n                else {\n                    // eslint-disable-next-line no-console\n                    console.error(`Giving up after ${attemptNumber} attempts\\n`);\n                    throw error;\n                }\n            }\n            break;\n        }\n    }\n    /**\n     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.\n     * @param command - the command to run on shell\n     * @param options - options for how the command should be run\n     */\n    static executeLifecycleCommand(command, options) {\n        const result = Utilities._executeLifecycleCommandInternal(command, child_process.spawnSync, options);\n        if (options.handleOutput) {\n            Utilities._processResult({\n                error: result.error,\n                status: result.status,\n                stderr: result.stderr.toString()\n            });\n        }\n        if (result.status !== null) {\n            return result.status;\n        }\n        else {\n            throw result.error || new Error('An unknown error occurred.');\n        }\n    }\n    /**\n     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.\n     * @param command - the command to run on shell\n     * @param options - options for how the command should be run\n     */\n    static executeLifecycleCommandAsync(command, options) {\n        const child = Utilities._executeLifecycleCommandInternal(command, child_process.spawn, options);\n        if (options.connectSubprocessTerminator) {\n            SubprocessTerminator.killProcessTreeOnExit(child, SubprocessTerminator.RECOMMENDED_OPTIONS);\n        }\n        return child;\n    }\n    /**\n     * For strings passed to a shell command, this adds appropriate escaping\n     * to avoid misinterpretation of spaces or special characters.\n     *\n     * Example: 'hello there' --> '\"hello there\"'\n     */\n    static escapeShellParameter(parameter) {\n        // This approach is based on what NPM 7 now does:\n        // https://github.com/npm/run-script/blob/47a4d539fb07220e7215cc0e482683b76407ef9b/lib/run-script-pkg.js#L34\n        return JSON.stringify(parameter);\n    }\n    /**\n     * Installs a package by name and version in the specified directory.\n     */\n    static async installPackageInDirectoryAsync({ packageName, version, tempPackageTitle, commonRushConfigFolder, maxInstallAttempts, suppressOutput, directory }) {\n        directory = path.resolve(directory);\n        const directoryExists = await FileSystem.existsAsync(directory);\n        if (directoryExists) {\n            // eslint-disable-next-line no-console\n            console.log('Deleting old files from ' + directory);\n        }\n        await FileSystem.ensureEmptyFolderAsync(directory);\n        const npmPackageJson = {\n            dependencies: {\n                [packageName]: version\n            },\n            description: 'Temporary file generated by the Rush tool',\n            name: tempPackageTitle,\n            private: true,\n            version: '0.0.0'\n        };\n        await JsonFile.saveAsync(npmPackageJson, path.join(directory, FileConstants.PackageJson));\n        if (commonRushConfigFolder) {\n            Utilities.syncNpmrc({\n                sourceNpmrcFolder: commonRushConfigFolder,\n                targetNpmrcFolder: directory,\n                supportEnvVarFallbackSyntax: false\n            });\n        }\n        // eslint-disable-next-line no-console\n        console.log('\\nRunning \"npm install\" in ' + directory);\n        // NOTE: Here we use whatever version of NPM we happen to find in the PATH\n        await Utilities.executeCommandWithRetryAsync({\n            command: 'npm',\n            args: ['install'],\n            workingDirectory: directory,\n            environment: Utilities._createEnvironmentForRushCommand({}),\n            suppressOutput\n        }, maxInstallAttempts);\n    }\n    /**\n     * Copies the file \"sourcePath\" to \"destinationPath\", overwriting the target file location.\n     * If the source file does not exist, then the target file is deleted.\n     */\n    static syncFile(sourcePath, destinationPath) {\n        if (FileSystem.exists(sourcePath)) {\n            // eslint-disable-next-line no-console\n            console.log(`Copying \"${sourcePath}\"`);\n            // eslint-disable-next-line no-console\n            console.log(`  --> \"${destinationPath}\"`);\n            FileSystem.copyFile({ sourcePath, destinationPath });\n        }\n        else {\n            if (FileSystem.exists(destinationPath)) {\n                // If the source file doesn't exist and there is one in the target, delete the one in the target\n                // eslint-disable-next-line no-console\n                console.log(`Deleting ${destinationPath}`);\n                FileSystem.deleteFile(destinationPath);\n            }\n        }\n    }\n    static getRushConfigNotFoundError() {\n        return new Error(`Unable to find ${RushConstants.rushJsonFilename} configuration file`);\n    }\n    static async usingAsync(getDisposableAsync, doActionAsync) {\n        let disposable;\n        try {\n            disposable = (await getDisposableAsync());\n            await doActionAsync(disposable);\n        }\n        finally {\n            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\n        }\n    }\n    static trimAfterLastSlash(filePath) {\n        const indexOfLastSlash = Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\\\'));\n        if (indexOfLastSlash < 0) {\n            return filePath;\n        }\n        return filePath.substring(0, indexOfLastSlash);\n    }\n    /**\n     * If the path refers to a symlink, `FileSystem.exists()` would normally test whether the symlink\n     * points to a target that exists. By contrast, `existsOrIsBrokenSymlink()` will return true even if\n     * the symlink exists but its target does not. */\n    static existsOrIsSymlink(linkPath) {\n        try {\n            FileSystem.getLinkStatistics(linkPath);\n            return true;\n        }\n        catch (err) {\n            return false;\n        }\n    }\n    static _executeLifecycleCommandInternal(command, spawnFunction, options) {\n        var _a;\n        let shellCommand = process.env.comspec || 'cmd';\n        let commandFlags = '/d /s /c';\n        let useShell = true;\n        if (process.platform !== 'win32') {\n            shellCommand = 'sh';\n            commandFlags = '-c';\n            useShell = false;\n        }\n        const environment = Utilities._createEnvironmentForRushCommand({\n            initCwd: options.initCwd,\n            initialEnvironment: options.initialEnvironment,\n            pathOptions: Object.assign(Object.assign({}, options.environmentPathOptions), { rushJsonFolder: (_a = options.rushConfiguration) === null || _a === void 0 ? void 0 : _a.rushJsonFolder, projectRoot: options.workingDirectory, commonTempFolder: options.rushConfiguration ? options.rushConfiguration.commonTempFolder : undefined })\n        });\n        const stdio = options.handleOutput ? ['pipe', 'pipe', 'pipe'] : [0, 1, 2];\n        if (options.ipc) {\n            stdio.push('ipc');\n        }\n        const spawnOptions = {\n            cwd: options.workingDirectory,\n            shell: useShell,\n            env: environment,\n            stdio\n        };\n        if (options.connectSubprocessTerminator) {\n            Object.assign(spawnOptions, SubprocessTerminator.RECOMMENDED_OPTIONS);\n        }\n        return spawnFunction(shellCommand, [commandFlags, command], spawnOptions);\n    }\n    /**\n     * Returns a process.env environment suitable for executing lifecycle scripts.\n     * @param initialEnvironment - an existing environment to copy instead of process.env\n     *\n     * @remarks\n     * Rush._assignRushInvokedFolder() assigns the `RUSH_INVOKED_FOLDER` variable globally\n     * via the parent process's environment.\n     */\n    static _createEnvironmentForRushCommand(options) {\n        var _a;\n        if (options.initialEnvironment === undefined) {\n            options.initialEnvironment = process.env;\n        }\n        // Set some defaults for the environment\n        const environment = {};\n        if ((_a = options.pathOptions) === null || _a === void 0 ? void 0 : _a.rushJsonFolder) {\n            environment.RUSHSTACK_FILE_ERROR_BASE_FOLDER = options.pathOptions.rushJsonFolder;\n        }\n        for (const key of Object.getOwnPropertyNames(options.initialEnvironment)) {\n            const normalizedKey = os.platform() === 'win32' ? key.toUpperCase() : key;\n            // If Rush itself was invoked inside a lifecycle script, this may be set and would interfere\n            // with Rush's installations.  If we actually want it, we will set it explicitly below.\n            if (normalizedKey === 'INIT_CWD') {\n                continue;\n            }\n            // When NPM invokes a lifecycle event, it copies its entire configuration into environment\n            // variables.  Rush is supposed to be a deterministic controlled environment, so don't bring\n            // this along.\n            //\n            // NOTE: Longer term we should clean out the entire environment and use rush.json to bring\n            // back specific environment variables that the repo maintainer has determined to be safe.\n            if (normalizedKey.match(/^NPM_CONFIG_/)) {\n                continue;\n            }\n            // Use the uppercased environment variable name on Windows because environment variable names\n            // are case-insensitive on Windows\n            environment[normalizedKey] = options.initialEnvironment[key];\n        }\n        // When NPM invokes a lifecycle script, it sets an environment variable INIT_CWD that remembers\n        // the directory that NPM started in.  This allows naive scripts to change their current working directory\n        // and invoke NPM operations, while still be able to find a local .npmrc file.  Although Rush recommends\n        // for toolchain scripts to be professionally written (versus brittle stuff like\n        // \"cd ./lib && npm run tsc && cd ..\"), we support INIT_CWD for compatibility.\n        //\n        // More about this feature: https://github.com/npm/npm/pull/12356\n        if (options.initCwd) {\n            environment['INIT_CWD'] = options.initCwd; // eslint-disable-line dot-notation\n        }\n        if (options.pathOptions) {\n            if (options.pathOptions.includeRepoBin && options.pathOptions.commonTempFolder) {\n                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.commonTempFolder);\n            }\n            if (options.pathOptions.includeProjectBin && options.pathOptions.projectRoot) {\n                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.projectRoot);\n            }\n            if (options.pathOptions.additionalPathFolders) {\n                environment.PATH = [...options.pathOptions.additionalPathFolders, environment.PATH].join(path.delimiter);\n            }\n        }\n        // Communicate to downstream calls that they should not try to run hooks\n        environment[EnvironmentVariableNames._RUSH_RECURSIVE_RUSHX_CALL] = '1';\n        return environment;\n    }\n    /**\n     * Prepend the node_modules/.bin folder under the specified folder to the specified PATH variable. For example,\n     * if `rootDirectory` is \"/foobar\" and `existingPath` is \"/bin\", this function will return\n     * \"/foobar/node_modules/.bin:/bin\"\n     */\n    static _prependNodeModulesBinToPath(existingPath, rootDirectory) {\n        const binPath = path.resolve(rootDirectory, 'node_modules', '.bin');\n        if (existingPath) {\n            return `${binPath}${path.delimiter}${existingPath}`;\n        }\n        else {\n            return binPath;\n        }\n    }\n    /**\n     * Executes the command with the specified command-line parameters, and waits for it to complete.\n     * The current directory will be set to the specified workingDirectory.\n     */\n    static async _executeCommandInternalAsync({ command, args, workingDirectory, stdio, environment, keepEnvironment, onStdoutStreamChunk, captureOutput, captureExitCodeAndSignal }) {\n        var _a;\n        const options = {\n            cwd: workingDirectory,\n            shell: true,\n            stdio: stdio,\n            env: keepEnvironment\n                ? environment\n                : Utilities._createEnvironmentForRushCommand({ initialEnvironment: environment }),\n            maxBuffer: 10 * 1024 * 1024 // Set default max buffer size to 10MB\n        };\n        // This is needed since we specify shell=true below.\n        // NOTE: On Windows if we escape \"NPM\", the spawnSync() function runs something like this:\n        //   [ 'C:\\\\Windows\\\\system32\\\\cmd.exe', '/s', '/c', '\"\"NPM\" \"install\"\"' ]\n        //\n        // Due to a bug with Windows cmd.exe, the npm.cmd batch file's \"%~dp0\" variable will\n        // return the current working directory instead of the batch file's directory.\n        // The workaround is to not escape, npm, i.e. do this instead:\n        //   [ 'C:\\\\Windows\\\\system32\\\\cmd.exe', '/s', '/c', '\"npm \"install\"\"' ]\n        //\n        // We will come up with a better solution for this when we promote executeCommand()\n        // into node-core-library, but for now this hack will unblock people:\n        // Only escape the command if it actually contains spaces:\n        const escapedCommand = command.indexOf(' ') < 0 ? command : Utilities.escapeShellParameter(command);\n        const escapedArgs = args.map((x) => Utilities.escapeShellParameter(x));\n        const childProcess = child_process.spawn(escapedCommand, escapedArgs, options);\n        if (onStdoutStreamChunk) {\n            const inspectStream = new Transform({\n                transform: onStdoutStreamChunk\n                    ? (chunk, encoding, callback) => {\n                        const chunkString = chunk.toString();\n                        const updatedChunk = onStdoutStreamChunk(chunkString);\n                        callback(undefined, updatedChunk !== null && updatedChunk !== void 0 ? updatedChunk : chunk);\n                    }\n                    : undefined\n            });\n            (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.pipe(inspectStream).pipe(process.stdout);\n        }\n        return await Executable.waitForExitAsync(childProcess, {\n            encoding: captureOutput ? 'utf8' : undefined,\n            throwOnNonZeroExitCode: !captureExitCodeAndSignal,\n            throwOnSignal: !captureExitCodeAndSignal\n        });\n    }\n    static _processResult({ error, stderr, status }) {\n        if (error) {\n            error.message += `\\n${stderr}`;\n            if (status) {\n                error.message += `\\nExited with status ${status}`;\n            }\n            throw error;\n        }\n        if (status) {\n            throw new Error(`The command failed with exit code ${status}\\n${stderr}`);\n        }\n    }\n}\nUtilities.syncNpmrc = syncNpmrc;\n//# sourceMappingURL=Utilities.js.map","// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nimport * as path from 'path';\nimport { Utilities } from '../utilities/Utilities';\nimport { EnvironmentConfiguration } from './EnvironmentConfiguration';\n/**\n * This class provides global folders that are used for rush's internal install locations.\n *\n * @internal\n */\nexport class RushGlobalFolder {\n    constructor() {\n        // Because RushGlobalFolder is used by the front-end VersionSelector before EnvironmentConfiguration\n        // is initialized, we need to read it using a special internal API.\n        const rushGlobalFolderOverride = EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);\n        if (rushGlobalFolderOverride !== undefined) {\n            this.path = rushGlobalFolderOverride;\n        }\n        else {\n            this.path = path.join(Utilities.getHomeFolder(), '.rush');\n        }\n        const normalizedNodeVersion = process.version.match(/^[a-z0-9\\-\\.]+$/i)\n            ? process.version\n            : 'unknown-version';\n        this.nodeSpecificPath = path.join(this.path, `node-${normalizedNodeVersion}`);\n    }\n}\n//# sourceMappingURL=RushGlobalFolder.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.requireRushLibUnderFolderPath = exports._require = exports.tryFindRushJsonLocation = exports.sdkContext = exports.RUSH_LIB_PATH_ENV_VAR_NAME = exports.RUSH_LIB_NAME = void 0;\nconst path = __importStar(require(\"path\"));\nconst node_core_library_1 = require(\"@rushstack/node-core-library\");\nexports.RUSH_LIB_NAME = '@microsoft/rush-lib';\nexports.RUSH_LIB_PATH_ENV_VAR_NAME = '_RUSH_LIB_PATH';\nexports.sdkContext = {\n    rushLibModule: undefined\n};\n/**\n * Find the rush.json location and return the path, or undefined if a rush.json can't be found.\n *\n * @privateRemarks\n * Keep this in sync with `RushConfiguration.tryFindRushJsonLocation`.\n */\nfunction tryFindRushJsonLocation(startingFolder) {\n    let currentFolder = startingFolder;\n    // Look upwards at parent folders until we find a folder containing rush.json\n    for (let i = 0; i < 10; ++i) {\n        const rushJsonFilename = path.join(currentFolder, 'rush.json');\n        if (node_core_library_1.FileSystem.exists(rushJsonFilename)) {\n            return rushJsonFilename;\n        }\n        const parentFolder = path.dirname(currentFolder);\n        if (parentFolder === currentFolder) {\n            break;\n        }\n        currentFolder = parentFolder;\n    }\n    return undefined;\n}\nexports.tryFindRushJsonLocation = tryFindRushJsonLocation;\nfunction _require(moduleName) {\n    if (typeof __non_webpack_require__ === 'function') {\n        // If this library has been bundled with Webpack, we need to call the real `require` function\n        // that doesn't get turned into a `__webpack_require__` statement.\n        // `__non_webpack_require__` is a Webpack macro that gets turned into a `require` statement\n        // during bundling.\n        return __non_webpack_require__(moduleName);\n    }\n    else {\n        return require(moduleName);\n    }\n}\nexports._require = _require;\n/**\n * Require `@microsoft/rush-lib` under the specified folder path.\n */\nfunction requireRushLibUnderFolderPath(folderPath) {\n    const rushLibModulePath = node_core_library_1.Import.resolveModule({\n        modulePath: exports.RUSH_LIB_NAME,\n        baseFolderPath: folderPath\n    });\n    return _require(rushLibModulePath);\n}\nexports.requireRushLibUnderFolderPath = requireRushLibUnderFolderPath;\n//# sourceMappingURL=helpers.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._rushSdk_loadInternalModule = void 0;\nconst path = __importStar(require(\"path\"));\nconst node_core_library_1 = require(\"@rushstack/node-core-library\");\nconst terminal_1 = require(\"@rushstack/terminal\");\nconst RushGlobalFolder_1 = require(\"@microsoft/rush-lib/lib-esnext/api/RushGlobalFolder\");\nconst helpers_1 = require(\"./helpers\");\nconst verboseEnabled = typeof process !== 'undefined' &&\n    (process.env.RUSH_SDK_DEBUG === '1' || process.env._RUSH_SDK_DEBUG === '1');\nconst terminal = new terminal_1.Terminal(new terminal_1.ConsoleTerminalProvider({\n    verboseEnabled\n}));\nlet errorMessage = '';\n// SCENARIO 1:  Rush's PluginManager has initialized \"rush-sdk\" with Rush's own instance of rush-lib.\n// The Rush host process will assign \"global.___rush___rushLibModule\" before loading the plugin.\nif (helpers_1.sdkContext.rushLibModule === undefined) {\n    helpers_1.sdkContext.rushLibModule =\n        global.___rush___rushLibModule ||\n            global.___rush___rushLibModuleFromEnvironment ||\n            global.___rush___rushLibModuleFromRushGlobalFolder ||\n            global.___rush___rushLibModuleFromInstallAndRunRush;\n}\n// SCENARIO 2:  The project importing \"rush-sdk\" has installed its own instance of \"rush-lib\"\n// as a package.json dependency.  For example, this is used by the Jest tests for Rush plugins.\nif (helpers_1.sdkContext.rushLibModule === undefined) {\n    const importingPath = (_a = module === null || module === void 0 ? void 0 : module.parent) === null || _a === void 0 ? void 0 : _a.filename;\n    if (importingPath) {\n        const callerPackageFolder = node_core_library_1.PackageJsonLookup.instance.tryGetPackageFolderFor(importingPath);\n        if (callerPackageFolder !== undefined) {\n            const callerPackageJson = (0, helpers_1._require)(path.join(callerPackageFolder, 'package.json'));\n            // Does the caller properly declare a dependency on rush-lib?\n            if ((callerPackageJson.dependencies && callerPackageJson.dependencies[helpers_1.RUSH_LIB_NAME] !== undefined) ||\n                (callerPackageJson.devDependencies &&\n                    callerPackageJson.devDependencies[helpers_1.RUSH_LIB_NAME] !== undefined) ||\n                (callerPackageJson.peerDependencies &&\n                    callerPackageJson.peerDependencies[helpers_1.RUSH_LIB_NAME] !== undefined)) {\n                // Try to resolve rush-lib from the caller's folder\n                terminal.writeVerboseLine(`Try to load ${helpers_1.RUSH_LIB_NAME} from caller package`);\n                try {\n                    helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(callerPackageFolder);\n                }\n                catch (error) {\n                    // If we fail to resolve it, ignore the error\n                    terminal.writeVerboseLine(`Failed to load ${helpers_1.RUSH_LIB_NAME} from caller package`);\n                }\n                // If two different libraries invoke `rush-sdk`, and one of them provides \"rush-lib\"\n                // then the first version to be loaded wins.  We do not support side-by-side instances of \"rush-lib\".\n                if (helpers_1.sdkContext.rushLibModule !== undefined) {\n                    // to track which scenario is active and how it got initialized.\n                    global.___rush___rushLibModule = helpers_1.sdkContext.rushLibModule;\n                    terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} from caller`);\n                }\n            }\n        }\n    }\n}\n// SCENARIO 3: A tool or script has been invoked as a child process by an instance of \"rush-lib\" and can use the\n// version that invoked it. In this case, use process.env._RUSH_LIB_PATH to find \"rush-lib\".\nif (helpers_1.sdkContext.rushLibModule === undefined) {\n    const rushLibPath = process.env[helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME];\n    if (rushLibPath) {\n        terminal.writeVerboseLine(`Try to load ${helpers_1.RUSH_LIB_NAME} from process.env.${helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME} from caller package`);\n        try {\n            helpers_1.sdkContext.rushLibModule = (0, helpers_1._require)(rushLibPath);\n        }\n        catch (error) {\n            // Log this as a warning, since it is unexpected to define an incorrect value of the variable.\n            terminal.writeWarningLine(`Failed to load ${helpers_1.RUSH_LIB_NAME} via process.env.${helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME}`);\n        }\n        if (helpers_1.sdkContext.rushLibModule !== undefined) {\n            // to track which scenario is active and how it got initialized.\n            global.___rush___rushLibModuleFromEnvironment = helpers_1.sdkContext.rushLibModule;\n            terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} from process.env.${helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME}`);\n        }\n    }\n}\n// SCENARIO 4:  A standalone tool or script depends on \"rush-sdk\", and is meant to be used inside a monorepo folder.\n// In this case, we can first load the rush-lib version in rush global folder. If the expected version is not installed,\n// using install-run-rush.js to obtain the appropriate rush-lib version for the monorepo.\nif (helpers_1.sdkContext.rushLibModule === undefined) {\n    try {\n        const rushJsonPath = (0, helpers_1.tryFindRushJsonLocation)(process.cwd());\n        if (!rushJsonPath) {\n            throw new Error('Unable to find rush.json in the current folder or its parent folders.\\n' +\n                'This tool is meant to be invoked from a working directory inside a Rush repository.');\n        }\n        const monorepoRoot = path.dirname(rushJsonPath);\n        const rushJson = node_core_library_1.JsonFile.load(rushJsonPath);\n        const { rushVersion } = rushJson;\n        try {\n            terminal.writeVerboseLine(`Try to load ${helpers_1.RUSH_LIB_NAME} from rush global folder`);\n            const rushGlobalFolder = new RushGlobalFolder_1.RushGlobalFolder();\n            // The path needs to keep align with the logic inside RushVersionSelector\n            const expectedGlobalRushInstalledFolder = `${rushGlobalFolder.nodeSpecificPath}/rush-${rushVersion}`;\n            terminal.writeVerboseLine(`The expected global rush installed folder is \"${expectedGlobalRushInstalledFolder}\"`);\n            helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(expectedGlobalRushInstalledFolder);\n        }\n        catch (e) {\n            terminal.writeVerboseLine(`Failed to load ${helpers_1.RUSH_LIB_NAME} from rush global folder: ${e.message}`);\n        }\n        if (helpers_1.sdkContext.rushLibModule !== undefined) {\n            // to track which scenario is active and how it got initialized.\n            global.___rush___rushLibModuleFromRushGlobalFolder = helpers_1.sdkContext.rushLibModule;\n            terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} installed from rush global folder`);\n        }\n        else {\n            const installRunNodeModuleFolder = `${monorepoRoot}/common/temp/install-run/@microsoft+rush@${rushVersion}`;\n            try {\n                // First, try to load the version of \"rush-lib\" that was installed by install-run-rush.js\n                terminal.writeVerboseLine(`Trying to load  ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush`);\n                helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(installRunNodeModuleFolder);\n            }\n            catch (e1) {\n                let installAndRunRushStderrContent = '';\n                try {\n                    const installAndRunRushJSPath = `${monorepoRoot}/common/scripts/install-run-rush.js`;\n                    terminal.writeLine('The Rush engine has not been installed yet. Invoking install-run-rush.js...');\n                    const installAndRunRushProcess = node_core_library_1.Executable.spawnSync('node', [installAndRunRushJSPath, '--help'], {\n                        stdio: 'pipe'\n                    });\n                    installAndRunRushStderrContent = installAndRunRushProcess.stderr;\n                    if (installAndRunRushProcess.status !== 0) {\n                        throw new Error(`The ${helpers_1.RUSH_LIB_NAME} package failed to install`);\n                    }\n                    // Retry to load \"rush-lib\" after install-run-rush run\n                    terminal.writeVerboseLine(`Trying to load  ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush a second time`);\n                    helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(installRunNodeModuleFolder);\n                }\n                catch (e2) {\n                    // eslint-disable-next-line no-console\n                    console.error(`${installAndRunRushStderrContent}`);\n                    throw new Error(`The ${helpers_1.RUSH_LIB_NAME} package failed to load`);\n                }\n            }\n            if (helpers_1.sdkContext.rushLibModule !== undefined) {\n                // to track which scenario is active and how it got initialized.\n                global.___rush___rushLibModuleFromInstallAndRunRush = helpers_1.sdkContext.rushLibModule;\n                terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush`);\n            }\n        }\n    }\n    catch (e) {\n        // no-catch\n        errorMessage = e.message;\n    }\n}\nif (helpers_1.sdkContext.rushLibModule === undefined) {\n    // This error indicates that a project is trying to import \"@rushstack/rush-sdk\", but the Rush engine\n    // instance cannot be found.  If you are writing Jest tests for a Rush plugin, add \"@microsoft/rush-lib\"\n    // to the devDependencies for your project.\n    // eslint-disable-next-line no-console\n    console.error(`Error: The @rushstack/rush-sdk package was not able to load the Rush engine:\n${errorMessage}\n`);\n    process.exit(1);\n}\n// Based on TypeScript's __exportStar()\nfor (const property in helpers_1.sdkContext.rushLibModule) {\n    if (property !== 'default' && !exports.hasOwnProperty(property)) {\n        const rushLibModuleForClosure = helpers_1.sdkContext.rushLibModule;\n        // Based on TypeScript's __createBinding()\n        Object.defineProperty(exports, property, {\n            enumerable: true,\n            get: function () {\n                return rushLibModuleForClosure[property];\n            }\n        });\n    }\n}\n/**\n * Used by the .js stubs for path-based imports of `@microsoft/rush-lib` internal APIs.\n */\nfunction _rushSdk_loadInternalModule(srcImportPath) {\n    if (!exports._RushInternals) {\n        throw new Error(`Rush version ${exports.Rush.version} does not support internal API imports via rush-sdk`);\n    }\n    return exports._RushInternals.loadModule(srcImportPath);\n}\nexports._rushSdk_loadInternalModule = _rushSdk_loadInternalModule;\n//# sourceMappingURL=index.js.map","module.exports = require(\"@rushstack/node-core-library\");","module.exports = require(\"@rushstack/terminal\");","module.exports = require(\"fs\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./lib-commonjs/index.js\");\n",""],"names":[],"sourceRoot":""}