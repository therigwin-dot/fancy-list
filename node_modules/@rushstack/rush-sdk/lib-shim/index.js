/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../common/temp/default/node_modules/.pnpm/true-case-path@2.2.1/node_modules/true-case-path/index.js":
/*!**************************************************************************************************************!*\
  !*** ../../common/temp/default/node_modules/.pnpm/true-case-path@2.2.1/node_modules/true-case-path/index.js ***!
  \**************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



const { readdir: _readdir, readdirSync } = __webpack_require__(/*! fs */ "fs")
const { platform } = __webpack_require__(/*! os */ "os")
const { isAbsolute, normalize } = __webpack_require__(/*! path */ "path")
const { promisify: pify } = __webpack_require__(/*! util */ "util")

const readdir = pify(_readdir)
const isWindows = platform() === 'win32'
const delimiter = isWindows ? '\\' : '/'

module.exports = {
  trueCasePath: _trueCasePath({ sync: false }),
  trueCasePathSync: _trueCasePath({ sync: true })
}

function getRelevantFilePathSegments(filePath) {
  return filePath.split(delimiter).filter((s) => s !== '')
}

function escapeString(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

function matchCaseInsensitive(fileOrDirectory, directoryContents, filePath) {
  const caseInsensitiveRegex = new RegExp(
    `^${escapeString(fileOrDirectory)}$`,
    'i'
  )
  for (const file of directoryContents) {
    if (caseInsensitiveRegex.test(file)) return file
  }
  throw new Error(
    `[true-case-path]: Called with ${filePath}, but no matching file exists`
  )
}

function _trueCasePath({ sync }) {
  return (filePath, basePath) => {
    if (basePath) {
      if (!isAbsolute(basePath)) {
        throw new Error(
          `[true-case-path]: basePath argument must be absolute. Received "${basePath}"`
        )
      }
      basePath = normalize(basePath)
    }
    filePath = normalize(filePath)
    const segments = getRelevantFilePathSegments(filePath)
    if (isAbsolute(filePath)) {
      if (basePath) {
        throw new Error(
          '[true-case-path]: filePath must be relative when used with basePath'
        )
      }
      basePath = isWindows
        ? segments.shift().toUpperCase() // drive letter
        : ''
    } else if (!basePath) {
      basePath = process.cwd()
    }
    return sync
      ? iterateSync(basePath, filePath, segments)
      : iterateAsync(basePath, filePath, segments)
  }
}

function iterateSync(basePath, filePath, segments) {
  return segments.reduce(
    (realPath, fileOrDirectory) =>
      realPath +
      delimiter +
      matchCaseInsensitive(
        fileOrDirectory,
        readdirSync(realPath + delimiter),
        filePath
      ),
    basePath
  )
}

async function iterateAsync(basePath, filePath, segments) {
  return await segments.reduce(
    async (realPathPromise, fileOrDirectory) =>
      (await realPathPromise) +
      delimiter +
      matchCaseInsensitive(
        fileOrDirectory,
        await readdir((await realPathPromise) + delimiter),
        filePath
      ),
    basePath
  )
}


/***/ }),

/***/ "../rush-lib/lib-esnext/api/RushGlobalFolder.js":
/*!******************************************************************!*\
  !*** ../rush-lib/lib-esnext/api/RushGlobalFolder.js + 7 modules ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  RushGlobalFolder: () => (/* binding */ RushGlobalFolder)
});

// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__("path");
;// external "child_process"
const external_child_process_namespaceObject = require("child_process");
// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__("os");
;// external "perf_hooks"
const external_perf_hooks_namespaceObject = require("perf_hooks");
;// external "stream"
const external_stream_namespaceObject = require("stream");
// EXTERNAL MODULE: external "@rushstack/node-core-library"
var node_core_library_ = __webpack_require__("@rushstack/node-core-library");
// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__("fs");
;// ../rush-lib/lib-esnext/utilities/npmrcUtilities.js
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
// IMPORTANT - do not use any non-built-in libraries in this file


/**
 * This function reads the content for given .npmrc file path, and also trims
 * unusable lines from the .npmrc file.
 *
 * @returns
 * The text of the the .npmrc.
 */
// create a global _combinedNpmrc for cache purpose
const _combinedNpmrcMap = new Map();
function _trimNpmrcFile(options) {
    const { sourceNpmrcPath, linesToPrepend, linesToAppend, supportEnvVarFallbackSyntax } = options;
    const combinedNpmrcFromCache = _combinedNpmrcMap.get(sourceNpmrcPath);
    if (combinedNpmrcFromCache !== undefined) {
        return combinedNpmrcFromCache;
    }
    let npmrcFileLines = [];
    if (linesToPrepend) {
        npmrcFileLines.push(...linesToPrepend);
    }
    if (external_fs_.existsSync(sourceNpmrcPath)) {
        npmrcFileLines.push(...external_fs_.readFileSync(sourceNpmrcPath).toString().split('\n'));
    }
    if (linesToAppend) {
        npmrcFileLines.push(...linesToAppend);
    }
    npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());
    const resultLines = trimNpmrcFileLines(npmrcFileLines, process.env, supportEnvVarFallbackSyntax);
    const combinedNpmrc = resultLines.join('\n');
    //save the cache
    _combinedNpmrcMap.set(sourceNpmrcPath, combinedNpmrc);
    return combinedNpmrc;
}
/**
 *
 * @param npmrcFileLines The npmrc file's lines
 * @param env The environment variables object
 * @param supportEnvVarFallbackSyntax Whether to support fallback values in the form of `${VAR_NAME:-fallback}`
 * @returns
 */
function trimNpmrcFileLines(npmrcFileLines, env, supportEnvVarFallbackSyntax) {
    var _a;
    const resultLines = [];
    // This finds environment variable tokens that look like "${VAR_NAME}"
    const expansionRegExp = /\$\{([^\}]+)\}/g;
    // Comment lines start with "#" or ";"
    const commentRegExp = /^\s*[#;]/;
    // Trim out lines that reference environment variables that aren't defined
    for (let line of npmrcFileLines) {
        let lineShouldBeTrimmed = false;
        //remove spaces before or after key and value
        line = line
            .split('=')
            .map((lineToTrim) => lineToTrim.trim())
            .join('=');
        // Ignore comment lines
        if (!commentRegExp.test(line)) {
            const environmentVariables = line.match(expansionRegExp);
            if (environmentVariables) {
                for (const token of environmentVariables) {
                    /**
                     * Remove the leading "${" and the trailing "}" from the token
                     *
                     * ${nameString}                  -> nameString
                     * ${nameString-fallbackString}   -> name-fallbackString
                     * ${nameString:-fallbackString}  -> name:-fallbackString
                     */
                    const nameWithFallback = token.substring(2, token.length - 1);
                    let environmentVariableName;
                    let fallback;
                    if (supportEnvVarFallbackSyntax) {
                        /**
                         * Get the environment variable name and fallback value.
                         *
                         *                                name          fallback
                         * nameString                 ->  nameString    undefined
                         * nameString-fallbackString  ->  nameString    fallbackString
                         * nameString:-fallbackString ->  nameString    fallbackString
                         */
                        const matched = nameWithFallback.match(/^([^:-]+)(?:\:?-(.+))?$/);
                        // matched: [originStr, variableName, fallback]
                        environmentVariableName = (_a = matched === null || matched === void 0 ? void 0 : matched[1]) !== null && _a !== void 0 ? _a : nameWithFallback;
                        fallback = matched === null || matched === void 0 ? void 0 : matched[2];
                    }
                    else {
                        environmentVariableName = nameWithFallback;
                    }
                    // Is the environment variable and fallback value defined.
                    if (!env[environmentVariableName] && !fallback) {
                        // No, so trim this line
                        lineShouldBeTrimmed = true;
                        break;
                    }
                }
            }
        }
        if (lineShouldBeTrimmed) {
            // Example output:
            // "; MISSING ENVIRONMENT VARIABLE: //my-registry.com/npm/:_authToken=${MY_AUTH_TOKEN}"
            resultLines.push('; MISSING ENVIRONMENT VARIABLE: ' + line);
        }
        else {
            resultLines.push(line);
        }
    }
    return resultLines;
}
function _copyAndTrimNpmrcFile(options) {
    const { logger, sourceNpmrcPath, targetNpmrcPath } = options;
    logger.info(`Transforming ${sourceNpmrcPath}`); // Verbose
    logger.info(`  --> "${targetNpmrcPath}"`);
    const combinedNpmrc = _trimNpmrcFile(options);
    external_fs_.writeFileSync(targetNpmrcPath, combinedNpmrc);
    return combinedNpmrc;
}
function syncNpmrc(options) {
    const { sourceNpmrcFolder, targetNpmrcFolder, useNpmrcPublish, logger = {
        // eslint-disable-next-line no-console
        info: console.log,
        // eslint-disable-next-line no-console
        error: console.error
    }, createIfMissing = false } = options;
    const sourceNpmrcPath = external_path_.join(sourceNpmrcFolder, !useNpmrcPublish ? '.npmrc' : '.npmrc-publish');
    const targetNpmrcPath = external_path_.join(targetNpmrcFolder, '.npmrc');
    try {
        if (external_fs_.existsSync(sourceNpmrcPath) || createIfMissing) {
            // Ensure the target folder exists
            if (!external_fs_.existsSync(targetNpmrcFolder)) {
                external_fs_.mkdirSync(targetNpmrcFolder, { recursive: true });
            }
            return _copyAndTrimNpmrcFile(Object.assign({ sourceNpmrcPath,
                targetNpmrcPath,
                logger }, options));
        }
        else if (external_fs_.existsSync(targetNpmrcPath)) {
            // If the source .npmrc doesn't exist and there is one in the target, delete the one in the target
            logger.info(`Deleting ${targetNpmrcPath}`); // Verbose
            external_fs_.unlinkSync(targetNpmrcPath);
        }
    }
    catch (e) {
        throw new Error(`Error syncing .npmrc file: ${e}`);
    }
}
function isVariableSetInNpmrcFile(sourceNpmrcFolder, variableKey, supportEnvVarFallbackSyntax) {
    const sourceNpmrcPath = `${sourceNpmrcFolder}/.npmrc`;
    //if .npmrc file does not exist, return false directly
    if (!fs.existsSync(sourceNpmrcPath)) {
        return false;
    }
    const trimmedNpmrcFile = _trimNpmrcFile({ sourceNpmrcPath, supportEnvVarFallbackSyntax });
    const variableKeyRegExp = new RegExp(`^${variableKey}=`, 'm');
    return trimmedNpmrcFile.match(variableKeyRegExp) !== null;
}
//# sourceMappingURL=npmrcUtilities.js.map
// EXTERNAL MODULE: ../../common/temp/default/node_modules/.pnpm/true-case-path@2.2.1/node_modules/true-case-path/index.js
var true_case_path = __webpack_require__("../../common/temp/default/node_modules/.pnpm/true-case-path@2.2.1/node_modules/true-case-path/index.js");
;// ../rush-lib/lib-esnext/api/EnvironmentConfiguration.js
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



/**
 * Names of environment variables used by Rush.
 * @beta
 */
// eslint-disable-next-line @typescript-eslint/typedef
const EnvironmentVariableNames = {
    /**
     * This variable overrides the temporary folder used by Rush.
     * The default value is "common/temp" under the repository root.
     *
     * @remarks This environment variable is not compatible with workspace installs. If attempting
     * to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.
     */
    RUSH_TEMP_FOLDER: 'RUSH_TEMP_FOLDER',
    /**
     * This variable overrides the version of Rush that will be installed by
     * the version selector.  The default value is determined by the "rushVersion"
     * field from rush.json.
     */
    RUSH_PREVIEW_VERSION: 'RUSH_PREVIEW_VERSION',
    /**
     * If this variable is set to "1", Rush will not fail the build when running a version
     * of Node that does not match the criteria specified in the "nodeSupportedVersionRange"
     * field from rush.json.
     */
    RUSH_ALLOW_UNSUPPORTED_NODEJS: 'RUSH_ALLOW_UNSUPPORTED_NODEJS',
    /**
     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`
     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,
     * or `0` to disallow them. (See the comments in the command-line.json file for more information).
     */
    RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: 'RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD',
    /**
     * This variable selects a specific installation variant for Rush to use when installing
     * and linking package dependencies.
     * For more information, see the command-line help for the `--variant` parameter
     * and this article:  https://rushjs.io/pages/advanced/installation_variants/
     */
    RUSH_VARIANT: 'RUSH_VARIANT',
    /**
     * Specifies the maximum number of concurrent processes to launch during a build.
     * For more information, see the command-line help for the `--parallelism` parameter for "rush build".
     */
    RUSH_PARALLELISM: 'RUSH_PARALLELISM',
    /**
     * If this variable is set to "1", Rush will create symlinks with absolute paths instead
     * of relative paths. This can be necessary when a repository is moved during a build or
     * if parts of a repository are moved into a sandbox.
     */
    RUSH_ABSOLUTE_SYMLINKS: 'RUSH_ABSOLUTE_SYMLINKS',
    /**
     * When using PNPM as the package manager, this variable can be used to configure the path that
     * PNPM will use as the store directory.
     *
     * If a relative path is used, then the store path will be resolved relative to the process's
     * current working directory.  An absolute path is recommended.
     */
    RUSH_PNPM_STORE_PATH: 'RUSH_PNPM_STORE_PATH',
    /**
     * When using PNPM as the package manager, this variable can be used to control whether or not PNPM
     * validates the integrity of the PNPM store during installation. The value of this environment variable must be
     * `1` (for true) or `0` (for false). If not specified, defaults to the value in .npmrc.
     */
    RUSH_PNPM_VERIFY_STORE_INTEGRITY: 'RUSH_PNPM_VERIFY_STORE_INTEGRITY',
    /**
     * This environment variable can be used to specify the `--target-folder` parameter
     * for the "rush deploy" command.
     */
    RUSH_DEPLOY_TARGET_FOLDER: 'RUSH_DEPLOY_TARGET_FOLDER',
    /**
     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.
     *
     * @remarks
     *
     * Most of the temporary files created by Rush are stored separately for each monorepo working folder,
     * to avoid issues of concurrency and compatibility between tool versions.  However, a small set
     * of files (e.g. installations of the `@microsoft/rush-lib` engine and the package manager) are stored
     * in a global folder to speed up installations.  The default location is `~/.rush` on POSIX-like
     * operating systems or `C:\Users\YourName` on Windows.
     *
     * Use `RUSH_GLOBAL_FOLDER` to specify a different folder path.  This is useful for example if a Windows
     * group policy forbids executing scripts installed in a user's home directory.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    RUSH_GLOBAL_FOLDER: 'RUSH_GLOBAL_FOLDER',
    /**
     * Provides a credential for a remote build cache, if configured.  This credential overrides any cached credentials.
     *
     * @remarks
     * Setting this environment variable overrides whatever credential has been saved in the
     * local cloud cache credentials using `rush update-cloud-credentials`.
     *
     *
     * If Azure Blob Storage is used to store cache entries, this must be a SAS token serialized as query
     * parameters.
     *
     * For information on SAS tokens, see here: https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview
     */
    RUSH_BUILD_CACHE_CREDENTIAL: 'RUSH_BUILD_CACHE_CREDENTIAL',
    /**
     * Setting this environment variable overrides the value of `buildCacheEnabled` in the `build-cache.json`
     * configuration file.
     *
     * @remarks
     * Specify `1` to enable the build cache or `0` to disable it.
     *
     * If there is no build cache configured, then this environment variable is ignored.
     */
    RUSH_BUILD_CACHE_ENABLED: 'RUSH_BUILD_CACHE_ENABLED',
    /**
     * Overrides the value of `isCacheWriteAllowed` in the `build-cache.json` configuration file. The value of this
     * environment variable must be `1` (for true) or `0` (for false). If there is no build cache configured, then
     * this environment variable is ignored.
     */
    RUSH_BUILD_CACHE_WRITE_ALLOWED: 'RUSH_BUILD_CACHE_WRITE_ALLOWED',
    /**
     * Setting this environment variable opts into running with cobuilds. The context id should be the same across
     * multiple VMs, but changed when it is a new round of cobuilds.
     *
     * e.g. `Build.BuildNumber` in Azure DevOps Pipeline.
     *
     * @remarks
     * If there is no cobuild configured, then this environment variable is ignored.
     */
    RUSH_COBUILD_CONTEXT_ID: 'RUSH_COBUILD_CONTEXT_ID',
    /**
     * Explicitly specifies a name for each participating cobuild runner.
     *
     * Setting this environment variable opts into running with cobuilds.
     *
     * @remarks
     * This environment variable is optional, if it is not provided, a random id is used.
     *
     * If there is no cobuild configured, then this environment variable is ignored.
     */
    RUSH_COBUILD_RUNNER_ID: 'RUSH_COBUILD_RUNNER_ID',
    /**
     * If this variable is set to "1", When getting distributed builds, Rush will automatically handle the leaf project
     * with build cache "disabled" by writing to the cache in a special "log files only mode". This is useful when you
     * want to use Cobuilds to improve the performance in CI validations and the leaf projects have not enabled cache.
     */
    RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: 'RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED',
    /**
     * Explicitly specifies the path for the Git binary that is invoked by certain Rush operations.
     */
    RUSH_GIT_BINARY_PATH: 'RUSH_GIT_BINARY_PATH',
    /**
     * Explicitly specifies the path for the `tar` binary that is invoked by certain Rush operations.
     */
    RUSH_TAR_BINARY_PATH: 'RUSH_TAR_BINARY_PATH',
    /**
     * Internal variable used by `rushx` when recursively invoking another `rushx` process, to avoid
     * nesting event hooks.
     */
    _RUSH_RECURSIVE_RUSHX_CALL: '_RUSH_RECURSIVE_RUSHX_CALL',
    /**
     * Internal variable that explicitly specifies the path for the version of `@microsoft/rush-lib` being executed.
     * Will be set upon loading Rush.
     */
    _RUSH_LIB_PATH: '_RUSH_LIB_PATH',
    /**
     * When Rush executes shell scripts, it sometimes changes the working directory to be a project folder or
     * the repository root folder.  The original working directory (where the Rush command was invoked) is assigned
     * to the the child process's `RUSH_INVOKED_FOLDER` environment variable, in case it is needed by the script.
     *
     * @remarks
     * The `RUSH_INVOKED_FOLDER` variable is the same idea as the `INIT_CWD` variable that package managers
     * assign when they execute lifecycle scripts.
     */
    RUSH_INVOKED_FOLDER: 'RUSH_INVOKED_FOLDER',
    /**
     * When running a hook script, this environment variable communicates the original arguments
     * passed to the `rush` or `rushx` command.
     *
     * @remarks
     * Unlike `RUSH_INVOKED_FOLDER`, the `RUSH_INVOKED_ARGS` variable is only available for hook scripts.
     * Other lifecycle scripts should not make assumptions about Rush's command line syntax
     * if Rush did not explicitly pass along command-line parameters to their process.
     */
    RUSH_INVOKED_ARGS: 'RUSH_INVOKED_ARGS'
};
/**
 * Provides Rush-specific environment variable data. All Rush environment variables must start with "RUSH_". This class
 * is designed to be used by RushConfiguration.
 * @beta
 *
 * @remarks
 * Initialize will throw if any unknown parameters are present.
 */
class EnvironmentConfiguration {
    /**
     * An override for the common/temp folder path.
     */
    static get rushTempFolderOverride() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._rushTempFolderOverride;
    }
    /**
     * If "1", create symlinks with absolute paths instead of relative paths.
     * See {@link EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS}
     */
    static get absoluteSymlinks() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._absoluteSymlinks;
    }
    /**
     * If this environment variable is set to "1", the Node.js version check will print a warning
     * instead of causing a hard error if the environment's Node.js version doesn't match the
     * version specifier in `rush.json`'s "nodeSupportedVersionRange" property.
     *
     * See {@link EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS}.
     */
    static get allowUnsupportedNodeVersion() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._allowUnsupportedNodeVersion;
    }
    /**
     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`
     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,
     * or `0` to disallow them. (See the comments in the command-line.json file for more information).
     */
    static get allowWarningsInSuccessfulBuild() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._allowWarningsInSuccessfulBuild;
    }
    /**
     * An override for the PNPM store path, if `pnpmStore` configuration is set to 'path'
     * See {@link EnvironmentVariableNames.RUSH_PNPM_STORE_PATH}
     */
    static get pnpmStorePathOverride() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._pnpmStorePathOverride;
    }
    /**
     * If specified, enables or disables integrity verification of the pnpm store during install.
     * See {@link EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY}
     */
    static get pnpmVerifyStoreIntegrity() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._pnpmVerifyStoreIntegrity;
    }
    /**
     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.
     * See {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER}
     */
    static get rushGlobalFolderOverride() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._rushGlobalFolderOverride;
    }
    /**
     * Provides a credential for reading from and writing to a remote build cache, if configured.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL}
     */
    static get buildCacheCredential() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._buildCacheCredential;
    }
    /**
     * If set, enables or disables the cloud build cache feature.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED}
     */
    static get buildCacheEnabled() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._buildCacheEnabled;
    }
    /**
     * If set, enables or disables writing to the cloud build cache.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED}
     */
    static get buildCacheWriteAllowed() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._buildCacheWriteAllowed;
    }
    /**
     * Provides a determined cobuild context id if configured
     * See {@link EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID}
     */
    static get cobuildContextId() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._cobuildContextId;
    }
    /**
     * Provides a determined cobuild runner id if configured
     * See {@link EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID}
     */
    static get cobuildRunnerId() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._cobuildRunnerId;
    }
    /**
     * If set, enables or disables the cobuild leaf project log only feature.
     * See {@link EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED}
     */
    static get cobuildLeafProjectLogOnlyAllowed() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._cobuildLeafProjectLogOnlyAllowed;
    }
    /**
     * Allows the git binary path to be explicitly provided.
     * See {@link EnvironmentVariableNames.RUSH_GIT_BINARY_PATH}
     */
    static get gitBinaryPath() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._gitBinaryPath;
    }
    /**
     * Allows the tar binary path to be explicitly provided.
     * See {@link EnvironmentVariableNames.RUSH_TAR_BINARY_PATH}
     */
    static get tarBinaryPath() {
        EnvironmentConfiguration._ensureValidated();
        return EnvironmentConfiguration._tarBinaryPath;
    }
    /**
     * The front-end RushVersionSelector relies on `RUSH_GLOBAL_FOLDER`, so its value must be read before
     * `EnvironmentConfiguration` is initialized (and actually before the correct version of `EnvironmentConfiguration`
     * is even installed). Thus we need to read this environment variable differently from all the others.
     * @internal
     */
    static _getRushGlobalFolderOverride(processEnv) {
        const value = processEnv[EnvironmentVariableNames.RUSH_GLOBAL_FOLDER];
        if (value) {
            const normalizedValue = EnvironmentConfiguration._normalizeDeepestParentFolderPath(value);
            return normalizedValue;
        }
    }
    /**
     * Reads and validates environment variables. If any are invalid, this function will throw.
     */
    static validate(options = {}) {
        var _a, _b, _c;
        EnvironmentConfiguration.reset();
        const unknownEnvVariables = [];
        for (const envVarName in process.env) {
            if (process.env.hasOwnProperty(envVarName) && envVarName.match(/^RUSH_/i)) {
                const value = process.env[envVarName];
                // Environment variables are only case-insensitive on Windows
                const normalizedEnvVarName = external_os_.platform() === 'win32' ? envVarName.toUpperCase() : envVarName;
                switch (normalizedEnvVarName) {
                    case EnvironmentVariableNames.RUSH_TEMP_FOLDER: {
                        EnvironmentConfiguration._rushTempFolderOverride =
                            value && !options.doNotNormalizePaths
                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value
                                : value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS: {
                        EnvironmentConfiguration._absoluteSymlinks =
                            (_a = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS, value)) !== null && _a !== void 0 ? _a : false;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS: {
                        if (value === 'true' || value === 'false') {
                            // Small, undocumented acceptance of old "true" and "false" values for
                            // users of RUSH_ALLOW_UNSUPPORTED_NODEJS in rush pre-v5.46.
                            EnvironmentConfiguration._allowUnsupportedNodeVersion = value === 'true';
                        }
                        else {
                            EnvironmentConfiguration._allowUnsupportedNodeVersion =
                                (_b = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS, value)) !== null && _b !== void 0 ? _b : false;
                        }
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: {
                        EnvironmentConfiguration._allowWarningsInSuccessfulBuild =
                            (_c = EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD, value)) !== null && _c !== void 0 ? _c : false;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_PNPM_STORE_PATH: {
                        EnvironmentConfiguration._pnpmStorePathOverride =
                            value && !options.doNotNormalizePaths
                                ? EnvironmentConfiguration._normalizeDeepestParentFolderPath(value) || value
                                : value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY: {
                        EnvironmentConfiguration._pnpmVerifyStoreIntegrity =
                            value === '1' ? true : value === '0' ? false : undefined;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_GLOBAL_FOLDER: {
                        // Handled specially below
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL: {
                        EnvironmentConfiguration._buildCacheCredential = value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED: {
                        EnvironmentConfiguration._buildCacheEnabled =
                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED, value);
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED: {
                        EnvironmentConfiguration._buildCacheWriteAllowed =
                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED, value);
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID: {
                        EnvironmentConfiguration._cobuildContextId = value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID: {
                        EnvironmentConfiguration._cobuildRunnerId = value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: {
                        EnvironmentConfiguration._cobuildLeafProjectLogOnlyAllowed =
                            EnvironmentConfiguration.parseBooleanEnvironmentVariable(EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED, value);
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_GIT_BINARY_PATH: {
                        EnvironmentConfiguration._gitBinaryPath = value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_TAR_BINARY_PATH: {
                        EnvironmentConfiguration._tarBinaryPath = value;
                        break;
                    }
                    case EnvironmentVariableNames.RUSH_PARALLELISM:
                    case EnvironmentVariableNames.RUSH_PREVIEW_VERSION:
                    case EnvironmentVariableNames.RUSH_VARIANT:
                    case EnvironmentVariableNames.RUSH_DEPLOY_TARGET_FOLDER:
                        // Handled by @microsoft/rush front end
                        break;
                    case EnvironmentVariableNames.RUSH_INVOKED_FOLDER:
                    case EnvironmentVariableNames.RUSH_INVOKED_ARGS:
                    case EnvironmentVariableNames._RUSH_LIB_PATH:
                        // Assigned by Rush itself
                        break;
                    case EnvironmentVariableNames._RUSH_RECURSIVE_RUSHX_CALL:
                        // Assigned/read internally by RushXCommandLine
                        break;
                    default:
                        unknownEnvVariables.push(envVarName);
                        break;
                }
            }
        }
        // This strictness intends to catch mistakes where variables are misspelled or not used correctly.
        if (unknownEnvVariables.length > 0) {
            throw new Error('The following environment variables were found with the "RUSH_" prefix, but they are not ' +
                `recognized by this version of Rush: ${unknownEnvVariables.join(', ')}`);
        }
        // See doc comment for EnvironmentConfiguration._getRushGlobalFolderOverride().
        EnvironmentConfiguration._rushGlobalFolderOverride =
            EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);
        EnvironmentConfiguration._hasBeenValidated = true;
    }
    /**
     * Resets EnvironmentConfiguration into an un-initialized state.
     */
    static reset() {
        EnvironmentConfiguration._rushTempFolderOverride = undefined;
        EnvironmentConfiguration._hasBeenValidated = false;
    }
    static _ensureValidated() {
        if (!EnvironmentConfiguration._hasBeenValidated) {
            EnvironmentConfiguration.validate();
        }
    }
    static parseBooleanEnvironmentVariable(name, value) {
        if (value === '' || value === undefined) {
            return undefined;
        }
        else if (value === '0') {
            return false;
        }
        else if (value === '1') {
            return true;
        }
        else {
            throw new Error(`Invalid value "${value}" for the environment variable ${name}. Valid choices are 0 or 1.`);
        }
    }
    /**
     * Given a path to a folder (that may or may not exist), normalize the path, including casing,
     * to the first existing parent folder in the path.
     *
     * If no existing path can be found (for example, if the root is a volume that doesn't exist),
     * this function returns undefined.
     *
     * @example
     * If the following path exists on disk: `C:\Folder1\folder2\`
     * _normalizeFirstExistingFolderPath('c:\\folder1\\folder2\\temp\\subfolder')
     * returns 'C:\\Folder1\\folder2\\temp\\subfolder'
     */
    static _normalizeDeepestParentFolderPath(folderPath) {
        folderPath = external_path_.normalize(folderPath);
        const endsWithSlash = folderPath.charAt(folderPath.length - 1) === external_path_.sep;
        const parsedPath = external_path_.parse(folderPath);
        const pathRoot = parsedPath.root;
        const pathWithoutRoot = parsedPath.dir.substr(pathRoot.length);
        const pathParts = [...pathWithoutRoot.split(external_path_.sep), parsedPath.name].filter((part) => !!part);
        // Starting with all path sections, and eliminating one from the end during each loop iteration,
        // run trueCasePathSync. If trueCasePathSync returns without exception, we've found a subset
        // of the path that exists and we've now gotten the correct casing.
        //
        // Once we've found a parent folder that exists, append the path sections that didn't exist.
        for (let i = pathParts.length; i >= 0; i--) {
            const constructedPath = external_path_.join(pathRoot, ...pathParts.slice(0, i));
            try {
                const normalizedConstructedPath = (0,true_case_path.trueCasePathSync)(constructedPath);
                const result = external_path_.join(normalizedConstructedPath, ...pathParts.slice(i));
                if (endsWithSlash) {
                    return `${result}${external_path_.sep}`;
                }
                else {
                    return result;
                }
            }
            catch (e) {
                // This path doesn't exist, continue to the next subpath
            }
        }
        return undefined;
    }
}
EnvironmentConfiguration._hasBeenValidated = false;
EnvironmentConfiguration._absoluteSymlinks = false;
EnvironmentConfiguration._allowUnsupportedNodeVersion = false;
EnvironmentConfiguration._allowWarningsInSuccessfulBuild = false;
//# sourceMappingURL=EnvironmentConfiguration.js.map
;// ../rush-lib/lib-esnext/logic/RushConstants.js
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
/**
 * Constants used by the Rush tool.
 * @beta
 *
 * @remarks
 *
 * These are NOT part of the public API surface for rush-lib.
 * The rationale is that we don't want people implementing custom parsers for
 * the Rush config files; instead, they should rely on the official APIs from rush-lib.
 */
class RushConstants {
}
/**
 * The filename ("rush.json") for the root-level configuration file.
 */
RushConstants.rushJsonFilename = 'rush.json';
/**
 * The filename ("browser-approved-packages.json") for an optional policy configuration file
 * that stores a list of NPM packages that have been approved for usage by Rush projects.
 * This is part of a pair of config files, one for projects that run in a web browser
 * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else
 * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).
 */
RushConstants.browserApprovedPackagesFilename = 'browser-approved-packages.json';
/**
 * The folder name ("changes") where change files will be stored.
 */
RushConstants.changeFilesFolderName = 'changes';
/**
 * The filename ("nonbrowser-approved-packages.json") for an optional policy configuration file
 * that stores a list of NPM packages that have been approved for usage by Rush projects.
 * This is part of a pair of config files, one for projects that run in a web browser
 * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else
 * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).
 */
RushConstants.nonbrowserApprovedPackagesFilename = 'nonbrowser-approved-packages.json';
/**
 * The folder name ("common") where Rush's common data will be stored.
 */
RushConstants.commonFolderName = 'common';
/**
 * The NPM scope ("\@rush-temp") that is used for Rush's temporary projects.
 */
RushConstants.rushTempNpmScope = '@rush-temp';
/**
 * The folder name ("variants") under which named variant configurations for
 * alternate dependency sets may be found.
 * Example: `C:\MyRepo\common\config\rush\variants`
 */
RushConstants.rushVariantsFolderName = 'variants';
/**
 * The folder name ("temp") under the common folder, or under the .rush folder in each project's directory where
 * temporary files will be stored.
 * Example: `C:\MyRepo\common\temp`
 */
RushConstants.rushTempFolderName = 'temp';
/**
 * The folder name ("projects") where temporary projects will be stored.
 * Example: `C:\MyRepo\common\temp\projects`
 */
RushConstants.rushTempProjectsFolderName = 'projects';
/**
 * The filename ("npm-shrinkwrap.json") used to store an installation plan for the NPM package manger.
 */
RushConstants.npmShrinkwrapFilename = 'npm-shrinkwrap.json';
/**
 * Number of installation attempts
 */
RushConstants.defaultMaxInstallAttempts = 1;
/**
 * The filename ("pnpm-lock.yaml") used to store an installation plan for the PNPM package manger
 * (PNPM version 3.x and later).
 */
RushConstants.pnpmV3ShrinkwrapFilename = 'pnpm-lock.yaml';
/**
 * The filename ("pnpmfile.js") used to add custom configuration to PNPM (PNPM version 1.x and later).
 */
RushConstants.pnpmfileV1Filename = 'pnpmfile.js';
/**
 * The filename (".pnpmfile.cjs") used to add custom configuration to PNPM (PNPM version 6.x and later).
 */
RushConstants.pnpmfileV6Filename = '.pnpmfile.cjs';
/**
 * The filename (".modules.yaml") used by pnpm to specify configurations in the node_modules directory
 */
RushConstants.pnpmModulesFilename = '.modules.yaml';
/**
 * The filename ("global-pnpmfile.cjs") used to add custom configuration to subspaces
 */
RushConstants.pnpmfileGlobalFilename = 'global-pnpmfile.cjs';
/**
 * The folder name used to store patch files for pnpm
 * Example: `C:\MyRepo\common\config\pnpm-patches`
 * Example: `C:\MyRepo\common\temp\patches`
 */
RushConstants.pnpmPatchesFolderName = 'patches';
/**
 * The folder name under `/common/temp` used to store checked-in patches.
 * Example: `C:\MyRepo\common\pnpm-patches`
 */
RushConstants.pnpmPatchesCommonFolderName = `pnpm-${RushConstants.pnpmPatchesFolderName}`;
/**
 * The filename ("shrinkwrap.yaml") used to store state for pnpm
 */
RushConstants.yarnShrinkwrapFilename = 'yarn.lock';
/**
 * The folder name ("node_modules") where NPM installs its packages.
 */
RushConstants.nodeModulesFolderName = 'node_modules';
/**
 * The filename ("pinned-versions.json") for an old configuration file that
 * that is no longer supported.
 *
 * @deprecated This feature has been superseded by the "preferredVersions" setting
 * in common-versions.json
 */
// NOTE: Although this is marked as "deprecated", we will probably never retire it,
// since we always want to report the warning when someone upgrades an old repo.
RushConstants.pinnedVersionsFilename = 'pinned-versions.json';
/**
 * The filename ("common-versions.json") for an optional configuration file
 * that stores dependency version information that affects all projects in the repo.
 * This configuration file should go in the "common/config/rush" folder.
 */
RushConstants.commonVersionsFilename = 'common-versions.json';
/**
 * The filename ("repo-state.json") for a file used by Rush to
 * store the state of various features as they stand in the repo.
 */
RushConstants.repoStateFilename = 'repo-state.json';
/**
 * The filename ("custom-tips.json") for the file used by Rush to
 * print user-customized messages.
 * This configuration file should go in the "common/config/rush" folder.
 */
RushConstants.customTipsFilename = 'custom-tips.json';
/**
 * The name of the per-project folder where project-specific Rush files are stored. For example,
 * the package-deps files, which are used by commands to determine if a particular project needs to be rebuilt.
 */
RushConstants.projectRushFolderName = '.rush';
/**
 * Custom command line configuration file, which is used by rush for implementing
 * custom command and options.
 */
RushConstants.commandLineFilename = 'command-line.json';
RushConstants.versionPoliciesFilename = 'version-policies.json';
/**
 * Experiments configuration file.
 */
RushConstants.experimentsFilename = 'experiments.json';
/**
 * Pnpm configuration file
 */
RushConstants.pnpmConfigFilename = 'pnpm-config.json';
/**
 * Rush plugins configuration file name.
 */
RushConstants.rushPluginsConfigFilename = 'rush-plugins.json';
/**
 * Rush plugin manifest file name.
 */
RushConstants.rushPluginManifestFilename = 'rush-plugin-manifest.json';
/**
 * The artifactory.json configuration file name.
 */
RushConstants.artifactoryFilename = 'artifactory.json';
/**
 * The subspaces.json configuration file name
 */
RushConstants.subspacesConfigFilename = 'subspaces.json';
/**
 * The name of the default subspace if one isn't specified but subspaces is enabled.
 */
RushConstants.defaultSubspaceName = 'default';
/**
 * Build cache configuration file.
 */
RushConstants.buildCacheFilename = 'build-cache.json';
/**
 * Build cache version number, incremented when the logic to create cache entries changes.
 * Changing this ensures that cache entries generated by an old version will no longer register as a cache hit.
 */
RushConstants.buildCacheVersion = 1;
/**
 * Cobuild configuration file.
 */
RushConstants.cobuildFilename = 'cobuild.json';
/**
 * Per-project configuration filename.
 */
RushConstants.rushProjectConfigFilename = 'rush-project.json';
/**
 * The URL ("http://rushjs.io") for the Rush web site.
 */
RushConstants.rushWebSiteUrl = 'https://rushjs.io';
/**
 * The name of the NPM package for the Rush tool ("\@microsoft/rush").
 */
RushConstants.rushPackageName = '@microsoft/rush';
/**
 * The folder name ("rush-recycler") where Rush moves large folder trees
 * before asynchronously deleting them.
 */
RushConstants.rushRecyclerFolderName = 'rush-recycler';
/**
 * The name of the file to drop in project-folder/.rush/temp/ containing a listing of the project's direct
 * and indirect dependencies. This is used to detect if a project's dependencies have changed since the last build.
 */
RushConstants.projectShrinkwrapFilename = 'shrinkwrap-deps.json';
/**
 * The value of the "commandKind" property for a bulk command in command-line.json
 */
RushConstants.bulkCommandKind = 'bulk';
/**
 * The value of the "commandKind" property for a global command in command-line.json
 */
RushConstants.globalCommandKind = 'global';
/**
 * The value of the "commandKind" property for a phased command in command-line.json
 */
RushConstants.phasedCommandKind = 'phased';
/**
 * The name of the incremental build command.
 */
RushConstants.buildCommandName = 'build';
/**
 * The name of the non-incremental build command.
 */
RushConstants.rebuildCommandName = 'rebuild';
RushConstants.updateCloudCredentialsCommandName = 'update-cloud-credentials';
/**
 * When a hash generated that contains multiple input segments, this character may be used
 * to separate them to avoid issues like
 * crypto.createHash('sha1').update('a').update('bc').digest('hex') === crypto.createHash('sha1').update('ab').update('c').digest('hex')
 */
RushConstants.hashDelimiter = '|';
/**
 * The name of the per-user Rush configuration data folder.
 */
RushConstants.rushUserConfigurationFolderName = '.rush-user';
/**
 * The name of the project `rush-logs` folder.
 */
RushConstants.rushLogsFolderName = 'rush-logs';
/**
 * The expected prefix for phase names in "common/config/rush/command-line.json"
 */
RushConstants.phaseNamePrefix = '_phase:';
/**
 * The default debounce value for Rush multi-project watch mode. When watching, controls
 * how long to wait after the last encountered file system event before execution. If another
 * file system event occurs in this interval, the timeout will reset.
 */
RushConstants.defaultWatchDebounceMs = 1000;
/**
 * The name of the parameter that can be used to bypass policies.
 */
RushConstants.bypassPolicyFlagLongName = '--bypass-policy';
/**
 * Merge Queue ignore configuration file.
 */
RushConstants.mergeQueueIgnoreFileName = '.mergequeueignore';
/**
 * The filename ("project-impact-graph.yaml") for the project impact graph file.
 */
RushConstants.projectImpactGraphFilename = 'project-impact-graph.yaml';
/**
 * The filename for the last link flag
 */
RushConstants.lastLinkFlagFilename = 'last-link';
/**
 * The filename for the Rush alerts config file.
 */
RushConstants.rushAlertsConfigFilename = 'rush-alerts.json';
/**
 * The filename for the file that tracks which variant is currently installed.
 */
RushConstants.currentVariantsFilename = 'current-variants.json';
//# sourceMappingURL=RushConstants.js.map
;// ../rush-lib/lib-esnext/utilities/Utilities.js
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.









// eslint-disable-next-line @typescript-eslint/no-redeclare
const UNINITIALIZED = 'UNINITIALIZED';
class Utilities {
    /**
     * Get the user's home directory. On windows this looks something like "C:\users\username\" and on UNIX
     * this looks something like "/home/username/"
     */
    static getHomeFolder() {
        const unresolvedUserFolder = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];
        const dirError = "Unable to determine the current user's home directory";
        if (unresolvedUserFolder === undefined) {
            throw new Error(dirError);
        }
        const homeFolder = external_path_.resolve(unresolvedUserFolder);
        if (!node_core_library_.FileSystem.exists(homeFolder)) {
            throw new Error(dirError);
        }
        return homeFolder;
    }
    /**
     * Node.js equivalent of performance.now().
     */
    static getTimeInMs() {
        return external_perf_hooks_namespaceObject.performance.now();
    }
    /**
     * Retries a function until a timeout is reached. The function is expected to throw if it failed and
     *  should be retried.
     */
    static retryUntilTimeout(fn, maxWaitTimeMs, getTimeoutError, fnName) {
        const startTime = Utilities.getTimeInMs();
        let looped = false;
        let result;
        for (;;) {
            try {
                result = fn();
                break;
            }
            catch (e) {
                looped = true;
                const currentTime = Utilities.getTimeInMs();
                if (currentTime - startTime > maxWaitTimeMs) {
                    throw getTimeoutError(e);
                }
            }
        }
        if (looped) {
            const currentTime = Utilities.getTimeInMs();
            const totalSeconds = ((currentTime - startTime) / 1000.0).toFixed(2);
            // This logging statement isn't meaningful to the end-user. `fnName` should be updated
            // to something like `operationDescription`
            // eslint-disable-next-line no-console
            console.log(`${fnName}() stalled for ${totalSeconds} seconds`);
        }
        return result;
    }
    /**
     * Creates the specified folder by calling FileSystem.ensureFolder(), but using a
     * retry loop to recover from temporary locks that may be held by other processes.
     * If the folder already exists, no error occurs.
     */
    static createFolderWithRetry(folderName) {
        // Note: If a file exists with the same name, then we fall through and report
        // an error.
        if (Utilities.directoryExists(folderName)) {
            return;
        }
        // We need to do a simple "FileSystem.ensureFolder(localModulesFolder)" here,
        // however if the folder we deleted above happened to contain any files,
        // then there seems to be some OS process (virus scanner?) that holds
        // a lock on the folder for a split second, which causes mkdirSync to
        // fail.  To workaround that, retry for up to 7 seconds before giving up.
        const maxWaitTimeMs = 7 * 1000;
        return Utilities.retryUntilTimeout(() => node_core_library_.FileSystem.ensureFolder(folderName), maxWaitTimeMs, (e) => new Error(`Error: ${e}\nOften this is caused by a file lock ` +
            'from a process such as your text editor, command prompt, ' +
            'or a filesystem watcher.'), 'createFolderWithRetry');
    }
    /**
     * Determines if a path points to a directory and that it exists.
     */
    static directoryExists(directoryPath) {
        let exists = false;
        try {
            const lstat = node_core_library_.FileSystem.getLinkStatistics(directoryPath);
            exists = lstat.isDirectory();
        }
        catch (e) {
            /* no-op */
        }
        return exists;
    }
    /**
     * BE VERY CAREFUL CALLING THIS FUNCTION!
     * If you specify the wrong folderPath (e.g. "/"), it could potentially delete your entire
     * hard disk.
     */
    static dangerouslyDeletePath(folderPath) {
        try {
            node_core_library_.FileSystem.deleteFolder(folderPath);
        }
        catch (e) {
            throw new Error(`${e.message}\nOften this is caused by a file lock from a process ` +
                'such as your text editor, command prompt, or a filesystem watcher');
        }
    }
    /*
     * Returns true if dateToCompare is more recent than all of the inputFilenames, which
     * would imply that we don't need to rebuild it. Returns false if any of the files
     * does not exist.
     * NOTE: The filenames can also be paths for directories, in which case the directory
     * timestamp is compared.
     */
    static async isFileTimestampCurrentAsync(dateToCompare, inputFilePaths) {
        let anyAreOutOfDate = false;
        await node_core_library_.Async.forEachAsync(inputFilePaths, async (filePath) => {
            if (!anyAreOutOfDate) {
                let inputStats;
                try {
                    inputStats = await node_core_library_.FileSystem.getStatisticsAsync(filePath);
                }
                catch (e) {
                    if (node_core_library_.FileSystem.isNotExistError(e)) {
                        // eslint-disable-next-line require-atomic-updates
                        anyAreOutOfDate = true;
                    }
                    else {
                        throw e;
                    }
                }
                if (inputStats && dateToCompare < inputStats.mtime) {
                    // eslint-disable-next-line require-atomic-updates
                    anyAreOutOfDate = true;
                }
            }
        }, { concurrency: 10 });
        return !anyAreOutOfDate;
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static async executeCommandAsync({ command, args, workingDirectory, suppressOutput, onStdoutStreamChunk, environment, keepEnvironment, captureExitCodeAndSignal }) {
        const { exitCode, signal } = await Utilities._executeCommandInternalAsync({
            command,
            args,
            workingDirectory,
            stdio: onStdoutStreamChunk
                ? // Inherit the stdin and stderr streams, but pipe the stdout stream, which will then be piped
                    // to the process's stdout after being intercepted by the onStdoutStreamChunk callback.
                    ['inherit', 'pipe', 'inherit']
                : suppressOutput
                    ? // If the output is being suppressed, create pipes for all streams to prevent the child process
                        // from printing to the parent process's (this process's) stdout/stderr, but allow the stdout and
                        // stderr to be inspected if an error occurs.
                        // TODO: Consider ignoring stdout and stdin and only piping stderr for inspection on error.
                        ['pipe', 'pipe', 'pipe']
                    : // If the output is not being suppressed or intercepted, inherit all streams from the parent process.
                        ['inherit', 'inherit', 'inherit'],
            environment,
            keepEnvironment,
            onStdoutStreamChunk,
            captureOutput: false,
            captureExitCodeAndSignal
        });
        if (captureExitCodeAndSignal) {
            return { exitCode, signal };
        }
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static async executeCommandAndCaptureOutputAsync(command, args, workingDirectory, environment, keepEnvironment = false) {
        const { stdout } = await Utilities._executeCommandInternalAsync({
            command,
            args,
            workingDirectory,
            stdio: ['pipe', 'pipe', 'pipe'],
            environment,
            keepEnvironment,
            captureOutput: true
        });
        return stdout;
    }
    /**
     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.
     */
    static async executeCommandWithRetryAsync(options, maxAttempts, retryCallback) {
        if (maxAttempts < 1) {
            throw new Error('The maxAttempts parameter cannot be less than 1');
        }
        let attemptNumber = 1;
        for (;;) {
            try {
                await Utilities.executeCommandAsync(options);
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.log('\nThe command failed:');
                const { command, args } = options;
                // eslint-disable-next-line no-console
                console.log(` ${command} ` + args.join(' '));
                // eslint-disable-next-line no-console
                console.log(`ERROR: ${error.toString()}`);
                if (attemptNumber < maxAttempts) {
                    ++attemptNumber;
                    // eslint-disable-next-line no-console
                    console.log(`Trying again (attempt #${attemptNumber})...\n`);
                    if (retryCallback) {
                        retryCallback();
                    }
                    continue;
                }
                else {
                    // eslint-disable-next-line no-console
                    console.error(`Giving up after ${attemptNumber} attempts\n`);
                    throw error;
                }
            }
            break;
        }
    }
    /**
     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.
     * @param command - the command to run on shell
     * @param options - options for how the command should be run
     */
    static executeLifecycleCommand(command, options) {
        const result = Utilities._executeLifecycleCommandInternal(command, external_child_process_namespaceObject.spawnSync, options);
        if (options.handleOutput) {
            Utilities._processResult({
                error: result.error,
                status: result.status,
                stderr: result.stderr.toString()
            });
        }
        if (result.status !== null) {
            return result.status;
        }
        else {
            throw result.error || new Error('An unknown error occurred.');
        }
    }
    /**
     * Executes the command using cmd if running on windows, or using sh if running on a non-windows OS.
     * @param command - the command to run on shell
     * @param options - options for how the command should be run
     */
    static executeLifecycleCommandAsync(command, options) {
        const child = Utilities._executeLifecycleCommandInternal(command, external_child_process_namespaceObject.spawn, options);
        if (options.connectSubprocessTerminator) {
            node_core_library_.SubprocessTerminator.killProcessTreeOnExit(child, node_core_library_.SubprocessTerminator.RECOMMENDED_OPTIONS);
        }
        return child;
    }
    /**
     * For strings passed to a shell command, this adds appropriate escaping
     * to avoid misinterpretation of spaces or special characters.
     *
     * Example: 'hello there' --> '"hello there"'
     */
    static escapeShellParameter(parameter) {
        // This approach is based on what NPM 7 now does:
        // https://github.com/npm/run-script/blob/47a4d539fb07220e7215cc0e482683b76407ef9b/lib/run-script-pkg.js#L34
        return JSON.stringify(parameter);
    }
    /**
     * Installs a package by name and version in the specified directory.
     */
    static async installPackageInDirectoryAsync({ packageName, version, tempPackageTitle, commonRushConfigFolder, maxInstallAttempts, suppressOutput, directory }) {
        directory = external_path_.resolve(directory);
        const directoryExists = await node_core_library_.FileSystem.existsAsync(directory);
        if (directoryExists) {
            // eslint-disable-next-line no-console
            console.log('Deleting old files from ' + directory);
        }
        await node_core_library_.FileSystem.ensureEmptyFolderAsync(directory);
        const npmPackageJson = {
            dependencies: {
                [packageName]: version
            },
            description: 'Temporary file generated by the Rush tool',
            name: tempPackageTitle,
            private: true,
            version: '0.0.0'
        };
        await node_core_library_.JsonFile.saveAsync(npmPackageJson, external_path_.join(directory, node_core_library_.FileConstants.PackageJson));
        if (commonRushConfigFolder) {
            Utilities.syncNpmrc({
                sourceNpmrcFolder: commonRushConfigFolder,
                targetNpmrcFolder: directory,
                supportEnvVarFallbackSyntax: false
            });
        }
        // eslint-disable-next-line no-console
        console.log('\nRunning "npm install" in ' + directory);
        // NOTE: Here we use whatever version of NPM we happen to find in the PATH
        await Utilities.executeCommandWithRetryAsync({
            command: 'npm',
            args: ['install'],
            workingDirectory: directory,
            environment: Utilities._createEnvironmentForRushCommand({}),
            suppressOutput
        }, maxInstallAttempts);
    }
    /**
     * Copies the file "sourcePath" to "destinationPath", overwriting the target file location.
     * If the source file does not exist, then the target file is deleted.
     */
    static syncFile(sourcePath, destinationPath) {
        if (node_core_library_.FileSystem.exists(sourcePath)) {
            // eslint-disable-next-line no-console
            console.log(`Copying "${sourcePath}"`);
            // eslint-disable-next-line no-console
            console.log(`  --> "${destinationPath}"`);
            node_core_library_.FileSystem.copyFile({ sourcePath, destinationPath });
        }
        else {
            if (node_core_library_.FileSystem.exists(destinationPath)) {
                // If the source file doesn't exist and there is one in the target, delete the one in the target
                // eslint-disable-next-line no-console
                console.log(`Deleting ${destinationPath}`);
                node_core_library_.FileSystem.deleteFile(destinationPath);
            }
        }
    }
    static getRushConfigNotFoundError() {
        return new Error(`Unable to find ${RushConstants.rushJsonFilename} configuration file`);
    }
    static async usingAsync(getDisposableAsync, doActionAsync) {
        let disposable;
        try {
            disposable = (await getDisposableAsync());
            await doActionAsync(disposable);
        }
        finally {
            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
        }
    }
    static trimAfterLastSlash(filePath) {
        const indexOfLastSlash = Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\'));
        if (indexOfLastSlash < 0) {
            return filePath;
        }
        return filePath.substring(0, indexOfLastSlash);
    }
    /**
     * If the path refers to a symlink, `FileSystem.exists()` would normally test whether the symlink
     * points to a target that exists. By contrast, `existsOrIsBrokenSymlink()` will return true even if
     * the symlink exists but its target does not. */
    static existsOrIsSymlink(linkPath) {
        try {
            node_core_library_.FileSystem.getLinkStatistics(linkPath);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    static _executeLifecycleCommandInternal(command, spawnFunction, options) {
        var _a;
        let shellCommand = process.env.comspec || 'cmd';
        let commandFlags = '/d /s /c';
        let useShell = true;
        if (process.platform !== 'win32') {
            shellCommand = 'sh';
            commandFlags = '-c';
            useShell = false;
        }
        const environment = Utilities._createEnvironmentForRushCommand({
            initCwd: options.initCwd,
            initialEnvironment: options.initialEnvironment,
            pathOptions: Object.assign(Object.assign({}, options.environmentPathOptions), { rushJsonFolder: (_a = options.rushConfiguration) === null || _a === void 0 ? void 0 : _a.rushJsonFolder, projectRoot: options.workingDirectory, commonTempFolder: options.rushConfiguration ? options.rushConfiguration.commonTempFolder : undefined })
        });
        const stdio = options.handleOutput ? ['pipe', 'pipe', 'pipe'] : [0, 1, 2];
        if (options.ipc) {
            stdio.push('ipc');
        }
        const spawnOptions = {
            cwd: options.workingDirectory,
            shell: useShell,
            env: environment,
            stdio
        };
        if (options.connectSubprocessTerminator) {
            Object.assign(spawnOptions, node_core_library_.SubprocessTerminator.RECOMMENDED_OPTIONS);
        }
        return spawnFunction(shellCommand, [commandFlags, command], spawnOptions);
    }
    /**
     * Returns a process.env environment suitable for executing lifecycle scripts.
     * @param initialEnvironment - an existing environment to copy instead of process.env
     *
     * @remarks
     * Rush._assignRushInvokedFolder() assigns the `RUSH_INVOKED_FOLDER` variable globally
     * via the parent process's environment.
     */
    static _createEnvironmentForRushCommand(options) {
        var _a;
        if (options.initialEnvironment === undefined) {
            options.initialEnvironment = process.env;
        }
        // Set some defaults for the environment
        const environment = {};
        if ((_a = options.pathOptions) === null || _a === void 0 ? void 0 : _a.rushJsonFolder) {
            environment.RUSHSTACK_FILE_ERROR_BASE_FOLDER = options.pathOptions.rushJsonFolder;
        }
        for (const key of Object.getOwnPropertyNames(options.initialEnvironment)) {
            const normalizedKey = external_os_.platform() === 'win32' ? key.toUpperCase() : key;
            // If Rush itself was invoked inside a lifecycle script, this may be set and would interfere
            // with Rush's installations.  If we actually want it, we will set it explicitly below.
            if (normalizedKey === 'INIT_CWD') {
                continue;
            }
            // When NPM invokes a lifecycle event, it copies its entire configuration into environment
            // variables.  Rush is supposed to be a deterministic controlled environment, so don't bring
            // this along.
            //
            // NOTE: Longer term we should clean out the entire environment and use rush.json to bring
            // back specific environment variables that the repo maintainer has determined to be safe.
            if (normalizedKey.match(/^NPM_CONFIG_/)) {
                continue;
            }
            // Use the uppercased environment variable name on Windows because environment variable names
            // are case-insensitive on Windows
            environment[normalizedKey] = options.initialEnvironment[key];
        }
        // When NPM invokes a lifecycle script, it sets an environment variable INIT_CWD that remembers
        // the directory that NPM started in.  This allows naive scripts to change their current working directory
        // and invoke NPM operations, while still be able to find a local .npmrc file.  Although Rush recommends
        // for toolchain scripts to be professionally written (versus brittle stuff like
        // "cd ./lib && npm run tsc && cd .."), we support INIT_CWD for compatibility.
        //
        // More about this feature: https://github.com/npm/npm/pull/12356
        if (options.initCwd) {
            environment['INIT_CWD'] = options.initCwd; // eslint-disable-line dot-notation
        }
        if (options.pathOptions) {
            if (options.pathOptions.includeRepoBin && options.pathOptions.commonTempFolder) {
                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.commonTempFolder);
            }
            if (options.pathOptions.includeProjectBin && options.pathOptions.projectRoot) {
                environment.PATH = Utilities._prependNodeModulesBinToPath(environment.PATH, options.pathOptions.projectRoot);
            }
            if (options.pathOptions.additionalPathFolders) {
                environment.PATH = [...options.pathOptions.additionalPathFolders, environment.PATH].join(external_path_.delimiter);
            }
        }
        // Communicate to downstream calls that they should not try to run hooks
        environment[EnvironmentVariableNames._RUSH_RECURSIVE_RUSHX_CALL] = '1';
        return environment;
    }
    /**
     * Prepend the node_modules/.bin folder under the specified folder to the specified PATH variable. For example,
     * if `rootDirectory` is "/foobar" and `existingPath` is "/bin", this function will return
     * "/foobar/node_modules/.bin:/bin"
     */
    static _prependNodeModulesBinToPath(existingPath, rootDirectory) {
        const binPath = external_path_.resolve(rootDirectory, 'node_modules', '.bin');
        if (existingPath) {
            return `${binPath}${external_path_.delimiter}${existingPath}`;
        }
        else {
            return binPath;
        }
    }
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static async _executeCommandInternalAsync({ command, args, workingDirectory, stdio, environment, keepEnvironment, onStdoutStreamChunk, captureOutput, captureExitCodeAndSignal }) {
        var _a;
        const options = {
            cwd: workingDirectory,
            shell: true,
            stdio: stdio,
            env: keepEnvironment
                ? environment
                : Utilities._createEnvironmentForRushCommand({ initialEnvironment: environment }),
            maxBuffer: 10 * 1024 * 1024 // Set default max buffer size to 10MB
        };
        // This is needed since we specify shell=true below.
        // NOTE: On Windows if we escape "NPM", the spawnSync() function runs something like this:
        //   [ 'C:\\Windows\\system32\\cmd.exe', '/s', '/c', '""NPM" "install""' ]
        //
        // Due to a bug with Windows cmd.exe, the npm.cmd batch file's "%~dp0" variable will
        // return the current working directory instead of the batch file's directory.
        // The workaround is to not escape, npm, i.e. do this instead:
        //   [ 'C:\\Windows\\system32\\cmd.exe', '/s', '/c', '"npm "install""' ]
        //
        // We will come up with a better solution for this when we promote executeCommand()
        // into node-core-library, but for now this hack will unblock people:
        // Only escape the command if it actually contains spaces:
        const escapedCommand = command.indexOf(' ') < 0 ? command : Utilities.escapeShellParameter(command);
        const escapedArgs = args.map((x) => Utilities.escapeShellParameter(x));
        const childProcess = external_child_process_namespaceObject.spawn(escapedCommand, escapedArgs, options);
        if (onStdoutStreamChunk) {
            const inspectStream = new external_stream_namespaceObject.Transform({
                transform: onStdoutStreamChunk
                    ? (chunk, encoding, callback) => {
                        const chunkString = chunk.toString();
                        const updatedChunk = onStdoutStreamChunk(chunkString);
                        callback(undefined, updatedChunk !== null && updatedChunk !== void 0 ? updatedChunk : chunk);
                    }
                    : undefined
            });
            (_a = childProcess.stdout) === null || _a === void 0 ? void 0 : _a.pipe(inspectStream).pipe(process.stdout);
        }
        return await node_core_library_.Executable.waitForExitAsync(childProcess, {
            encoding: captureOutput ? 'utf8' : undefined,
            throwOnNonZeroExitCode: !captureExitCodeAndSignal,
            throwOnSignal: !captureExitCodeAndSignal
        });
    }
    static _processResult({ error, stderr, status }) {
        if (error) {
            error.message += `\n${stderr}`;
            if (status) {
                error.message += `\nExited with status ${status}`;
            }
            throw error;
        }
        if (status) {
            throw new Error(`The command failed with exit code ${status}\n${stderr}`);
        }
    }
}
Utilities.syncNpmrc = syncNpmrc;
//# sourceMappingURL=Utilities.js.map
;// ../rush-lib/lib-esnext/api/RushGlobalFolder.js
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.



/**
 * This class provides global folders that are used for rush's internal install locations.
 *
 * @internal
 */
class RushGlobalFolder {
    constructor() {
        // Because RushGlobalFolder is used by the front-end VersionSelector before EnvironmentConfiguration
        // is initialized, we need to read it using a special internal API.
        const rushGlobalFolderOverride = EnvironmentConfiguration._getRushGlobalFolderOverride(process.env);
        if (rushGlobalFolderOverride !== undefined) {
            this.path = rushGlobalFolderOverride;
        }
        else {
            this.path = external_path_.join(Utilities.getHomeFolder(), '.rush');
        }
        const normalizedNodeVersion = process.version.match(/^[a-z0-9\-\.]+$/i)
            ? process.version
            : 'unknown-version';
        this.nodeSpecificPath = external_path_.join(this.path, `node-${normalizedNodeVersion}`);
    }
}
//# sourceMappingURL=RushGlobalFolder.js.map

/***/ }),

/***/ "./lib-commonjs/helpers.js":
/*!*********************************!*\
  !*** ./lib-commonjs/helpers.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requireRushLibUnderFolderPath = exports._require = exports.tryFindRushJsonLocation = exports.sdkContext = exports.RUSH_LIB_PATH_ENV_VAR_NAME = exports.RUSH_LIB_NAME = void 0;
const path = __importStar(__webpack_require__(/*! path */ "path"));
const node_core_library_1 = __webpack_require__(/*! @rushstack/node-core-library */ "@rushstack/node-core-library");
exports.RUSH_LIB_NAME = '@microsoft/rush-lib';
exports.RUSH_LIB_PATH_ENV_VAR_NAME = '_RUSH_LIB_PATH';
exports.sdkContext = {
    rushLibModule: undefined
};
/**
 * Find the rush.json location and return the path, or undefined if a rush.json can't be found.
 *
 * @privateRemarks
 * Keep this in sync with `RushConfiguration.tryFindRushJsonLocation`.
 */
function tryFindRushJsonLocation(startingFolder) {
    let currentFolder = startingFolder;
    // Look upwards at parent folders until we find a folder containing rush.json
    for (let i = 0; i < 10; ++i) {
        const rushJsonFilename = path.join(currentFolder, 'rush.json');
        if (node_core_library_1.FileSystem.exists(rushJsonFilename)) {
            return rushJsonFilename;
        }
        const parentFolder = path.dirname(currentFolder);
        if (parentFolder === currentFolder) {
            break;
        }
        currentFolder = parentFolder;
    }
    return undefined;
}
exports.tryFindRushJsonLocation = tryFindRushJsonLocation;
function _require(moduleName) {
    if (typeof require === 'function') {
        // If this library has been bundled with Webpack, we need to call the real `require` function
        // that doesn't get turned into a `__webpack_require__` statement.
        // `__non_webpack_require__` is a Webpack macro that gets turned into a `require` statement
        // during bundling.
        return require(moduleName);
    }
    else {
        return require(moduleName);
    }
}
exports._require = _require;
/**
 * Require `@microsoft/rush-lib` under the specified folder path.
 */
function requireRushLibUnderFolderPath(folderPath) {
    const rushLibModulePath = node_core_library_1.Import.resolveModule({
        modulePath: exports.RUSH_LIB_NAME,
        baseFolderPath: folderPath
    });
    return _require(rushLibModulePath);
}
exports.requireRushLibUnderFolderPath = requireRushLibUnderFolderPath;
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ "./lib-commonjs/index.js":
/*!*******************************!*\
  !*** ./lib-commonjs/index.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);

// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._rushSdk_loadInternalModule = void 0;
const path = __importStar(__webpack_require__(/*! path */ "path"));
const node_core_library_1 = __webpack_require__(/*! @rushstack/node-core-library */ "@rushstack/node-core-library");
const terminal_1 = __webpack_require__(/*! @rushstack/terminal */ "@rushstack/terminal");
const RushGlobalFolder_1 = __webpack_require__(/*! @microsoft/rush-lib/lib-esnext/api/RushGlobalFolder */ "../rush-lib/lib-esnext/api/RushGlobalFolder.js");
const helpers_1 = __webpack_require__(/*! ./helpers */ "./lib-commonjs/helpers.js");
const verboseEnabled = typeof process !== 'undefined' &&
    (process.env.RUSH_SDK_DEBUG === '1' || process.env._RUSH_SDK_DEBUG === '1');
const terminal = new terminal_1.Terminal(new terminal_1.ConsoleTerminalProvider({
    verboseEnabled
}));
let errorMessage = '';
// SCENARIO 1:  Rush's PluginManager has initialized "rush-sdk" with Rush's own instance of rush-lib.
// The Rush host process will assign "global.___rush___rushLibModule" before loading the plugin.
if (helpers_1.sdkContext.rushLibModule === undefined) {
    helpers_1.sdkContext.rushLibModule =
        global.___rush___rushLibModule ||
            global.___rush___rushLibModuleFromEnvironment ||
            global.___rush___rushLibModuleFromRushGlobalFolder ||
            global.___rush___rushLibModuleFromInstallAndRunRush;
}
// SCENARIO 2:  The project importing "rush-sdk" has installed its own instance of "rush-lib"
// as a package.json dependency.  For example, this is used by the Jest tests for Rush plugins.
if (helpers_1.sdkContext.rushLibModule === undefined) {
    const importingPath = (_a = module === null || module === void 0 ? void 0 : module.parent) === null || _a === void 0 ? void 0 : _a.filename;
    if (importingPath) {
        const callerPackageFolder = node_core_library_1.PackageJsonLookup.instance.tryGetPackageFolderFor(importingPath);
        if (callerPackageFolder !== undefined) {
            const callerPackageJson = (0, helpers_1._require)(path.join(callerPackageFolder, 'package.json'));
            // Does the caller properly declare a dependency on rush-lib?
            if ((callerPackageJson.dependencies && callerPackageJson.dependencies[helpers_1.RUSH_LIB_NAME] !== undefined) ||
                (callerPackageJson.devDependencies &&
                    callerPackageJson.devDependencies[helpers_1.RUSH_LIB_NAME] !== undefined) ||
                (callerPackageJson.peerDependencies &&
                    callerPackageJson.peerDependencies[helpers_1.RUSH_LIB_NAME] !== undefined)) {
                // Try to resolve rush-lib from the caller's folder
                terminal.writeVerboseLine(`Try to load ${helpers_1.RUSH_LIB_NAME} from caller package`);
                try {
                    helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(callerPackageFolder);
                }
                catch (error) {
                    // If we fail to resolve it, ignore the error
                    terminal.writeVerboseLine(`Failed to load ${helpers_1.RUSH_LIB_NAME} from caller package`);
                }
                // If two different libraries invoke `rush-sdk`, and one of them provides "rush-lib"
                // then the first version to be loaded wins.  We do not support side-by-side instances of "rush-lib".
                if (helpers_1.sdkContext.rushLibModule !== undefined) {
                    // to track which scenario is active and how it got initialized.
                    global.___rush___rushLibModule = helpers_1.sdkContext.rushLibModule;
                    terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} from caller`);
                }
            }
        }
    }
}
// SCENARIO 3: A tool or script has been invoked as a child process by an instance of "rush-lib" and can use the
// version that invoked it. In this case, use process.env._RUSH_LIB_PATH to find "rush-lib".
if (helpers_1.sdkContext.rushLibModule === undefined) {
    const rushLibPath = process.env[helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME];
    if (rushLibPath) {
        terminal.writeVerboseLine(`Try to load ${helpers_1.RUSH_LIB_NAME} from process.env.${helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME} from caller package`);
        try {
            helpers_1.sdkContext.rushLibModule = (0, helpers_1._require)(rushLibPath);
        }
        catch (error) {
            // Log this as a warning, since it is unexpected to define an incorrect value of the variable.
            terminal.writeWarningLine(`Failed to load ${helpers_1.RUSH_LIB_NAME} via process.env.${helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME}`);
        }
        if (helpers_1.sdkContext.rushLibModule !== undefined) {
            // to track which scenario is active and how it got initialized.
            global.___rush___rushLibModuleFromEnvironment = helpers_1.sdkContext.rushLibModule;
            terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} from process.env.${helpers_1.RUSH_LIB_PATH_ENV_VAR_NAME}`);
        }
    }
}
// SCENARIO 4:  A standalone tool or script depends on "rush-sdk", and is meant to be used inside a monorepo folder.
// In this case, we can first load the rush-lib version in rush global folder. If the expected version is not installed,
// using install-run-rush.js to obtain the appropriate rush-lib version for the monorepo.
if (helpers_1.sdkContext.rushLibModule === undefined) {
    try {
        const rushJsonPath = (0, helpers_1.tryFindRushJsonLocation)(process.cwd());
        if (!rushJsonPath) {
            throw new Error('Unable to find rush.json in the current folder or its parent folders.\n' +
                'This tool is meant to be invoked from a working directory inside a Rush repository.');
        }
        const monorepoRoot = path.dirname(rushJsonPath);
        const rushJson = node_core_library_1.JsonFile.load(rushJsonPath);
        const { rushVersion } = rushJson;
        try {
            terminal.writeVerboseLine(`Try to load ${helpers_1.RUSH_LIB_NAME} from rush global folder`);
            const rushGlobalFolder = new RushGlobalFolder_1.RushGlobalFolder();
            // The path needs to keep align with the logic inside RushVersionSelector
            const expectedGlobalRushInstalledFolder = `${rushGlobalFolder.nodeSpecificPath}/rush-${rushVersion}`;
            terminal.writeVerboseLine(`The expected global rush installed folder is "${expectedGlobalRushInstalledFolder}"`);
            helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(expectedGlobalRushInstalledFolder);
        }
        catch (e) {
            terminal.writeVerboseLine(`Failed to load ${helpers_1.RUSH_LIB_NAME} from rush global folder: ${e.message}`);
        }
        if (helpers_1.sdkContext.rushLibModule !== undefined) {
            // to track which scenario is active and how it got initialized.
            global.___rush___rushLibModuleFromRushGlobalFolder = helpers_1.sdkContext.rushLibModule;
            terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} installed from rush global folder`);
        }
        else {
            const installRunNodeModuleFolder = `${monorepoRoot}/common/temp/install-run/@microsoft+rush@${rushVersion}`;
            try {
                // First, try to load the version of "rush-lib" that was installed by install-run-rush.js
                terminal.writeVerboseLine(`Trying to load  ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush`);
                helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(installRunNodeModuleFolder);
            }
            catch (e1) {
                let installAndRunRushStderrContent = '';
                try {
                    const installAndRunRushJSPath = `${monorepoRoot}/common/scripts/install-run-rush.js`;
                    terminal.writeLine('The Rush engine has not been installed yet. Invoking install-run-rush.js...');
                    const installAndRunRushProcess = node_core_library_1.Executable.spawnSync('node', [installAndRunRushJSPath, '--help'], {
                        stdio: 'pipe'
                    });
                    installAndRunRushStderrContent = installAndRunRushProcess.stderr;
                    if (installAndRunRushProcess.status !== 0) {
                        throw new Error(`The ${helpers_1.RUSH_LIB_NAME} package failed to install`);
                    }
                    // Retry to load "rush-lib" after install-run-rush run
                    terminal.writeVerboseLine(`Trying to load  ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush a second time`);
                    helpers_1.sdkContext.rushLibModule = (0, helpers_1.requireRushLibUnderFolderPath)(installRunNodeModuleFolder);
                }
                catch (e2) {
                    // eslint-disable-next-line no-console
                    console.error(`${installAndRunRushStderrContent}`);
                    throw new Error(`The ${helpers_1.RUSH_LIB_NAME} package failed to load`);
                }
            }
            if (helpers_1.sdkContext.rushLibModule !== undefined) {
                // to track which scenario is active and how it got initialized.
                global.___rush___rushLibModuleFromInstallAndRunRush = helpers_1.sdkContext.rushLibModule;
                terminal.writeVerboseLine(`Loaded ${helpers_1.RUSH_LIB_NAME} installed by install-run-rush`);
            }
        }
    }
    catch (e) {
        // no-catch
        errorMessage = e.message;
    }
}
if (helpers_1.sdkContext.rushLibModule === undefined) {
    // This error indicates that a project is trying to import "@rushstack/rush-sdk", but the Rush engine
    // instance cannot be found.  If you are writing Jest tests for a Rush plugin, add "@microsoft/rush-lib"
    // to the devDependencies for your project.
    // eslint-disable-next-line no-console
    console.error(`Error: The @rushstack/rush-sdk package was not able to load the Rush engine:
${errorMessage}
`);
    process.exit(1);
}
// Based on TypeScript's __exportStar()
for (const property in helpers_1.sdkContext.rushLibModule) {
    if (property !== 'default' && !exports.hasOwnProperty(property)) {
        const rushLibModuleForClosure = helpers_1.sdkContext.rushLibModule;
        // Based on TypeScript's __createBinding()
        Object.defineProperty(exports, property, {
            enumerable: true,
            get: function () {
                return rushLibModuleForClosure[property];
            }
        });
    }
}
/**
 * Used by the .js stubs for path-based imports of `@microsoft/rush-lib` internal APIs.
 */
function _rushSdk_loadInternalModule(srcImportPath) {
    if (!exports._RushInternals) {
        throw new Error(`Rush version ${exports.Rush.version} does not support internal API imports via rush-sdk`);
    }
    return exports._RushInternals.loadModule(srcImportPath);
}
exports._rushSdk_loadInternalModule = _rushSdk_loadInternalModule;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "@rushstack/node-core-library":
/*!***********************************************!*\
  !*** external "@rushstack/node-core-library" ***!
  \***********************************************/
/***/ ((module) => {

module.exports = require("@rushstack/node-core-library");

/***/ }),

/***/ "@rushstack/terminal":
/*!**************************************!*\
  !*** external "@rushstack/terminal" ***!
  \**************************************/
/***/ ((module) => {

module.exports = require("@rushstack/terminal");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lib-commonjs/index.js");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=index.js.map