/**
 * A library for writing scripts that interact with the {@link https://rushjs.io/ | Rush} tool.
 * @packageDocumentation
 */

/// <reference types="node" />

import { AsyncParallelHook } from 'tapable';
import { AsyncSeriesBailHook } from 'tapable';
import { AsyncSeriesHook } from 'tapable';
import { AsyncSeriesWaterfallHook } from 'tapable';
import type { CollatedWriter } from '@rushstack/stream-collator';
import type { CommandLineParameter } from '@rushstack/ts-command-line';
import { CommandLineParameterKind } from '@rushstack/ts-command-line';
import { HookMap } from 'tapable';
import { IFileDiffStatus } from '@rushstack/package-deps-hash';
import { IPackageJson } from '@rushstack/node-core-library';
import { IPrefixMatch } from '@rushstack/lookup-by-path';
import { ITerminal } from '@rushstack/terminal';
import { ITerminalProvider } from '@rushstack/terminal';
import { JsonNull } from '@rushstack/node-core-library';
import { JsonObject } from '@rushstack/node-core-library';
import { LookupByPath } from '@rushstack/lookup-by-path';
import { PackageNameParser } from '@rushstack/node-core-library';
import type { StdioSummarizer } from '@rushstack/terminal';
import { SyncHook } from 'tapable';
import { SyncWaterfallHook } from 'tapable';
import { Terminal } from '@rushstack/terminal';

/**
 * This represents the JSON file specified via the "approvedPackagesFile" option in rush.json.
 * @public
 */
export declare class ApprovedPackagesConfiguration {
    private static _jsonSchema;
    items: ApprovedPackagesItem[];
    private _itemsByName;
    private _loadedJson;
    private _jsonFilename;
    constructor(jsonFilename: string);
    /**
     * Clears all the settings, returning to an empty state.
     */
    clear(): void;
    getItemByName(packageName: string): ApprovedPackagesItem | undefined;
    addOrUpdatePackage(packageName: string, reviewCategory: string): boolean;
    /**
     * If the file exists, calls loadFromFile().
     */
    tryLoadFromFile(approvedPackagesPolicyEnabled: boolean): boolean;
    /**
     * Loads the configuration data from the filename that was passed to the constructor.
     */
    loadFromFile(): void;
    /**
     * Loads the configuration data to the filename that was passed to the constructor.
     */
    saveToFile(): void;
    /**
     * Helper function only used by the constructor when loading the file.
     */
    private _addItemJson;
    /**
     * Helper function that adds an already created ApprovedPackagesItem to the
     * list and set.
     */
    private _addItem;
}

/**
 * An item returned by ApprovedPackagesConfiguration
 * @public
 */
export declare class ApprovedPackagesItem {
    /**
     * The NPM package name
     */
    packageName: string;
    /**
     * The project categories that are allowed to use this package.
     */
    allowedCategories: Set<string>;
    /**
     * @internal
     */
    constructor(packageName: string);
}

/**
 * This is a helper object for RushConfiguration.
 * It exposes the "approvedPackagesPolicy" feature from rush.json.
 * @public
 */
export declare class ApprovedPackagesPolicy {
    /**
     * Whether the feature is enabled.  The feature is enabled if the "approvedPackagesPolicy"
     * field is assigned in rush.json.
     */
    readonly enabled: boolean;
    /**
     * A list of NPM package scopes that will be excluded from review (e.g. `@types`)
     */
    readonly ignoredNpmScopes: ReadonlySet<string>;
    /**
     * A list of category names that are valid for usage as the RushConfigurationProject.reviewCategory field.
     * This array will never be undefined.
     */
    readonly reviewCategories: ReadonlySet<string>;
    /**
     * Packages approved for usage in a web browser.  This is the stricter of the two types, so by default
     * all new packages are added to this file.
     *
     * @remarks
     *
     * This is part of an optional approval workflow, whose purpose is to review any new dependencies
     * that are introduced (e.g. maybe a legal review is required, or maybe we are trying to minimize bloat).
     * When Rush discovers a new dependency has been added to package.json, it will update the file.
     * The intent is that the file will be stored in Git and tracked by a branch policy that notifies
     * reviewers when a PR attempts to modify the file.
     *
     * Example filename: `C:\MyRepo\common\config\rush\browser-approved-packages.json`
     */
    readonly browserApprovedPackages: ApprovedPackagesConfiguration;
    /**
     * Packages approved for usage everywhere *except* in a web browser.
     *
     * @remarks
     *
     * This is part of an optional approval workflow, whose purpose is to review any new dependencies
     * that are introduced (e.g. maybe a legal review is required, or maybe we are trying to minimize bloat).
     * The intent is that the file will be stored in Git and tracked by a branch policy that notifies
     * reviewers when a PR attempts to modify the file.
     *
     * Example filename: `C:\MyRepo\common\config\rush\browser-approved-packages.json`
     */
    readonly nonbrowserApprovedPackages: ApprovedPackagesConfiguration;
    /** @internal */
    constructor(rushConfiguration: RushConfiguration, rushConfigurationJson: IRushConfigurationJson);
}

/**
 * Use this class to load and save the "common/config/rush/build-cache.json" config file.
 * This file provides configuration options for cached project build output.
 * @beta
 */
export declare class BuildCacheConfiguration {
    private static _jsonSchema;
    /**
     * Indicates whether the build cache feature is enabled.
     * Typically it is enabled in the build-cache.json config file.
     */
    readonly buildCacheEnabled: boolean;
    /**
     * Indicates whether or not writing to the cache is enabled.
     */
    cacheWriteEnabled: boolean;
    /**
     * Method to calculate the cache entry id for a project, phase, and project state.
     */
    readonly getCacheEntryId: GetCacheEntryIdFunction;
    /**
     * The provider for interacting with the local build cache.
     */
    readonly localCacheProvider: FileSystemBuildCacheProvider;
    /**
     * The provider for interacting with the cloud build cache, if configured.
     */
    readonly cloudCacheProvider: ICloudBuildCacheProvider | undefined;
    /**
     * An optional salt to inject during calculation of the cache key. This can be used to invalidate the cache for all projects when the salt changes.
     */
    readonly cacheHashSalt: string | undefined;
    private constructor();
    /**
     * Attempts to load the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.
     * If the file has not been created yet, then undefined is returned.
     */
    static tryLoadAsync(terminal: ITerminal, rushConfiguration: RushConfiguration, rushSession: RushSession): Promise<BuildCacheConfiguration | undefined>;
    /**
     * Loads the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.
     * If the file has not been created yet, or if the feature is not enabled, then an error is reported.
     */
    static loadAndRequireEnabledAsync(terminal: ITerminal, rushConfiguration: RushConfiguration, rushSession: RushSession): Promise<BuildCacheConfiguration>;
    /**
     * Gets the absolute path to the build-cache.json file in the specified rush workspace.
     */
    static getBuildCacheConfigFilePath(rushConfiguration: RushConfiguration): string;
    private static _loadAsync;
}

/**
 * Type of version bumps
 * @public
 *
 * @internalRemarks
 * This is a copy of the semver ReleaseType enum, but with the `none` value added and
 * the `premajor` and `prepatch` omitted.
 * See {@link LockStepVersionPolicy._getReleaseType}.
 *
 * TODO: Consider supporting `premajor` and `prepatch` in the future.
 */
export declare enum BumpType {
    'none' = 0,
    'prerelease' = 1,
    'patch' = 2,
    'preminor' = 3,
    'minor' = 4,
    'major' = 5
}

/**
 * A class that helps with programmatically interacting with Rush's change files.
 * @public
 */
export declare class ChangeManager {
    /**
     * Creates a change file that has a 'none' type.
     * @param rushConfiguration - The rush configuration we are working with
     * @param projectName - The name of the project for which to create a change file
     * @param emailAddress - The email address which should be associated with this change
     * @returns the path to the file that was created, or undefined if no file was written
     */
    static createEmptyChangeFiles(rushConfiguration: RushConfiguration, projectName: string, emailAddress: string): string | undefined;
}

/**
 * @beta
 */
export declare type CloudBuildCacheProviderFactory = (buildCacheJson: IBuildCacheJson) => ICloudBuildCacheProvider | Promise<ICloudBuildCacheProvider>;

/**
 * Use this class to load and save the "common/config/rush/cobuild.json" config file.
 * This file provides configuration options for the Rush Cobuild feature.
 * @beta
 */
export declare class CobuildConfiguration {
    private static _jsonSchema;
    /**
     * Indicates whether the cobuild feature is enabled.
     * Typically it is enabled in the cobuild.json config file.
     *
     * Note: The orchestrator (or local users) should always have to opt into running with cobuilds by
     * providing a cobuild context id. Even if cobuilds are "enabled" as a feature, they don't
     * actually turn on for that particular build unless the cobuild context id is provided as an
     * non-empty string.
     */
    readonly cobuildFeatureEnabled: boolean;
    /**
     * Cobuild context id
     *
     * @remarks
     * The cobuild feature won't be enabled until the context id is provided as an non-empty string.
     */
    readonly cobuildContextId: string | undefined;
    /**
     * This is a name of the participating cobuild runner. It can be specified by the environment variable
     * RUSH_COBUILD_RUNNER_ID. If it is not provided, a random id will be generated to identify the runner.
     */
    readonly cobuildRunnerId: string;
    /**
     * If true, Rush will automatically handle the leaf project with build cache "disabled" by writing
     * to the cache in a special "log files only mode". This is useful when you want to use Cobuilds
     * to improve the performance in CI validations and the leaf projects have not enabled cache.
     */
    readonly cobuildLeafProjectLogOnlyAllowed: boolean;
    /**
     * If true, operations can opt into leveraging cobuilds without restoring from the build cache.
     *  Operations will need to us the allowCobuildWithoutCache flag to opt into this behavior per phase.
     */
    readonly cobuildWithoutCacheAllowed: boolean;
    private _cobuildLockProvider;
    private readonly _cobuildLockProviderFactory;
    private readonly _cobuildJson;
    private constructor();
    /**
     * Attempts to load the cobuild.json data from the standard file path `common/config/rush/cobuild.json`.
     * If the file has not been created yet, then undefined is returned.
     */
    static tryLoadAsync(terminal: ITerminal, rushConfiguration: RushConfiguration, rushSession: RushSession): Promise<CobuildConfiguration | undefined>;
    static getCobuildConfigFilePath(rushConfiguration: RushConfiguration): string;
    private static _loadAsync;
    createLockProviderAsync(terminal: ITerminal): Promise<void>;
    destroyLockProviderAsync(): Promise<void>;
    getCobuildLockProvider(): ICobuildLockProvider;
}

/**
 * @beta
 */
export declare type CobuildLockProviderFactory = (cobuildJson: ICobuildJson) => ICobuildLockProvider | Promise<ICobuildLockProvider>;

/**
 * Use this class to load and save the "common/config/rush/common-versions.json" config file.
 * This config file stores dependency version information that affects all projects in the repo.
 * @public
 */
export declare class CommonVersionsConfiguration {
    private static _jsonSchema;
    private _preferredVersions;
    private _allowedAlternativeVersions;
    private _modified;
    /**
     * Get the absolute file path of the common-versions.json file.
     */
    readonly filePath: string;
    /**
     * When set to true, for all projects in the repo, all dependencies will be automatically added as preferredVersions,
     * except in cases where different projects specify different version ranges for a given dependency.  For older
     * package managers, this tended to reduce duplication of indirect dependencies.  However, it can sometimes cause
     * trouble for indirect dependencies with incompatible peerDependencies ranges.
     *
     * If the value is `undefined`, then the default value is `true`.
     */
    readonly implicitlyPreferredVersions: boolean | undefined;
    /**
     * If true, then consistent version specifiers for dependencies will be enforced.
     * I.e. "rush check" is run before some commands.
     */
    readonly ensureConsistentVersions: boolean;
    /**
     * A table that specifies a "preferred version" for a given NPM package.  This feature is typically used
     * to hold back an indirect dependency to a specific older version, or to reduce duplication of indirect dependencies.
     *
     * @remarks
     * The "preferredVersions" value can be any SemVer range specifier (e.g. `~1.2.3`).  Rush injects these values into
     * the "dependencies" field of the top-level common/temp/package.json, which influences how the package manager
     * will calculate versions.  The specific effect depends on your package manager.  Generally it will have no
     * effect on an incompatible or already constrained SemVer range.  If you are using PNPM, similar effects can be
     * achieved using the pnpmfile.js hook.  See the Rush documentation for more details.
     *
     * After modifying this field, it's recommended to run `rush update --full` so that the package manager
     * will recalculate all version selections.
     */
    readonly preferredVersions: Map<string, string>;
    /**
     * A table that stores, for a given dependency, a list of SemVer ranges that will be accepted
     * by "rush check" in addition to the normal version range.
     *
     * @remarks
     * The "rush check" command can be used to enforce that every project in the repo
     * must specify the same SemVer range for a given dependency.  However, sometimes
     * exceptions are needed.  The allowedAlternativeVersions table allows you to list
     * other SemVer ranges that will be accepted by "rush check" for a given dependency.
     * Note that the normal version range (as inferred by looking at all projects in the repo)
     * should NOT be included in this list.
     */
    readonly allowedAlternativeVersions: Map<string, ReadonlyArray<string>>;
    private constructor();
    /**
     * Loads the common-versions.json data from the specified file path.
     * If the file has not been created yet, then an empty object is returned.
     */
    static loadFromFile(jsonFilePath: string, rushConfiguration?: RushConfiguration): CommonVersionsConfiguration;
    private static _deserializeTable;
    private static _serializeTable;
    /**
     * Get a sha1 hash of the preferred versions.
     */
    getPreferredVersionsHash(): string;
    /**
     * Writes the "common-versions.json" file to disk, using the filename that was passed to loadFromFile().
     */
    save(): boolean;
    /**
     * Returns preferredVersions.
     */
    getAllPreferredVersions(): Map<string, string>;
    private _onSetPreferredVersions;
    private _onSetAllowedAlternativeVersions;
    private _serialize;
}

/**
 * @beta
 */
export declare class CredentialCache {
    private readonly _cacheFilePath;
    private readonly _cacheEntries;
    private _modified;
    private _disposed;
    private _supportsEditing;
    private readonly _lockfile;
    private constructor();
    static initializeAsync(options: ICredentialCacheOptions): Promise<CredentialCache>;
    static usingAsync(options: ICredentialCacheOptions, doActionAsync: (credentialCache: CredentialCache) => Promise<void> | void): Promise<void>;
    setCacheEntry(cacheId: string, entry: ICredentialCacheEntry): void;
    tryGetCacheEntry(cacheId: string): ICredentialCacheEntry | undefined;
    deleteCacheEntry(cacheId: string): void;
    trimExpiredEntries(): void;
    saveIfModifiedAsync(): Promise<void>;
    dispose(): void;
    private _validate;
}

/**
 * An identifier representing a Rush message that can be customized by
 * defining a custom tip in `common/config/rush/custom-tips.json`.
 * @remarks
 * Custom tip ids always start with the `TIP_` prefix.
 *
 * @privateRemarks
 * Events from the Rush process should with "TIP_RUSH_".
 * Events from a PNPM subprocess should start with "TIP_PNPM_".
 *
 * @beta
 */
export declare enum CustomTipId {
    TIP_RUSH_INCONSISTENT_VERSIONS = "TIP_RUSH_INCONSISTENT_VERSIONS",
    TIP_RUSH_DISALLOW_INSECURE_SHA1 = "TIP_RUSH_DISALLOW_INSECURE_SHA1",
    TIP_PNPM_UNEXPECTED_STORE = "TIP_PNPM_UNEXPECTED_STORE",
    TIP_PNPM_NO_MATCHING_VERSION = "TIP_PNPM_NO_MATCHING_VERSION",
    TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE = "TIP_PNPM_NO_MATCHING_VERSION_INSIDE_WORKSPACE",
    TIP_PNPM_PEER_DEP_ISSUES = "TIP_PNPM_PEER_DEP_ISSUES",
    TIP_PNPM_OUTDATED_LOCKFILE = "TIP_PNPM_OUTDATED_LOCKFILE",
    TIP_PNPM_TARBALL_INTEGRITY = "TIP_PNPM_TARBALL_INTEGRITY",
    TIP_PNPM_MISMATCHED_RELEASE_CHANNEL = "TIP_PNPM_MISMATCHED_RELEASE_CHANNEL",
    TIP_PNPM_INVALID_NODE_VERSION = "TIP_PNPM_INVALID_NODE_VERSION"
}

/**
 * Used to access the `common/config/rush/custom-tips.json` config file,
 * which allows repo maintainers to configure extra details to be printed alongside
 * certain Rush messages.
 * @beta
 */
export declare class CustomTipsConfiguration {
    private static _jsonSchema;
    readonly providedCustomTipsByTipId: ReadonlyMap<CustomTipId, ICustomTipItemJson>;
    /**
     * A registry mapping custom tip IDs to their corresponding metadata.
     *
     * @remarks
     * This registry is used to look up metadata for custom tips based on their IDs. The metadata includes
     * information such as the severity level, the type of tip, and an optional matching function.
     *
     * Each key in the registry corresponds to a `CustomTipIdEnum` value, and each value is an object
     * implementing the `ICustomTipInfo` interface.
     *
     * @example
     * ```typescript
     * const tipInfo = CustomTipsConfiguration.customTipRegistry[CustomTipIdEnum.TIP_RUSH_INCONSISTENT_VERSIONS];
     * console.log(tipInfo.severity);  // Output: CustomTipSeverity.Error
     * ```
     *
     * See {@link CustomTipId} for the list of custom tip IDs.
     * See {@link ICustomTipInfo} for the structure of the metadata.
     */
    static customTipRegistry: Readonly<Record<CustomTipId, ICustomTipInfo>>;
    constructor(configFilePath: string);
    /**
     * If custom-tips.json defines a tip for the specified tipId,  display the tip on the terminal.
     *
     * @remarks
     * The severity of the tip is defined in ${@link CustomTipsConfiguration.customTipRegistry}.
     * If you want to change the severity specifically for this call,
     * use other APIs such as {@link CustomTipsConfiguration._showErrorTip}.
     *
     * Custom tips by design do not replace Rush's standard messaging; instead, they annotate Rush's
     * output with additional team-specific advice.
     *
     * @internal
     */
    _showTip(terminal: ITerminal, tipId: CustomTipId): void;
    /**
     * If custom-tips.json defines a tip for the specified tipId, display the tip on the terminal.
     * @remarks
     * Custom tips by design do not replace Rush's standard messaging; instead, they annotate Rush's
     * output with additional team-specific advice.
     * @internal
     */
    _showInfoTip(terminal: ITerminal, tipId: CustomTipId): void;
    /**
     * If custom-tips.json defines a tip for the specified tipId, display the tip on the terminal.
     * @remarks
     * Custom tips by design do not replace Rush's standard messaging; instead, they annotate Rush's
     * output with additional team-specific advice.
     * @internal
     */
    _showWarningTip(terminal: ITerminal, tipId: CustomTipId): void;
    /**
     * If custom-tips.json defines a tip for the specified tipId, display the tip on the terminal.
     * @remarks
     * Custom tips by design do not replace Rush's standard messaging; instead, they annotate Rush's
     * output with additional team-specific advice.
     * @internal
     */
    _showErrorTip(terminal: ITerminal, tipId: CustomTipId): void;
    private _writeMessageWithPipes;
}

/**
 * The severity of a custom tip.
 * It determines the printing severity ("Error" = red, "Warning" = yellow, "Info" = normal).
 *
 * @beta
 */
export declare enum CustomTipSeverity {
    Warning = "Warning",
    Error = "Error",
    Info = "Info"
}

/**
 * The type of the custom tip.
 *
 * @remarks
 * There might be types like `git` in the future.
 *
 * @beta
 */
export declare enum CustomTipType {
    rush = "rush",
    pnpm = "pnpm"
}

/**
 * @public
 */
export declare enum DependencyType {
    Regular = "dependencies",
    Dev = "devDependencies",
    Optional = "optionalDependencies",
    Peer = "peerDependencies",
    YarnResolutions = "resolutions"
}

/**
 * Provides Rush-specific environment variable data. All Rush environment variables must start with "RUSH_". This class
 * is designed to be used by RushConfiguration.
 * @beta
 *
 * @remarks
 * Initialize will throw if any unknown parameters are present.
 */
export declare class EnvironmentConfiguration {
    private static _hasBeenValidated;
    private static _rushTempFolderOverride;
    private static _absoluteSymlinks;
    private static _allowUnsupportedNodeVersion;
    private static _allowWarningsInSuccessfulBuild;
    private static _pnpmStorePathOverride;
    private static _pnpmVerifyStoreIntegrity;
    private static _rushGlobalFolderOverride;
    private static _buildCacheCredential;
    private static _buildCacheEnabled;
    private static _buildCacheWriteAllowed;
    private static _cobuildContextId;
    private static _cobuildRunnerId;
    private static _cobuildLeafProjectLogOnlyAllowed;
    private static _gitBinaryPath;
    private static _tarBinaryPath;
    /**
     * An override for the common/temp folder path.
     */
    static get rushTempFolderOverride(): string | undefined;
    /**
     * If "1", create symlinks with absolute paths instead of relative paths.
     * See {@link EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS}
     */
    static get absoluteSymlinks(): boolean;
    /**
     * If this environment variable is set to "1", the Node.js version check will print a warning
     * instead of causing a hard error if the environment's Node.js version doesn't match the
     * version specifier in `rush.json`'s "nodeSupportedVersionRange" property.
     *
     * See {@link EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS}.
     */
    static get allowUnsupportedNodeVersion(): boolean;
    /**
     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`
     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,
     * or `0` to disallow them. (See the comments in the command-line.json file for more information).
     */
    static get allowWarningsInSuccessfulBuild(): boolean;
    /**
     * An override for the PNPM store path, if `pnpmStore` configuration is set to 'path'
     * See {@link EnvironmentVariableNames.RUSH_PNPM_STORE_PATH}
     */
    static get pnpmStorePathOverride(): string | undefined;
    /**
     * If specified, enables or disables integrity verification of the pnpm store during install.
     * See {@link EnvironmentVariableNames.RUSH_PNPM_VERIFY_STORE_INTEGRITY}
     */
    static get pnpmVerifyStoreIntegrity(): boolean | undefined;
    /**
     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.
     * See {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER}
     */
    static get rushGlobalFolderOverride(): string | undefined;
    /**
     * Provides a credential for reading from and writing to a remote build cache, if configured.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL}
     */
    static get buildCacheCredential(): string | undefined;
    /**
     * If set, enables or disables the cloud build cache feature.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED}
     */
    static get buildCacheEnabled(): boolean | undefined;
    /**
     * If set, enables or disables writing to the cloud build cache.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED}
     */
    static get buildCacheWriteAllowed(): boolean | undefined;
    /**
     * Provides a determined cobuild context id if configured
     * See {@link EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID}
     */
    static get cobuildContextId(): string | undefined;
    /**
     * Provides a determined cobuild runner id if configured
     * See {@link EnvironmentVariableNames.RUSH_COBUILD_RUNNER_ID}
     */
    static get cobuildRunnerId(): string | undefined;
    /**
     * If set, enables or disables the cobuild leaf project log only feature.
     * See {@link EnvironmentVariableNames.RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED}
     */
    static get cobuildLeafProjectLogOnlyAllowed(): boolean | undefined;
    /**
     * Allows the git binary path to be explicitly provided.
     * See {@link EnvironmentVariableNames.RUSH_GIT_BINARY_PATH}
     */
    static get gitBinaryPath(): string | undefined;
    /**
     * Allows the tar binary path to be explicitly provided.
     * See {@link EnvironmentVariableNames.RUSH_TAR_BINARY_PATH}
     */
    static get tarBinaryPath(): string | undefined;
    /**
     * The front-end RushVersionSelector relies on `RUSH_GLOBAL_FOLDER`, so its value must be read before
     * `EnvironmentConfiguration` is initialized (and actually before the correct version of `EnvironmentConfiguration`
     * is even installed). Thus we need to read this environment variable differently from all the others.
     * @internal
     */
    static _getRushGlobalFolderOverride(processEnv: IEnvironment): string | undefined;
    /**
     * Reads and validates environment variables. If any are invalid, this function will throw.
     */
    static validate(options?: IEnvironmentConfigurationInitializeOptions): void;
    /**
     * Resets EnvironmentConfiguration into an un-initialized state.
     */
    static reset(): void;
    private static _ensureValidated;
    static parseBooleanEnvironmentVariable(name: string, value: string | undefined): boolean | undefined;
    /**
     * Given a path to a folder (that may or may not exist), normalize the path, including casing,
     * to the first existing parent folder in the path.
     *
     * If no existing path can be found (for example, if the root is a volume that doesn't exist),
     * this function returns undefined.
     *
     * @example
     * If the following path exists on disk: `C:\Folder1\folder2\`
     * _normalizeFirstExistingFolderPath('c:\\folder1\\folder2\\temp\\subfolder')
     * returns 'C:\\Folder1\\folder2\\temp\\subfolder'
     */
    private static _normalizeDeepestParentFolderPath;
}

/**
 * Names of environment variables used by Rush.
 * @beta
 */
export declare const EnvironmentVariableNames: {
    /**
     * This variable overrides the temporary folder used by Rush.
     * The default value is "common/temp" under the repository root.
     *
     * @remarks This environment variable is not compatible with workspace installs. If attempting
     * to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.
     */
    readonly RUSH_TEMP_FOLDER: "RUSH_TEMP_FOLDER";
    /**
     * This variable overrides the version of Rush that will be installed by
     * the version selector.  The default value is determined by the "rushVersion"
     * field from rush.json.
     */
    readonly RUSH_PREVIEW_VERSION: "RUSH_PREVIEW_VERSION";
    /**
     * If this variable is set to "1", Rush will not fail the build when running a version
     * of Node that does not match the criteria specified in the "nodeSupportedVersionRange"
     * field from rush.json.
     */
    readonly RUSH_ALLOW_UNSUPPORTED_NODEJS: "RUSH_ALLOW_UNSUPPORTED_NODEJS";
    /**
     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`
     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,
     * or `0` to disallow them. (See the comments in the command-line.json file for more information).
     */
    readonly RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD: "RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD";
    /**
     * This variable selects a specific installation variant for Rush to use when installing
     * and linking package dependencies.
     * For more information, see the command-line help for the `--variant` parameter
     * and this article:  https://rushjs.io/pages/advanced/installation_variants/
     */
    readonly RUSH_VARIANT: "RUSH_VARIANT";
    /**
     * Specifies the maximum number of concurrent processes to launch during a build.
     * For more information, see the command-line help for the `--parallelism` parameter for "rush build".
     */
    readonly RUSH_PARALLELISM: "RUSH_PARALLELISM";
    /**
     * If this variable is set to "1", Rush will create symlinks with absolute paths instead
     * of relative paths. This can be necessary when a repository is moved during a build or
     * if parts of a repository are moved into a sandbox.
     */
    readonly RUSH_ABSOLUTE_SYMLINKS: "RUSH_ABSOLUTE_SYMLINKS";
    /**
     * When using PNPM as the package manager, this variable can be used to configure the path that
     * PNPM will use as the store directory.
     *
     * If a relative path is used, then the store path will be resolved relative to the process's
     * current working directory.  An absolute path is recommended.
     */
    readonly RUSH_PNPM_STORE_PATH: "RUSH_PNPM_STORE_PATH";
    /**
     * When using PNPM as the package manager, this variable can be used to control whether or not PNPM
     * validates the integrity of the PNPM store during installation. The value of this environment variable must be
     * `1` (for true) or `0` (for false). If not specified, defaults to the value in .npmrc.
     */
    readonly RUSH_PNPM_VERIFY_STORE_INTEGRITY: "RUSH_PNPM_VERIFY_STORE_INTEGRITY";
    /**
     * This environment variable can be used to specify the `--target-folder` parameter
     * for the "rush deploy" command.
     */
    readonly RUSH_DEPLOY_TARGET_FOLDER: "RUSH_DEPLOY_TARGET_FOLDER";
    /**
     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.
     *
     * @remarks
     *
     * Most of the temporary files created by Rush are stored separately for each monorepo working folder,
     * to avoid issues of concurrency and compatibility between tool versions.  However, a small set
     * of files (e.g. installations of the `@microsoft/rush-lib` engine and the package manager) are stored
     * in a global folder to speed up installations.  The default location is `~/.rush` on POSIX-like
     * operating systems or `C:\Users\YourName` on Windows.
     *
     * Use `RUSH_GLOBAL_FOLDER` to specify a different folder path.  This is useful for example if a Windows
     * group policy forbids executing scripts installed in a user's home directory.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    readonly RUSH_GLOBAL_FOLDER: "RUSH_GLOBAL_FOLDER";
    /**
     * Provides a credential for a remote build cache, if configured.  This credential overrides any cached credentials.
     *
     * @remarks
     * Setting this environment variable overrides whatever credential has been saved in the
     * local cloud cache credentials using `rush update-cloud-credentials`.
     *
     *
     * If Azure Blob Storage is used to store cache entries, this must be a SAS token serialized as query
     * parameters.
     *
     * For information on SAS tokens, see here: https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview
     */
    readonly RUSH_BUILD_CACHE_CREDENTIAL: "RUSH_BUILD_CACHE_CREDENTIAL";
    /**
     * Setting this environment variable overrides the value of `buildCacheEnabled` in the `build-cache.json`
     * configuration file.
     *
     * @remarks
     * Specify `1` to enable the build cache or `0` to disable it.
     *
     * If there is no build cache configured, then this environment variable is ignored.
     */
    readonly RUSH_BUILD_CACHE_ENABLED: "RUSH_BUILD_CACHE_ENABLED";
    /**
     * Overrides the value of `isCacheWriteAllowed` in the `build-cache.json` configuration file. The value of this
     * environment variable must be `1` (for true) or `0` (for false). If there is no build cache configured, then
     * this environment variable is ignored.
     */
    readonly RUSH_BUILD_CACHE_WRITE_ALLOWED: "RUSH_BUILD_CACHE_WRITE_ALLOWED";
    /**
     * Setting this environment variable opts into running with cobuilds. The context id should be the same across
     * multiple VMs, but changed when it is a new round of cobuilds.
     *
     * e.g. `Build.BuildNumber` in Azure DevOps Pipeline.
     *
     * @remarks
     * If there is no cobuild configured, then this environment variable is ignored.
     */
    readonly RUSH_COBUILD_CONTEXT_ID: "RUSH_COBUILD_CONTEXT_ID";
    /**
     * Explicitly specifies a name for each participating cobuild runner.
     *
     * Setting this environment variable opts into running with cobuilds.
     *
     * @remarks
     * This environment variable is optional, if it is not provided, a random id is used.
     *
     * If there is no cobuild configured, then this environment variable is ignored.
     */
    readonly RUSH_COBUILD_RUNNER_ID: "RUSH_COBUILD_RUNNER_ID";
    /**
     * If this variable is set to "1", When getting distributed builds, Rush will automatically handle the leaf project
     * with build cache "disabled" by writing to the cache in a special "log files only mode". This is useful when you
     * want to use Cobuilds to improve the performance in CI validations and the leaf projects have not enabled cache.
     */
    readonly RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED: "RUSH_COBUILD_LEAF_PROJECT_LOG_ONLY_ALLOWED";
    /**
     * Explicitly specifies the path for the Git binary that is invoked by certain Rush operations.
     */
    readonly RUSH_GIT_BINARY_PATH: "RUSH_GIT_BINARY_PATH";
    /**
     * Explicitly specifies the path for the `tar` binary that is invoked by certain Rush operations.
     */
    readonly RUSH_TAR_BINARY_PATH: "RUSH_TAR_BINARY_PATH";
    /**
     * Internal variable used by `rushx` when recursively invoking another `rushx` process, to avoid
     * nesting event hooks.
     */
    readonly _RUSH_RECURSIVE_RUSHX_CALL: "_RUSH_RECURSIVE_RUSHX_CALL";
    /**
     * Internal variable that explicitly specifies the path for the version of `@microsoft/rush-lib` being executed.
     * Will be set upon loading Rush.
     */
    readonly _RUSH_LIB_PATH: "_RUSH_LIB_PATH";
    /**
     * When Rush executes shell scripts, it sometimes changes the working directory to be a project folder or
     * the repository root folder.  The original working directory (where the Rush command was invoked) is assigned
     * to the the child process's `RUSH_INVOKED_FOLDER` environment variable, in case it is needed by the script.
     *
     * @remarks
     * The `RUSH_INVOKED_FOLDER` variable is the same idea as the `INIT_CWD` variable that package managers
     * assign when they execute lifecycle scripts.
     */
    readonly RUSH_INVOKED_FOLDER: "RUSH_INVOKED_FOLDER";
    /**
     * When running a hook script, this environment variable communicates the original arguments
     * passed to the `rush` or `rushx` command.
     *
     * @remarks
     * Unlike `RUSH_INVOKED_FOLDER`, the `RUSH_INVOKED_ARGS` variable is only available for hook scripts.
     * Other lifecycle scripts should not make assumptions about Rush's command line syntax
     * if Rush did not explicitly pass along command-line parameters to their process.
     */
    readonly RUSH_INVOKED_ARGS: "RUSH_INVOKED_ARGS";
};

/**
 * Events happen during Rush runs.
 * @beta
 */
declare enum Event_2 {
    /**
     * Pre Rush install event
     */
    preRushInstall = 1,
    /**
     * Post Rush install event
     */
    postRushInstall = 2,
    /**
     * Pre Rush build event
     */
    preRushBuild = 3,
    /**
     * Post Rush build event
     */
    postRushBuild = 4,
    /**
     * Start of rushx execution event
     */
    preRushx = 5,
    /**
     * End of rushx execution event
     */
    postRushx = 6
}
export { Event_2 as Event }

/**
 * This class represents Rush event hooks configured for this repo.
 * Hooks are customized script actions that Rush executes when specific events occur.
 * The actions are expressed as a command-line that is executed using the operating system shell.
 * @beta
 */
export declare class EventHooks {
    private _hooks;
    /**
     * @internal
     */
    constructor(eventHooksJson: IEventHooksJson);
    /**
     * Return all the scripts associated with the specified event.
     * @param event - Rush event
     */
    get(event: Event_2): string[];
}

/**
 * Use this class to load the "common/config/rush/experiments.json" config file.
 * This file allows repo maintainers to enable and disable experimental Rush features.
 * @public
 */
export declare class ExperimentsConfiguration {
    /**
     * Get the experiments configuration.
     * @beta
     */
    readonly configuration: Readonly<IExperimentsJson>;
    /**
     * @internal
     */
    constructor(jsonFilePath: string);
}

/**
 * A build cache provider using the local file system.
 * Required by all cloud cache providers.
 * @beta
 */
export declare class FileSystemBuildCacheProvider {
    private readonly _cacheFolderPath;
    constructor(options: IFileSystemBuildCacheProviderOptions);
    /**
     * Returns the absolute disk path for the specified cache id.
     */
    getCacheEntryPath(cacheId: string): string;
    /**
     * Validates that the specified cache id exists on disk, and returns the path if it does.
     */
    tryGetCacheEntryPathByIdAsync(terminal: ITerminal, cacheId: string): Promise<string | undefined>;
    /**
     * Writes the specified buffer to the corresponding file system path for the cache id.
     */
    trySetCacheEntryBufferAsync(terminal: ITerminal, cacheId: string, entryBuffer: Buffer): Promise<string>;
}

/**
 * A base class for flag file.
 * @internal
 */
export declare class _FlagFile<TState extends JsonObject = JsonObject> {
    /**
     * Flag file path
     */
    readonly path: string;
    /**
     * Content of the flag
     */
    protected _state: TState;
    /**
     * Creates a new flag file
     * @param folderPath - the folder that this flag is managing
     * @param state - optional, the state that should be managed or compared
     */
    constructor(folderPath: string, flagName: string, initialState: TState);
    /**
     * Returns true if the file exists and the contents match the current state.
     */
    isValidAsync(): Promise<boolean>;
    /**
     * Writes the flag file to disk with the current state
     */
    createAsync(): Promise<void>;
    /**
     * Removes the flag file
     */
    clearAsync(): Promise<void>;
}

/**
 * Calculates the cache entry id string for an operation.
 * @beta
 */
export declare type GetCacheEntryIdFunction = (options: IGenerateCacheEntryIdOptions) => string;

/**
 * Function that computes a new snapshot of the current state of the repository as of the current moment.
 * Rush-level configuration state will have been bound during creation of the function.
 * Captures the state of the environment, tracked files, and additional files.
 *
 * @beta
 */
export declare type GetInputsSnapshotAsyncFn = () => Promise<IInputsSnapshot | undefined>;

/**
 * Part of IRushConfigurationJson.
 */
declare interface IApprovedPackagesPolicyJson {
    reviewCategories?: string[];
    ignoredNpmScopes?: string[];
}

/**
 * Describes the file structure for the "common/config/rush/build-cache.json" config file.
 */
declare interface IBaseBuildCacheJson {
    buildCacheEnabled: boolean;
    cacheProvider: string;
    /**
     * Used to specify the cache entry ID format. If this property is set, it must
     * contain a `[hash]` token. It may also contain one of the following tokens:
     * - `[projectName]`
     * - `[projectName:normalize]`
     * - `[phaseName]`
     * - `[phaseName:normalize]`
     * - `[phaseName:trimPrefix]`
     * - `[os]`
     * - `[arch]`
     * @privateRemarks
     * NOTE: If you update this comment, make sure to update build-cache.json in the "rush init" template.
     * The token parser is in CacheEntryId.ts
     */
    cacheEntryNamePattern?: string;
    /**
     * An optional salt to inject during calculation of the cache key. This can be used to invalidate the cache for all projects when the salt changes.
     */
    cacheHashSalt?: string;
}

/**
 * @beta
 */
declare type IBuildCacheJson = ICloudBuildCacheJson | ILocalBuildCacheJson;

/**
 * @internal
 */
export declare interface _IBuiltInPluginConfiguration extends _IRushPluginConfigurationBase {
    pluginPackageFolder: string;
}

/**
 * @beta
 */
declare interface ICloudBuildCacheJson extends IBaseBuildCacheJson {
    readonly cacheProvider: string;
    [otherConfigKey: string]: JsonObject;
}

/**
 * @beta
 */
export declare interface ICloudBuildCacheProvider {
    readonly isCacheWriteAllowed: boolean;
    tryGetCacheEntryBufferByIdAsync(terminal: ITerminal, cacheId: string): Promise<Buffer | undefined>;
    trySetCacheEntryBufferAsync(terminal: ITerminal, cacheId: string, entryBuffer: Buffer): Promise<boolean>;
    updateCachedCredentialAsync(terminal: ITerminal, credential: string): Promise<void>;
    updateCachedCredentialInteractiveAsync(terminal: ITerminal): Promise<void>;
    deleteCachedCredentialsAsync(terminal: ITerminal): Promise<void>;
}

/**
 * @beta
 */
export declare interface ICobuildCompletedState {
    status: OperationStatus.Success | OperationStatus.SuccessWithWarning | OperationStatus.Failure;
    /**
     * Completed state points to the cache id that was used to store the build cache.
     * Note: Cache failed builds in a separate cache id
     */
    cacheId: string;
}

/**
 * @beta
 */
export declare interface ICobuildContext {
    /**
     * The key for acquiring lock.
     */
    lockKey: string;
    /**
     * The expire time of the lock in seconds.
     */
    lockExpireTimeInSeconds: number;
    /**
     * The key for storing completed state.
     */
    completedStateKey: string;
    /**
     * The contextId is provided by the monorepo maintainer, it reads from environment variable {@link EnvironmentVariableNames.RUSH_COBUILD_CONTEXT_ID}.
     * It ensure only the builds from the same given contextId cooperated.
     */
    contextId: string;
    /**
     * The id of the cluster. The operations in the same cluster share the same clusterId and
     * will be executed on the same machine.
     */
    clusterId: string;
    /**
     * The id of the runner. The identifier for the running machine.
     *
     * It can be specified via assigning `RUSH_COBUILD_RUNNER_ID` environment variable.
     */
    runnerId: string;
    /**
     * The id of the cache entry. It should be kept the same as the normal cacheId from ProjectBuildCache.
     * Otherwise, there is a discrepancy in the success case wherein turning on cobuilds will
     * fail to populate the normal build cache.
     */
    cacheId: string;
    /**
     * The name of NPM package
     *
     * Example: `@scope/MyProject`
     */
    packageName: string;
    /**
     * The name of the phase.
     *
     * Example: _phase:build
     */
    phaseName: string;
}

/**
 * @beta
 */
export declare interface ICobuildJson {
    cobuildFeatureEnabled: boolean;
    cobuildLockProvider: string;
}

/**
 * @beta
 */
export declare interface ICobuildLockProvider {
    /**
     * The callback function invoked to connect to the lock provider.
     * For example, initializing the connection to the redis server.
     */
    connectAsync(): Promise<void>;
    /**
     * The callback function invoked to disconnect the lock provider.
     */
    disconnectAsync(): Promise<void>;
    /**
     * The callback function to acquire a lock with a lock key and specific contexts.
     *
     * NOTE: This lock implementation must be a ReentrantLock. It says the lock might be acquired
     * multiple times, since tasks in the same cluster can be run in the same VM.
     */
    acquireLockAsync(context: Readonly<ICobuildContext>): Promise<boolean>;
    /**
     * The callback function to renew a lock with a lock key and specific contexts.
     *
     * NOTE: If the lock key expired
     */
    renewLockAsync(context: Readonly<ICobuildContext>): Promise<void>;
    /**
     * The callback function to set completed state.
     */
    setCompletedStateAsync(context: Readonly<ICobuildContext>, state: ICobuildCompletedState): Promise<void>;
    /**
     * The callback function to get completed state.
     */
    getCompletedStateAsync(context: Readonly<ICobuildContext>): Promise<ICobuildCompletedState | undefined>;
}

/**
 * A collection of environment variables
 * @public
 */
export declare interface IConfigurationEnvironment {
    /**
     * Environment variables
     */
    [environmentVariableName: string]: IConfigurationEnvironmentVariable;
}

/**
 * Represents the value of an environment variable, and if the value should be overridden if the variable is set
 * in the parent environment.
 * @public
 */
export declare interface IConfigurationEnvironmentVariable {
    /**
     * Value of the environment variable
     */
    value: string;
    /**
     * Set to true to override the environment variable even if it is set in the parent environment.
     * The default value is false.
     */
    override?: boolean;
}

/**
 * Context used for creating operations to be executed.
 * @alpha
 */
export declare interface ICreateOperationsContext {
    /**
     * The configuration for the build cache, if the feature is enabled.
     */
    readonly buildCacheConfiguration: BuildCacheConfiguration | undefined;
    /**
     * The configuration for the cobuild, if cobuild feature and build cache feature are both enabled.
     */
    readonly cobuildConfiguration: CobuildConfiguration | undefined;
    /**
     * The set of custom parameters for the executing command.
     * Maps from the `longName` field in command-line.json to the parser configuration in ts-command-line.
     */
    readonly customParameters: ReadonlyMap<string, CommandLineParameter>;
    /**
     * If true, projects may read their output from cache or be skipped if already up to date.
     * If false, neither of the above may occur, e.g. "rush rebuild"
     */
    readonly isIncrementalBuildAllowed: boolean;
    /**
     * If true, this is the initial run of the command.
     * If false, this execution is in response to changes.
     */
    readonly isInitial: boolean;
    /**
     * If true, the command is running in watch mode.
     */
    readonly isWatch: boolean;
    /**
     * The set of phases original for the current command execution.
     */
    readonly phaseOriginal: ReadonlySet<IPhase>;
    /**
     * The set of phases selected for the current command execution.
     */
    readonly phaseSelection: ReadonlySet<IPhase>;
    /**
     * The set of Rush projects selected for the current command execution.
     */
    readonly projectSelection: ReadonlySet<RushConfigurationProject>;
    /**
     * All successfully loaded rush-project.json data for selected projects.
     */
    readonly projectConfigurations: ReadonlyMap<RushConfigurationProject, RushProjectConfiguration>;
    /**
     * The set of Rush projects that have not been built in the current process since they were last modified.
     * When `isInitial` is true, this will be an exact match of `projectSelection`.
     */
    readonly projectsInUnknownState: ReadonlySet<RushConfigurationProject>;
    /**
     * The Rush configuration
     */
    readonly rushConfiguration: RushConfiguration;
    /**
     * If true, Rush will automatically include the dependent phases for the specified set of phases.
     * @remarks
     * If the selection of projects was "unsafe" (i.e. missing some dependencies), this will add the
     * minimum number of phases required to make it safe.
     */
    readonly includePhaseDeps: boolean;
    /**
     * Marks an operation's result as invalid, potentially triggering a new build. Only applicable in watch mode.
     * @param operation - The operation to invalidate
     * @param reason - The reason for invalidating the operation
     */
    readonly invalidateOperation?: ((operation: Operation, reason: string) => void) | undefined;
}

/**
 * @beta
 */
export declare interface ICredentialCacheEntry {
    expires?: Date;
    credential: string;
    credentialMetadata?: object;
}

/**
 * @beta
 */
export declare interface ICredentialCacheOptions {
    supportEditing: boolean;
}

/**
 * This represents the JSON data structure for the "current-variant.json" data file.
 */
declare interface ICurrentVariantJson {
    variant: string | JsonNull;
}

/**
 * Metadata for a custom tip.
 *
 * @remarks
 * This differs from the  {@link ICustomTipItemJson} interface in that these are not configurable by the user;
 * it's the inherent state of a custom tip. For example, the custom tip for `ERR_PNPM_NO_MATCHING_VERSION`
 * has a inherent severity of `Error`, and a inherent match function that rush maintainer defines.
 *
 * @beta
 */
export declare interface ICustomTipInfo {
    tipId: CustomTipId;
    /**
     * The severity of the custom tip. It will determine the printing severity ("Error" = red, "Warning" = yellow, "Info" = normal).
     *
     * @remarks
     *  The severity should be consistent with the original message, unless there are strong reasons not to.
     */
    severity: CustomTipSeverity;
    /**
     * The type of the custom tip.
     */
    type: CustomTipType;
    /**
     * The function to determine how to match this tipId.
     *
     * @remarks
     * This function might need to be updated if the depending package is updated.
     * For example, if `pnpm` change the error logs for "ERR_PNPM_NO_MATCHING_VERSION", we will need to update the match function accordingly.
     */
    isMatch?: (str: string) => boolean;
}

/**
 * An item from the {@link ICustomTipsJson.customTips} list.
 * @beta
 */
export declare interface ICustomTipItemJson {
    /**
     * (REQUIRED) An identifier indicating a message that may be printed by Rush.
     * If that message is printed, then this custom tip will be shown.
     * Consult the Rush documentation for the current list of possible identifiers.
     */
    tipId: CustomTipId;
    /**
     * (REQUIRED) The message text to be displayed for this tip.
     */
    message: string;
}

/**
 * This interface represents the raw custom-tips.json file which allows repo maintainers
 * to configure extra details to be printed alongside certain Rush messages.
 * @beta
 */
export declare interface ICustomTipsJson {
    /**
     *  Specifies the custom tips to be displayed by Rush.
     */
    customTips?: ICustomTipItemJson[];
}

declare interface IEnvironment {
    [environmentVariableName: string]: string | undefined;
}

/**
 * @beta
 */
export declare interface IEnvironmentConfigurationInitializeOptions {
    doNotNormalizePaths?: boolean;
}

/**
 * Part of IRushConfigurationJson.
 * @beta
 */
declare interface IEventHooksJson {
    /**
     * The list of scripts to run after every Rush build command finishes
     */
    postRushBuild?: string[];
}

/**
 * Context used for executing operations.
 * @alpha
 */
export declare interface IExecuteOperationsContext extends ICreateOperationsContext {
    /**
     * The current state of the repository, if available.
     * Not part of the creation context to avoid the overhead of Git calls when initializing the graph.
     */
    readonly inputsSnapshot?: IInputsSnapshot;
}

/**
 * The `IExecutionResult` interface represents the results of executing a set of {@link Operation}s.
 * @alpha
 */
export declare interface IExecutionResult {
    /**
     * The results for each scheduled operation.
     */
    readonly operationResults: ReadonlyMap<Operation, IOperationExecutionResult>;
    /**
     * The overall result.
     */
    readonly status: OperationStatus;
}

/**
 * This interface represents the raw experiments.json file which allows repo
 * maintainers to enable and disable experimental Rush features.
 * @beta
 */
export declare interface IExperimentsJson {
    /**
     * By default, 'rush install' passes --no-prefer-frozen-lockfile to 'pnpm install'.
     * Set this option to true to pass '--frozen-lockfile' instead for faster installs.
     */
    usePnpmFrozenLockfileForRushInstall?: boolean;
    /**
     * By default, 'rush update' passes --no-prefer-frozen-lockfile to 'pnpm install'.
     * Set this option to true to pass '--prefer-frozen-lockfile' instead to minimize shrinkwrap changes.
     */
    usePnpmPreferFrozenLockfileForRushUpdate?: boolean;
    /**
     * By default, 'rush update' runs as a single operation.
     * Set this option to true to instead update the lockfile with `--lockfile-only`, then perform a `--frozen-lockfile` install.
     * Necessary when using the `afterAllResolved` hook in .pnpmfile.cjs.
     */
    usePnpmLockfileOnlyThenFrozenLockfileForRushUpdate?: boolean;
    /**
     * If using the 'preventManualShrinkwrapChanges' option, restricts the hash to only include the layout of external dependencies.
     * Used to allow links between workspace projects or the addition/removal of references to existing dependency versions to not
     * cause hash changes.
     */
    omitImportersFromPreventManualShrinkwrapChanges?: boolean;
    /**
     * If true, the chmod field in temporary project tar headers will not be normalized.
     * This normalization can help ensure consistent tarball integrity across platforms.
     */
    noChmodFieldInTarHeaderNormalization?: boolean;
    /**
     * If true, build caching will respect the allowWarningsInSuccessfulBuild flag and cache builds with warnings.
     * This will not replay warnings from the cached build.
     */
    buildCacheWithAllowWarningsInSuccessfulBuild?: boolean;
    /**
     * If true, build skipping will respect the allowWarningsInSuccessfulBuild flag and skip builds with warnings.
     * This will not replay warnings from the skipped build.
     */
    buildSkipWithAllowWarningsInSuccessfulBuild?: boolean;
    /**
     * If true, perform a clean install after when running `rush install` or `rush update` if the
     * `.npmrc` file has changed since the last install.
     */
    cleanInstallAfterNpmrcChanges?: boolean;
    /**
     * If true, print the outputs of shell commands defined in event hooks to the console.
     */
    printEventHooksOutputToConsole?: boolean;
    /**
     * If true, Rush will not allow node_modules in the repo folder or in parent folders.
     */
    forbidPhantomResolvableNodeModulesFolders?: boolean;
    /**
     * (UNDER DEVELOPMENT) For certain installation problems involving peer dependencies, PNPM cannot
     * correctly satisfy versioning requirements without installing duplicate copies of a package inside the
     * node_modules folder. This poses a problem for "workspace:*" dependencies, as they are normally
     * installed by making a symlink to the local project source folder. PNPM's "injected dependencies"
     * feature provides a model for copying the local project folder into node_modules, however copying
     * must occur AFTER the dependency project is built and BEFORE the consuming project starts to build.
     * The "pnpm-sync" tool manages this operation; see its documentation for details.
     * Enable this experiment if you want "rush" and "rushx" commands to resync injected dependencies
     * by invoking "pnpm-sync" during the build.
     */
    usePnpmSyncForInjectedDependencies?: boolean;
    /**
     * If set to true, Rush will generate a `project-impact-graph.yaml` file in the repository root during `rush update`.
     */
    generateProjectImpactGraphDuringRushUpdate?: boolean;
    /**
     * If true, when running in watch mode, Rush will check for phase scripts named `_phase:<name>:ipc` and run them instead
     * of `_phase:<name>` if they exist. The created child process will be provided with an IPC channel and expected to persist
     * across invocations.
     */
    useIPCScriptsInWatchMode?: boolean;
    /**
     * (UNDER DEVELOPMENT) The Rush alerts feature provides a way to send announcements to engineers
     * working in the monorepo, by printing directly in the user's shell window when they invoke Rush commands.
     * This ensures that important notices will be seen by anyone doing active development, since people often
     * ignore normal discussion group messages or don't know to subscribe.
     */
    rushAlerts?: boolean;
    /**
     * Allow cobuilds without using the build cache to store previous execution info. When setting up
     *  distributed builds, Rush will allow uncacheable projects to still leverage the cobuild feature.
     * This is useful when you want to speed up operations that can't (or shouldn't) be cached.
     */
    allowCobuildWithoutCache?: boolean;
    /**
     * By default, rush perform a full scan of the entire repository. For example, Rush runs `git status` to check for local file changes.
     * When this toggle is enabled, Rush will only scan specific paths, significantly speeding up Git operations.
     */
    enableSubpathScan?: boolean;
    /**
     * Rush has a policy that normally requires Rush projects to specify `workspace:*` in package.json when depending
     * on other projects in the workspace, unless they are explicitly declared as `decoupledLocalDependencies`
     * in rush.json.  Enabling this experiment will remove that requirement for dependencies belonging to a different
     * subspace.  This is useful for large product groups who work in separate subspaces and generally prefer to consume
     * each other's packages via the NPM registry.
     */
    exemptDecoupledDependenciesBetweenSubspaces?: boolean;
}

/**
 * Options for creating a file system build cache provider.
 * @beta
 */
export declare interface IFileSystemBuildCacheProviderOptions {
    /**
     * The workspace Rush configuration
     */
    rushConfiguration: RushConfiguration;
    /**
     * The user Rush configuration
     */
    rushUserConfiguration: RushUserConfiguration;
}

/**
 * Options for generating the cache id for an operation.
 * @beta
 */
export declare interface IGenerateCacheEntryIdOptions {
    /**
     * The name of the project
     */
    projectName: string;
    /**
     * The name of the phase
     */
    phaseName: string;
    /**
     * A hash of the input files
     */
    projectStateHash: string;
}

/**
 * @beta
 */
export declare interface IGetChangedProjectsOptions {
    targetBranchName: string;
    terminal: ITerminal;
    shouldFetch?: boolean;
    variant?: string;
    /**
     * If set to `true`, consider a project's external dependency installation layout as defined in the
     * package manager lockfile when determining if it has changed.
     */
    includeExternalDependencies: boolean;
    /**
     * If set to `true` apply the `incrementalBuildIgnoredGlobs` property in a project's `rush-project.json`
     * and exclude matched files from change detection.
     */
    enableFiltering: boolean;
}

/**
 * Information about the currently executing global script command (as defined in command-line.json) provided to plugins.
 * @beta
 */
export declare interface IGlobalCommand extends IRushCommand {
}

declare interface IIndividualVersionJson extends IVersionPolicyJson {
    lockedMajor?: number;
}

/**
 * Represents a synchronously-queryable in-memory snapshot of the state of the inputs to a Rush repository.
 *
 * The methods on this interface are idempotent and will return the same result regardless of when they are executed.
 * @beta
 */
export declare interface IInputsSnapshot {
    /**
     * The raw hashes of all tracked files in the repository.
     */
    readonly hashes: ReadonlyMap<string, string>;
    /**
     * The directory that all paths in `hashes` are relative to.
     */
    readonly rootDirectory: string;
    /**
     * Gets the map of file paths to Git hashes that will be used to compute the local state hash of the operation.
     * Exposed separately from the final state hash to facilitate detailed change detection.
     *
     * @param project - The Rush project to get hashes for
     * @param operationName - The name of the operation (phase) to get hashes for. If omitted, returns a default set for the project, as used for bulk commands.
     * @returns A map of file name to Git hash. For local files paths will be relative. Configured additional files may be absolute paths.
     */
    getTrackedFileHashesForOperation(project: IRushConfigurationProjectForSnapshot, operationName?: string): ReadonlyMap<string, string>;
    /**
     * Gets the state hash for the files owned by this operation, including the resolutions of package.json dependencies. This will later be combined with the hash of
     * the command being executed and the final hashes of the operation's dependencies to compute the final hash for the operation.
     * @param project - The Rush project to compute the state hash for
     * @param operationName - The name of the operation (phase) to get hashes for. If omitted, returns a generic hash for the whole project, as used for bulk commands.
     * @returns The local state hash for the project. This is a hash of the environment, the project's tracked files, and any additional files.
     */
    getOperationOwnStateHash(project: IRushConfigurationProjectForSnapshot, operationName?: string): string;
}

/**
 * Options to pass to the rush "launch" functions.
 *
 * @public
 */
export declare interface ILaunchOptions {
    /**
     * True if the tool was invoked from within a project with a rush.json file, otherwise false. We
     * consider a project without a rush.json to be "unmanaged" and we'll print that to the command line when
     * the tool is executed. This is mainly used for debugging purposes.
     */
    isManaged: boolean;
    /**
     * If true, the wrapper process already printed a warning that the version of Node.js hasn't been tested
     * with this version of Rush, so we shouldn't print a similar error.
     */
    alreadyReportedNodeTooNewError?: boolean;
    /**
     * Pass along the terminal provider from the CLI version selector.
     *
     * @privateRemarks
     * We should remove this.  The version selector package can be very old.  It's unwise for
     * `rush-lib` to rely on a potentially ancient `ITerminalProvider` implementation.
     */
    terminalProvider?: ITerminalProvider;
    /**
     * Used only by `@microsoft/rush/lib/start-dev.js` during development.
     * Specifies Rush devDependencies of the `@microsoft/rush` to be manually loaded.
     *
     * @remarks
     * Marked as `@internal` because `IBuiltInPluginConfiguration` is internal.
     * @internal
     */
    builtInPluginConfigurations?: _IBuiltInPluginConfiguration[];
}

/**
 * @public
 */
declare interface ILocalBuildCacheJson extends IBaseBuildCacheJson {
    readonly cacheProvider: 'local-only';
}

declare interface ILockStepVersionJson extends IVersionPolicyJson {
    version: string;
    nextBump?: string;
    mainProject?: string;
}

/**
 * Information about the log files for an operation.
 *
 * @alpha
 */
export declare interface ILogFilePaths {
    /**
     * The absolute path to the folder containing the text log files.
     * Provided as a convenience since it is an intermediary value of producing the text log file path.
     */
    textFolder: string;
    /**
     * The absolute path to the folder containing the JSONL log files.
     * Provided as a convenience since it is an intermediary value of producing the jsonl log file path.
     */
    jsonlFolder: string;
    /**
     * The absolute path to the merged (interleaved stdout and stderr) text log.
     * ANSI escape codes have been stripped.
     */
    text: string;
    /**
     * The absolute path to the stderr text log.
     * ANSI escape codes have been stripped.
     */
    error: string;
    /**
     * The absolute path to the JSONL log. ANSI escape codes are left intact to be able to reproduce the console output.
     */
    jsonl: string;
}

/**
 * @beta
 */
export declare interface ILogger {
    readonly terminal: Terminal;
    /**
     * Call this function to emit an error to the Rush runtime.
     */
    emitError(error: Error): void;
    /**
     * Call this function to emit a warning to the Rush runtime.
     */
    emitWarning(warning: Error): void;
}

/**
 * This policy indicates all related projects get version bump driven by their own changes.
 * @public
 */
export declare class IndividualVersionPolicy extends VersionPolicy {
    /**
     * The major version that has been locked
     */
    readonly lockedMajor: number | undefined;
    /**
     * @internal
     */
    constructor(versionPolicyJson: IIndividualVersionJson);
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json(): IIndividualVersionJson;
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    /**
     * Bumps version.
     * Individual version policy lets change files drive version bump. This method currently does not do anything.
     *
     * @param bumpType - bump type
     * @param identifier - prerelease id
     */
    bump(bumpType?: BumpType, identifier?: string): void;
    /**
     * Validates the specified version and throws if the version does not satisfy the policy.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString: string, packageName: string): void;
}

/**
 * Part of IRushConfigurationJson.
 * @internal
 */
export declare interface _INpmOptionsJson extends IPackageManagerOptionsJsonBase {
}

/**
 * The `IOperationExecutionResult` interface represents the results of executing an {@link Operation}.
 * @alpha
 */
export declare interface IOperationExecutionResult {
    /**
     * The operation itself
     */
    readonly operation: Operation;
    /**
     * The current execution status of an operation. Operations start in the 'ready' state,
     * but can be 'blocked' if an upstream operation failed. It is 'executing' when
     * the operation is executing. Once execution is complete, it is either 'success' or
     * 'failure'.
     */
    readonly status: OperationStatus;
    /**
     * The error which occurred while executing this operation, this is stored in case we need
     * it later (for example to re-print errors at end of execution).
     */
    readonly error: Error | undefined;
    /**
     * If this operation is only present in the graph to maintain dependency relationships, this flag will be set to true.
     */
    readonly silent: boolean;
    /**
     * Object tracking execution timing.
     */
    readonly stopwatch: IStopwatchResult;
    /**
     * Object used to report a summary at the end of the Rush invocation.
     */
    readonly stdioSummarizer: StdioSummarizer;
    /**
     * The value indicates the duration of the same operation without cache hit.
     */
    readonly nonCachedDurationMs: number | undefined;
    /**
     * The id of the runner which actually runs the building process in cobuild mode.
     */
    readonly cobuildRunnerId: string | undefined;
    /**
     * The relative path to the folder that contains operation metadata. This folder will be automatically included in cache entries.
     */
    readonly metadataFolderPath: string | undefined;
    /**
     * The paths to the log files, if applicable.
     */
    readonly logFilePaths: ILogFilePaths | undefined;
}

/**
 * @internal
 */
export declare interface _IOperationMetadata {
    durationInSeconds: number;
    logPath: string;
    errorLogPath: string;
    logChunksPath: string;
    cobuildContextId: string | undefined;
    cobuildRunnerId: string | undefined;
}

/**
 * @internal
 */
export declare interface _IOperationMetadataManagerOptions {
    rushProject: RushConfigurationProject;
    phase: IPhase;
    operation: Operation;
}

/**
 * Options for constructing a new Operation.
 * @alpha
 */
export declare interface IOperationOptions {
    /**
     * The Rush phase associated with this Operation, if any
     */
    phase?: IPhase | undefined;
    /**
     * The Rush project associated with this Operation, if any
     */
    project?: RushConfigurationProject | undefined;
    /**
     * When the scheduler is ready to process this `Operation`, the `runner` implements the actual work of
     * running the operation.
     */
    runner?: IOperationRunner | undefined;
    /**
     * Settings defined in the project configuration for this operation, can be overridden.
     */
    settings?: IOperationSettings | undefined;
    /**
     * {@inheritDoc Operation.logFilenameIdentifier}
     */
    logFilenameIdentifier: string;
}

/**
 * The `Operation` class is a node in the dependency graph of work that needs to be scheduled by the
 * `OperationExecutionManager`. Each `Operation` has a `runner` member of type `IOperationRunner`, whose
 * implementation manages the actual process for running a single operation.
 *
 * @beta
 */
export declare interface IOperationRunner {
    /**
     * Name of the operation, for logging.
     */
    readonly name: string;
    /**
     * Whether or not the operation is cacheable. If false, all cache engines will be disabled for this operation.
     */
    cacheable: boolean;
    /**
     * Indicates that this runner's duration has meaning.
     */
    reportTiming: boolean;
    /**
     * Indicates that this runner is architectural and should not be reported on.
     */
    silent: boolean;
    /**
     * If set to true, a warning result should not make Rush exit with a nonzero
     * exit code
     */
    warningsAreAllowed: boolean;
    /**
     * If set to true, this operation is considered a no-op and can be considered always skipped for
     * analysis purposes.
     */
    readonly isNoOp?: boolean;
    /**
     * Method to be executed for the operation.
     */
    executeAsync(context: IOperationRunnerContext): Promise<OperationStatus>;
    /**
     * Return a hash of the configuration that affects the operation.
     */
    getConfigHash(): string;
}

/**
 * Information passed to the executing `IOperationRunner`
 *
 * @beta
 */
export declare interface IOperationRunnerContext {
    /**
     * The writer into which this `IOperationRunner` should write its logs.
     */
    collatedWriter: CollatedWriter;
    /**
     * If Rush was invoked with `--debug`
     */
    debugMode: boolean;
    /**
     * Defaults to `true`. Will be `false` if Rush was invoked with `--verbose`.
     */
    quietMode: boolean;
    /**
     * Object used to manage metadata of the operation.
     *
     * @internal
     */
    _operationMetadataManager?: _OperationMetadataManager;
    /**
     * Object used to track elapsed time.
     */
    stopwatch: IStopwatchResult;
    /**
     * The current execution status of an operation. Operations start in the 'ready' state,
     * but can be 'blocked' if an upstream operation failed. It is 'executing' when
     * the operation is executing. Once execution is complete, it is either 'success' or
     * 'failure'.
     */
    status: OperationStatus;
    /**
     * The environment in which the operation is being executed.
     * A return value of `undefined` indicates that it should inherit the environment from the parent process.
     */
    environment: IEnvironment | undefined;
    /**
     * Error which occurred while executing this operation, this is stored in case we need
     * it later (for example to re-print errors at end of execution).
     */
    error?: Error;
    /**
     * Invokes the specified callback with a terminal that is associated with this operation.
     *
     * Will write to a log file corresponding to the phase and project, and clean it up upon completion.
     */
    runWithTerminalAsync<T>(callback: (terminal: ITerminal, terminalProvider: ITerminalProvider) => Promise<T>, options: {
        createLogFile: boolean;
        logFileSuffix?: string;
    }): Promise<T>;
}

/**
 * @alpha
 */
export declare interface IOperationSettings {
    /**
     * The name of the operation. This should be a key in the `package.json`'s `scripts` object.
     */
    operationName: string;
    /**
     * Specify the folders where this operation writes its output files. If enabled, the Rush build
     * cache will restore these folders from the cache. The strings are folder names under the project
     * root folder.
     *
     * These folders should not be tracked by Git. They must not contain symlinks.
     */
    outputFolderNames?: string[];
    /**
     * Disable caching for this operation. The operation will never be restored from cache.
     * This may be useful if this operation affects state outside of its folder.
     *
     * This option is only used when the build cache is enabled for the repo. You can set
     * disableBuildCacheForOperation=true to disable caching for a specific project operation.
     * This is a useful workaround if that project's build scripts violate the assumptions of the cache,
     * for example by writing files outside the project folder. Where possible, a better solution is to improve
     * the build scripts to be compatible with caching.
     */
    disableBuildCacheForOperation?: boolean;
    /**
     * An optional list of environment variables that can affect this operation. The values of
     * these environment variables will become part of the hash when reading and writing the build cache.
     *
     * Note: generally speaking, all environment variables available to Rush are also available to any
     * operations performed -- Rush assumes that environment variables do not affect build outputs unless
     * you list them here.
     */
    dependsOnEnvVars?: string[];
    /**
     * An optional list of glob (minimatch) patterns pointing to files that can affect this operation.
     * The hash values of the contents of these files will become part of the final hash when reading
     * and writing the build cache.
     *
     * Note: if a particular file will be matched by patterns provided by both `incrementalBuildIgnoredGlobs` and
     * `dependsOnAdditionalFiles` options - `dependsOnAdditionalFiles` will win and the file will be included
     * calculating final hash value when reading and writing the build cache
     */
    dependsOnAdditionalFiles?: string[];
    /**
     * An optional config object for sharding the operation. If specified, the operation will be sharded
     * into multiple invocations. The `count` property specifies the number of shards to create. The
     * `shardArgumentFormat` property specifies the format of the argument to pass to the command to
     * indicate the shard index and count. The default value is `--shard={shardIndex}/{shardCount}`.
     */
    sharding?: IRushPhaseSharding;
    /**
     * How many concurrency units this operation should take up during execution. The maximum concurrent units is
     *  determined by the -p flag.
     */
    weight?: number;
    /**
     * If true, this operation can use cobuilds for orchestration without restoring build cache entries.
     */
    allowCobuildWithoutCache?: boolean;
}

/**
 * @internal
 */
export declare interface _IOperationStateFileOptions {
    projectFolder: string;
    metadataFolder: string;
}

/**
 * @internal
 */
export declare interface _IOperationStateJson {
    nonCachedDurationMs: number;
    cobuildContextId: string | undefined;
    cobuildRunnerId: string | undefined;
}

/**
 * Options for the package manager.
 * @public
 */
export declare interface IPackageManagerOptionsJsonBase {
    /**
     * Environment variables for the package manager
     */
    environmentVariables?: IConfigurationEnvironment;
}

/**
 * Metadata about a phase.
 * @alpha
 */
export declare interface IPhase {
    /**
     * The name of this phase.
     */
    name: string;
    /**
     * If set to `true,` this this phase was generated from a bulk command, and
     * was not explicitly defined in the command-line.json file.
     */
    isSynthetic: boolean;
    /**
     * This property is used in the name of the filename for the logs generated by this
     * phase. This is a filesystem-safe version of the phase name. For example,
     * a phase with name `_phase:compile` has a `logFilenameIdentifier` of `_phase_compile`.
     */
    logFilenameIdentifier: string;
    /**
     * The set of custom command line parameters that are relevant to this phase.
     */
    associatedParameters: Set<CommandLineParameter>;
    /**
     * The resolved dependencies of the phase
     */
    dependencies: {
        self: Set<IPhase>;
        upstream: Set<IPhase>;
    };
    /**
     * By default, Rush returns a nonzero exit code if errors or warnings occur during a command. If this option is
     * set to `true`, Rush will return a zero exit code if warnings occur during the execution of this phase.
     */
    allowWarningsOnSuccess: boolean;
    /**
     * What should happen if the script is not defined in a project's package.json scripts field. Default is "error".
     */
    missingScriptBehavior: IPhaseBehaviorForMissingScript;
    /**
     * (Optional) If the `shellCommand` field is set for a bulk command, Rush will invoke it for each
     * selected project; otherwise, Rush will invoke the package.json `"scripts"` entry matching Rush command/phase name.
     *
     * This string is the path to a script that will be invoked using the OS shell. The working directory will be
     * the folder that contains rush.json.  If custom parameters are associated with this command, their
     * values will be appended to the end of this string.
     */
    shellCommand?: string;
}

/**
 * The set of valid behaviors for a missing script in a project's package.json scripts for a given phase.
 * @alpha
 */
export declare type IPhaseBehaviorForMissingScript = 'silent' | 'log' | 'error';

/**
 * Information about the currently executing phased script command (as defined in command-line.json, or default "build" or "rebuild") provided to plugins.
 * @beta
 */
export declare interface IPhasedCommand extends IRushCommand {
    /**
     * Hooks into the execution of the current phased command
     * @alpha
     */
    readonly hooks: PhasedCommandHooks;
}

/**
 * Possible values for the `pnpmLockfilePolicies` setting in Rush's pnpm-config.json file.
 * @public
 */
export declare interface IPnpmLockfilePolicies {
    /**
     * Forbid sha1 hashes in `pnpm-lock.yaml`
     */
    disallowInsecureSha1?: {
        enabled: boolean;
        exemptPackageVersions: Record<string, string[]>;
    };
}

/**
 * Part of IRushConfigurationJson.
 * @internal
 */
export declare interface _IPnpmOptionsJson extends IPackageManagerOptionsJsonBase {
    /**
     * {@inheritDoc PnpmOptionsConfiguration.pnpmStore}
     */
    pnpmStore?: PnpmStoreLocation;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.strictPeerDependencies}
     */
    strictPeerDependencies?: boolean;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.preventManualShrinkwrapChanges}
     */
    preventManualShrinkwrapChanges?: boolean;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.useWorkspaces}
     */
    useWorkspaces?: boolean;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.globalOverrides}
     */
    globalOverrides?: Record<string, string>;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.globalPeerDependencyRules}
     */
    globalPeerDependencyRules?: IPnpmPeerDependencyRules;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.globalPackageExtensions}
     */
    globalPackageExtensions?: Record<string, IPnpmPackageExtension>;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.globalNeverBuiltDependencies}
     */
    globalNeverBuiltDependencies?: string[];
    /**
     * {@inheritDoc PnpmOptionsConfiguration.globalIgnoredOptionalDependencies}
     */
    globalIgnoredOptionalDependencies?: string[];
    /**
     * {@inheritDoc PnpmOptionsConfiguration.globalAllowedDeprecatedVersions}
     */
    globalAllowedDeprecatedVersions?: Record<string, string>;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.globalPatchedDependencies}
     */
    globalPatchedDependencies?: Record<string, string>;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.unsupportedPackageJsonSettings}
     */
    unsupportedPackageJsonSettings?: unknown;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.resolutionMode}
     */
    resolutionMode?: PnpmResolutionMode;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.autoInstallPeers}
     */
    autoInstallPeers?: boolean;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.alwaysInjectDependenciesFromOtherSubspaces}
     */
    alwaysInjectDependenciesFromOtherSubspaces?: boolean;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.alwaysFullInstall}
     */
    alwaysFullInstall?: boolean;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.pnpmLockfilePolicies}
     */
    pnpmLockfilePolicies?: IPnpmLockfilePolicies;
}

/**
 * @public
 */
export declare interface IPnpmPackageExtension {
    dependencies?: Record<string, string>;
    optionalDependencies?: Record<string, string>;
    peerDependencies?: Record<string, string>;
    peerDependenciesMeta?: IPnpmPeerDependenciesMeta;
}

/**
 * @public
 */
export declare interface IPnpmPeerDependenciesMeta {
    [packageName: string]: {
        optional?: boolean;
    };
}

/**
 * @public
 */
export declare interface IPnpmPeerDependencyRules {
    ignoreMissing?: string[];
    allowAny?: string[];
    allowedVersions?: Record<string, string>;
}

export { IPrefixMatch }

/**
 * Information about the currently executing command provided to plugins.
 * @beta
 */
export declare interface IRushCommand {
    /**
     * The name of this command, as seen on the command line
     */
    readonly actionName: string;
}

/**
 * The full spec of an available Rush command line action
 *
 * @beta
 */
export declare interface IRushCommandLineAction {
    actionName: string;
    parameters: IRushCommandLineParameter[];
}

/**
 * Information about the available parameters associated with a Rush action
 *
 * @beta
 */
export declare interface IRushCommandLineParameter {
    /**
     * The corresponding string representation of CliParameterKind
     */
    readonly kind: keyof typeof CommandLineParameterKind;
    /**
     * The long name of the flag including double dashes, e.g. "--do-something"
     */
    readonly longName: string;
    /**
     * An optional short name for the flag including the dash, e.g. "-d"
     */
    readonly shortName?: string;
    /**
     * Documentation for the parameter that will be shown when invoking the tool with "--help"
     */
    readonly description: string;
    /**
     * If true, then an error occurs if the parameter was not included on the command-line.
     */
    readonly required?: boolean;
    /**
     * If provided, this parameter can also be provided by an environment variable with the specified name.
     */
    readonly environmentVariable?: string;
}

/**
 * The full spec of a Rush CLI
 *
 * @beta
 */
export declare interface IRushCommandLineSpec {
    actions: IRushCommandLineAction[];
}

/**
 * This represents the JSON data structure for the "rush.json" configuration file.
 * See rush.schema.json for documentation.
 */
declare interface IRushConfigurationJson {
    $schema: string;
    npmVersion?: string;
    pnpmVersion?: string;
    yarnVersion?: string;
    rushVersion: string;
    repository?: IRushRepositoryJson;
    nodeSupportedVersionRange?: string;
    nodeSupportedVersionInstructions?: string;
    suppressNodeLtsWarning?: boolean;
    suppressRushIsPublicVersionCheck?: boolean;
    projectFolderMinDepth?: number;
    projectFolderMaxDepth?: number;
    allowMostlyStandardPackageNames?: boolean;
    approvedPackagesPolicy?: IApprovedPackagesPolicyJson;
    gitPolicy?: IRushGitPolicyJson;
    telemetryEnabled?: boolean;
    allowedProjectTags?: string[];
    projects: IRushConfigurationProjectJson[];
    eventHooks?: IEventHooksJson;
    hotfixChangeEnabled?: boolean;
    npmOptions?: _INpmOptionsJson;
    pnpmOptions?: _IPnpmOptionsJson;
    yarnOptions?: _IYarnOptionsJson;
    ensureConsistentVersions?: boolean;
    variants?: IRushVariantOptionsJson[];
}

/**
 * @beta
 */
export declare type IRushConfigurationProjectForSnapshot = Pick<RushConfigurationProject, 'projectFolder' | 'projectRelativeFolder'>;

/**
 * This represents the JSON data object for a project entry in the rush.json configuration file.
 */
declare interface IRushConfigurationProjectJson {
    packageName: string;
    projectFolder: string;
    reviewCategory?: string;
    decoupledLocalDependencies: string[];
    cyclicDependencyProjects?: string[];
    versionPolicyName?: string;
    shouldPublish?: boolean;
    skipRushCheck?: boolean;
    publishFolder?: string;
    tags?: string[];
    subspaceName?: string;
}

/**
 * @internal
 */
declare interface IRushConfigurationProjectOptions {
    /**
     * The raw JSON representation from rush.json
     */
    projectJson: IRushConfigurationProjectJson;
    /**
     * The enclosing configuration
     */
    rushConfiguration: RushConfiguration;
    /**
     * A unique string name for this project
     */
    tempProjectName: string;
    /**
     * If specified, validate project tags against this list.
     */
    allowedProjectTags: Set<string> | undefined;
    /**
     * The containing subspace.
     */
    subspace: Subspace;
}

/**
 * Part of IRushConfigurationJson.
 */
declare interface IRushGitPolicyJson {
    allowedEmailRegExps?: string[];
    sampleEmail?: string;
    versionBumpCommitMessage?: string;
    changeLogUpdateCommitMessage?: string;
    changefilesCommitMessage?: string;
    tagSeparator?: string;
}

/** @alpha */
export declare interface IRushPhaseSharding {
    /**
     * The number of shards to create.
     */
    count: number;
    /**
     * The format of the argument to pass to the command to indicate the shard index and count.
     *
     * @defaultValue `--shard={shardIndex}/{shardCount}`
     */
    shardArgumentFormat?: string;
    /**
     * An optional argument to pass to the command to indicate the output folder for the shard.
     *  It must end with `{shardIndex}`.
     *
     * @defaultValue `--shard-output-folder=.rush/operations/{phaseName}/shards/{shardIndex}`.
     */
    outputFolderArgumentFormat?: string;
    /**
     * @deprecated Create a separate operation settings object for the shard operation settings with the name `{operationName}:shard`.
     */
    shardOperationSettings?: unknown;
}

/**
 * @beta
 */
export declare interface IRushPlugin {
    apply(rushSession: RushSession, rushConfiguration: RushConfiguration): void;
}

declare interface IRushPluginConfiguration extends _IRushPluginConfigurationBase {
    autoinstallerName: string;
}

/**
 * @internal
 */
export declare interface _IRushPluginConfigurationBase {
    packageName: string;
    pluginName: string;
}

declare interface IRushPluginsConfigurationJson {
    plugins: IRushPluginConfiguration[];
}

/**
 * Describes the file structure for the `<project root>/config/rush-project.json` config file.
 * @internal
 */
export declare interface _IRushProjectJson {
    /**
     * The incremental analyzer can skip Rush commands for projects whose input files have
     * not changed since the last build. Normally, every Git-tracked file under the project
     * folder is assumed to be an input. Set incrementalBuildIgnoredGlobs to ignore specific
     * files, specified as globs relative to the project folder. The list of file globs will
     * be interpreted the same way your .gitignore file is.
     */
    incrementalBuildIgnoredGlobs?: string[];
    /**
     * Disable caching for this project. The project will never be restored from cache.
     * This may be useful if this project affects state outside of its folder.
     *
     * This option is only used when the build cache is enabled for the repo. You can set
     * disableBuildCacheForProject=true to disable caching for a specific project. This is a useful workaround
     * if that project's build scripts violate the assumptions of the cache, for example by writing
     * files outside the project folder. Where possible, a better solution is to improve the build scripts
     * to be compatible with caching.
     */
    disableBuildCacheForProject?: boolean;
    operationSettings?: IOperationSettings[];
}

declare type IRushRepositoryJson = IRushRepositoryJsonSingleUrl | IRushRepositoryJsonMultipleUrls;

/**
 * Part of IRushConfigurationJson.
 */
declare interface IRushRepositoryJsonBase {
    /**
     * The default branch name. This tells "rush change" which remote branch to compare against.
     */
    defaultBranch?: string;
    /**
     * The default remote. This tells "rush change" which remote to compare against if the remote URL is not set
     * or if a remote matching the provided remote URL is not found.
     */
    defaultRemote?: string;
}

declare interface IRushRepositoryJsonMultipleUrls extends IRushRepositoryJsonBase {
    /**
     * Remote url(s) of the repository. If a value is provided, \"rush change\" will
     * use one of these to find the right remote to compare against. Specifying multiple URLs
     * is useful if a GitHub repository is renamed or for `<projectName>.visualstudio.com` versus
     * `dev.azure.com/<projectName>` URLs.
     */
    urls?: string[];
}

declare interface IRushRepositoryJsonSingleUrl extends IRushRepositoryJsonBase {
    /**
     * The remote url of the repository. If a value is provided,
     * \"rush change\" will use it to find the right remote to compare against.
     *
     * @deprecated Use "urls" instead.
     */
    url?: string;
}

/**
 * @beta
 */
export declare interface IRushSessionOptions {
    terminalProvider: ITerminalProvider;
    getIsDebugMode: () => boolean;
}

/**
 * Options defining an allowed variant as part of IRushConfigurationJson.
 */
declare interface IRushVariantOptionsJson {
    variantName: string;
    description: string;
}

/**
 * Represents a readonly view of a `Stopwatch`.
 * @beta
 */
export declare interface IStopwatchResult {
    /**
     * Displays how long the stopwatch has been executing in a human readable format.
     */
    toString(): string;
    /**
     * Get the duration in seconds.
     */
    get duration(): number;
    /**
     * Return the start time of the most recent stopwatch run.
     */
    get startTime(): number | undefined;
    /**
     * Return the end time of the most recent stopwatch run.
     */
    get endTime(): number | undefined;
}

/**
 * @internal
 */
declare interface ISubspaceOptions {
    subspaceName: string;
    rushConfiguration: RushConfiguration;
    splitWorkspaceCompatibility: boolean;
}

/**
 * @beta
 */
export declare interface ITelemetryData {
    /**
     * Command name
     * @example `"build"`
     */
    readonly name: string;
    /**
     * Duration in seconds
     */
    readonly durationInSeconds: number;
    /**
     * The result of the command
     */
    readonly result: 'Succeeded' | 'Failed';
    /**
     * The millisecond-resolution timestamp of the telemetry logging
     * @example 1648001893024
     */
    readonly timestampMs?: number;
    /**
     * The platform the command was executed on, based on the Node.js `process.platform()` API
     * @example `"darwin"`, `"win32"`, `"linux"`
     */
    readonly platform?: string;
    /**
     * The Rush version
     * @example `5.63.0`
     */
    readonly rushVersion?: string;
    /**
     * Detailed information about the host machine.
     */
    readonly machineInfo?: ITelemetryMachineInfo;
    /**
     * Only applicable to phased commands. Provides detailed results by operation.
     * Keys are operation names, values contain result, timing information, and dependencies.
     */
    readonly operationResults?: Record<string, ITelemetryOperationResult>;
    readonly extraData?: {
        [key: string]: string | number | boolean;
    };
}

/**
 * @beta
 */
export declare interface ITelemetryMachineInfo {
    /**
     * The CPU architecture
     * @example `"AMD64"`
     */
    machineArchitecture: string;
    /**
     * The CPU model
     * * @example `"AMD Ryzen 7 3700X 8-Core Processor"`
     */
    machineCpu: string;
    /**
     * The number of logical CPU cores.
     */
    machineCores: number;
    /**
     * The total amount of RAM on the machine, in MiB.
     */
    machineTotalMemoryMiB: number;
    /**
     * The amount of free RAM on the machine at the end of execution, in MiB.
     */
    machineFreeMemoryMiB: number;
}

/**
 * @beta
 */
export declare interface ITelemetryOperationResult {
    /**
     * The names of operations that this operation depends on.
     */
    dependencies: string[];
    /**
     * The status code for the operation.
     */
    result: string;
    /**
     * A timestamp in milliseconds (from `performance.now()`) when the operation started.
     * If the operation was blocked, will be `undefined`.
     */
    startTimestampMs?: number;
    /**
     * A timestamp in milliseconds (from `performance.now()`) when the operation finished.
     * If the operation was blocked, will be `undefined`.
     */
    endTimestampMs?: number;
    /**
     * Duration in milliseconds when the operation does not hit cache
     */
    nonCachedDurationMs?: number;
    /**
     * Was this operation built on this machine? If so, the duration can be calculated from `startTimestampMs` and `endTimestampMs`.
     *  If not, you should use the metrics from the machine that built it.
     */
    wasExecutedOnThisMachine?: boolean;
}

/**
 * Options for `RushConfiguration.tryFindRushJsonLocation`.
 * @public
 */
export declare interface ITryFindRushJsonLocationOptions {
    /**
     * Whether to show verbose console messages.  Defaults to false.
     */
    showVerbose?: boolean;
    /**
     * The folder path where the search will start.  Defaults to the current working directory.
     */
    startingFolder?: string;
}

declare interface IVersionPolicyDependencyJson {
    versionFormatForPublish?: VersionFormatForPublish;
    versionFormatForCommit?: VersionFormatForCommit;
}

declare interface IVersionPolicyJson {
    policyName: string;
    definitionName: string;
    dependencies?: IVersionPolicyDependencyJson;
    exemptFromRushChange?: boolean;
    includeEmailInChangeFile?: boolean;
}

/**
 * Part of IRushConfigurationJson.
 * @internal
 */
export declare interface _IYarnOptionsJson extends IPackageManagerOptionsJsonBase {
    /**
     * If true, then Rush will add the "--ignore-engines" option when invoking Yarn.
     * This allows "rush install" to succeed if there are dependencies with engines defined in
     * package.json which do not match the current environment.
     *
     * The default value is false.
     */
    ignoreEngines?: boolean;
}

/**
 * This policy indicates all related projects should use the same version.
 * @public
 */
export declare class LockStepVersionPolicy extends VersionPolicy {
    private _version;
    /**
     * The type of bump for next bump.
     */
    readonly nextBump: BumpType | undefined;
    /**
     * The main project for the version policy.
     *
     * If the value is provided, change logs will only be generated in that project.
     * If the value is not provided, change logs will be hosted in each project associated with the policy.
     */
    readonly mainProject: string | undefined;
    /**
     * @internal
     */
    constructor(versionPolicyJson: ILockStepVersionJson);
    /**
     * The value of the lockstep version
     */
    get version(): string;
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json(): ILockStepVersionJson;
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    /**
     * Bumps the version of the lockstep policy
     *
     * @param bumpType - Overwrite bump type in version-policy.json with the provided value.
     * @param identifier - Prerelease identifier if bump type is prerelease.
     */
    bump(bumpType?: BumpType, identifier?: string): void;
    /**
     * Updates the version of the policy directly with a new value
     * @param newVersionString - New version
     */
    update(newVersionString: string): boolean;
    /**
     * Validates the specified version and throws if the version does not satisfy lockstep version.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString: string, packageName: string): void;
    private _updatePackageVersion;
    private _getReleaseType;
}

export { LookupByPath }

/**
 * Options that are only used when the NPM package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the NPM package manager
 * is not being used.
 *
 * @public
 */
export declare class NpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    /** @internal */
    constructor(json: _INpmOptionsJson);
}

/**
 * The `Operation` class is a node in the dependency graph of work that needs to be scheduled by the
 * `OperationExecutionManager`. Each `Operation` has a `runner` member of type `IOperationRunner`, whose
 * implementation manages the actual process of running a single operation.
 *
 * The graph of `Operation` instances will be cloned into a separate execution graph after processing.
 *
 * @alpha
 */
export declare class Operation {
    /**
     * The Rush phase associated with this Operation, if any
     */
    readonly associatedPhase: IPhase | undefined;
    /**
     * The Rush project associated with this Operation, if any
     */
    readonly associatedProject: RushConfigurationProject | undefined;
    /**
     * A set of all operations which depend on this operation.
     */
    readonly consumers: ReadonlySet<Operation>;
    /**
     * A set of all dependencies which must be executed before this operation is complete.
     */
    readonly dependencies: ReadonlySet<Operation>;
    /**
     * This property is used in the name of the filename for the logs generated by this
     * operation. This is a filesystem-safe version of the phase name. For example,
     * an operation for a phase with name `_phase:compile` has a `logFilenameIdentifier` of `_phase_compile`.
     */
    logFilenameIdentifier: string;
    /**
     * When the scheduler is ready to process this `Operation`, the `runner` implements the actual work of
     * running the operation.
     */
    runner: IOperationRunner | undefined;
    /**
     * The weight for this operation. This scalar is the contribution of this operation to the
     * `criticalPathLength` calculation above. Modify to indicate the following:
     * - `weight` === 1: indicates that this operation has an average duration
     * - `weight` &gt; 1: indicates that this operation takes longer than average and so the scheduler
     *     should try to favor starting it over other, shorter operations. An example might be an operation that
     *     bundles an entire application and runs whole-program optimization.
     * - `weight` &lt; 1: indicates that this operation takes less time than average and so the scheduler
     *     should favor other, longer operations over it. An example might be an operation to unpack a cached
     *     output, or an operation using NullOperationRunner, which might use a value of 0.
     */
    weight: number;
    /**
     * Get the operation settings for this operation, defaults to the values defined in
     *  the project configuration.
     */
    settings: IOperationSettings | undefined;
    /**
     * If set to false, this operation will be skipped during evaluation (return OperationStatus.Skipped).
     * This is useful for plugins to alter the scope of the operation graph across executions,
     * e.g. to enable or disable unit test execution, or to include or exclude dependencies.
     */
    enabled: boolean;
    constructor(options: IOperationOptions);
    /**
     * The name of this operation, for logging.
     */
    get name(): string | undefined;
    /**
     * If set to true, this operation is considered a no-op and can be considered always skipped for analysis purposes.
     */
    get isNoOp(): boolean;
    /**
     * Adds the specified operation as a dependency and updates the consumer list.
     */
    addDependency(dependency: Operation): void;
    /**
     * Deletes the specified operation as a dependency and updates the consumer list.
     */
    deleteDependency(dependency: Operation): void;
}

/**
 * A helper class for managing the meta files of a operation.
 *
 * @internal
 */
export declare class _OperationMetadataManager {
    readonly stateFile: _OperationStateFile;
    readonly logFilenameIdentifier: string;
    private readonly _metadataFolderPath;
    private readonly _logPath;
    private readonly _errorLogPath;
    private readonly _logChunksPath;
    constructor(options: _IOperationMetadataManagerOptions);
    /**
     * Returns the relative paths of the metadata files to project folder.
     *
     * Example: `.rush/temp/operation/_phase_build/state.json`
     * Example: `.rush/temp/operation/_phase_build/all.log`
     * Example: `.rush/temp/operation/_phase_build/error.log`
     */
    get metadataFolderPath(): string;
    saveAsync({ durationInSeconds, cobuildContextId, cobuildRunnerId, logPath, errorLogPath, logChunksPath }: _IOperationMetadata): Promise<void>;
    tryRestoreAsync({ terminal, terminalProvider, errorLogPath }: {
        terminalProvider: ITerminalProvider;
        terminal: ITerminal;
        errorLogPath: string;
    }): Promise<void>;
}

/**
 * A helper class for managing the state file of a operation.
 *
 * @internal
 */
export declare class _OperationStateFile {
    private _state;
    /**
     * The path of the state json file.
     *
     * Example: `/code/repo/my-project/.rush/temp/operation/_phase_build/state.json`
     */
    readonly filepath: string;
    /**
     * The relative path of the state json file to project folder
     *
     * Example: `.rush/temp/operation/_phase_build/state.json`
     */
    readonly relativeFilepath: string;
    static filename: string;
    constructor(options: _IOperationStateFileOptions);
    get state(): _IOperationStateJson | undefined;
    writeAsync(json: _IOperationStateJson): Promise<void>;
    tryRestoreAsync(): Promise<_IOperationStateJson | undefined>;
}

/**
 * Enumeration defining potential states of an operation
 * @beta
 */
export declare enum OperationStatus {
    /**
     * The Operation is ready to execute. All its dependencies have succeeded.
     */
    Ready = "READY",
    /**
     * The Operation is waiting for one or more dependencies to complete.
     */
    Waiting = "WAITING",
    /**
     * The Operation is Queued
     */
    Queued = "QUEUED",
    /**
     * The Operation is currently executing
     */
    Executing = "EXECUTING",
    /**
     * The Operation completed successfully and did not write to standard output
     */
    Success = "SUCCESS",
    /**
     * The Operation completed successfully, but wrote to standard output
     */
    SuccessWithWarning = "SUCCESS WITH WARNINGS",
    /**
     * The Operation was skipped via the legacy incremental build logic
     */
    Skipped = "SKIPPED",
    /**
     * The Operation had its outputs restored from the build cache
     */
    FromCache = "FROM CACHE",
    /**
     * The Operation failed
     */
    Failure = "FAILURE",
    /**
     * The Operation could not be executed because one or more of its dependencies failed
     */
    Blocked = "BLOCKED",
    /**
     * The Operation was a no-op (for example, it had an empty script)
     */
    NoOp = "NO OP"
}

/**
 * @public
 */
export declare class PackageJsonDependency {
    private _version;
    private _onChange;
    readonly name: string;
    readonly dependencyType: DependencyType;
    constructor(name: string, version: string, type: DependencyType, onChange: () => void);
    get version(): string;
    setVersion(newVersion: string): void;
}

/**
 * @public
 */
export declare class PackageJsonDependencyMeta {
    private _injected;
    private _onChange;
    readonly name: string;
    constructor(name: string, injected: boolean, onChange: () => void);
    get injected(): boolean;
}

/**
 * @public
 */
export declare class PackageJsonEditor {
    private readonly _dependencies;
    private readonly _devDependencies;
    private readonly _dependenciesMeta;
    private readonly _resolutions;
    private _modified;
    private _sourceData;
    readonly filePath: string;
    /**
     * @internal
     */
    protected constructor(filepath: string, data: IPackageJson);
    static load(filePath: string): PackageJsonEditor;
    static fromObject(object: IPackageJson, filename: string): PackageJsonEditor;
    get name(): string;
    get version(): string;
    /**
     * The list of dependencies of type DependencyType.Regular, DependencyType.Optional, or DependencyType.Peer.
     */
    get dependencyList(): ReadonlyArray<PackageJsonDependency>;
    /**
     * The list of dependencies of type DependencyType.Dev.
     */
    get devDependencyList(): ReadonlyArray<PackageJsonDependency>;
    /**
     * The list of dependenciesMeta in package.json.
     */
    get dependencyMetaList(): ReadonlyArray<PackageJsonDependencyMeta>;
    /**
     * This field is a Yarn-specific feature that allows overriding of package resolution.
     *
     * @remarks
     * See the {@link https://github.com/yarnpkg/rfcs/blob/master/implemented/0000-selective-versions-resolutions.md
     * | 0000-selective-versions-resolutions.md RFC} for details.
     */
    get resolutionsList(): ReadonlyArray<PackageJsonDependency>;
    tryGetDependency(packageName: string): PackageJsonDependency | undefined;
    tryGetDevDependency(packageName: string): PackageJsonDependency | undefined;
    addOrUpdateDependency(packageName: string, newVersion: string, dependencyType: DependencyType): void;
    removeDependency(packageName: string, dependencyType: DependencyType): void;
    saveIfModified(): boolean;
    /**
     * Get the normalized package.json that represents the current state of the
     * PackageJsonEditor. This method does not save any changes that were made to the
     * package.json, but instead returns the object representation of what would be saved
     * if saveIfModified() is called.
     */
    saveToObject(): IPackageJson;
    private _onChange;
    /**
     * Create a normalized shallow copy of the provided package.json without modifying the
     * original. If the result of this method is being returned via a public facing method,
     * it will still need to be deep-cloned to avoid propogating changes back to the
     * original dataset.
     */
    private _normalize;
}

/**
 * An abstraction for controlling the supported package managers: PNPM, NPM, and Yarn.
 * @public
 */
export declare abstract class PackageManager {
    /**
     * The package manager.
     */
    readonly packageManager: PackageManagerName;
    /**
     * The SemVer version of the package manager.
     */
    readonly version: string;
    /**
     * The filename of the shrinkwrap file that is used by the package manager.
     *
     * @remarks
     * Example: `npm-shrinkwrap.json` or `pnpm-lock.yaml`
     */
    readonly shrinkwrapFilename: string;
    /** @internal */
    protected constructor(version: string, packageManager: PackageManagerName, shrinkwrapFilename: string);
}

/**
 * This represents the available Package Manager tools as a string
 * @public
 */
export declare type PackageManagerName = 'pnpm' | 'npm' | 'yarn';

/**
 * Options that all package managers share.
 *
 * @public
 */
export declare abstract class PackageManagerOptionsConfigurationBase implements IPackageManagerOptionsJsonBase {
    /**
     * Environment variables for the package manager
     */
    readonly environmentVariables?: IConfigurationEnvironment;
    /** @internal */
    protected constructor(json: IPackageManagerOptionsJsonBase);
}

/**
 * Hooks into the execution process for phased commands
 * @alpha
 */
export declare class PhasedCommandHooks {
    /**
     * Hook invoked to create operations for execution.
     * Use the context to distinguish between the initial run and phased runs.
     */
    readonly createOperations: AsyncSeriesWaterfallHook<[Set<Operation>, ICreateOperationsContext]>;
    /**
     * Hook invoked before operation start
     * Hook is series for stable output.
     */
    readonly beforeExecuteOperations: AsyncSeriesHook<[
    Map<Operation, IOperationExecutionResult>,
    IExecuteOperationsContext
    ]>;
    /**
     * Hook invoked when operation status changed
     * Hook is series for stable output.
     */
    readonly onOperationStatusChanged: SyncHook<[IOperationExecutionResult]>;
    /**
     * Hook invoked after executing a set of operations.
     * Use the context to distinguish between the initial run and phased runs.
     * Hook is series for stable output.
     */
    readonly afterExecuteOperations: AsyncSeriesHook<[IExecutionResult, IExecuteOperationsContext]>;
    /**
     * Hook invoked before executing a operation.
     */
    readonly beforeExecuteOperation: AsyncSeriesBailHook<[
    IOperationRunnerContext & IOperationExecutionResult
    ], OperationStatus | undefined>;
    /**
     * Hook invoked to define environment variables for an operation.
     * May be invoked by the runner to get the environment for the operation.
     */
    readonly createEnvironmentForOperation: SyncWaterfallHook<[
    IEnvironment,
    IOperationRunnerContext & IOperationExecutionResult
    ]>;
    /**
     * Hook invoked after executing a operation.
     */
    readonly afterExecuteOperation: AsyncSeriesHook<[
    IOperationRunnerContext & IOperationExecutionResult
    ]>;
    /**
     * Hook invoked to shutdown long-lived work in plugins.
     */
    readonly shutdownAsync: AsyncParallelHook<void>;
    /**
     * Hook invoked after a run has finished and the command is watching for changes.
     * May be used to display additional relevant data to the user.
     * Only relevant when running in watch mode.
     */
    readonly waitingForChanges: SyncHook<void>;
    /**
     * Hook invoked after executing operations and before waitingForChanges. Allows the caller
     * to augment or modify the log entry about to be written.
     */
    readonly beforeLog: SyncHook<ITelemetryData, void>;
}

/**
 * Options that are only used when the PNPM package manager is selected.
 * Use this class to load "common/config/rush/pnpm-config.json" file,
 * or, load json from "pnpmOptions" field in "rush.json" for legacy support.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the PNPM package manager
 * is not being used.
 *
 * @public
 */
export declare class PnpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    private readonly _json;
    private _globalPatchedDependencies;
    /**
     * The method used to resolve the store used by PNPM.
     *
     * @remarks
     * Available options:
     *  - local: Use the standard Rush store path: common/temp/pnpm-store
     *  - global: Use PNPM's global store path
     */
    readonly pnpmStore: PnpmStoreLocation;
    /**
     * This setting determines how PNPM chooses version numbers during `rush update`.
     *
     * @remarks
     * For example, suppose `lib-x@3.0.0` depends on `"lib-y": "^1.2.3"` whose latest major
     * releases are `1.8.9` and `2.3.4`.  The resolution mode `lowest-direct` might choose
     * `lib-y@1.2.3`, wheres `highest` will choose 1.8.9, and `time-based` will pick the
     * highest compatible version at the time when `lib-x@3.0.0` itself was published (ensuring
     * that the version could have been tested by the maintainer of "lib-x").  For local workspace
     * projects, `time-based` instead works like `lowest-direct`, avoiding upgrades unless
     * they are explicitly requested. Although `time-based` is the most robust option, it may be
     * slightly slower with registries such as npmjs.com that have not implemented an optimization.
     *
     * IMPORTANT: Be aware that PNPM 8.0.0 initially defaulted to `lowest-direct` instead of
     * `highest`, but PNPM reverted this decision in 8.6.12 because it caused confusion for users.
     * Rush version 5.106.0 and newer avoids this confusion by consistently defaulting to
     * `highest` when `resolutionMode` is not explicitly set in pnpm-config.json or .npmrc,
     * regardless of your PNPM version.
     *
     * PNPM documentation: https://pnpm.io/npmrc#resolution-mode
     *
     * Possible values are: `highest`, `time-based`, and `lowest-direct`.
     * The default is `highest`.
     */
    readonly resolutionMode: PnpmResolutionMode | undefined;
    /**
     * The path for PNPM to use as the store directory.
     *
     * Will be overridden by environment variable RUSH_PNPM_STORE_PATH
     */
    readonly pnpmStorePath: string;
    /**
     * If true, then Rush will add the "--strict-peer-dependencies" option when invoking PNPM.
     *
     * @remarks
     * This causes "rush install" to fail if there are unsatisfied peer dependencies, which is
     * an invalid state that can cause build failures or incompatible dependency versions.
     * (For historical reasons, JavaScript package managers generally do not treat this invalid state
     * as an error.)
     *
     * The default value is false.  (For now.)
     */
    readonly strictPeerDependencies: boolean;
    /**
     * If true, then `rush install` will report an error if manual modifications
     * were made to the PNPM shrinkwrap file without running `rush update` afterwards.
     *
     * @remarks
     * This feature protects against accidental inconsistencies that may be introduced
     * if the PNPM shrinkwrap file (`pnpm-lock.yaml`) is manually edited.  When this
     * feature is enabled, `rush update` will write a hash of the shrinkwrap contents to repo-state.json,
     * and then `rush update` and `rush install` will validate the hash.  Note that this does not prohibit
     * manual modifications, but merely requires `rush update` be run
     * afterwards, ensuring that PNPM can report or repair any potential inconsistencies.
     *
     * To temporarily disable this validation when invoking `rush install`, use the
     * `--bypass-policy` command-line parameter.
     *
     * The default value is false.
     */
    readonly preventManualShrinkwrapChanges: boolean;
    /**
     * If true, then Rush will use the workspaces feature to install and link packages when invoking PNPM.
     *
     * @remarks
     * The default value is true.  (For now.)
     */
    readonly useWorkspaces: boolean;
    /**
     * When true, any missing non-optional peer dependencies are automatically installed.
     *
     * @remarks
     * The default value is same as PNPM default value.  (In PNPM 8.x, this value is true)
     */
    readonly autoInstallPeers: boolean | undefined;
    /**
     * If true, then `rush update` add injected install options for all cross-subspace
     * workspace dependencies, to avoid subspace doppelganger issue.
     *
     * Here, the injected install refers to PNPM's PNPM's "injected dependencies"
     * feature. Learn more: https://pnpm.io/package_json#dependenciesmeta
     *
     * @remarks
     * The default value is false.
     */
    readonly alwaysInjectDependenciesFromOtherSubspaces: boolean | undefined;
    /**
     * The "globalOverrides" setting provides a simple mechanism for overriding version selections
     * for all dependencies of all projects in the monorepo workspace.  The settings are copied
     * into the `pnpm.overrides` field of the `common/temp/package.json` file that is generated
     * by Rush during installation.
     *
     * Order of precedence: `.pnpmfile.cjs` has the highest precedence, followed by
     * `unsupportedPackageJsonSettings`, `globalPeerDependencyRules`, `globalPackageExtensions`,
     * and `globalOverrides` has lowest precedence.
     *
     * PNPM documentation: https://pnpm.io/package_json#pnpmoverrides
     */
    readonly globalOverrides: Record<string, string> | undefined;
    /**
     * The `globalPeerDependencyRules` setting provides various settings for suppressing validation errors
     * that are reported during installation with `strictPeerDependencies=true`.  The settings are copied
     * into the `pnpm.peerDependencyRules` field of the `common/temp/package.json` file that is generated
     * by Rush during installation.
     *
     * Order of precedence: `.pnpmfile.cjs` has the highest precedence, followed by
     * `unsupportedPackageJsonSettings`, `globalPeerDependencyRules`, `globalPackageExtensions`,
     * and `globalOverrides` has lowest precedence.
     *
     * https://pnpm.io/package_json#pnpmpeerdependencyrules
     */
    readonly globalPeerDependencyRules: IPnpmPeerDependencyRules | undefined;
    /**
     * The `globalPackageExtension` setting provides a way to patch arbitrary package.json fields
     * for any PNPM dependency of the monorepo.  The settings are copied into the `pnpm.packageExtensions`
     * field of the `common/temp/package.json` file that is generated by Rush during installation.
     * The `globalPackageExtension` setting has similar capabilities as `.pnpmfile.cjs` but without
     * the downsides of an executable script (nondeterminism, unreliable caching, performance concerns).
     *
     * Order of precedence: `.pnpmfile.cjs` has the highest precedence, followed by
     * `unsupportedPackageJsonSettings`, `globalPeerDependencyRules`, `globalPackageExtensions`,
     * and `globalOverrides` has lowest precedence.
     *
     * PNPM documentation: https://pnpm.io/package_json#pnpmpackageextensions
     */
    readonly globalPackageExtensions: Record<string, IPnpmPackageExtension> | undefined;
    /**
     * The `globalNeverBuiltDependencies` setting suppresses the `preinstall`, `install`, and `postinstall`
     * lifecycle events for the specified NPM dependencies.  This is useful for scripts with poor practices
     * such as downloading large binaries without retries or attempting to invoke OS tools such as
     * a C++ compiler.  (PNPM's terminology refers to these lifecycle events as "building" a package;
     * it has nothing to do with build system operations such as `rush build` or `rushx build`.)
     * The settings are copied into the `pnpm.neverBuiltDependencies` field of the `common/temp/package.json`
     * file that is generated by Rush during installation.
     *
     * PNPM documentation: https://pnpm.io/package_json#pnpmneverbuiltdependencies
     */
    readonly globalNeverBuiltDependencies: string[] | undefined;
    /**
     * The ignoredOptionalDependencies setting allows you to exclude certain optional dependencies from being installed
     * during the Rush installation process. This can be useful when optional dependencies are not required or are
     * problematic in specific environments (e.g., dependencies with incompatible binaries or platform-specific requirements).
     * The listed dependencies will be treated as though they are missing, even if other packages specify them as optional
     * dependencies. The settings are copied into the pnpm.ignoredOptionalDependencies field of the common/temp/package.json
     * file that is generated by Rush during installation.
     *
     * (SUPPORTED ONLY IN PNPM 9.0.0 AND NEWER)
     *
     * PNPM documentation: https://pnpm.io/package_json#pnpmignoredoptionaldependencies
     */
    readonly globalIgnoredOptionalDependencies: string[] | undefined;
    /**
     * The `globalAllowedDeprecatedVersions` setting suppresses installation warnings for package
     * versions that the NPM registry reports as being deprecated.  This is useful if the
     * deprecated package is an indirect dependency of an external package that has not released a fix.
     * The settings are copied into the `pnpm.allowedDeprecatedVersions` field of the `common/temp/package.json`
     * file that is generated by Rush during installation.
     *
     * PNPM documentation: https://pnpm.io/package_json#pnpmalloweddeprecatedversions
     *
     * If you are working to eliminate a deprecated version, it's better to specify `allowedDeprecatedVersions`
     * in the package.json file for individual Rush projects.
     */
    readonly globalAllowedDeprecatedVersions: Record<string, string> | undefined;
    /**
     * (USE AT YOUR OWN RISK)  This is a free-form property bag that will be copied into
     * the `common/temp/package.json` file that is generated by Rush during installation.
     * This provides a way to experiment with new PNPM features.  These settings will override
     * any other Rush configuration associated with a given JSON field except for `.pnpmfile.cjs`.
     *
     * USAGE OF THIS SETTING IS NOT SUPPORTED BY THE RUSH MAINTAINERS AND MAY CAUSE RUSH
     * TO MALFUNCTION.  If you encounter a missing PNPM setting that you believe should
     * be supported, please create a GitHub issue or PR.  Note that Rush does not aim to
     * support every possible PNPM setting, but rather to promote a battle-tested installation
     * strategy that is known to provide a good experience for large teams with lots of projects.
     */
    readonly unsupportedPackageJsonSettings: unknown | undefined;
    readonly jsonFilename: string | undefined;
    /**
     * The `pnpmLockfilePolicies` setting defines the policies that govern the `pnpm-lock.yaml` file.
     */
    readonly pnpmLockfilePolicies: IPnpmLockfilePolicies | undefined;
    /**
     * (EXPERIMENTAL) If "true", then filtered installs ("rush install --to my-project")
     * will be disregarded, instead always performing a full installation of the lockfile.
     * This setting is primarily useful with Rush subspaces which enable filtering across
     * multiple lockfiles, if filtering may be inefficient or undesirable for certain lockfiles.
     *
     * The default value is false.
     */
    readonly alwaysFullInstall: boolean | undefined;
    /**
     * (GENERATED BY RUSH-PNPM PATCH-COMMIT) When modifying this property, make sure you know what you are doing.
     *
     * The `globalPatchedDependencies` is added/updated automatically when you run pnpm patch-commit
     * command. It is a dictionary where the key should be the package name and exact version. The value
     * should be a relative path to a patch file.
     *
     * PNPM documentation: https://pnpm.io/package_json#pnpmpatcheddependencies
     */
    get globalPatchedDependencies(): Record<string, string> | undefined;
    private constructor();
    /** @internal */
    static loadFromJsonFileOrThrow(jsonFilename: string, commonTempFolder: string): PnpmOptionsConfiguration;
    /** @internal */
    static loadFromJsonObject(json: _IPnpmOptionsJson, commonTempFolder: string): PnpmOptionsConfiguration;
    /**
     * Updates patchedDependencies field of the PNPM options in the common/config/rush/pnpm-config.json file.
     */
    updateGlobalPatchedDependencies(patchedDependencies: Record<string, string> | undefined): void;
}

/**
 * Possible values for the `resolutionMode` setting in Rush's pnpm-config.json file.
 * @remarks
 * These modes correspond to PNPM's `resolution-mode` values, which are documented here:
 * {@link https://pnpm.io/npmrc#resolution-mode}
 *
 * @public
 */
export declare type PnpmResolutionMode = 'highest' | 'time-based' | 'lowest-direct';

/**
 * This represents the available PNPM store options
 * @public
 */
export declare type PnpmStoreLocation = 'local' | 'global';

/**
 * @deprecated Use {@link PnpmStoreLocation} instead
 * @public
 */
export declare type PnpmStoreOptions = PnpmStoreLocation;

/**
 * @beta
 */
export declare class ProjectChangeAnalyzer {
    private readonly _rushConfiguration;
    private readonly _git;
    constructor(rushConfiguration: RushConfiguration);
    /**
     * Gets a list of projects that have changed in the current state of the repo
     * when compared to the specified branch, optionally taking the shrinkwrap and settings in
     * the rush-project.json file into consideration.
     */
    getChangedProjectsAsync(options: IGetChangedProjectsOptions): Promise<Set<RushConfigurationProject>>;
    protected getChangesByProject(lookup: LookupByPath<RushConfigurationProject>, changedFiles: Map<string, IFileDiffStatus>): Map<RushConfigurationProject, Map<string, IFileDiffStatus>>;
    /**
     * Gets a snapshot of the input state of the Rush workspace that can be queried for incremental
     * build operations and use by the build cache.
     * @internal
     */
    _tryGetSnapshotProviderAsync(projectConfigurations: ReadonlyMap<RushConfigurationProject, RushProjectConfiguration>, terminal: ITerminal, projectSelection?: ReadonlySet<RushConfigurationProject>): Promise<GetInputsSnapshotAsyncFn | undefined>;
    /**
     * @internal
     */
    _filterProjectDataAsync<T>(project: RushConfigurationProject, unfilteredProjectData: Map<string, T>, rootDir: string, terminal: ITerminal): Promise<Map<string, T>>;
    private _getIgnoreMatcherForProjectAsync;
}

/**
 * This file is used to track the state of various Rush-related features. It is generated
 * and updated by Rush.
 *
 * @public
 */
export declare class RepoStateFile {
    private static _jsonSchema;
    private _pnpmShrinkwrapHash;
    private _preferredVersionsHash;
    private _packageJsonInjectedDependenciesHash;
    private _isValid;
    private _modified;
    /**
     * Get the absolute file path of the repo-state.json file.
     */
    readonly filePath: string;
    private constructor();
    /**
     * The hash of the pnpm shrinkwrap file at the end of the last update.
     */
    get pnpmShrinkwrapHash(): string | undefined;
    /**
     * The hash of all preferred versions at the end of the last update.
     */
    get preferredVersionsHash(): string | undefined;
    /**
     * The hash of all preferred versions at the end of the last update.
     */
    get packageJsonInjectedDependenciesHash(): string | undefined;
    /**
     * If false, the repo-state.json file is not valid and its values cannot be relied upon
     */
    get isValid(): boolean;
    /**
     * Loads the repo-state.json data from the specified file path.
     * If the file has not been created yet, then an empty object is returned.
     *
     * @param jsonFilename - The path to the repo-state.json file.
     */
    static loadFromFile(jsonFilename: string): RepoStateFile;
    /**
     * Refresh the data contained in repo-state.json using the current state
     * of the Rush repo, and save the file if changes were made.
     *
     * @param rushConfiguration - The Rush configuration for the repo.
     * @param subspace - The subspace that repo-state.json was loaded from,
     * or `undefined` for the default subspace.
     *
     * @returns true if the file was modified, otherwise false.
     */
    refreshState(rushConfiguration: RushConfiguration, subspace: Subspace | undefined, variant?: string): boolean;
    /**
     * Writes the "repo-state.json" file to disk, using the filename that was passed to loadFromFile().
     */
    private _saveIfModified;
    private _serialize;
}

/**
 * General operations for the Rush engine.
 *
 * @public
 */
export declare class Rush {
    private static __rushLibPackageJson;
    private static __rushLibPackageFolder;
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rush" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rush" binary
     * and start a new Node.js process.
     *
     * @remarks
     * Earlier versions of the rush frontend used a different API contract. In the old contract,
     * the second argument was the `isManaged` value of the {@link ILaunchOptions} object.
     *
     * Even though this API isn't documented, it is still supported for legacy compatibility.
     */
    static launch(launcherVersion: string, options: ILaunchOptions): void;
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rushx" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rushx" binary
     * and start a new Node.js process.
     */
    static launchRushX(launcherVersion: string, options: ILaunchOptions): void;
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rush-pnpm" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rush-pnpm" binary
     * and start a new Node.js process.
     */
    static launchRushPnpm(launcherVersion: string, options: ILaunchOptions): void;
    /**
     * The currently executing version of the "rush-lib" library.
     * This is the same as the Rush tool version for that release.
     */
    static get version(): string;
    /**
     * @internal
     */
    static get _rushLibPackageJson(): IPackageJson;
    static get _rushLibPackageFolder(): string;
    private static _ensureOwnPackageJsonIsLoaded;
    /**
     * Assign the `RUSH_INVOKED_FOLDER` environment variable during startup.  This is only applied when
     * Rush is invoked via the CLI, not via the `@microsoft/rush-lib` automation API.
     *
     * @remarks
     * Modifying the parent process's environment is not a good design.  The better design is (1) to consolidate
     * Rush's code paths that invoke scripts, and (2) to pass down the invoked folder with each code path,
     * so that it can finally be applied in a centralized helper like `Utilities._createEnvironmentForRushCommand()`.
     * The natural time to do that refactoring is when we rework `Utilities.executeCommand()` to use
     * `Executable.spawn()` or rushell.
     */
    private static _assignRushInvokedFolder;
    /**
     * This function normalizes legacy options to the current {@link ILaunchOptions} object.
     */
    private static _normalizeLaunchOptions;
}

/**
 * Information about the available CLI commands
 *
 * @beta
 */
export declare class RushCommandLine {
    static getCliSpec(rushJsonFolder: string): IRushCommandLineSpec;
}

/**
 * This represents the Rush configuration for a repository, based on the "rush.json"
 * configuration file.
 * @public
 */
export declare class RushConfiguration {
    private static _jsonSchema;
    private readonly _pathTrees;
    /**
     * @internal
     */
    _currentVariantJsonLoadingPromise: Promise<ICurrentVariantJson | undefined> | undefined;
    private _projects;
    private _projectsByName;
    private _projectsByTag;
    private readonly _subspacesByName;
    private readonly _subspaces;
    /**
     * The name of the package manager being used to install dependencies
     */
    readonly packageManager: PackageManagerName;
    /**
     * If true, the repository is using PNPM as its package manager.
     */
    readonly isPnpm: boolean;
    /**
     * {@inheritdoc PackageManager}
     *
     * @privateremarks
     * In the next major breaking API change, we will rename this property to "packageManager" and eliminate the
     * old property with that name.
     *
     * @beta
     */
    readonly packageManagerWrapper: PackageManager;
    /**
     * Gets the JSON data structure for the "rush.json" configuration file.
     *
     * @internal
     */
    readonly rushConfigurationJson: IRushConfigurationJson;
    /**
     * The absolute path to the "rush.json" configuration file that was loaded to construct this object.
     */
    readonly rushJsonFile: string;
    /**
     * The absolute path of the folder that contains rush.json for this project.
     */
    readonly rushJsonFolder: string;
    /**
     * The folder that contains all change files.
     */
    readonly changesFolder: string;
    /**
     * The fully resolved path for the "common" folder where Rush will store settings that
     * affect all Rush projects.  This is always a subfolder of the folder containing "rush.json".
     * Example: `C:\MyRepo\common`
     */
    readonly commonFolder: string;
    /**
     * The folder where Rush's additional config files are stored.  This folder is always a
     * subfolder called `config\rush` inside the common folder.  (The `common\config` folder
     * is reserved for configuration files used by other tools.)  To avoid confusion or mistakes,
     * Rush will report an error if this this folder contains any unrecognized files.
     *
     * Example: `C:\MyRepo\common\config\rush`
     */
    readonly commonRushConfigFolder: string;
    /**
     * The folder where temporary files will be stored.  This is always a subfolder called "temp"
     * under the common folder.
     * Example: `C:\MyRepo\common\temp`
     */
    readonly commonTempFolder: string;
    /**
     * The folder where automation scripts are stored.  This is always a subfolder called "scripts"
     * under the common folder.
     * Example: `C:\MyRepo\common\scripts`
     */
    readonly commonScriptsFolder: string;
    /**
     * The local folder that will store the NPM package cache.  Rush does not rely on the
     * npm's default global cache folder, because npm's caching implementation does not
     * reliably handle multiple processes.  (For example, if a build box is running
     * "rush install" simultaneously for two different working folders, it may fail randomly.)
     *
     * Example: `C:\MyRepo\common\temp\npm-cache`
     */
    readonly npmCacheFolder: string;
    /**
     * The local folder where npm's temporary files will be written during installation.
     * Rush does not rely on the global default folder, because it may be on a different
     * hard disk.
     *
     * Example: `C:\MyRepo\common\temp\npm-tmp`
     */
    readonly npmTmpFolder: string;
    /**
     * The local folder that will store the Yarn package cache.
     *
     * Example: `C:\MyRepo\common\temp\yarn-cache`
     */
    readonly yarnCacheFolder: string;
    /**
     * The filename (without any path) of the shrinkwrap file that is used by the package manager.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `npm-shrinkwrap.json` or `pnpm-lock.yaml`
     */
    readonly shrinkwrapFilename: string;
    /**
     * The object that specifies subspace configurations if they are provided in the rush workspace.
     * @beta
     */
    readonly subspacesConfiguration: SubspacesConfiguration | undefined;
    /**
     * Returns true if subspaces.json is present with "subspacesEnabled=true".
     */
    readonly subspacesFeatureEnabled: boolean;
    /**
     * The filename of the variant dependency data file.  By default this is
     * called 'current-variant.json' and resides in the Rush common folder.
     * Its data structure is defined by ICurrentVariantJson.
     *
     * Example: `C:\MyRepo\common\temp\current-variant.json`
     */
    readonly currentVariantJsonFilePath: string;
    /**
     * The version of the locally package manager tool.  (Example: "1.2.3")
     */
    readonly packageManagerToolVersion: string;
    /**
     * The absolute path to the locally package manager tool.  If "rush install" has not
     * been run, then this file may not exist yet.
     * Example: `C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm`
     */
    readonly packageManagerToolFilename: string;
    /**
     * The minimum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements a standard 2-level hierarchy of `<categoryFolder>/<projectFolder>/package.json`.
     */
    readonly projectFolderMinDepth: number;
    /**
     * The maximum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements on a standard convention of `<categoryFolder>/<projectFolder>/package.json`.
     */
    readonly projectFolderMaxDepth: number;
    /**
     * Today the npmjs.com registry enforces fairly strict naming rules for packages, but in the early
     * days there was no standard and hardly any enforcement.  A few large legacy projects are still using
     * nonstandard package names, and private registries sometimes allow it.  Set "allowMostlyStandardPackageNames"
     * to true to relax Rush's enforcement of package names.  This allows upper case letters and in the future may
     * relax other rules, however we want to minimize these exceptions.  Many popular tools use certain punctuation
     * characters as delimiters, based on the assumption that they will never appear in a package name; thus if we relax
     * the rules too much it is likely to cause very confusing malfunctions.
     *
     * The default value is false.
     */
    readonly allowMostlyStandardPackageNames: boolean;
    /**
     * The "approvedPackagesPolicy" settings.
     */
    readonly approvedPackagesPolicy: ApprovedPackagesPolicy;
    /**
     * [Part of the "gitPolicy" feature.]
     * A list of regular expressions describing allowable email patterns for Git commits.
     * They are case-insensitive anchored JavaScript RegExps.
     * Example: `".*@example\.com"`
     * This array will never be undefined.
     */
    readonly gitAllowedEmailRegExps: string[];
    /**
     * [Part of the "gitPolicy" feature.]
     * An example valid email address that conforms to one of the allowedEmailRegExps.
     * Example: `"foxtrot@example\.com"`
     * This will never be undefined, and will always be nonempty if gitAllowedEmailRegExps is used.
     */
    readonly gitSampleEmail: string;
    /**
     * [Part of the "gitPolicy" feature.]
     * The commit message to use when committing changes during 'rush publish'
     */
    readonly gitVersionBumpCommitMessage: string | undefined;
    /**
     * [Part of the "gitPolicy" feature.]
     * The commit message to use when committing change log files 'rush version'
     */
    readonly gitChangeLogUpdateCommitMessage: string | undefined;
    /**
     * [Part of the "gitPolicy" feature.]
     * The commit message to use when committing change log files 'rush version'
     */
    readonly gitChangefilesCommitMessage: string | undefined;
    /**
     * [Part of the "gitPolicy" feature.]
     * The separator between package name and version in git tag.
     */
    readonly gitTagSeparator: string | undefined;
    /**
     * [Part of the "hotfixChange" feature.]
     * Enables creating hotfix changes
     */
    readonly hotfixChangeEnabled: boolean;
    /**
     * Remote URL(s) of the repository. If a value is provided, \"rush change\" will
     * use one of these to find the right remote to compare against. Specifying multiple URLs
     * is useful if a GitHub repository is renamed or for `<projectName>.visualstudio.com` versus
     * `dev.azure.com/<projectName>` URLs.
     */
    readonly repositoryUrls: string[];
    /**
     * The default branch name. This tells "rush change" which remote branch to compare against.
     */
    readonly repositoryDefaultBranch: string;
    /**
     * The default remote. This tells "rush change" which remote to compare against if the remote URL is not set
     * or if a remote matching the provided remote URL is not found.
     */
    readonly repositoryDefaultRemote: string;
    /**
     * Odd-numbered major versions of Node.js are experimental.  Even-numbered releases
     * spend six months in a stabilization period before the first Long Term Support (LTS) version.
     * For example, 8.9.0 was the first LTS version of Node.js 8.  Pre-LTS versions are not recommended
     * for production usage because they frequently have bugs.  They may cause Rush itself
     * to malfunction.
     *
     * Rush normally prints a warning if it detects a pre-LTS Node.js version.  If you are testing
     * pre-LTS versions in preparation for supporting the first LTS version, you can use this setting
     * to disable Rush's warning.
     */
    readonly suppressNodeLtsWarning: boolean;
    /**
     * The raw value of `ensureConsistentVersions` from the `rush.json` file.
     *
     * @internal
     */
    readonly _ensureConsistentVersionsJsonValue: boolean | undefined;
    /**
     * If true, then consistent version specifiers for dependencies will be enforced.
     * I.e. "rush check" is run before some commands.
     *
     * @deprecated
     * This setting was moved from `rush.json` to `common-versions.json`.
     * Read it using {@link Subspace.shouldEnsureConsistentVersions} instead.
     */
    readonly ensureConsistentVersions: boolean;
    /**
     * Indicates whether telemetry collection is enabled for Rush runs.
     * @beta
     */
    readonly telemetryEnabled: boolean;
    /**
     * {@inheritDoc NpmOptionsConfiguration}
     */
    readonly npmOptions: NpmOptionsConfiguration;
    /**
     * {@inheritDoc PnpmOptionsConfiguration}
     */
    readonly pnpmOptions: PnpmOptionsConfiguration;
    /**
     * {@inheritDoc YarnOptionsConfiguration}
     */
    readonly yarnOptions: YarnOptionsConfiguration;
    /**
     * The configuration options used by the current package manager.
     * @remarks
     * For package manager specific variants, reference {@link RushConfiguration.npmOptions | npmOptions},
     * {@link RushConfiguration.pnpmOptions | pnpmOptions}, or {@link RushConfiguration.yarnOptions | yarnOptions}.
     */
    readonly packageManagerOptions: PackageManagerOptionsConfigurationBase;
    /**
     * The rush hooks. It allows customized scripts to run at the specified point.
     * @beta
     */
    readonly eventHooks: EventHooks;
    /**
     * The rush hooks. It allows customized scripts to run at the specified point.
     */
    readonly packageNameParser: PackageNameParser;
    /**
     * @beta
     */
    readonly versionPolicyConfiguration: VersionPolicyConfiguration;
    /**
     * @beta
     */
    readonly versionPolicyConfigurationFilePath: string;
    /**
     * Accesses the custom-tips.json configuration.
     * @beta
     */
    readonly customTipsConfiguration: CustomTipsConfiguration;
    /**
     * The absolute path to the custom tips configuration file.
     * @beta
     */
    readonly customTipsConfigurationFilePath: string;
    /**
     * This configuration object contains settings repo maintainers have specified to enable
     * and disable experimental Rush features.
     *
     * @beta
     */
    readonly experimentsConfiguration: ExperimentsConfiguration;
    /**
     * @internal
     */
    readonly _rushPluginsConfiguration: RushPluginsConfiguration;
    /**
     * The variants specified in the rush.json configuration file.
     *
     * @beta
     */
    readonly variants: ReadonlySet<string>;
    /**
     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()
     * instead.
     */
    private constructor();
    private _initializeAndValidateLocalProjects;
    /**
     * Loads the configuration data from an Rush.json configuration file and returns
     * an RushConfiguration object.
     */
    static loadFromConfigurationFile(rushJsonFilename: string): RushConfiguration;
    static tryLoadFromDefaultLocation(options?: ITryFindRushJsonLocationOptions): RushConfiguration | undefined;
    static loadFromDefaultLocation(options?: ITryFindRushJsonLocationOptions): RushConfiguration;
    /**
     * Find the rush.json location and return the path, or undefined if a rush.json can't be found.
     *
     * @privateRemarks
     * Keep this in sync with `findRushJsonLocation` in `rush-sdk/src/index.ts`.
     */
    static tryFindRushJsonLocation(options?: ITryFindRushJsonLocationOptions): string | undefined;
    /**
     * This generates the unique names that are used to create temporary projects
     * in the Rush common folder.
     * NOTE: sortedProjectJsons is sorted by the caller.
     */
    private static _generateTempNameForProject;
    /**
     * If someone adds a config file in the "common/rush/config" folder, it would be a bad
     * experience for Rush to silently ignore their file simply because they misspelled the
     * filename, or maybe it's an old format that's no longer supported.  The
     * _validateCommonRushConfigFolder() function makes sure that this folder only contains
     * recognized config files.
     */
    private static _validateCommonRushConfigFolder;
    /**
     * The fully resolved path for the "autoinstallers" folder.
     * Example: `C:\MyRepo\common\autoinstallers`
     */
    get commonAutoinstallersFolder(): string;
    /**
     * The folder where rush-plugin options json files are stored.
     * Example: `C:\MyRepo\common\config\rush-plugins`
     */
    get rushPluginOptionsFolder(): string;
    /**
     * The full path of the temporary shrinkwrap file that is used during "rush install".
     * This file may get rewritten by the package manager during installation.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\temp\npm-shrinkwrap.json` or `C:\MyRepo\common\temp\pnpm-lock.yaml`
     *
     * @deprecated Introduced with subspaces is subspace specific tempShrinkwrapFilename accessible from the Subspace class.
     */
    get tempShrinkwrapFilename(): string;
    /**
     * The full path of a backup copy of tempShrinkwrapFilename. This backup copy is made
     * before installation begins, and can be compared to determine how the package manager
     * modified tempShrinkwrapFilename.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\temp\npm-shrinkwrap-preinstall.json`
     * or `C:\MyRepo\common\temp\pnpm-lock-preinstall.yaml`
     *
     * @deprecated Introduced with subspaces is subspace specific tempShrinkwrapPreinstallFilename accessible from the Subspace class.
     */
    get tempShrinkwrapPreinstallFilename(): string;
    /**
     * Returns an English phrase such as "shrinkwrap file" that can be used in logging messages
     * to refer to the shrinkwrap file using appropriate terminology for the currently selected
     * package manager.
     */
    get shrinkwrapFilePhrase(): string;
    /**
     * The filename of the build dependency data file.  By default this is
     * called 'rush-link.json' resides in the Rush common folder.
     * Its data structure is defined by IRushLinkJson.
     *
     * Example: `C:\MyRepo\common\temp\rush-link.json`
     *
     * @deprecated The "rush-link.json" file was removed in Rush 5.30.0.
     * Use `RushConfigurationProject.localDependencyProjects` instead.
     */
    get rushLinkJsonFilename(): string;
    /**
     * The default fully-qualified git remote branch of the repository. This helps "rush change" find the right branch to compare against.
     */
    get repositoryDefaultFullyQualifiedRemoteBranch(): string;
    get projects(): RushConfigurationProject[];
    /**
     * @beta
     */
    get defaultSubspace(): Subspace;
    /**
     * A list of all the available subspaces in this workspace.
     * @beta
     */
    get subspaces(): readonly Subspace[];
    /**
     * @beta
     */
    tryGetSubspace(subspaceName: string): Subspace | undefined;
    /**
     * @beta
     */
    getSubspace(subspaceName: string): Subspace;
    /**
     * Returns the set of subspaces that the given projects belong to
     * @beta
     */
    getSubspacesForProjects(projects: Iterable<RushConfigurationProject>): ReadonlySet<Subspace>;
    /**
     * @beta
     */
    get projectsByName(): ReadonlyMap<string, RushConfigurationProject>;
    /**
     * Obtains the mapping from custom tags to projects.
     * @beta
     */
    get projectsByTag(): ReadonlyMap<string, ReadonlySet<RushConfigurationProject>>;
    /**
     * Settings from the common-versions.json config file.
     * @remarks
     * If the common-versions.json file is missing, this property will not be undefined.
     * Instead it will be initialized in an empty state, and calling CommonVersionsConfiguration.save()
     * will create the file.
     *
     * @deprecated Use `getCommonVersions` instead, which gets the correct common version data
     * for a given active variant.
     */
    get commonVersions(): CommonVersionsConfiguration;
    /**
     * Gets the currently-installed variant, if an installation has occurred.
     * For Rush operations which do not take a --variant parameter, this method
     * determines which variant, if any, was last specified when performing "rush install"
     * or "rush update".
     */
    getCurrentlyInstalledVariantAsync(): Promise<string | undefined>;
    /**
     * @deprecated Use {@link Subspace.getCommonVersionsFilePath} instead
     */
    getCommonVersionsFilePath(subspace?: Subspace, variant?: string): string;
    /**
     * @deprecated Use {@link Subspace.getCommonVersions} instead
     */
    getCommonVersions(subspace?: Subspace, variant?: string): CommonVersionsConfiguration;
    /**
     * Returns a map of all direct dependencies that only have a single semantic version specifier.
     *
     * @param subspace - The subspace to use
     * @param variant - The name of the current variant in use by the active command.
     *
     * @returns A map of dependency name --\> version specifier for implicitly preferred versions.
     */
    getImplicitlyPreferredVersions(subspace?: Subspace, variant?: string): Map<string, string>;
    /**
     * @deprecated Use {@link Subspace.getRepoStateFilePath} instead
     */
    getRepoStateFilePath(subspace?: Subspace): string;
    /**
     * @deprecated Use {@link Subspace.getRepoState} instead
     */
    getRepoState(subspace?: Subspace): RepoStateFile;
    /**
     * @deprecated Use {@link Subspace.getCommittedShrinkwrapFilePath} instead
     */
    getCommittedShrinkwrapFilename(subspace?: Subspace, variant?: string): string;
    /**
     * @deprecated Use {@link Subspace.getPnpmfilePath} instead
     */
    getPnpmfilePath(subspace?: Subspace, variant?: string): string;
    /**
     * Looks up a project in the projectsByName map.  If the project is not found,
     * then undefined is returned.
     */
    getProjectByName(projectName: string): RushConfigurationProject | undefined;
    /**
     * This is used e.g. by command-line interfaces such as "rush build --to example".
     * If "example" is not a project name, then it also looks for a scoped name
     * like `@something/example`.  If exactly one project matches this heuristic, it
     * is returned.  Otherwise, undefined is returned.
     */
    findProjectByShorthandName(shorthandProjectName: string): RushConfigurationProject | undefined;
    /**
     * Looks up a project by its RushConfigurationProject.tempProjectName field.
     * @returns The found project, or undefined if no match was found.
     */
    findProjectByTempName(tempProjectName: string): RushConfigurationProject | undefined;
    /**
     * @returns An optimized lookup engine to find a project by its path relative to the specified root.
     * @beta
     */
    getProjectLookupForRoot(rootPath: string): LookupByPath<RushConfigurationProject>;
    /**
     * Returns the project for which the specified path is underneath that project's folder.
     * If the path is not under any project's folder, returns undefined.
     */
    tryGetProjectForPath(currentFolderPath: string): RushConfigurationProject | undefined;
    private _loadCurrentVariantJsonAsync;
}

/**
 * This represents the configuration of a project that is built by Rush, based on
 * the Rush.json configuration file.
 * @public
 */
export declare class RushConfigurationProject {
    private readonly _shouldPublish;
    private _versionPolicy;
    private _dependencyProjects;
    private _consumingProjects;
    private _packageJson;
    /**
     * The name of the NPM package.  An error is reported if this name is not
     * identical to packageJson.name.
     *
     * Example: `@scope/MyProject`
     */
    readonly packageName: string;
    /**
     * The full path of the folder that contains the project to be built by Rush.
     *
     * Example: `C:\MyRepo\libraries\my-project`
     */
    readonly projectFolder: string;
    /**
     * The relative path of the folder that contains the project to be built by Rush.
     *
     * Example: `libraries/my-project`
     */
    readonly projectRelativeFolder: string;
    /**
     * The project-specific Rush configuration folder.
     *
     * Example: `C:\MyRepo\libraries\my-project\config\rush`
     */
    readonly projectRushConfigFolder: string;
    /**
     * The project-specific Rush temp folder. This folder is used to store Rush-specific temporary files.
     *
     * Example: `C:\MyRepo\libraries\my-project\.rush\temp`
     */
    readonly projectRushTempFolder: string;
    /**
     * The Rush configuration for the monorepo that the project belongs to.
     */
    readonly rushConfiguration: RushConfiguration;
    /**
     * Returns the subspace name that a project belongs to.
     * If subspaces is not enabled, returns the default subspace.
     */
    readonly subspace: Subspace;
    /**
     * The review category name, or undefined if no category was assigned.
     * This name must be one of the valid choices listed in RushConfiguration.reviewCategories.
     */
    readonly reviewCategory: string | undefined;
    /**
     * A list of local projects that appear as devDependencies for this project, but cannot be
     * locally linked because it would create a cyclic dependency; instead, the last published
     * version will be installed in the Common folder.
     *
     * These are package names that would be found by RushConfiguration.getProjectByName().
     */
    readonly decoupledLocalDependencies: Set<string>;
    /**
     * The parsed NPM "package.json" file from projectFolder.
     */
    get packageJson(): IPackageJson;
    /**
     * A useful wrapper around the package.json file for making modifications
     * @beta
     */
    readonly packageJsonEditor: PackageJsonEditor;
    /**
     * The unique name for the temporary project that will be generated in the Common folder.
     * For example, if the project name is `@scope/MyProject`, the temporary project name
     * might be `@rush-temp/MyProject-2`.
     *
     * Example: `@rush-temp/MyProject-2`
     */
    readonly tempProjectName: string;
    /**
     * The unscoped temporary project name
     *
     * Example: `my-project-2`
     */
    readonly unscopedTempProjectName: string;
    /**
     * If true, then this project will be ignored by the "rush check" command.
     * The default value is false.
     */
    readonly skipRushCheck: boolean;
    /**
     * Name of the version policy used by this project.
     * @beta
     */
    readonly versionPolicyName: string | undefined;
    /**
     * The full path of the folder that will get published by Rush.
     *
     * @remarks
     * By default this is the same as the project folder, but a custom folder can be specified
     * using the the "publishFolder" setting in rush.json.
     *
     * Example: `C:\MyRepo\libraries\my-project\temp\publish`
     */
    readonly publishFolder: string;
    /**
     * An optional set of custom tags that can be used to select this project.
     *
     * @remarks
     * For example, adding `my-custom-tag` will allow this project to be selected by the
     * command `rush list --only tag:my-custom-tag`.  The tag name must be one or more words separated
     * by hyphens, where a word may contain lowercase letters, digits, and the period character.
     *
     * @beta
     */
    readonly tags: ReadonlySet<string>;
    /**
     * Returns the subspace name specified in the `"subspaceName"` field in `rush.json`.
     * Note that this field may be undefined, if the `default` subspace is being used,
     * and this field may be ignored if the subspaces feature is disabled.
     *
     * @beta
     */
    readonly configuredSubspaceName: string | undefined;
    /** @internal */
    constructor(options: IRushConfigurationProjectOptions);
    /**
     * A list of local projects that appear as devDependencies for this project, but cannot be
     * locally linked because it would create a cyclic dependency; instead, the last published
     * version will be installed in the Common folder.
     *
     * These are package names that would be found by RushConfiguration.getProjectByName().
     *
     * @deprecated Use `decoupledLocalDependencies` instead, as it better describes the purpose of the data.
     */
    get cyclicDependencyProjects(): Set<string>;
    /**
     * An array of projects within the Rush configuration which directly depend on this package.
     * @deprecated Use `consumingProjectNames` instead, as it has Set semantics, which better reflect the nature
     * of the data.
     */
    get downstreamDependencyProjects(): string[];
    /**
     * An array of projects within the Rush configuration which this project declares as dependencies.
     * @deprecated Use `dependencyProjects` instead, as it has Set semantics, which better reflect the nature
     * of the data.
     */
    get localDependencyProjects(): ReadonlyArray<RushConfigurationProject>;
    /**
     * The set of projects within the Rush configuration which this project declares as dependencies.
     *
     * @remarks
     * Can be used recursively to walk the project dependency graph to find all projects that are directly or indirectly
     * referenced from this project.
     */
    get dependencyProjects(): ReadonlySet<RushConfigurationProject>;
    /**
     * The set of projects within the Rush configuration which declare this project as a dependency.
     * Excludes those that declare this project as a `cyclicDependencyProject`.
     *
     * @remarks
     * This field is the counterpart to `dependencyProjects`, and can be used recursively to walk the project dependency
     * graph to find all projects which will be impacted by changes to this project.
     */
    get consumingProjects(): ReadonlySet<RushConfigurationProject>;
    /**
     * A flag which indicates whether changes to this project should be published. This controls
     * whether or not the project would show up when running `rush change`, and whether or not it
     * should be published during `rush publish`.
     */
    get shouldPublish(): boolean;
    /**
     * Version policy of the project
     * @beta
     */
    get versionPolicy(): VersionPolicy | undefined;
    /**
     * Indicate whether this project is the main project for the related version policy.
     *
     * False if the project is not for publishing.
     * True if the project is individually versioned or if its lockstep version policy does not specify main project.
     * False if the project is lockstepped and is not the main project for its version policy.
     *
     * @beta
     */
    get isMainProject(): boolean;
}

/**
 * Constants used by the Rush tool.
 * @beta
 *
 * @remarks
 *
 * These are NOT part of the public API surface for rush-lib.
 * The rationale is that we don't want people implementing custom parsers for
 * the Rush config files; instead, they should rely on the official APIs from rush-lib.
 */
export declare class RushConstants {
    /**
     * The filename ("rush.json") for the root-level configuration file.
     */
    static readonly rushJsonFilename: 'rush.json';
    /**
     * The filename ("browser-approved-packages.json") for an optional policy configuration file
     * that stores a list of NPM packages that have been approved for usage by Rush projects.
     * This is part of a pair of config files, one for projects that run in a web browser
     * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else
     * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).
     */
    static readonly browserApprovedPackagesFilename: 'browser-approved-packages.json';
    /**
     * The folder name ("changes") where change files will be stored.
     */
    static readonly changeFilesFolderName: 'changes';
    /**
     * The filename ("nonbrowser-approved-packages.json") for an optional policy configuration file
     * that stores a list of NPM packages that have been approved for usage by Rush projects.
     * This is part of a pair of config files, one for projects that run in a web browser
     * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else
     * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).
     */
    static readonly nonbrowserApprovedPackagesFilename: 'nonbrowser-approved-packages.json';
    /**
     * The folder name ("common") where Rush's common data will be stored.
     */
    static readonly commonFolderName: 'common';
    /**
     * The NPM scope ("\@rush-temp") that is used for Rush's temporary projects.
     */
    static readonly rushTempNpmScope: '@rush-temp';
    /**
     * The folder name ("variants") under which named variant configurations for
     * alternate dependency sets may be found.
     * Example: `C:\MyRepo\common\config\rush\variants`
     */
    static readonly rushVariantsFolderName: 'variants';
    /**
     * The folder name ("temp") under the common folder, or under the .rush folder in each project's directory where
     * temporary files will be stored.
     * Example: `C:\MyRepo\common\temp`
     */
    static readonly rushTempFolderName: 'temp';
    /**
     * The folder name ("projects") where temporary projects will be stored.
     * Example: `C:\MyRepo\common\temp\projects`
     */
    static readonly rushTempProjectsFolderName: 'projects';
    /**
     * The filename ("npm-shrinkwrap.json") used to store an installation plan for the NPM package manger.
     */
    static readonly npmShrinkwrapFilename: 'npm-shrinkwrap.json';
    /**
     * Number of installation attempts
     */
    static readonly defaultMaxInstallAttempts: 1;
    /**
     * The filename ("pnpm-lock.yaml") used to store an installation plan for the PNPM package manger
     * (PNPM version 3.x and later).
     */
    static readonly pnpmV3ShrinkwrapFilename: 'pnpm-lock.yaml';
    /**
     * The filename ("pnpmfile.js") used to add custom configuration to PNPM (PNPM version 1.x and later).
     */
    static readonly pnpmfileV1Filename: 'pnpmfile.js';
    /**
     * The filename (".pnpmfile.cjs") used to add custom configuration to PNPM (PNPM version 6.x and later).
     */
    static readonly pnpmfileV6Filename: '.pnpmfile.cjs';
    /**
     * The filename (".modules.yaml") used by pnpm to specify configurations in the node_modules directory
     */
    static readonly pnpmModulesFilename: '.modules.yaml';
    /**
     * The filename ("global-pnpmfile.cjs") used to add custom configuration to subspaces
     */
    static readonly pnpmfileGlobalFilename: 'global-pnpmfile.cjs';
    /**
     * The folder name used to store patch files for pnpm
     * Example: `C:\MyRepo\common\config\pnpm-patches`
     * Example: `C:\MyRepo\common\temp\patches`
     */
    static readonly pnpmPatchesFolderName: 'patches';
    /**
     * The folder name under `/common/temp` used to store checked-in patches.
     * Example: `C:\MyRepo\common\pnpm-patches`
     */
    static readonly pnpmPatchesCommonFolderName: `pnpm-patches`;
    /**
     * The filename ("shrinkwrap.yaml") used to store state for pnpm
     */
    static readonly yarnShrinkwrapFilename: 'yarn.lock';
    /**
     * The folder name ("node_modules") where NPM installs its packages.
     */
    static readonly nodeModulesFolderName: 'node_modules';
    /**
     * The filename ("pinned-versions.json") for an old configuration file that
     * that is no longer supported.
     *
     * @deprecated This feature has been superseded by the "preferredVersions" setting
     * in common-versions.json
     */
    static readonly pinnedVersionsFilename: 'pinned-versions.json';
    /**
     * The filename ("common-versions.json") for an optional configuration file
     * that stores dependency version information that affects all projects in the repo.
     * This configuration file should go in the "common/config/rush" folder.
     */
    static readonly commonVersionsFilename: 'common-versions.json';
    /**
     * The filename ("repo-state.json") for a file used by Rush to
     * store the state of various features as they stand in the repo.
     */
    static readonly repoStateFilename: 'repo-state.json';
    /**
     * The filename ("custom-tips.json") for the file used by Rush to
     * print user-customized messages.
     * This configuration file should go in the "common/config/rush" folder.
     */
    static readonly customTipsFilename: 'custom-tips.json';
    /**
     * The name of the per-project folder where project-specific Rush files are stored. For example,
     * the package-deps files, which are used by commands to determine if a particular project needs to be rebuilt.
     */
    static readonly projectRushFolderName: '.rush';
    /**
     * Custom command line configuration file, which is used by rush for implementing
     * custom command and options.
     */
    static readonly commandLineFilename: 'command-line.json';
    static readonly versionPoliciesFilename: 'version-policies.json';
    /**
     * Experiments configuration file.
     */
    static readonly experimentsFilename: 'experiments.json';
    /**
     * Pnpm configuration file
     */
    static readonly pnpmConfigFilename: 'pnpm-config.json';
    /**
     * Rush plugins configuration file name.
     */
    static readonly rushPluginsConfigFilename: 'rush-plugins.json';
    /**
     * Rush plugin manifest file name.
     */
    static readonly rushPluginManifestFilename: 'rush-plugin-manifest.json';
    /**
     * The artifactory.json configuration file name.
     */
    static readonly artifactoryFilename: 'artifactory.json';
    /**
     * The subspaces.json configuration file name
     */
    static readonly subspacesConfigFilename: 'subspaces.json';
    /**
     * The name of the default subspace if one isn't specified but subspaces is enabled.
     */
    static readonly defaultSubspaceName: 'default';
    /**
     * Build cache configuration file.
     */
    static readonly buildCacheFilename: 'build-cache.json';
    /**
     * Build cache version number, incremented when the logic to create cache entries changes.
     * Changing this ensures that cache entries generated by an old version will no longer register as a cache hit.
     */
    static readonly buildCacheVersion: 1;
    /**
     * Cobuild configuration file.
     */
    static readonly cobuildFilename: 'cobuild.json';
    /**
     * Per-project configuration filename.
     */
    static readonly rushProjectConfigFilename: 'rush-project.json';
    /**
     * The URL ("http://rushjs.io") for the Rush web site.
     */
    static readonly rushWebSiteUrl: 'https://rushjs.io';
    /**
     * The name of the NPM package for the Rush tool ("\@microsoft/rush").
     */
    static readonly rushPackageName: '@microsoft/rush';
    /**
     * The folder name ("rush-recycler") where Rush moves large folder trees
     * before asynchronously deleting them.
     */
    static readonly rushRecyclerFolderName: 'rush-recycler';
    /**
     * The name of the file to drop in project-folder/.rush/temp/ containing a listing of the project's direct
     * and indirect dependencies. This is used to detect if a project's dependencies have changed since the last build.
     */
    static readonly projectShrinkwrapFilename: 'shrinkwrap-deps.json';
    /**
     * The value of the "commandKind" property for a bulk command in command-line.json
     */
    static readonly bulkCommandKind: 'bulk';
    /**
     * The value of the "commandKind" property for a global command in command-line.json
     */
    static readonly globalCommandKind: 'global';
    /**
     * The value of the "commandKind" property for a phased command in command-line.json
     */
    static readonly phasedCommandKind: 'phased';
    /**
     * The name of the incremental build command.
     */
    static readonly buildCommandName: 'build';
    /**
     * The name of the non-incremental build command.
     */
    static readonly rebuildCommandName: 'rebuild';
    static readonly updateCloudCredentialsCommandName: 'update-cloud-credentials';
    /**
     * When a hash generated that contains multiple input segments, this character may be used
     * to separate them to avoid issues like
     * crypto.createHash('sha1').update('a').update('bc').digest('hex') === crypto.createHash('sha1').update('ab').update('c').digest('hex')
     */
    static readonly hashDelimiter: '|';
    /**
     * The name of the per-user Rush configuration data folder.
     */
    static readonly rushUserConfigurationFolderName: '.rush-user';
    /**
     * The name of the project `rush-logs` folder.
     */
    static readonly rushLogsFolderName: 'rush-logs';
    /**
     * The expected prefix for phase names in "common/config/rush/command-line.json"
     */
    static readonly phaseNamePrefix: '_phase:';
    /**
     * The default debounce value for Rush multi-project watch mode. When watching, controls
     * how long to wait after the last encountered file system event before execution. If another
     * file system event occurs in this interval, the timeout will reset.
     */
    static readonly defaultWatchDebounceMs: 1000;
    /**
     * The name of the parameter that can be used to bypass policies.
     */
    static readonly bypassPolicyFlagLongName: '--bypass-policy';
    /**
     * Merge Queue ignore configuration file.
     */
    static readonly mergeQueueIgnoreFileName: '.mergequeueignore';
    /**
     * The filename ("project-impact-graph.yaml") for the project impact graph file.
     */
    static readonly projectImpactGraphFilename: 'project-impact-graph.yaml';
    /**
     * The filename for the last link flag
     */
    static readonly lastLinkFlagFilename: 'last-link';
    /**
     * The filename for the Rush alerts config file.
     */
    static readonly rushAlertsConfigFilename: 'rush-alerts.json';
    /**
     * The filename for the file that tracks which variant is currently installed.
     */
    static readonly currentVariantsFilename: 'current-variants.json';
}

/**
 * This class provides global folders that are used for rush's internal install locations.
 *
 * @internal
 */
export declare class _RushGlobalFolder {
    /**
     * The global folder where Rush stores temporary files.
     *
     * @remarks
     *
     * Most of the temporary files created by Rush are stored separately for each monorepo working folder,
     * to avoid issues of concurrency and compatibility between tool versions.  However, a small set
     * of files (e.g. installations of the `@microsoft/rush-lib` engine and the package manager) are stored
     * in a global folder to speed up installations.  The default location is `~/.rush` on POSIX-like
     * operating systems or `C:\Users\YourName` on Windows.
     *
     * You can use the {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER} environment  variable to specify
     * a different folder path.  This is useful for example if a Windows group policy forbids executing scripts
     * installed in a user's home directory.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    readonly path: string;
    /**
     * The absolute path to Rush's storage in the home directory for the current user and node version.
     * On Windows, it would be something like `C:\Users\YourName\.rush\node-v3.4.5`.
     */
    readonly nodeSpecificPath: string;
    constructor();
}

/**
 * Used by rush-sdk to access internals of rush-lib.
 * @internal
 */
export declare class _RushInternals {
    /**
     * Used by rush-sdk to load an internal API specified by its module path.
     *
     * @param srcImportPath - The module path to load.  For example, to refer to `src/api/ChangeFile.ts`,
     * the `srcImportPath` would be `"api/ChangeFile"`.
     * @returns the module object as would be returned by `require()`
     */
    static loadModule(srcImportPath: string): unknown;
}

/**
 * Hooks into the lifecycle of the Rush process invocation that plugins may tap into.
 *
 * @beta
 */
export declare class RushLifecycleHooks {
    /**
     * The hook to run before executing any Rush CLI Command.
     */
    readonly initialize: AsyncSeriesHook<IRushCommand>;
    /**
     * The hook to run before executing any global Rush CLI Command (defined in command-line.json).
     */
    readonly runAnyGlobalCustomCommand: AsyncSeriesHook<IGlobalCommand>;
    /**
     * A hook map to allow plugins to hook specific named global commands (defined in command-line.json) before execution.
     */
    readonly runGlobalCustomCommand: HookMap<AsyncSeriesHook<IGlobalCommand>>;
    /**
     * The hook to run before executing any phased Rush CLI Command (defined in command-line.json, or the default "build" or "rebuild").
     */
    readonly runAnyPhasedCommand: AsyncSeriesHook<IPhasedCommand>;
    /**
     * A hook map to allow plugins to hook specific named phased commands (defined in command-line.json) before execution.
     */
    readonly runPhasedCommand: HookMap<AsyncSeriesHook<IPhasedCommand>>;
    /**
     * The hook to run between preparing the common/temp folder and invoking the package manager during "rush install" or "rush update".
     */
    readonly beforeInstall: AsyncSeriesHook<[
    command: IGlobalCommand,
    subspace: Subspace,
    variant: string | undefined
    ]>;
    /**
     * The hook to run after a successful install.
     */
    readonly afterInstall: AsyncSeriesHook<[
    command: IRushCommand,
    subspace: Subspace,
    variant: string | undefined
    ]>;
    /**
     * A hook to allow plugins to hook custom logic to process telemetry data.
     */
    readonly flushTelemetry: AsyncParallelHook<[ReadonlyArray<ITelemetryData>]>;
}

declare class RushPluginsConfiguration {
    private static _jsonSchema;
    private _jsonFilename;
    readonly configuration: Readonly<IRushPluginsConfigurationJson>;
    constructor(jsonFilename: string);
}

/**
 * Use this class to load the "config/rush-project.json" config file.
 *
 * This file provides project-specific configuration options.
 * @alpha
 */
export declare class RushProjectConfiguration {
    private static readonly _configCache;
    readonly project: RushConfigurationProject;
    /**
     * {@inheritdoc _IRushProjectJson.incrementalBuildIgnoredGlobs}
     */
    readonly incrementalBuildIgnoredGlobs: ReadonlyArray<string>;
    /**
     * {@inheritdoc _IRushProjectJson.disableBuildCacheForProject}
     */
    readonly disableBuildCacheForProject: boolean;
    readonly operationSettingsByOperationName: ReadonlyMap<string, Readonly<IOperationSettings>>;
    private readonly _validationCache;
    private constructor();
    /**
     * Validates that the requested phases are compatible.
     * Deferral of this logic to its own method means that Rush no longer eagerly validates
     * all defined commands in command-line.json. As such, while validation will be run for a given
     * command upon invoking that command, defining overlapping phases in "rush custom-command"
     * that are not used by "rush build" will not cause "rush build" to exit with an error.
     */
    validatePhaseConfiguration(phases: Iterable<IPhase>, terminal: ITerminal): void;
    /**
     * Examines the list of source files for the project and the target phase and returns a reason
     * why the project cannot enable the build cache for that phase, or undefined if it is safe to so do.
     */
    getCacheDisabledReason(trackedFileNames: Iterable<string>, phaseName: string, isNoOp: boolean): string | undefined;
    /**
     * Source of truth for whether a project is unable to use the build cache for a given phase.
     * As some operations may not have a rush-project.json file defined at all, but may be no-op operations
     *  we'll want to ignore those completely.
     */
    static getCacheDisabledReasonForProject(options: {
        projectConfiguration: RushProjectConfiguration | undefined;
        trackedFileNames: Iterable<string>;
        phaseName: string;
        isNoOp: boolean;
    }): string | undefined;
    /**
     * Loads the rush-project.json data for the specified project.
     */
    static tryLoadForProjectAsync(project: RushConfigurationProject, terminal: ITerminal): Promise<RushProjectConfiguration | undefined>;
    /**
     * Load only the `incrementalBuildIgnoredGlobs` property from the rush-project.json file, skipping
     * validation of other parts of the config file.
     *
     * @remarks
     * This function exists to allow the ProjectChangeAnalyzer to load just the ignore globs without
     * having to validate the rest of the `rush-project.json` file against the repo's command-line configuration.
     */
    static tryLoadIgnoreGlobsForProjectAsync(project: RushConfigurationProject, terminal: ITerminal): Promise<ReadonlyArray<string> | undefined>;
    /**
     * Load the rush-project.json data for all selected projects.
     * Validate compatibility of output folders across all selected phases.
     */
    static tryLoadForProjectsAsync(projects: Iterable<RushConfigurationProject>, terminal: ITerminal): Promise<ReadonlyMap<RushConfigurationProject, RushProjectConfiguration>>;
    private static _tryLoadJsonForProjectAsync;
    private static _getRushProjectConfiguration;
}

/**
 * @beta
 */
export declare class RushSession {
    private readonly _options;
    private readonly _cloudBuildCacheProviderFactories;
    private readonly _cobuildLockProviderFactories;
    readonly hooks: RushLifecycleHooks;
    constructor(options: IRushSessionOptions);
    getLogger(name: string): ILogger;
    get terminalProvider(): ITerminalProvider;
    registerCloudBuildCacheProviderFactory(cacheProviderName: string, factory: CloudBuildCacheProviderFactory): void;
    getCloudBuildCacheProviderFactory(cacheProviderName: string): CloudBuildCacheProviderFactory | undefined;
    registerCobuildLockProviderFactory(cobuildLockProviderName: string, factory: CobuildLockProviderFactory): void;
    getCobuildLockProviderFactory(cobuildLockProviderName: string): CobuildLockProviderFactory | undefined;
}

/**
 * Rush per-user configuration data.
 *
 * @beta
 */
export declare class RushUserConfiguration {
    private static _schema;
    /**
     * If provided, store build cache in the specified folder. Must be an absolute path.
     */
    readonly buildCacheFolder: string | undefined;
    private constructor();
    static initializeAsync(): Promise<RushUserConfiguration>;
    static getRushUserFolderPath(): string;
}

/**
 * This represents the subspace configurations for a repository, based on the "subspaces.json"
 * configuration file.
 * @public
 */
export declare class Subspace {
    readonly subspaceName: string;
    private readonly _rushConfiguration;
    private readonly _projects;
    private readonly _splitWorkspaceCompatibility;
    private _commonVersionsConfiguration;
    private _detail;
    private _cachedPnpmOptions;
    private _cachedPnpmOptionsInitialized;
    constructor(options: ISubspaceOptions);
    /**
     * Returns the list of projects belonging to this subspace.
     * @beta
     */
    getProjects(): RushConfigurationProject[];
    /**
     * Returns the parsed contents of the pnpm-config.json config file.
     * @beta
     */
    getPnpmOptions(): PnpmOptionsConfiguration | undefined;
    private _ensureDetail;
    /**
     * Returns the full path of the folder containing this subspace's variant-dependent configuration files
     * such as `pnpm-lock.yaml`.
     *
     * Example: `common/config/subspaces/my-subspace` or `common/config/subspaces/my-subspace/variants/my-variant`
     * @beta
     *
     * @remarks
     * The following files may be variant-dependent:
     * - Lockfiles: (i.e. - `pnpm-lock.yaml`, `npm-shrinkwrap.json`, `yarn.lock`, etc)
     * - 'common-versions.json'
     * - 'pnpmfile.js'/'.pnpmfile.cjs'
     */
    getVariantDependentSubspaceConfigFolderPath(variant: string | undefined): string;
    /**
     * Returns the full path of the folder containing this subspace's configuration files such as `pnpm-lock.yaml`.
     *
     * Example: `common/config/subspaces/my-subspace`
     * @beta
     */
    getSubspaceConfigFolderPath(): string;
    /**
     * Returns the full path of the folder containing this subspace's configuration files such as `pnpm-lock.yaml`.
     *
     * Example: `common/config/subspaces/my-subspace/pnpm-patches` (subspaces feature enabled)
     * Example: `common/config/pnpm-patches` (subspaces feature disabled)
     * @beta
     */
    getSubspacePnpmPatchesFolderPath(): string;
    /**
     * The folder where the subspace's node_modules and other temporary files will be stored.
     *
     * Example: `common/temp/subspaces/my-subspace`
     * @beta
     */
    getSubspaceTempFolderPath(): string;
    /**
     * Returns full path of the temporary shrinkwrap file for a specific subspace and returns the common workspace
     * shrinkwrap if no subspaceName is provided.
     * @remarks
     * This function takes the subspace name, and returns the full path for the subspace's shrinkwrap file.
     * This function also consults the deprecated option to allow for shrinkwraps to be stored under a package folder.
     * This shrinkwrap file is used during "rush install", and may be rewritten by the package manager during installation
     * This property merely reports the filename, the file itself may not actually exist.
     * example: `C:\MyRepo\common\<subspace_name>\pnpm-lock.yaml`
     * @beta
     */
    getTempShrinkwrapFilename(): string;
    /**
     * @deprecated - Use {@link Subspace.getTempShrinkwrapPreinstallFilePath} instead.
     */
    getTempShrinkwrapPreinstallFilename(subspaceName?: string | undefined): string;
    /**
     * The full path of a backup copy of tempShrinkwrapFilename. This backup copy is made
     * before installation begins, and can be compared to determine how the package manager
     * modified tempShrinkwrapFilename.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\temp\npm-shrinkwrap-preinstall.json`
     * or `C:\MyRepo\common\temp\pnpm-lock-preinstall.yaml`
     * @beta
     */
    getTempShrinkwrapPreinstallFilePath(): string;
    /**
     * Gets the path to the common-versions.json config file for this subspace.
     *
     * Example: `C:\MyRepo\common\subspaces\my-subspace\common-versions.json`
     * @beta
     */
    getCommonVersionsFilePath(variant?: string): string;
    /**
     * Gets the path to the pnpm-config.json config file for this subspace.
     *
     * Example: `C:\MyRepo\common\subspaces\my-subspace\pnpm-config.json`
     * @beta
     */
    getPnpmConfigFilePath(): string;
    /**
     * Gets the settings from the common-versions.json config file.
     * @beta
     */
    getCommonVersions(variant?: string): CommonVersionsConfiguration;
    /**
     * Gets the ensureConsistentVersions property from the common-versions.json config file,
     * or from the rush.json file if it isn't defined in common-versions.json
     * @beta
     */
    shouldEnsureConsistentVersions(variant?: string): boolean;
    /**
     * Gets the path to the repo-state.json file.
     * @beta
     */
    getRepoStateFilePath(): string;
    /**
     * Gets the contents from the repo-state.json file.
     * @param subspaceName - The name of the subspace in use by the active command.
     * @beta
     */
    getRepoState(): RepoStateFile;
    /**
     * @deprecated - Use {@link Subspace.getCommittedShrinkwrapFilePath} instead.
     */
    getCommittedShrinkwrapFilename(): string;
    /**
     * Gets the committed shrinkwrap file name for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     * @beta
     */
    getCommittedShrinkwrapFilePath(variant?: string): string;
    /**
     * Gets the absolute path for "pnpmfile.js" for a specific subspace.
     * @param subspace - The name of the current subspace in use by the active command.
     * @remarks
     * The file path is returned even if PNPM is not configured as the package manager.
     * @beta
     */
    getPnpmfilePath(variant?: string): string;
    /**
     * Returns true if the specified project belongs to this subspace.
     * @beta
     */
    contains(project: RushConfigurationProject): boolean;
    /** @internal */
    _addProject(project: RushConfigurationProject): void;
    /**
     * Returns hash value of injected dependencies in related package.json.
     * @beta
     */
    getPackageJsonInjectedDependenciesHash(variant?: string): string | undefined;
}

/**
 * This represents the subspace configurations for a repository, based on the "subspaces.json"
 * configuration file.
 * @beta
 */
export declare class SubspacesConfiguration {
    private static _jsonSchema;
    /**
     * The absolute path to the "subspaces.json" configuration file that was loaded to construct this object.
     */
    readonly subspaceJsonFilePath: string;
    readonly subspacesEnabled: boolean;
    /**
     * This determines if the subspaces feature supports adding configuration files under the project folder itself
     */
    readonly splitWorkspaceCompatibility: boolean;
    /**
     * This determines if selectors are required when installing and building
     */
    readonly preventSelectingAllSubspaces: boolean;
    /**
     * A set of the available subspaces
     */
    readonly subspaceNames: ReadonlySet<string>;
    private constructor();
    /**
     * Checks whether the provided string could be used as a subspace name.
     * Returns `undefined` if the name is valid; otherwise returns an error message.
     * @remarks
     * This is a syntax check only; it does not test whether the subspace is actually defined in the Rush configuration.
     */
    static explainIfInvalidSubspaceName(subspaceName: string, splitWorkspaceCompatibility?: boolean): string | undefined;
    /**
     * Checks whether the provided string could be used as a subspace name.
     * If not, an exception is thrown.
     * @remarks
     * This is a syntax check only; it does not test whether the subspace is actually defined in the Rush configuration.
     */
    static requireValidSubspaceName(subspaceName: string, splitWorkspaceCompatibility?: boolean): void;
    static tryLoadFromConfigurationFile(subspaceJsonFilePath: string): SubspacesConfiguration | undefined;
    static tryLoadFromDefaultLocation(rushConfiguration: RushConfiguration): SubspacesConfiguration | undefined;
}

declare enum VersionFormatForCommit {
    wildcard = "wildcard",
    original = "original"
}

declare enum VersionFormatForPublish {
    original = "original",
    exact = "exact"
}

/**
 * This is the base class for version policy which controls how versions get bumped.
 * @public
 */
export declare abstract class VersionPolicy {
    private _versionFormatForCommit;
    private _versionFormatForPublish;
    /**
     * Version policy name
     */
    readonly policyName: string;
    /**
     * Version policy definition name
     */
    readonly definitionName: VersionPolicyDefinitionName;
    /**
     * Determines if a version policy wants to opt out of changelog files.
     */
    readonly exemptFromRushChange: boolean;
    /**
     * Determines if a version policy wants to opt in to including email.
     */
    readonly includeEmailInChangeFile: boolean;
    /**
     * @internal
     */
    constructor(versionPolicyJson: IVersionPolicyJson);
    /**
     * Loads from version policy json
     *
     * @param versionPolicyJson - version policy Json
     *
     * @internal
     */
    static load(versionPolicyJson: IVersionPolicyJson): VersionPolicy | undefined;
    /**
     * Whether it is a lockstepped version policy
     */
    get isLockstepped(): boolean;
    /**
     * Returns an updated package json that satisfies the policy.
     *
     * @param project - package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    abstract ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    /**
     * Bumps version based on the policy
     *
     * @param bumpType - (optional) override bump type
     * @param identifier - (optional) override prerelease Id
     */
    abstract bump(bumpType?: BumpType, identifier?: string): void;
    /**
     * Serialized json for the policy
     *
     * @internal
     */
    abstract get _json(): IVersionPolicyJson;
    /**
     * Validates the specified version and throws if the version does not satisfy the policy.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    abstract validate(versionString: string, packageName: string): void;
    /**
     * Tells the version policy to modify any dependencies in the target package
     * to values used for publishing.
     */
    setDependenciesBeforePublish(packageName: string, configuration: RushConfiguration): void;
    /**
     * Tells the version policy to modify any dependencies in the target package
     * to values used for checked-in source.
     */
    setDependenciesBeforeCommit(packageName: string, configuration: RushConfiguration): void;
}

/**
 * Use this class to load and save the "common/config/rush/version-policies.json" config file.
 * This config file configures how different groups of projects will be published by Rush,
 * and how their version numbers will be determined.
 * @public
 */
export declare class VersionPolicyConfiguration {
    private static _jsonSchema;
    private _jsonFileName;
    /**
     * Gets all the version policies
     */
    readonly versionPolicies: Map<string, VersionPolicy>;
    /**
     * @internal
     */
    constructor(jsonFileName: string);
    /**
     * Validate the version policy configuration against the rush config
     */
    validate(projectsByName: ReadonlyMap<string, RushConfigurationProject>): void;
    /**
     * Gets the version policy by its name.
     * Throws error if the version policy is not found.
     * @param policyName - Name of the version policy
     */
    getVersionPolicy(policyName: string): VersionPolicy;
    /**
     * Bumps up versions for the specified version policy or all version policies
     *
     * @param versionPolicyName - version policy name
     * @param bumpType - bump type to override what policy has defined.
     * @param identifier - prerelease identifier to override what policy has defined.
     * @param shouldCommit - should save to disk
     */
    bump(versionPolicyName?: string, bumpType?: BumpType, identifier?: string, shouldCommit?: boolean): void;
    /**
     * Updates the version directly for the specified version policy
     * @param versionPolicyName - version policy name
     * @param newVersion - new version
     */
    update(versionPolicyName: string, newVersion: string, shouldCommit?: boolean): void;
    private _loadFile;
    private _saveFile;
}

/**
 * Version policy base type names
 * @public
 */
export declare enum VersionPolicyDefinitionName {
    'lockStepVersion' = 0,
    'individualVersion' = 1
}

/**
 * Options that are only used when the yarn package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the yarn package manager
 * is not being used.
 *
 * @public
 */
export declare class YarnOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    /**
     * If true, then Rush will add the "--ignore-engines" option when invoking Yarn.
     * This allows "rush install" to succeed if there are dependencies with engines defined in
     * package.json which do not match the current environment.
     *
     * The default value is false.
     */
    readonly ignoreEngines: boolean;
    /** @internal */
    constructor(json: _IYarnOptionsJson);
}

export { }
