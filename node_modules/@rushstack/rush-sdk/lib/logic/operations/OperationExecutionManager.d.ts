import { type TerminalWritable } from '@rushstack/terminal';
import type { Operation } from './Operation';
import { OperationStatus } from './OperationStatus';
import { OperationExecutionRecord } from './OperationExecutionRecord';
import type { IExecutionResult } from './IOperationExecutionResult';
import type { IEnvironment } from '../../utilities/Utilities';
export interface IOperationExecutionManagerOptions {
    quietMode: boolean;
    debugMode: boolean;
    parallelism: number;
    changedProjectsOnly: boolean;
    destination?: TerminalWritable;
    beforeExecuteOperationAsync?: (operation: OperationExecutionRecord) => Promise<OperationStatus | undefined>;
    afterExecuteOperationAsync?: (operation: OperationExecutionRecord) => Promise<void>;
    createEnvironmentForOperation?: (operation: OperationExecutionRecord) => IEnvironment;
    onOperationStatusChangedAsync?: (record: OperationExecutionRecord) => void;
    beforeExecuteOperationsAsync?: (records: Map<Operation, OperationExecutionRecord>) => Promise<void>;
}
/**
 * A class which manages the execution of a set of tasks with interdependencies.
 * Initially, and at the end of each task execution, all unblocked tasks
 * are added to a ready queue which is then executed. This is done continually until all
 * tasks are complete, or prematurely fails if any of the tasks fail.
 */
export declare class OperationExecutionManager {
    private readonly _changedProjectsOnly;
    private readonly _executionRecords;
    private readonly _quietMode;
    private readonly _parallelism;
    private readonly _totalOperations;
    private readonly _outputWritable;
    private readonly _colorsNewlinesTransform;
    private readonly _streamCollator;
    private readonly _terminal;
    private readonly _beforeExecuteOperation?;
    private readonly _afterExecuteOperation?;
    private readonly _onOperationStatusChanged?;
    private readonly _beforeExecuteOperations?;
    private readonly _createEnvironmentForOperation?;
    private _hasAnyFailures;
    private _hasAnyNonAllowedWarnings;
    private _completedOperations;
    private _executionQueue;
    constructor(operations: Set<Operation>, options: IOperationExecutionManagerOptions);
    private _streamCollator_onWriterActive;
    /**
     * Executes all operations which have been registered, returning a promise which is resolved when all the
     * operations are completed successfully, or rejects when any operation fails.
     */
    executeAsync(): Promise<IExecutionResult>;
    private _reportOperationErrorIfAny;
    /**
     * Handles the result of the operation and propagates any relevant effects.
     */
    private _onOperationComplete;
}
//# sourceMappingURL=OperationExecutionManager.d.ts.map